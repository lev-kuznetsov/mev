/*[system-bundles-config]*/
System.bundles = {"bundles/demo/index.css!":["nvd3@1.8.1-dev#build/nv.d3.css!$css","mev-scatter-plot@0.0.0#src/style/scatter.less!$less"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    var npmModuleRegEx = /.+@.+\..+\..+#.+/;
    var utils = {
        extend: function (d, s) {
            for (var prop in s) {
                d[prop] = s[prop];
            }
            return d;
        },
        map: function (arr, fn) {
            var i = 0, len = arr.length, out = [];
            for (; i < len; i++) {
                out.push(fn.call(arr, arr[i]));
            }
            return out;
        },
        filter: function (arr, fn) {
            var i = 0, len = arr.length, out = [], res;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i]);
                if (res) {
                    out.push(res);
                }
            }
            return out;
        },
        forEach: function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                fn.call(arr, arr[i], i);
            }
        },
        moduleName: {
            create: function (descriptor, standard) {
                if (standard) {
                    return descriptor.moduleName;
                } else {
                    if (descriptor === '@empty') {
                        return descriptor;
                    }
                    var modulePath;
                    if (descriptor.modulePath) {
                        modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                    }
                    return descriptor.packageName + (descriptor.version ? '@' + descriptor.version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                }
            },
            isNpm: function (moduleName) {
                return npmModuleRegEx.test(moduleName);
            },
            parse: function (moduleName, currentPackageName) {
                var pluginParts = moduleName.split('!');
                var modulePathParts = pluginParts[0].split('#');
                var versionParts = modulePathParts[0].split('@');
                if (!modulePathParts[1] && !versionParts[0]) {
                    versionParts = ['@' + versionParts[1]];
                }
                var packageName, modulePath;
                if (currentPackageName && utils.path.isRelative(moduleName)) {
                    packageName = currentPackageName;
                    modulePath = versionParts[0];
                } else {
                    if (modulePathParts[1]) {
                        packageName = versionParts[0];
                        modulePath = modulePathParts[1];
                    } else {
                        var folderParts = versionParts[0].split('/');
                        packageName = folderParts.shift();
                        modulePath = folderParts.join('/');
                    }
                }
                return {
                    plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                    version: versionParts[1],
                    modulePath: modulePath,
                    packageName: packageName,
                    moduleName: moduleName
                };
            },
            parseFromPackage: function (loader, refPkg, name, parentName) {
                var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName);
                if (utils.path.isRelative(parsedModuleName.modulePath)) {
                    var parentParsed = utils.moduleName.parse(parentName, packageName);
                    if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                        parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                    }
                }
                var mapName = utils.moduleName.create(parsedModuleName), mappedName;
                if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refPkg.system || !refPkg.system.ignoreBrowser)) {
                    mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                }
                var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                if (global) {
                    mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                }
                if (mappedName) {
                    return utils.moduleName.parse(mappedName, packageName);
                } else {
                    return parsedModuleName;
                }
            }
        },
        pkg: {
            name: function (pkg) {
                return pkg.system && pkg.system.name || pkg.name;
            },
            main: function (pkg) {
                return utils.path.removeJS(pkg.system && pkg.system.main || typeof pkg.browser === 'string' && pkg.browser || pkg.main || 'index');
            },
            rootDir: function (pkg, isRoot) {
                var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                var lib = pkg.system && pkg.system.directories && pkg.system.directories.lib;
                if (lib) {
                    root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                }
                return root;
            },
            findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                if (loader.npm) {
                    if (moduleName) {
                        var parsed = utils.moduleName.parse(moduleName);
                        if (parsed.version && parsed.packageName) {
                            var name = parsed.packageName + '@' + parsed.version;
                            if (name in loader.npm) {
                                return loader.npm[name];
                            }
                        }
                    }
                    if (moduleAddress) {
                        var packageFolder = utils.pkg.folderAddress(moduleAddress);
                        return packageFolder ? loader.npmPaths[packageFolder] : loader.npmPaths.__default;
                    } else {
                        return loader.npmPaths.__default;
                    }
                }
            },
            folderAddress: function (address) {
                var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                if (nodeModulesIndex >= 0) {
                    return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                }
            },
            findDep: function (loader, refPackage, name) {
                if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                    var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                    while (curPackage) {
                        var pkg = loader.npmPaths[curPackage];
                        if (pkg) {
                            return pkg;
                        }
                        var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                        if (!parentAddress) {
                            return;
                        }
                        curPackage = parentAddress + '/' + name;
                    }
                }
            },
            findByName: function (loader, name) {
                if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                    return loader.npm[name];
                }
            },
            hasDirectoriesLib: function (pkg) {
                var system = pkg.system;
                return system && system.directories && !!system.directories.lib;
            }
        },
        path: {
            makeRelative: function (path) {
                if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                    return path;
                } else {
                    return './' + path;
                }
            },
            removeJS: function (path) {
                return path.replace(/\.js(!|$)/, function (whole, part) {
                    return part;
                });
            },
            removePackage: function (path) {
                return path.replace(/\/package\.json.*/, '');
            },
            addJS: function (path) {
                if (/\.js(on)?$/.test(path)) {
                    return path;
                } else {
                    return path + '.js';
                }
            },
            isRelative: function (path) {
                return path.substr(0, 1) === '.';
            },
            joinURIs: function (base, href) {
                function removeDotSegments(input) {
                    var output = [];
                    input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                        if (p === '/..') {
                            output.pop();
                        } else {
                            output.push(p);
                        }
                    });
                    return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                }
                href = parseURI(href || '');
                base = parseURI(base || '');
                return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
            },
            startsWithDotSlash: function (path) {
                return path.substr(0, 2) === './';
            },
            endsWithSlash: function (path) {
                return path[path.length - 1] === '/';
            },
            addEndingSlash: function (path) {
                return utils.path.endsWithSlash(path) ? path : path + '/';
            },
            depPackage: function (parentPackageAddress, childName) {
                var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
            },
            depPackageDir: function (parentPackageAddress, childName) {
                return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
            },
            parentNodeModuleAddress: function (address) {
                var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                if (prevModulesIndex >= 0) {
                    return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                }
            },
            pkgDir: function (address) {
                var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                if (nodeModulesIndex >= 0) {
                    return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                }
            }
        },
        includeInBuild: true
    };
    function parseURI(url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    }
    module.exports = utils;
});
/*npm-extension*/
define('npm-extension', function (require, exports, module) {
    'format cjs';
    var utils = require('./npm-utils');
    exports.includeInBuild = true;
    var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
    var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
    var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
    exports.addExtension = function (System) {
        var oldNormalize = System.normalize;
        System.normalize = function (name, parentName, parentAddress, pluginNormalize) {
            if (parentName && utils.path.isRelative(name) && !utils.moduleName.isNpm(parentName)) {
                return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
            }
            var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
            if (!refPkg) {
                return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
            }
            var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
            var depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
            if (!depPkg) {
                depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
            }
            if (!depPkg) {
                var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                if (browserPackageName) {
                    parsedModuleName.packageName = browserPackageName;
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
            }
            if (!depPkg && refPkg === this.npmPaths.__default && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                parsedModuleName.version = refPkg.version;
                parsedModuleName.packageName = refPkg.name;
                parsedModuleName.modulePath = utils.pkg.main(refPkg);
                return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
            }
            if (depPkg) {
                parsedModuleName.version = depPkg.version;
                if (!parsedModuleName.modulePath) {
                    parsedModuleName.modulePath = utils.pkg.main(depPkg);
                }
                var moduleName = utils.moduleName.create(parsedModuleName);
                if (refPkg.system && refPkg.system.map && typeof refPkg.system.map[moduleName] === 'string') {
                    moduleName = refPkg.system.map[moduleName];
                }
                return oldNormalize.call(this, moduleName, parentName, parentAddress, pluginNormalize);
            } else {
                if (depPkg === this.npmPaths.__default) {
                    var localName = parsedModuleName.modulePath ? parsedModuleName.modulePath + (parsedModuleName.plugin ? parsedModuleName.plugin : '') : utils.pkg.main(depPkg);
                    return oldNormalize.call(this, localName, parentName, parentAddress, pluginNormalize);
                }
                if (refPkg.browser && refPkg.browser[name]) {
                    return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                }
                return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
            }
        };
        var oldLocate = System.locate;
        System.locate = function (load) {
            var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
            if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                var pkg = this.npm[parsedModuleName.packageName];
                if (pkg) {
                    return oldLocate.call(this, load).then(function (address) {
                        var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                        if (isBrowser) {
                            expectedAddress = expectedAddress.replace(/#/g, '%23');
                        }
                        if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                            return address;
                        }
                        var root = utils.pkg.rootDir(pkg, pkg === loader.npmPaths.__default);
                        if (parsedModuleName.modulePath) {
                            return utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                        }
                        return address;
                    });
                }
            }
            return oldLocate.call(this, load);
        };
        var convertName = function (loader, name) {
            var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
            if (pkg) {
                var parsed = utils.moduleName.parse(name, pkg.name);
                parsed.version = pkg.version;
                if (!parsed.modulePath) {
                    parsed.modulePath = utils.pkg.main(pkg);
                }
                return utils.moduleName.create(parsed);
            }
            return name;
        };
        var configSpecial = {
            map: function (map) {
                var newMap = {}, val;
                for (var name in map) {
                    val = map[name];
                    newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                }
                return newMap;
            },
            meta: function (map) {
                var newMap = {};
                for (var name in map) {
                    newMap[convertName(this, name)] = map[name];
                }
                return newMap;
            },
            paths: function (paths) {
                var newPaths = {};
                for (var name in paths) {
                    newPaths[convertName(this, name)] = paths[name];
                }
                return newPaths;
            }
        };
        var oldConfig = System.config;
        System.config = function (cfg) {
            var loader = this;
            for (var name in cfg) {
                if (configSpecial[name]) {
                    cfg[name] = configSpecial[name].call(loader, cfg[name]);
                }
            }
            oldConfig.apply(loader, arguments);
        };
    };
});
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'index';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                cwd: function () {
                },
                env: { NODE_ENV: loader.env }
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        loader.npmPaths.__default = packages[0];
        var lib = packages[0].system && packages[0].system.directories && packages[0].system.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                fn.call(arr, arr[i]);
            }
        };
        var setupLiveReload = function () {
            var hasLiveReload = !!(loader.liveReloadInstalled || loader._liveMap);
            if (hasLiveReload) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        delete loader.npm;
                        delete loader.npmPaths;
                    });
                });
            }
        };
        forEach(packages, function (pkg) {
            if (pkg.system) {
                var main = pkg.system.main;
                delete pkg.system.main;
                delete pkg.system.configDependencies;
                loader.config(pkg.system);
                pkg.system.main = main;
            }
            if (pkg.globalBrowser) {
                setGlobalBrowser(pkg.globalBrowser, pkg);
            }
            var systemName = pkg.system && pkg.system.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
        setupLiveReload();
    }(loader, [
        {
            'name': 'mev-scatter-plot',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/package.json',
            'main': 'index',
            'system': { 'paths': {} },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jquery',
            'version': '2.1.4',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'nvd3',
            'version': '1.8.1-dev',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/nvd3/package.json',
            'main': 'build/nv.d3.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-nvd3',
            'version': '1.0.5',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/angular-nvd3/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular',
            'version': '1.4.8',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/angular/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '2.4.2',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/lodash/package.json',
            'main': 'dist/lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mui',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/mui/package.json',
            'main': 'mui',
            'system': {
                'meta': {
                    'mui@0.0.0#mui': { 'deps': ['angular'] },
                    'angular@1.4.8#index': { 'deps': ['jquery'] }
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'crossfilter',
            'version': '1.3.12',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/crossfilter/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'steal-jasmine',
            'version': '0.0.2',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/steal-jasmine/package.json',
            'main': 'steal-jasmine',
            'system': {
                'npmIgnore': {
                    'steal': true,
                    'steal-tools': true
                },
                'meta': {
                    'jasmine-core@2.4.1#lib/jasmine-core/jasmine': {
                        'formats': 'global',
                        'exports': 'jasmineRequire'
                    },
                    'jasmine-core@2.4.1#lib/jasmine-core/jasmine-html': { 'deps': ['jasmine-core/lib/jasmine-core/jasmine'] },
                    'jasmine-core@2.4.1#lib/jasmine-core/boot': {
                        'deps': [
                            'jasmine-core/lib/jasmine-core/jasmine',
                            'jasmine-core/lib/jasmine-core/jasmine-html'
                        ]
                    }
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3',
            'version': '3.5.12',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/d3/package.json',
            'main': 'd3.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jasmine-core',
            'version': '2.4.1',
            'fileUrl': 'file:/home/antony/git/sandbox/stealjs/play-angularNvd3/charts/scatter/node_modules/steal-jasmine/node_modules/jasmine-core/package.json',
            'main': './lib/jasmine-core.js',
            'globalBrowser': {},
            'browser': {}
        }
    ]));
});
/*jquery@2.1.4#dist/jquery*/
(function (global, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var document = window.document, version = '2.1.4', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: '',
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isArray: Array.isArray,
        isWindow: function (obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function (obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
        },
        isPlainObject: function (obj) {
            if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
            return true;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf('use strict') === 1) {
                    script = document.createElement('script');
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function (obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var tmp, args, proxy;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = 'length' in obj && obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                var i = 0, len = list.length;
                for (; i < len; i++) {
                    if (list[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + characterEncoding + ')'),
                'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, unloadHandler = function () {
                setDocument();
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            nodeType = context.nodeType;
            if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed && documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType !== 1 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                        groups = tokenize(selector);
                        if (old = context.getAttribute('id')) {
                            nid = old.replace(rescape, '\\$&');
                        } else {
                            context.setAttribute('id', nid);
                        }
                        nid = '[id=\'' + nid + '\'] ';
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(',');
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                        } finally {
                            if (!old) {
                                context.removeAttribute('id');
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement('div');
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== 'undefined' && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            parent = doc.defaultView;
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener('unload', unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent('onunload', unloadHandler);
                }
            }
            documentIsHTML = !isXML(doc);
            support.attributes = assert(function (div) {
                div.className = 'i';
                return !div.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (div) {
                div.appendChild(doc.createComment(''));
                return !div.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
            support.getById = assert(function (div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [m] : [];
                    }
                };
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
            } else {
                delete Expr.find['ID'];
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== 'undefined') {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function (div) {
                    docElem.appendChild(div).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\f]\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
                    if (div.querySelectorAll('[msallowcapture^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!div.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!div.querySelectorAll('[id~=' + expando + '-]').length) {
                        rbuggyQSA.push('~=');
                    }
                    if (!div.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                    if (!div.querySelectorAll('a#' + expando + '+*').length) {
                        rbuggyQSA.push('.#.+[+~]');
                    }
                });
                assert(function (div) {
                    var input = doc.createElement('input');
                    input.setAttribute('type', 'hidden');
                    div.appendChild(input).setAttribute('name', 'D');
                    if (div.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (!div.querySelectorAll(':enabled').length) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    div.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (div) {
                    support.disconnectedMatch = matches.call(div, 'div');
                    matches.call(div, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || '';
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    text = text.replace(runescape, funescape);
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': function (elem) {
                    return elem.disabled === false;
                },
                'disabled': function (elem) {
                    return elem.disabled === true;
                },
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function (elem, context, xml) {
                var oldCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context !== document && context;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (div1) {
            return div1.compareDocumentPosition(document.createElement('div')) & 1;
        });
        if (!assert(function (div) {
                div.innerHTML = '<a href=\'#\'></a>';
                return div.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (div) {
                div.innerHTML = '<input/>';
                div.firstChild.setAttribute('value', '');
                return div.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (div) {
                return div.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === 'string') {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + ' ' + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
            var match, elem;
            if (!selector) {
                return this;
            }
            if (typeof selector === 'string') {
                if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },
        sibling: function (n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        }
    });
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg);
                                if (type === 'function') {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (firing) {
                            firingLength = list.length;
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                },
                empty: function () {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                disable: function () {
                    list = stack = memory = undefined;
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                locked: function () {
                    return !stack;
                },
                fireWith: function (context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        'rejected'
                    ],
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory')
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function (fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler('ready');
                jQuery(document).off('ready');
            }
        }
    });
    function completed() {
        document.removeEventListener('DOMContentLoaded', completed, false);
        window.removeEventListener('load', completed, false);
        jQuery.ready();
    }
    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === 'complete') {
                setTimeout(jQuery.ready);
            } else {
                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    jQuery.acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function () {
                return {};
            }
        });
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function (owner) {
            if (!Data.accepts(owner)) {
                return 0;
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = { value: unlock };
                    Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }
            return unlock;
        },
        set: function (owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === 'string') {
                cache[data] = value;
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function (owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key];
        },
        access: function (owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === 'string' && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {};
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [
                            key,
                            camel
                        ];
                    } else {
                        name = camel;
                        name = name in cache ? [name] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function (owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function (owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();
    var data_user = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {
                }
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function (elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function (elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function (elem, name) {
            data_user.remove(elem, name);
        },
        _data: function (elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function (elem, name) {
            data_priv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, 'hasDataAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    data_user.set(this, key);
                });
            }
            return access(this, function (value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function () {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf('-') !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function (key) {
            return this.each(function () {
                data_user.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = data_priv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    data_priv.remove(elem, [
                        type + 'queue',
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = data_priv.get(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHidden = function (elem, el) {
        elem = el || elem;
        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
        input.setAttribute('type', 'radio');
        input.setAttribute('checked', 'checked');
        input.setAttribute('name', 't');
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }());
    var strundefined = typeof undefined;
    support.focusinBubbles = 'onfocusin' in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, 'events');
            }
        },
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') >= 0) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function (event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== 'click') {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
        fixHooks: {},
        keyHooks: {
            props: 'char charCode key keyCode'.split(' '),
            filter: function (event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
            filter: function (event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function (type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout',
        pointerenter: 'pointerover',
        pointerleave: 'pointerout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);
                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function (types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === 'object') {
                if (typeof selector !== 'string') {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === 'string') {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
            option: [
                1,
                '<select multiple=\'multiple\'>',
                '</select>'
            ],
            thead: [
                1,
                '<table>',
                '</table>'
            ],
            col: [
                2,
                '<table><colgroup>',
                '</colgroup></table>'
            ],
            tr: [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            td: [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            _default: [
                0,
                '',
                ''
            ]
        };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
            data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
        }
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur);
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            return clone;
        },
        buildFragment: function (elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === 'object') {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement('div'));
                        tag = (rtagName.exec(elem) || [
                            '',
                            ''
                        ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = '';
                    }
                }
            }
            fragment.textContent = '';
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), 'script');
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || '')) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        },
        cleanData: function (elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key];
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });
    jQuery.fn.extend({
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function (selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, 'script'));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = '';
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, '<$1></$2>');
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var arg = arguments[0];
            this.domManip(arguments, function (elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function (selector) {
            return this.remove(selector, true);
        },
        domManip: function (args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
                return this.each(function (index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, 'script'));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                                }
                            }
                        }
                    }
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], 'display');
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === 'none' || !display) {
                iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles = function (elem) {
        if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        }
        return window.getComputedStyle(elem, null);
    };
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
            if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + '' : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function () {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement('div'), div = document.createElement('div');
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        container.style.cssText = 'border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;' + 'position:absolute';
        container.appendChild(div);
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;' + 'box-sizing:border-box;display:block;margin-top:1%;top:1%;' + 'border:1px;padding:1px;width:4px;position:absolute';
            div.innerHTML = '';
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== '1%';
            boxSizingReliableVal = divStyle.width === '4px';
            docElem.removeChild(container);
        }
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function () {
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function () {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function () {
                    var ret, marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' + 'box-sizing:content-box;display:block;margin:0;border:0;padding:0';
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    docElem.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                    docElem.removeChild(container);
                    div.removeChild(marginDiv);
                    return ret;
                }
            });
        }
    }());
    jQuery.swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'), cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400'
        }, cssPrefixes = [
            'Webkit',
            'O',
            'Moz',
            'ms'
        ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = data_priv.get(elem, 'olddisplay');
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === 'none') {
                    elem.style.display = '';
                }
                if (elem.style.display === '' && isHidden(elem)) {
                    values[index] = data_priv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== 'none' || !hidden) {
                    data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                elem.style.display = show ? values[index] || '' : 'none';
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': 'cssFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number' && !jQuery.cssNumber[origName]) {
                    value += 'px';
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
            }
        };
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                elem,
                'marginRight'
            ]);
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || 'swing';
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                    if (start && start[3] !== unit) {
                        unit = unit || start[3];
                        parts = parts || [];
                        start = +target || 1;
                        do {
                            scale = scale || '.5';
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }
                    if (parts) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                    }
                    return tween;
                }]
        };
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            display = jQuery.css(elem, 'display');
            checkDisplay = display === 'none' ? data_priv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
                style.display = 'inline-block';
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ('hidden' in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, 'fxshow', {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                data_priv.remove(elem, 'fxshow');
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                    }
                }
            }
        } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.split(' ');
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || data_priv.get(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout);
            };
        });
    };
    (function () {
        var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
        input.type = 'checkbox';
        support.checkOn = input.value !== '';
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement('input');
        input.value = 't';
        input.type = 'radio';
        support.radioValue = input.value === 't';
    }());
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + '');
                    return value;
                }
            } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        },
        prop: function (elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === 'string' && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === 'string' && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : '';
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function () {
                if (type === 'string') {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === 'boolean') {
                    if (this.className) {
                        data_priv.set(this, '__className__', this.className);
                    }
                    this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
                }
            });
        },
        hasClass: function (selector) {
            var className = ' ' + selector + ' ', i = 0, l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function (data) {
        return JSON.parse(data + '');
    };
    jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, 'text/xml');
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = '*/'.concat('*'), ajaxLocation = window.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s['throws']) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: 'GET',
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': jQuery.parseJSON,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, 'body')) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function (elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
            };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&').replace(r20, '+');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.attachEvent) {
        window.attachEvent('onunload', function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers['X-Requested-With']) {
                        headers['X-Requested-With'] = 'XMLHttpRequest';
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === 'abort') {
                                    xhr.abort();
                                } else if (type === 'error') {
                                    complete(xhr.status, xhr.statusText);
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    xhr.onerror = callback('error');
                    callback = xhrCallbacks[id] = callback('abort');
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
        contents: { script: /(?:java|ecma)script/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery('<script>').prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on('load error', callback = function (evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === 'error' ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = jQuery.buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== 'string' && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(' ');
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function (jqXHR, status) {
                self.each(callback, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        }
        return this;
    };
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                    top: 0,
                    left: 0
                }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = 'pageYOffset' === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function () {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === 'function' && define.amd) {
        define('jquery@2.1.4#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*angular@1.4.8#angular*/
define('angular@1.4.8#angular', function (require, exports, module) {
    (function (window, document, undefined) {
        'use strict';
        function minErr(module, ErrorConstructor) {
            ErrorConstructor = ErrorConstructor || Error;
            return function () {
                var SKIP_INDEXES = 2;
                var templateArgs = arguments, code = templateArgs[0], message = '[' + (module ? module + ':' : '') + code + '] ', template = templateArgs[1], paramPrefix, i;
                message += template.replace(/\{\d+\}/g, function (match) {
                    var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                    if (shiftedIndex < templateArgs.length) {
                        return toDebugString(templateArgs[shiftedIndex]);
                    }
                    return match;
                });
                message += '\nhttp://errors.angularjs.org/1.4.8/' + (module ? module + '/' : '') + code;
                for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
                    message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
                }
                return new ErrorConstructor(message);
            };
        }
        var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
        var VALIDITY_STATE_PROPERTY = 'validity';
        var lowercase = function (string) {
            return isString(string) ? string.toLowerCase() : string;
        };
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var uppercase = function (string) {
            return isString(string) ? string.toUpperCase() : string;
        };
        var manualLowercase = function (s) {
            return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
                return String.fromCharCode(ch.charCodeAt(0) | 32);
            }) : s;
        };
        var manualUppercase = function (s) {
            return isString(s) ? s.replace(/[a-z]/g, function (ch) {
                return String.fromCharCode(ch.charCodeAt(0) & ~32);
            }) : s;
        };
        if ('i' !== 'I'.toLowerCase()) {
            lowercase = manualLowercase;
            uppercase = manualUppercase;
        }
        var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr('ng'), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
        msie = document.documentMode;
        function isArrayLike(obj) {
            if (obj == null || isWindow(obj))
                return false;
            if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite)
                return true;
            var length = 'length' in Object(obj) && obj.length;
            return isNumber(length) && (length >= 0 && length - 1 in obj || typeof obj.item == 'function');
        }
        function forEach(obj, iterator, context) {
            var key, length;
            if (obj) {
                if (isFunction(obj)) {
                    for (key in obj) {
                        if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else if (isArray(obj) || isArrayLike(obj)) {
                    var isPrimitive = typeof obj !== 'object';
                    for (key = 0, length = obj.length; key < length; key++) {
                        if (isPrimitive || key in obj) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else if (obj.forEach && obj.forEach !== forEach) {
                    obj.forEach(iterator, context, obj);
                } else if (isBlankObject(obj)) {
                    for (key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                } else if (typeof obj.hasOwnProperty === 'function') {
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else {
                    for (key in obj) {
                        if (hasOwnProperty.call(obj, key)) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                }
            }
            return obj;
        }
        function forEachSorted(obj, iterator, context) {
            var keys = Object.keys(obj).sort();
            for (var i = 0; i < keys.length; i++) {
                iterator.call(context, obj[keys[i]], keys[i]);
            }
            return keys;
        }
        function reverseParams(iteratorFn) {
            return function (value, key) {
                iteratorFn(key, value);
            };
        }
        function nextUid() {
            return ++uid;
        }
        function setHashKey(obj, h) {
            if (h) {
                obj.$$hashKey = h;
            } else {
                delete obj.$$hashKey;
            }
        }
        function baseExtend(dst, objs, deep) {
            var h = dst.$$hashKey;
            for (var i = 0, ii = objs.length; i < ii; ++i) {
                var obj = objs[i];
                if (!isObject(obj) && !isFunction(obj))
                    continue;
                var keys = Object.keys(obj);
                for (var j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    var src = obj[key];
                    if (deep && isObject(src)) {
                        if (isDate(src)) {
                            dst[key] = new Date(src.valueOf());
                        } else if (isRegExp(src)) {
                            dst[key] = new RegExp(src);
                        } else if (src.nodeName) {
                            dst[key] = src.cloneNode(true);
                        } else if (isElement(src)) {
                            dst[key] = src.clone();
                        } else {
                            if (!isObject(dst[key]))
                                dst[key] = isArray(src) ? [] : {};
                            baseExtend(dst[key], [src], true);
                        }
                    } else {
                        dst[key] = src;
                    }
                }
            }
            setHashKey(dst, h);
            return dst;
        }
        function extend(dst) {
            return baseExtend(dst, slice.call(arguments, 1), false);
        }
        function merge(dst) {
            return baseExtend(dst, slice.call(arguments, 1), true);
        }
        function toInt(str) {
            return parseInt(str, 10);
        }
        function inherit(parent, extra) {
            return extend(Object.create(parent), extra);
        }
        function noop() {
        }
        noop.$inject = [];
        function identity($) {
            return $;
        }
        identity.$inject = [];
        function valueFn(value) {
            return function () {
                return value;
            };
        }
        function hasCustomToString(obj) {
            return isFunction(obj.toString) && obj.toString !== toString;
        }
        function isUndefined(value) {
            return typeof value === 'undefined';
        }
        function isDefined(value) {
            return typeof value !== 'undefined';
        }
        function isObject(value) {
            return value !== null && typeof value === 'object';
        }
        function isBlankObject(value) {
            return value !== null && typeof value === 'object' && !getPrototypeOf(value);
        }
        function isString(value) {
            return typeof value === 'string';
        }
        function isNumber(value) {
            return typeof value === 'number';
        }
        function isDate(value) {
            return toString.call(value) === '[object Date]';
        }
        var isArray = Array.isArray;
        function isFunction(value) {
            return typeof value === 'function';
        }
        function isRegExp(value) {
            return toString.call(value) === '[object RegExp]';
        }
        function isWindow(obj) {
            return obj && obj.window === obj;
        }
        function isScope(obj) {
            return obj && obj.$evalAsync && obj.$watch;
        }
        function isFile(obj) {
            return toString.call(obj) === '[object File]';
        }
        function isFormData(obj) {
            return toString.call(obj) === '[object FormData]';
        }
        function isBlob(obj) {
            return toString.call(obj) === '[object Blob]';
        }
        function isBoolean(value) {
            return typeof value === 'boolean';
        }
        function isPromiseLike(obj) {
            return obj && isFunction(obj.then);
        }
        var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
        function isTypedArray(value) {
            return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
        }
        var trim = function (value) {
            return isString(value) ? value.trim() : value;
        };
        var escapeForRegexp = function (s) {
            return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
        };
        function isElement(node) {
            return !!(node && (node.nodeName || node.prop && node.attr && node.find));
        }
        function makeMap(str) {
            var obj = {}, items = str.split(','), i;
            for (i = 0; i < items.length; i++) {
                obj[items[i]] = true;
            }
            return obj;
        }
        function nodeName_(element) {
            return lowercase(element.nodeName || element[0] && element[0].nodeName);
        }
        function includes(array, obj) {
            return Array.prototype.indexOf.call(array, obj) != -1;
        }
        function arrayRemove(array, value) {
            var index = array.indexOf(value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return index;
        }
        function copy(source, destination) {
            var stackSource = [];
            var stackDest = [];
            if (destination) {
                if (isTypedArray(destination)) {
                    throw ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot be mutated.');
                }
                if (source === destination) {
                    throw ngMinErr('cpi', 'Can\'t copy! Source and destination are identical.');
                }
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function (value, key) {
                        if (key !== '$$hashKey') {
                            delete destination[key];
                        }
                    });
                }
                stackSource.push(source);
                stackDest.push(destination);
                return copyRecurse(source, destination);
            }
            return copyElement(source);
            function copyRecurse(source, destination) {
                var h = destination.$$hashKey;
                var result, key;
                if (isArray(source)) {
                    for (var i = 0, ii = source.length; i < ii; i++) {
                        destination.push(copyElement(source[i]));
                    }
                } else if (isBlankObject(source)) {
                    for (key in source) {
                        destination[key] = copyElement(source[key]);
                    }
                } else if (source && typeof source.hasOwnProperty === 'function') {
                    for (key in source) {
                        if (source.hasOwnProperty(key)) {
                            destination[key] = copyElement(source[key]);
                        }
                    }
                } else {
                    for (key in source) {
                        if (hasOwnProperty.call(source, key)) {
                            destination[key] = copyElement(source[key]);
                        }
                    }
                }
                setHashKey(destination, h);
                return destination;
            }
            function copyElement(source) {
                if (!isObject(source)) {
                    return source;
                }
                var index = stackSource.indexOf(source);
                if (index !== -1) {
                    return stackDest[index];
                }
                if (isWindow(source) || isScope(source)) {
                    throw ngMinErr('cpws', 'Can\'t copy! Making copies of Window or Scope instances is not supported.');
                }
                var needsRecurse = false;
                var destination;
                if (isArray(source)) {
                    destination = [];
                    needsRecurse = true;
                } else if (isTypedArray(source)) {
                    destination = new source.constructor(source);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isRegExp(source)) {
                    destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                    destination.lastIndex = source.lastIndex;
                } else if (isFunction(source.cloneNode)) {
                    destination = source.cloneNode(true);
                } else {
                    destination = Object.create(getPrototypeOf(source));
                    needsRecurse = true;
                }
                stackSource.push(source);
                stackDest.push(destination);
                return needsRecurse ? copyRecurse(source, destination) : destination;
            }
        }
        function shallowCopy(src, dst) {
            if (isArray(src)) {
                dst = dst || [];
                for (var i = 0, ii = src.length; i < ii; i++) {
                    dst[i] = src[i];
                }
            } else if (isObject(src)) {
                dst = dst || {};
                for (var key in src) {
                    if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
                        dst[key] = src[key];
                    }
                }
            }
            return dst || src;
        }
        function equals(o1, o2) {
            if (o1 === o2)
                return true;
            if (o1 === null || o2 === null)
                return false;
            if (o1 !== o1 && o2 !== o2)
                return true;
            var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
            if (t1 == t2) {
                if (t1 == 'object') {
                    if (isArray(o1)) {
                        if (!isArray(o2))
                            return false;
                        if ((length = o1.length) == o2.length) {
                            for (key = 0; key < length; key++) {
                                if (!equals(o1[key], o2[key]))
                                    return false;
                            }
                            return true;
                        }
                    } else if (isDate(o1)) {
                        if (!isDate(o2))
                            return false;
                        return equals(o1.getTime(), o2.getTime());
                    } else if (isRegExp(o1)) {
                        return isRegExp(o2) ? o1.toString() == o2.toString() : false;
                    } else {
                        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                            return false;
                        keySet = createMap();
                        for (key in o1) {
                            if (key.charAt(0) === '$' || isFunction(o1[key]))
                                continue;
                            if (!equals(o1[key], o2[key]))
                                return false;
                            keySet[key] = true;
                        }
                        for (key in o2) {
                            if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                                return false;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
        var csp = function () {
            if (!isDefined(csp.rules)) {
                var ngCspElement = document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]');
                if (ngCspElement) {
                    var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
                    csp.rules = {
                        noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf('no-unsafe-eval') !== -1,
                        noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf('no-inline-style') !== -1
                    };
                } else {
                    csp.rules = {
                        noUnsafeEval: noUnsafeEval(),
                        noInlineStyle: false
                    };
                }
            }
            return csp.rules;
            function noUnsafeEval() {
                try {
                    new Function('');
                    return false;
                } catch (e) {
                    return true;
                }
            }
        };
        var jq = function () {
            if (isDefined(jq.name_))
                return jq.name_;
            var el;
            var i, ii = ngAttrPrefixes.length, prefix, name;
            for (i = 0; i < ii; ++i) {
                prefix = ngAttrPrefixes[i];
                if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
                    name = el.getAttribute(prefix + 'jq');
                    break;
                }
            }
            return jq.name_ = name;
        };
        function concat(array1, array2, index) {
            return array1.concat(slice.call(array2, index));
        }
        function sliceArgs(args, startIndex) {
            return slice.call(args, startIndex || 0);
        }
        function bind(self, fn) {
            var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
            if (isFunction(fn) && !(fn instanceof RegExp)) {
                return curryArgs.length ? function () {
                    return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
                } : function () {
                    return arguments.length ? fn.apply(self, arguments) : fn.call(self);
                };
            } else {
                return fn;
            }
        }
        function toJsonReplacer(key, value) {
            var val = value;
            if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
                val = undefined;
            } else if (isWindow(value)) {
                val = '$WINDOW';
            } else if (value && document === value) {
                val = '$DOCUMENT';
            } else if (isScope(value)) {
                val = '$SCOPE';
            }
            return val;
        }
        function toJson(obj, pretty) {
            if (typeof obj === 'undefined')
                return undefined;
            if (!isNumber(pretty)) {
                pretty = pretty ? 2 : null;
            }
            return JSON.stringify(obj, toJsonReplacer, pretty);
        }
        function fromJson(json) {
            return isString(json) ? JSON.parse(json) : json;
        }
        function timezoneToOffset(timezone, fallback) {
            var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
            return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }
        function addDateMinutes(date, minutes) {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + minutes);
            return date;
        }
        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
        }
        function startingTag(element) {
            element = jqLite(element).clone();
            try {
                element.empty();
            } catch (e) {
            }
            var elemHtml = jqLite('<div>').append(element).html();
            try {
                return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
                    return '<' + lowercase(nodeName);
                });
            } catch (e) {
                return lowercase(elemHtml);
            }
        }
        function tryDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value);
            } catch (e) {
            }
        }
        function parseKeyValue(keyValue) {
            var obj = {};
            forEach((keyValue || '').split('&'), function (keyValue) {
                var splitPoint, key, val;
                if (keyValue) {
                    key = keyValue = keyValue.replace(/\+/g, '%20');
                    splitPoint = keyValue.indexOf('=');
                    if (splitPoint !== -1) {
                        key = keyValue.substring(0, splitPoint);
                        val = keyValue.substring(splitPoint + 1);
                    }
                    key = tryDecodeURIComponent(key);
                    if (isDefined(key)) {
                        val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                        if (!hasOwnProperty.call(obj, key)) {
                            obj[key] = val;
                        } else if (isArray(obj[key])) {
                            obj[key].push(val);
                        } else {
                            obj[key] = [
                                obj[key],
                                val
                            ];
                        }
                    }
                }
            });
            return obj;
        }
        function toKeyValue(obj) {
            var parts = [];
            forEach(obj, function (value, key) {
                if (isArray(value)) {
                    forEach(value, function (arrayValue) {
                        parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
                    });
                } else {
                    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
                }
            });
            return parts.length ? parts.join('&') : '';
        }
        function encodeUriSegment(val) {
            return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
        }
        function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
        }
        var ngAttrPrefixes = [
            'ng-',
            'data-ng-',
            'ng:',
            'x-ng-'
        ];
        function getNgAttribute(element, ngAttr) {
            var attr, i, ii = ngAttrPrefixes.length;
            for (i = 0; i < ii; ++i) {
                attr = ngAttrPrefixes[i] + ngAttr;
                if (isString(attr = element.getAttribute(attr))) {
                    return attr;
                }
            }
            return null;
        }
        function angularInit(element, bootstrap) {
            var appElement, module, config = {};
            forEach(ngAttrPrefixes, function (prefix) {
                var name = prefix + 'app';
                if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                    appElement = element;
                    module = element.getAttribute(name);
                }
            });
            forEach(ngAttrPrefixes, function (prefix) {
                var name = prefix + 'app';
                var candidate;
                if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
                    appElement = candidate;
                    module = candidate.getAttribute(name);
                }
            });
            if (appElement) {
                config.strictDi = getNgAttribute(appElement, 'strict-di') !== null;
                bootstrap(appElement, module ? [module] : [], config);
            }
        }
        function bootstrap(element, modules, config) {
            if (!isObject(config))
                config = {};
            var defaultConfig = { strictDi: false };
            config = extend(defaultConfig, config);
            var doBootstrap = function () {
                element = jqLite(element);
                if (element.injector()) {
                    var tag = element[0] === document ? 'document' : startingTag(element);
                    throw ngMinErr('btstrpd', 'App Already Bootstrapped with this Element \'{0}\'', tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
                }
                modules = modules || [];
                modules.unshift([
                    '$provide',
                    function ($provide) {
                        $provide.value('$rootElement', element);
                    }
                ]);
                if (config.debugInfoEnabled) {
                    modules.push([
                        '$compileProvider',
                        function ($compileProvider) {
                            $compileProvider.debugInfoEnabled(true);
                        }
                    ]);
                }
                modules.unshift('ng');
                var injector = createInjector(modules, config.strictDi);
                injector.invoke([
                    '$rootScope',
                    '$rootElement',
                    '$compile',
                    '$injector',
                    function bootstrapApply(scope, element, compile, injector) {
                        scope.$apply(function () {
                            element.data('$injector', injector);
                            compile(element)(scope);
                        });
                    }
                ]);
                return injector;
            };
            var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
            var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
            if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
                config.debugInfoEnabled = true;
                window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
            }
            if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
                return doBootstrap();
            }
            window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
            angular.resumeBootstrap = function (extraModules) {
                forEach(extraModules, function (module) {
                    modules.push(module);
                });
                return doBootstrap();
            };
            if (isFunction(angular.resumeDeferredBootstrap)) {
                angular.resumeDeferredBootstrap();
            }
        }
        function reloadWithDebugInfo() {
            window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
            window.location.reload();
        }
        function getTestability(rootElement) {
            var injector = angular.element(rootElement).injector();
            if (!injector) {
                throw ngMinErr('test', 'no injector found for element argument to getTestability');
            }
            return injector.get('$$testability');
        }
        var SNAKE_CASE_REGEXP = /[A-Z]/g;
        function snake_case(name, separator) {
            separator = separator || '_';
            return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? separator : '') + letter.toLowerCase();
            });
        }
        var bindJQueryFired = false;
        var skipDestroyOnNextJQueryCleanData;
        function bindJQuery() {
            var originalCleanData;
            if (bindJQueryFired) {
                return;
            }
            var jqName = jq();
            jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
            if (jQuery && jQuery.fn.on) {
                jqLite = jQuery;
                extend(jQuery.fn, {
                    scope: JQLitePrototype.scope,
                    isolateScope: JQLitePrototype.isolateScope,
                    controller: JQLitePrototype.controller,
                    injector: JQLitePrototype.injector,
                    inheritedData: JQLitePrototype.inheritedData
                });
                originalCleanData = jQuery.cleanData;
                jQuery.cleanData = function (elems) {
                    var events;
                    if (!skipDestroyOnNextJQueryCleanData) {
                        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                            events = jQuery._data(elem, 'events');
                            if (events && events.$destroy) {
                                jQuery(elem).triggerHandler('$destroy');
                            }
                        }
                    } else {
                        skipDestroyOnNextJQueryCleanData = false;
                    }
                    originalCleanData(elems);
                };
            } else {
                jqLite = JQLite;
            }
            angular.element = jqLite;
            bindJQueryFired = true;
        }
        function assertArg(arg, name, reason) {
            if (!arg) {
                throw ngMinErr('areq', 'Argument \'{0}\' is {1}', name || '?', reason || 'required');
            }
            return arg;
        }
        function assertArgFn(arg, name, acceptArrayAnnotation) {
            if (acceptArrayAnnotation && isArray(arg)) {
                arg = arg[arg.length - 1];
            }
            assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
            return arg;
        }
        function assertNotHasOwnProperty(name, context) {
            if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
            }
        }
        function getter(obj, path, bindFnToScope) {
            if (!path)
                return obj;
            var keys = path.split('.');
            var key;
            var lastInstance = obj;
            var len = keys.length;
            for (var i = 0; i < len; i++) {
                key = keys[i];
                if (obj) {
                    obj = (lastInstance = obj)[key];
                }
            }
            if (!bindFnToScope && isFunction(obj)) {
                return bind(lastInstance, obj);
            }
            return obj;
        }
        function getBlockNodes(nodes) {
            var node = nodes[0];
            var endNode = nodes[nodes.length - 1];
            var blockNodes;
            for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
                if (blockNodes || nodes[i] !== node) {
                    if (!blockNodes) {
                        blockNodes = jqLite(slice.call(nodes, 0, i));
                    }
                    blockNodes.push(node);
                }
            }
            return blockNodes || nodes;
        }
        function createMap() {
            return Object.create(null);
        }
        var NODE_TYPE_ELEMENT = 1;
        var NODE_TYPE_ATTRIBUTE = 2;
        var NODE_TYPE_TEXT = 3;
        var NODE_TYPE_COMMENT = 8;
        var NODE_TYPE_DOCUMENT = 9;
        var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
        function setupModuleLoader(window) {
            var $injectorMinErr = minErr('$injector');
            var ngMinErr = minErr('ng');
            function ensure(obj, name, factory) {
                return obj[name] || (obj[name] = factory());
            }
            var angular = ensure(window, 'angular', Object);
            angular.$$minErr = angular.$$minErr || minErr;
            return ensure(angular, 'module', function () {
                var modules = {};
                return function module(name, requires, configFn) {
                    var assertNotHasOwnProperty = function (name, context) {
                        if (name === 'hasOwnProperty') {
                            throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
                        }
                    };
                    assertNotHasOwnProperty(name, 'module');
                    if (requires && modules.hasOwnProperty(name)) {
                        modules[name] = null;
                    }
                    return ensure(modules, name, function () {
                        if (!requires) {
                            throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
                        }
                        var invokeQueue = [];
                        var configBlocks = [];
                        var runBlocks = [];
                        var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
                        var moduleInstance = {
                            _invokeQueue: invokeQueue,
                            _configBlocks: configBlocks,
                            _runBlocks: runBlocks,
                            requires: requires,
                            name: name,
                            provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                            factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                            service: invokeLaterAndSetModuleName('$provide', 'service'),
                            value: invokeLater('$provide', 'value'),
                            constant: invokeLater('$provide', 'constant', 'unshift'),
                            decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                            animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                            filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                            controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                            directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                            config: config,
                            run: function (block) {
                                runBlocks.push(block);
                                return this;
                            }
                        };
                        if (configFn) {
                            config(configFn);
                        }
                        return moduleInstance;
                        function invokeLater(provider, method, insertMethod, queue) {
                            if (!queue)
                                queue = invokeQueue;
                            return function () {
                                queue[insertMethod || 'push']([
                                    provider,
                                    method,
                                    arguments
                                ]);
                                return moduleInstance;
                            };
                        }
                        function invokeLaterAndSetModuleName(provider, method) {
                            return function (recipeName, factoryFunction) {
                                if (factoryFunction && isFunction(factoryFunction))
                                    factoryFunction.$$moduleName = name;
                                invokeQueue.push([
                                    provider,
                                    method,
                                    arguments
                                ]);
                                return moduleInstance;
                            };
                        }
                    });
                };
            });
        }
        function serializeObject(obj) {
            var seen = [];
            return JSON.stringify(obj, function (key, val) {
                val = toJsonReplacer(key, val);
                if (isObject(val)) {
                    if (seen.indexOf(val) >= 0)
                        return '...';
                    seen.push(val);
                }
                return val;
            });
        }
        function toDebugString(obj) {
            if (typeof obj === 'function') {
                return obj.toString().replace(/ \{[\s\S]*$/, '');
            } else if (isUndefined(obj)) {
                return 'undefined';
            } else if (typeof obj !== 'string') {
                return serializeObject(obj);
            }
            return obj;
        }
        var version = {
            full: '1.4.8',
            major: 1,
            minor: 4,
            dot: 8,
            codeName: 'ice-manipulation'
        };
        function publishExternalAPI(angular) {
            extend(angular, {
                'bootstrap': bootstrap,
                'copy': copy,
                'extend': extend,
                'merge': merge,
                'equals': equals,
                'element': jqLite,
                'forEach': forEach,
                'injector': createInjector,
                'noop': noop,
                'bind': bind,
                'toJson': toJson,
                'fromJson': fromJson,
                'identity': identity,
                'isUndefined': isUndefined,
                'isDefined': isDefined,
                'isString': isString,
                'isFunction': isFunction,
                'isObject': isObject,
                'isNumber': isNumber,
                'isElement': isElement,
                'isArray': isArray,
                'version': version,
                'isDate': isDate,
                'lowercase': lowercase,
                'uppercase': uppercase,
                'callbacks': { counter: 0 },
                'getTestability': getTestability,
                '$$minErr': minErr,
                '$$csp': csp,
                'reloadWithDebugInfo': reloadWithDebugInfo
            });
            angularModule = setupModuleLoader(window);
            angularModule('ng', ['ngLocale'], [
                '$provide',
                function ngModule($provide) {
                    $provide.provider({ $$sanitizeUri: $$SanitizeUriProvider });
                    $provide.provider('$compile', $CompileProvider).directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        style: styleDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        pattern: patternDirective,
                        ngPattern: patternDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        minlength: minlengthDirective,
                        ngMinlength: minlengthDirective,
                        maxlength: maxlengthDirective,
                        ngMaxlength: maxlengthDirective,
                        ngValue: ngValueDirective,
                        ngModelOptions: ngModelOptionsDirective
                    }).directive({ ngInclude: ngIncludeFillContentDirective }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
                    $provide.provider({
                        $anchorScroll: $AnchorScrollProvider,
                        $animate: $AnimateProvider,
                        $animateCss: $CoreAnimateCssProvider,
                        $$animateQueue: $$CoreAnimateQueueProvider,
                        $$AnimateRunner: $$CoreAnimateRunnerProvider,
                        $browser: $BrowserProvider,
                        $cacheFactory: $CacheFactoryProvider,
                        $controller: $ControllerProvider,
                        $document: $DocumentProvider,
                        $exceptionHandler: $ExceptionHandlerProvider,
                        $filter: $FilterProvider,
                        $$forceReflow: $$ForceReflowProvider,
                        $interpolate: $InterpolateProvider,
                        $interval: $IntervalProvider,
                        $http: $HttpProvider,
                        $httpParamSerializer: $HttpParamSerializerProvider,
                        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                        $httpBackend: $HttpBackendProvider,
                        $xhrFactory: $xhrFactoryProvider,
                        $location: $LocationProvider,
                        $log: $LogProvider,
                        $parse: $ParseProvider,
                        $rootScope: $RootScopeProvider,
                        $q: $QProvider,
                        $$q: $$QProvider,
                        $sce: $SceProvider,
                        $sceDelegate: $SceDelegateProvider,
                        $sniffer: $SnifferProvider,
                        $templateCache: $TemplateCacheProvider,
                        $templateRequest: $TemplateRequestProvider,
                        $$testability: $$TestabilityProvider,
                        $timeout: $TimeoutProvider,
                        $window: $WindowProvider,
                        $$rAF: $$RAFProvider,
                        $$jqLite: $$jqLiteProvider,
                        $$HashMap: $$HashMapProvider,
                        $$cookieReader: $$CookieReaderProvider
                    });
                }
            ]);
        }
        JQLite.expando = 'ng339';
        var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function (element, type, fn) {
                element.addEventListener(type, fn, false);
            }, removeEventListenerFn = function (element, type, fn) {
                element.removeEventListener(type, fn, false);
            };
        JQLite._data = function (node) {
            return this.cache[node[this.expando]] || {};
        };
        function jqNextId() {
            return ++jqId;
        }
        var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
        var MOZ_HACK_REGEXP = /^moz([A-Z])/;
        var MOUSE_EVENT_MAP = {
            mouseleave: 'mouseout',
            mouseenter: 'mouseover'
        };
        var jqLiteMinErr = minErr('jqLite');
        function camelCase(name) {
            return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).replace(MOZ_HACK_REGEXP, 'Moz$1');
        }
        var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
        var HTML_REGEXP = /<|&#?\w+;/;
        var TAG_NAME_REGEXP = /<([\w:-]+)/;
        var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
        var wrapMap = {
            'option': [
                1,
                '<select multiple="multiple">',
                '</select>'
            ],
            'thead': [
                1,
                '<table>',
                '</table>'
            ],
            'col': [
                2,
                '<table><colgroup>',
                '</colgroup></table>'
            ],
            'tr': [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            'td': [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            '_default': [
                0,
                '',
                ''
            ]
        };
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        function jqLiteIsTextNode(html) {
            return !HTML_REGEXP.test(html);
        }
        function jqLiteAcceptsData(node) {
            var nodeType = node.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
        }
        function jqLiteHasData(node) {
            for (var key in jqCache[node.ng339]) {
                return true;
            }
            return false;
        }
        function jqLiteBuildFragment(html, context) {
            var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
            if (jqLiteIsTextNode(html)) {
                nodes.push(context.createTextNode(html));
            } else {
                tmp = tmp || fragment.appendChild(context.createElement('div'));
                tag = (TAG_NAME_REGEXP.exec(html) || [
                    '',
                    ''
                ])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, '<$1></$2>') + wrap[2];
                i = wrap[0];
                while (i--) {
                    tmp = tmp.lastChild;
                }
                nodes = concat(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = '';
            }
            fragment.textContent = '';
            fragment.innerHTML = '';
            forEach(nodes, function (node) {
                fragment.appendChild(node);
            });
            return fragment;
        }
        function jqLiteParseHTML(html, context) {
            context = context || document;
            var parsed;
            if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
                return [context.createElement(parsed[1])];
            }
            if (parsed = jqLiteBuildFragment(html, context)) {
                return parsed.childNodes;
            }
            return [];
        }
        var jqLiteContains = Node.prototype.contains || function (arg) {
            return !!(this.compareDocumentPosition(arg) & 16);
        };
        function JQLite(element) {
            if (element instanceof JQLite) {
                return element;
            }
            var argIsString;
            if (isString(element)) {
                element = trim(element);
                argIsString = true;
            }
            if (!(this instanceof JQLite)) {
                if (argIsString && element.charAt(0) != '<') {
                    throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
                }
                return new JQLite(element);
            }
            if (argIsString) {
                jqLiteAddNodes(this, jqLiteParseHTML(element));
            } else {
                jqLiteAddNodes(this, element);
            }
        }
        function jqLiteClone(element) {
            return element.cloneNode(true);
        }
        function jqLiteDealoc(element, onlyDescendants) {
            if (!onlyDescendants)
                jqLiteRemoveData(element);
            if (element.querySelectorAll) {
                var descendants = element.querySelectorAll('*');
                for (var i = 0, l = descendants.length; i < l; i++) {
                    jqLiteRemoveData(descendants[i]);
                }
            }
        }
        function jqLiteOff(element, type, fn, unsupported) {
            if (isDefined(unsupported))
                throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var handle = expandoStore && expandoStore.handle;
            if (!handle)
                return;
            if (!type) {
                for (type in events) {
                    if (type !== '$destroy') {
                        removeEventListenerFn(element, type, handle);
                    }
                    delete events[type];
                }
            } else {
                var removeHandler = function (type) {
                    var listenerFns = events[type];
                    if (isDefined(fn)) {
                        arrayRemove(listenerFns || [], fn);
                    }
                    if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                        removeEventListenerFn(element, type, handle);
                        delete events[type];
                    }
                };
                forEach(type.split(' '), function (type) {
                    removeHandler(type);
                    if (MOUSE_EVENT_MAP[type]) {
                        removeHandler(MOUSE_EVENT_MAP[type]);
                    }
                });
            }
        }
        function jqLiteRemoveData(element, name) {
            var expandoId = element.ng339;
            var expandoStore = expandoId && jqCache[expandoId];
            if (expandoStore) {
                if (name) {
                    delete expandoStore.data[name];
                    return;
                }
                if (expandoStore.handle) {
                    if (expandoStore.events.$destroy) {
                        expandoStore.handle({}, '$destroy');
                    }
                    jqLiteOff(element);
                }
                delete jqCache[expandoId];
                element.ng339 = undefined;
            }
        }
        function jqLiteExpandoStore(element, createIfNecessary) {
            var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
            if (createIfNecessary && !expandoStore) {
                element.ng339 = expandoId = jqNextId();
                expandoStore = jqCache[expandoId] = {
                    events: {},
                    data: {},
                    handle: undefined
                };
            }
            return expandoStore;
        }
        function jqLiteData(element, key, value) {
            if (jqLiteAcceptsData(element)) {
                var isSimpleSetter = isDefined(value);
                var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
                var massGetter = !key;
                var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
                var data = expandoStore && expandoStore.data;
                if (isSimpleSetter) {
                    data[key] = value;
                } else {
                    if (massGetter) {
                        return data;
                    } else {
                        if (isSimpleGetter) {
                            return data && data[key];
                        } else {
                            extend(data, key);
                        }
                    }
                }
            }
        }
        function jqLiteHasClass(element, selector) {
            if (!element.getAttribute)
                return false;
            return (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
        }
        function jqLiteRemoveClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                forEach(cssClasses.split(' '), function (cssClass) {
                    element.setAttribute('class', trim((' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' ')));
                });
            }
        }
        function jqLiteAddClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ');
                forEach(cssClasses.split(' '), function (cssClass) {
                    cssClass = trim(cssClass);
                    if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                        existingClasses += cssClass + ' ';
                    }
                });
                element.setAttribute('class', trim(existingClasses));
            }
        }
        function jqLiteAddNodes(root, elements) {
            if (elements) {
                if (elements.nodeType) {
                    root[root.length++] = elements;
                } else {
                    var length = elements.length;
                    if (typeof length === 'number' && elements.window !== elements) {
                        if (length) {
                            for (var i = 0; i < length; i++) {
                                root[root.length++] = elements[i];
                            }
                        }
                    } else {
                        root[root.length++] = elements;
                    }
                }
            }
        }
        function jqLiteController(element, name) {
            return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
        }
        function jqLiteInheritedData(element, name, value) {
            if (element.nodeType == NODE_TYPE_DOCUMENT) {
                element = element.documentElement;
            }
            var names = isArray(name) ? name : [name];
            while (element) {
                for (var i = 0, ii = names.length; i < ii; i++) {
                    if (isDefined(value = jqLite.data(element, names[i])))
                        return value;
                }
                element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
            }
        }
        function jqLiteEmpty(element) {
            jqLiteDealoc(element, true);
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
        function jqLiteRemove(element, keepData) {
            if (!keepData)
                jqLiteDealoc(element);
            var parent = element.parentNode;
            if (parent)
                parent.removeChild(element);
        }
        function jqLiteDocumentLoaded(action, win) {
            win = win || window;
            if (win.document.readyState === 'complete') {
                win.setTimeout(action);
            } else {
                jqLite(win).on('load', action);
            }
        }
        var JQLitePrototype = JQLite.prototype = {
            ready: function (fn) {
                var fired = false;
                function trigger() {
                    if (fired)
                        return;
                    fired = true;
                    fn();
                }
                if (document.readyState === 'complete') {
                    setTimeout(trigger);
                } else {
                    this.on('DOMContentLoaded', trigger);
                    JQLite(window).on('load', trigger);
                }
            },
            toString: function () {
                var value = [];
                forEach(this, function (e) {
                    value.push('' + e);
                });
                return '[' + value.join(', ') + ']';
            },
            eq: function (index) {
                return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
            },
            length: 0,
            push: push,
            sort: [].sort,
            splice: [].splice
        };
        var BOOLEAN_ATTR = {};
        forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function (value) {
            BOOLEAN_ATTR[lowercase(value)] = value;
        });
        var BOOLEAN_ELEMENTS = {};
        forEach('input,select,option,textarea,button,form,details'.split(','), function (value) {
            BOOLEAN_ELEMENTS[value] = true;
        });
        var ALIASED_ATTR = {
            'ngMinlength': 'minlength',
            'ngMaxlength': 'maxlength',
            'ngMin': 'min',
            'ngMax': 'max',
            'ngPattern': 'pattern'
        };
        function getBooleanAttrName(element, name) {
            var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
            return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
        }
        function getAliasedAttrName(name) {
            return ALIASED_ATTR[name];
        }
        forEach({
            data: jqLiteData,
            removeData: jqLiteRemoveData,
            hasData: jqLiteHasData
        }, function (fn, name) {
            JQLite[name] = fn;
        });
        forEach({
            data: jqLiteData,
            inheritedData: jqLiteInheritedData,
            scope: function (element) {
                return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, [
                    '$isolateScope',
                    '$scope'
                ]);
            },
            isolateScope: function (element) {
                return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
            },
            controller: jqLiteController,
            injector: function (element) {
                return jqLiteInheritedData(element, '$injector');
            },
            removeAttr: function (element, name) {
                element.removeAttribute(name);
            },
            hasClass: jqLiteHasClass,
            css: function (element, name, value) {
                name = camelCase(name);
                if (isDefined(value)) {
                    element.style[name] = value;
                } else {
                    return element.style[name];
                }
            },
            attr: function (element, name, value) {
                var nodeType = element.nodeType;
                if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
                    return;
                }
                var lowercasedName = lowercase(name);
                if (BOOLEAN_ATTR[lowercasedName]) {
                    if (isDefined(value)) {
                        if (!!value) {
                            element[name] = true;
                            element.setAttribute(name, lowercasedName);
                        } else {
                            element[name] = false;
                            element.removeAttribute(lowercasedName);
                        }
                    } else {
                        return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                    }
                } else if (isDefined(value)) {
                    element.setAttribute(name, value);
                } else if (element.getAttribute) {
                    var ret = element.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            },
            prop: function (element, name, value) {
                if (isDefined(value)) {
                    element[name] = value;
                } else {
                    return element[name];
                }
            },
            text: function () {
                getText.$dv = '';
                return getText;
                function getText(element, value) {
                    if (isUndefined(value)) {
                        var nodeType = element.nodeType;
                        return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : '';
                    }
                    element.textContent = value;
                }
            }(),
            val: function (element, value) {
                if (isUndefined(value)) {
                    if (element.multiple && nodeName_(element) === 'select') {
                        var result = [];
                        forEach(element.options, function (option) {
                            if (option.selected) {
                                result.push(option.value || option.text);
                            }
                        });
                        return result.length === 0 ? null : result;
                    }
                    return element.value;
                }
                element.value = value;
            },
            html: function (element, value) {
                if (isUndefined(value)) {
                    return element.innerHTML;
                }
                jqLiteDealoc(element, true);
                element.innerHTML = value;
            },
            empty: jqLiteEmpty
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2) {
                var i, key;
                var nodeCount = this.length;
                if (fn !== jqLiteEmpty && isUndefined(fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
                    if (isObject(arg1)) {
                        for (i = 0; i < nodeCount; i++) {
                            if (fn === jqLiteData) {
                                fn(this[i], arg1);
                            } else {
                                for (key in arg1) {
                                    fn(this[i], key, arg1[key]);
                                }
                            }
                        }
                        return this;
                    } else {
                        var value = fn.$dv;
                        var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                        for (var j = 0; j < jj; j++) {
                            var nodeValue = fn(this[j], arg1, arg2);
                            value = value ? value + nodeValue : nodeValue;
                        }
                        return value;
                    }
                } else {
                    for (i = 0; i < nodeCount; i++) {
                        fn(this[i], arg1, arg2);
                    }
                    return this;
                }
            };
        });
        function createEventHandler(element, events) {
            var eventHandler = function (event, type) {
                event.isDefaultPrevented = function () {
                    return event.defaultPrevented;
                };
                var eventFns = events[type || event.type];
                var eventFnsLength = eventFns ? eventFns.length : 0;
                if (!eventFnsLength)
                    return;
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function () {
                        event.immediatePropagationStopped = true;
                        if (event.stopPropagation) {
                            event.stopPropagation();
                        }
                        if (originalStopImmediatePropagation) {
                            originalStopImmediatePropagation.call(event);
                        }
                    };
                }
                event.isImmediatePropagationStopped = function () {
                    return event.immediatePropagationStopped === true;
                };
                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                if (eventFnsLength > 1) {
                    eventFns = shallowCopy(eventFns);
                }
                for (var i = 0; i < eventFnsLength; i++) {
                    if (!event.isImmediatePropagationStopped()) {
                        handlerWrapper(element, event, eventFns[i]);
                    }
                }
            };
            eventHandler.elem = element;
            return eventHandler;
        }
        function defaultHandlerWrapper(element, event, handler) {
            handler.call(element, event);
        }
        function specialMouseHandlerWrapper(target, event, handler) {
            var related = event.relatedTarget;
            if (!related || related !== target && !jqLiteContains.call(target, related)) {
                handler.call(target, event);
            }
        }
        forEach({
            removeData: jqLiteRemoveData,
            on: function jqLiteOn(element, type, fn, unsupported) {
                if (isDefined(unsupported))
                    throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
                if (!jqLiteAcceptsData(element)) {
                    return;
                }
                var expandoStore = jqLiteExpandoStore(element, true);
                var events = expandoStore.events;
                var handle = expandoStore.handle;
                if (!handle) {
                    handle = expandoStore.handle = createEventHandler(element, events);
                }
                var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
                var i = types.length;
                var addHandler = function (type, specialHandlerWrapper, noEventListener) {
                    var eventFns = events[type];
                    if (!eventFns) {
                        eventFns = events[type] = [];
                        eventFns.specialHandlerWrapper = specialHandlerWrapper;
                        if (type !== '$destroy' && !noEventListener) {
                            addEventListenerFn(element, type, handle);
                        }
                    }
                    eventFns.push(fn);
                };
                while (i--) {
                    type = types[i];
                    if (MOUSE_EVENT_MAP[type]) {
                        addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                        addHandler(type, undefined, true);
                    } else {
                        addHandler(type);
                    }
                }
            },
            off: jqLiteOff,
            one: function (element, type, fn) {
                element = jqLite(element);
                element.on(type, function onFn() {
                    element.off(type, fn);
                    element.off(type, onFn);
                });
                element.on(type, fn);
            },
            replaceWith: function (element, replaceNode) {
                var index, parent = element.parentNode;
                jqLiteDealoc(element);
                forEach(new JQLite(replaceNode), function (node) {
                    if (index) {
                        parent.insertBefore(node, index.nextSibling);
                    } else {
                        parent.replaceChild(node, element);
                    }
                    index = node;
                });
            },
            children: function (element) {
                var children = [];
                forEach(element.childNodes, function (element) {
                    if (element.nodeType === NODE_TYPE_ELEMENT) {
                        children.push(element);
                    }
                });
                return children;
            },
            contents: function (element) {
                return element.contentDocument || element.childNodes || [];
            },
            append: function (element, node) {
                var nodeType = element.nodeType;
                if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
                    return;
                node = new JQLite(node);
                for (var i = 0, ii = node.length; i < ii; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            },
            prepend: function (element, node) {
                if (element.nodeType === NODE_TYPE_ELEMENT) {
                    var index = element.firstChild;
                    forEach(new JQLite(node), function (child) {
                        element.insertBefore(child, index);
                    });
                }
            },
            wrap: function (element, wrapNode) {
                wrapNode = jqLite(wrapNode).eq(0).clone()[0];
                var parent = element.parentNode;
                if (parent) {
                    parent.replaceChild(wrapNode, element);
                }
                wrapNode.appendChild(element);
            },
            remove: jqLiteRemove,
            detach: function (element) {
                jqLiteRemove(element, true);
            },
            after: function (element, newElement) {
                var index = element, parent = element.parentNode;
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; i < ii; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling);
                    index = node;
                }
            },
            addClass: jqLiteAddClass,
            removeClass: jqLiteRemoveClass,
            toggleClass: function (element, selector, condition) {
                if (selector) {
                    forEach(selector.split(' '), function (className) {
                        var classCondition = condition;
                        if (isUndefined(classCondition)) {
                            classCondition = !jqLiteHasClass(element, className);
                        }
                        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                    });
                }
            },
            parent: function (element) {
                var parent = element.parentNode;
                return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
            },
            next: function (element) {
                return element.nextElementSibling;
            },
            find: function (element, selector) {
                if (element.getElementsByTagName) {
                    return element.getElementsByTagName(selector);
                } else {
                    return [];
                }
            },
            clone: jqLiteClone,
            triggerHandler: function (element, event, extraParameters) {
                var dummyEvent, eventFnsCopy, handlerArgs;
                var eventName = event.type || event;
                var expandoStore = jqLiteExpandoStore(element);
                var events = expandoStore && expandoStore.events;
                var eventFns = events && events[eventName];
                if (eventFns) {
                    dummyEvent = {
                        preventDefault: function () {
                            this.defaultPrevented = true;
                        },
                        isDefaultPrevented: function () {
                            return this.defaultPrevented === true;
                        },
                        stopImmediatePropagation: function () {
                            this.immediatePropagationStopped = true;
                        },
                        isImmediatePropagationStopped: function () {
                            return this.immediatePropagationStopped === true;
                        },
                        stopPropagation: noop,
                        type: eventName,
                        target: element
                    };
                    if (event.type) {
                        dummyEvent = extend(dummyEvent, event);
                    }
                    eventFnsCopy = shallowCopy(eventFns);
                    handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
                    forEach(eventFnsCopy, function (fn) {
                        if (!dummyEvent.isImmediatePropagationStopped()) {
                            fn.apply(element, handlerArgs);
                        }
                    });
                }
            }
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2, arg3) {
                var value;
                for (var i = 0, ii = this.length; i < ii; i++) {
                    if (isUndefined(value)) {
                        value = fn(this[i], arg1, arg2, arg3);
                        if (isDefined(value)) {
                            value = jqLite(value);
                        }
                    } else {
                        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                    }
                }
                return isDefined(value) ? value : this;
            };
            JQLite.prototype.bind = JQLite.prototype.on;
            JQLite.prototype.unbind = JQLite.prototype.off;
        });
        function $$jqLiteProvider() {
            this.$get = function $$jqLite() {
                return extend(JQLite, {
                    hasClass: function (node, classes) {
                        if (node.attr)
                            node = node[0];
                        return jqLiteHasClass(node, classes);
                    },
                    addClass: function (node, classes) {
                        if (node.attr)
                            node = node[0];
                        return jqLiteAddClass(node, classes);
                    },
                    removeClass: function (node, classes) {
                        if (node.attr)
                            node = node[0];
                        return jqLiteRemoveClass(node, classes);
                    }
                });
            };
        }
        function hashKey(obj, nextUidFn) {
            var key = obj && obj.$$hashKey;
            if (key) {
                if (typeof key === 'function') {
                    key = obj.$$hashKey();
                }
                return key;
            }
            var objType = typeof obj;
            if (objType == 'function' || objType == 'object' && obj !== null) {
                key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
            } else {
                key = objType + ':' + obj;
            }
            return key;
        }
        function HashMap(array, isolatedUid) {
            if (isolatedUid) {
                var uid = 0;
                this.nextUid = function () {
                    return ++uid;
                };
            }
            forEach(array, this.put, this);
        }
        HashMap.prototype = {
            put: function (key, value) {
                this[hashKey(key, this.nextUid)] = value;
            },
            get: function (key) {
                return this[hashKey(key, this.nextUid)];
            },
            remove: function (key) {
                var value = this[key = hashKey(key, this.nextUid)];
                delete this[key];
                return value;
            }
        };
        var $$HashMapProvider = [function () {
                this.$get = [function () {
                        return HashMap;
                    }];
            }];
        var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
        var $injectorMinErr = minErr('$injector');
        function anonFn(fn) {
            var fnText = fn.toString().replace(STRIP_COMMENTS, ''), args = fnText.match(FN_ARGS);
            if (args) {
                return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
            }
            return 'fn';
        }
        function annotate(fn, strictDi, name) {
            var $inject, fnText, argDecl, last;
            if (typeof fn === 'function') {
                if (!($inject = fn.$inject)) {
                    $inject = [];
                    if (fn.length) {
                        if (strictDi) {
                            if (!isString(name) || !name) {
                                name = fn.name || anonFn(fn);
                            }
                            throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
                        }
                        fnText = fn.toString().replace(STRIP_COMMENTS, '');
                        argDecl = fnText.match(FN_ARGS);
                        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                            arg.replace(FN_ARG, function (all, underscore, name) {
                                $inject.push(name);
                            });
                        });
                    }
                    fn.$inject = $inject;
                }
            } else if (isArray(fn)) {
                last = fn.length - 1;
                assertArgFn(fn[last], 'fn');
                $inject = fn.slice(0, last);
            } else {
                assertArgFn(fn, 'fn', true);
            }
            return $inject;
        }
        function createInjector(modulesToLoad, strictDi) {
            strictDi = strictDi === true;
            var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap([], true), providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject(service),
                        value: supportObject(value),
                        constant: supportObject(constant),
                        decorator: decorator
                    }
                }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
                    if (angular.isString(caller)) {
                        path.push(caller);
                    }
                    throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' <- '));
                }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (serviceName, caller) {
                    var provider = providerInjector.get(serviceName + providerSuffix, caller);
                    return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
                });
            forEach(loadModules(modulesToLoad), function (fn) {
                if (fn)
                    instanceInjector.invoke(fn);
            });
            return instanceInjector;
            function supportObject(delegate) {
                return function (key, value) {
                    if (isObject(key)) {
                        forEach(key, reverseParams(delegate));
                    } else {
                        return delegate(key, value);
                    }
                };
            }
            function provider(name, provider_) {
                assertNotHasOwnProperty(name, 'service');
                if (isFunction(provider_) || isArray(provider_)) {
                    provider_ = providerInjector.instantiate(provider_);
                }
                if (!provider_.$get) {
                    throw $injectorMinErr('pget', 'Provider \'{0}\' must define $get factory method.', name);
                }
                return providerCache[name + providerSuffix] = provider_;
            }
            function enforceReturnValue(name, factory) {
                return function enforcedReturnValue() {
                    var result = instanceInjector.invoke(factory, this);
                    if (isUndefined(result)) {
                        throw $injectorMinErr('undef', 'Provider \'{0}\' must return a value from $get factory method.', name);
                    }
                    return result;
                };
            }
            function factory(name, factoryFn, enforce) {
                return provider(name, { $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn });
            }
            function service(name, constructor) {
                return factory(name, [
                    '$injector',
                    function ($injector) {
                        return $injector.instantiate(constructor);
                    }
                ]);
            }
            function value(name, val) {
                return factory(name, valueFn(val), false);
            }
            function constant(name, value) {
                assertNotHasOwnProperty(name, 'constant');
                providerCache[name] = value;
                instanceCache[name] = value;
            }
            function decorator(serviceName, decorFn) {
                var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                origProvider.$get = function () {
                    var origInstance = instanceInjector.invoke(orig$get, origProvider);
                    return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
                };
            }
            function loadModules(modulesToLoad) {
                assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
                var runBlocks = [], moduleFn;
                forEach(modulesToLoad, function (module) {
                    if (loadedModules.get(module))
                        return;
                    loadedModules.put(module, true);
                    function runInvokeQueue(queue) {
                        var i, ii;
                        for (i = 0, ii = queue.length; i < ii; i++) {
                            var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        }
                    }
                    try {
                        if (isString(module)) {
                            moduleFn = angularModule(module);
                            runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                            runInvokeQueue(moduleFn._invokeQueue);
                            runInvokeQueue(moduleFn._configBlocks);
                        } else if (isFunction(module)) {
                            runBlocks.push(providerInjector.invoke(module));
                        } else if (isArray(module)) {
                            runBlocks.push(providerInjector.invoke(module));
                        } else {
                            assertArgFn(module, 'module');
                        }
                    } catch (e) {
                        if (isArray(module)) {
                            module = module[module.length - 1];
                        }
                        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                            e = e.message + '\n' + e.stack;
                        }
                        throw $injectorMinErr('modulerr', 'Failed to instantiate module {0} due to:\n{1}', module, e.stack || e.message || e);
                    }
                });
                return runBlocks;
            }
            function createInternalInjector(cache, factory) {
                function getService(serviceName, caller) {
                    if (cache.hasOwnProperty(serviceName)) {
                        if (cache[serviceName] === INSTANTIATING) {
                            throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
                        }
                        return cache[serviceName];
                    } else {
                        try {
                            path.unshift(serviceName);
                            cache[serviceName] = INSTANTIATING;
                            return cache[serviceName] = factory(serviceName, caller);
                        } catch (err) {
                            if (cache[serviceName] === INSTANTIATING) {
                                delete cache[serviceName];
                            }
                            throw err;
                        } finally {
                            path.shift();
                        }
                    }
                }
                function invoke(fn, self, locals, serviceName) {
                    if (typeof locals === 'string') {
                        serviceName = locals;
                        locals = null;
                    }
                    var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), length, i, key;
                    for (i = 0, length = $inject.length; i < length; i++) {
                        key = $inject[i];
                        if (typeof key !== 'string') {
                            throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
                        }
                        args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                    }
                    if (isArray(fn)) {
                        fn = fn[length];
                    }
                    return fn.apply(self, args);
                }
                function instantiate(Type, locals, serviceName) {
                    var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
                    var returnedValue = invoke(Type, instance, locals, serviceName);
                    return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
                }
                return {
                    invoke: invoke,
                    instantiate: instantiate,
                    get: getService,
                    annotate: createInjector.$$annotate,
                    has: function (name) {
                        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                    }
                };
            }
        }
        createInjector.$$annotate = annotate;
        function $AnchorScrollProvider() {
            var autoScrollingEnabled = true;
            this.disableAutoScrolling = function () {
                autoScrollingEnabled = false;
            };
            this.$get = [
                '$window',
                '$location',
                '$rootScope',
                function ($window, $location, $rootScope) {
                    var document = $window.document;
                    function getFirstAnchor(list) {
                        var result = null;
                        Array.prototype.some.call(list, function (element) {
                            if (nodeName_(element) === 'a') {
                                result = element;
                                return true;
                            }
                        });
                        return result;
                    }
                    function getYOffset() {
                        var offset = scroll.yOffset;
                        if (isFunction(offset)) {
                            offset = offset();
                        } else if (isElement(offset)) {
                            var elem = offset[0];
                            var style = $window.getComputedStyle(elem);
                            if (style.position !== 'fixed') {
                                offset = 0;
                            } else {
                                offset = elem.getBoundingClientRect().bottom;
                            }
                        } else if (!isNumber(offset)) {
                            offset = 0;
                        }
                        return offset;
                    }
                    function scrollTo(elem) {
                        if (elem) {
                            elem.scrollIntoView();
                            var offset = getYOffset();
                            if (offset) {
                                var elemTop = elem.getBoundingClientRect().top;
                                $window.scrollBy(0, elemTop - offset);
                            }
                        } else {
                            $window.scrollTo(0, 0);
                        }
                    }
                    function scroll(hash) {
                        hash = isString(hash) ? hash : $location.hash();
                        var elm;
                        if (!hash)
                            scrollTo(null);
                        else if (elm = document.getElementById(hash))
                            scrollTo(elm);
                        else if (elm = getFirstAnchor(document.getElementsByName(hash)))
                            scrollTo(elm);
                        else if (hash === 'top')
                            scrollTo(null);
                    }
                    if (autoScrollingEnabled) {
                        $rootScope.$watch(function autoScrollWatch() {
                            return $location.hash();
                        }, function autoScrollWatchAction(newVal, oldVal) {
                            if (newVal === oldVal && newVal === '')
                                return;
                            jqLiteDocumentLoaded(function () {
                                $rootScope.$evalAsync(scroll);
                            });
                        });
                    }
                    return scroll;
                }
            ];
        }
        var $animateMinErr = minErr('$animate');
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_CLASSNAME = 'ng-animate';
        function mergeClasses(a, b) {
            if (!a && !b)
                return '';
            if (!a)
                return b;
            if (!b)
                return a;
            if (isArray(a))
                a = a.join(' ');
            if (isArray(b))
                b = b.join(' ');
            return a + ' ' + b;
        }
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType === ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function splitClasses(classes) {
            if (isString(classes)) {
                classes = classes.split(' ');
            }
            var obj = createMap();
            forEach(classes, function (klass) {
                if (klass.length) {
                    obj[klass] = true;
                }
            });
            return obj;
        }
        function prepareAnimateOptions(options) {
            return isObject(options) ? options : {};
        }
        var $$CoreAnimateRunnerProvider = function () {
            this.$get = [
                '$q',
                '$$rAF',
                function ($q, $$rAF) {
                    function AnimateRunner() {
                    }
                    AnimateRunner.all = noop;
                    AnimateRunner.chain = noop;
                    AnimateRunner.prototype = {
                        end: noop,
                        cancel: noop,
                        resume: noop,
                        pause: noop,
                        complete: noop,
                        then: function (pass, fail) {
                            return $q(function (resolve) {
                                $$rAF(function () {
                                    resolve();
                                });
                            }).then(pass, fail);
                        }
                    };
                    return AnimateRunner;
                }
            ];
        };
        var $$CoreAnimateQueueProvider = function () {
            var postDigestQueue = new HashMap();
            var postDigestElements = [];
            this.$get = [
                '$$AnimateRunner',
                '$rootScope',
                function ($$AnimateRunner, $rootScope) {
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function (element, event, options, domOperation) {
                            domOperation && domOperation();
                            options = options || {};
                            options.from && element.css(options.from);
                            options.to && element.css(options.to);
                            if (options.addClass || options.removeClass) {
                                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                            }
                            return new $$AnimateRunner();
                        }
                    };
                    function updateData(data, classes, value) {
                        var changed = false;
                        if (classes) {
                            classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
                            forEach(classes, function (className) {
                                if (className) {
                                    changed = true;
                                    data[className] = value;
                                }
                            });
                        }
                        return changed;
                    }
                    function handleCSSClassChanges() {
                        forEach(postDigestElements, function (element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = splitClasses(element.attr('class'));
                                var toAdd = '';
                                var toRemove = '';
                                forEach(data, function (status, className) {
                                    var hasClass = !!existing[className];
                                    if (status !== hasClass) {
                                        if (status) {
                                            toAdd += (toAdd.length ? ' ' : '') + className;
                                        } else {
                                            toRemove += (toRemove.length ? ' ' : '') + className;
                                        }
                                    }
                                });
                                forEach(element, function (elm) {
                                    toAdd && jqLiteAddClass(elm, toAdd);
                                    toRemove && jqLiteRemoveClass(elm, toRemove);
                                });
                                postDigestQueue.remove(element);
                            }
                        });
                        postDigestElements.length = 0;
                    }
                    function addRemoveClassesPostDigest(element, add, remove) {
                        var data = postDigestQueue.get(element) || {};
                        var classesAdded = updateData(data, add, true);
                        var classesRemoved = updateData(data, remove, false);
                        if (classesAdded || classesRemoved) {
                            postDigestQueue.put(element, data);
                            postDigestElements.push(element);
                            if (postDigestElements.length === 1) {
                                $rootScope.$$postDigest(handleCSSClassChanges);
                            }
                        }
                    }
                }
            ];
        };
        var $AnimateProvider = [
            '$provide',
            function ($provide) {
                var provider = this;
                this.$$registeredAnimations = Object.create(null);
                this.register = function (name, factory) {
                    if (name && name.charAt(0) !== '.') {
                        throw $animateMinErr('notcsel', 'Expecting class selector starting with \'.\' got \'{0}\'.', name);
                    }
                    var key = name + '-animation';
                    provider.$$registeredAnimations[name.substr(1)] = key;
                    $provide.factory(key, factory);
                };
                this.classNameFilter = function (expression) {
                    if (arguments.length === 1) {
                        this.$$classNameFilter = expression instanceof RegExp ? expression : null;
                        if (this.$$classNameFilter) {
                            var reservedRegex = new RegExp('(\\s+|\\/)' + NG_ANIMATE_CLASSNAME + '(\\s+|\\/)');
                            if (reservedRegex.test(this.$$classNameFilter.toString())) {
                                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                            }
                        }
                    }
                    return this.$$classNameFilter;
                };
                this.$get = [
                    '$$animateQueue',
                    function ($$animateQueue) {
                        function domInsert(element, parentElement, afterElement) {
                            if (afterElement) {
                                var afterNode = extractElementNode(afterElement);
                                if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                                    afterElement = null;
                                }
                            }
                            afterElement ? afterElement.after(element) : parentElement.prepend(element);
                        }
                        return {
                            on: $$animateQueue.on,
                            off: $$animateQueue.off,
                            pin: $$animateQueue.pin,
                            enabled: $$animateQueue.enabled,
                            cancel: function (runner) {
                                runner.end && runner.end();
                            },
                            enter: function (element, parent, after, options) {
                                parent = parent && jqLite(parent);
                                after = after && jqLite(after);
                                parent = parent || after.parent();
                                domInsert(element, parent, after);
                                return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
                            },
                            move: function (element, parent, after, options) {
                                parent = parent && jqLite(parent);
                                after = after && jqLite(after);
                                parent = parent || after.parent();
                                domInsert(element, parent, after);
                                return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
                            },
                            leave: function (element, options) {
                                return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function () {
                                    element.remove();
                                });
                            },
                            addClass: function (element, className, options) {
                                options = prepareAnimateOptions(options);
                                options.addClass = mergeClasses(options.addclass, className);
                                return $$animateQueue.push(element, 'addClass', options);
                            },
                            removeClass: function (element, className, options) {
                                options = prepareAnimateOptions(options);
                                options.removeClass = mergeClasses(options.removeClass, className);
                                return $$animateQueue.push(element, 'removeClass', options);
                            },
                            setClass: function (element, add, remove, options) {
                                options = prepareAnimateOptions(options);
                                options.addClass = mergeClasses(options.addClass, add);
                                options.removeClass = mergeClasses(options.removeClass, remove);
                                return $$animateQueue.push(element, 'setClass', options);
                            },
                            animate: function (element, from, to, className, options) {
                                options = prepareAnimateOptions(options);
                                options.from = options.from ? extend(options.from, from) : from;
                                options.to = options.to ? extend(options.to, to) : to;
                                className = className || 'ng-inline-animate';
                                options.tempClasses = mergeClasses(options.tempClasses, className);
                                return $$animateQueue.push(element, 'animate', options);
                            }
                        };
                    }
                ];
            }
        ];
        var $CoreAnimateCssProvider = function () {
            this.$get = [
                '$$rAF',
                '$q',
                function ($$rAF, $q) {
                    var RAFPromise = function () {
                    };
                    RAFPromise.prototype = {
                        done: function (cancel) {
                            this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
                        },
                        end: function () {
                            this.done();
                        },
                        cancel: function () {
                            this.done(true);
                        },
                        getPromise: function () {
                            if (!this.defer) {
                                this.defer = $q.defer();
                            }
                            return this.defer.promise;
                        },
                        then: function (f1, f2) {
                            return this.getPromise().then(f1, f2);
                        },
                        'catch': function (f1) {
                            return this.getPromise()['catch'](f1);
                        },
                        'finally': function (f1) {
                            return this.getPromise()['finally'](f1);
                        }
                    };
                    return function (element, options) {
                        if (options.cleanupStyles) {
                            options.from = options.to = null;
                        }
                        if (options.from) {
                            element.css(options.from);
                            options.from = null;
                        }
                        var closed, runner = new RAFPromise();
                        return {
                            start: run,
                            end: run
                        };
                        function run() {
                            $$rAF(function () {
                                close();
                                if (!closed) {
                                    runner.done();
                                }
                                closed = true;
                            });
                            return runner;
                        }
                        function close() {
                            if (options.addClass) {
                                element.addClass(options.addClass);
                                options.addClass = null;
                            }
                            if (options.removeClass) {
                                element.removeClass(options.removeClass);
                                options.removeClass = null;
                            }
                            if (options.to) {
                                element.css(options.to);
                                options.to = null;
                            }
                        }
                    };
                }
            ];
        };
        function Browser(window, document, $log, $sniffer) {
            var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
            self.isMock = false;
            var outstandingRequestCount = 0;
            var outstandingRequestCallbacks = [];
            self.$$completeOutstandingRequest = completeOutstandingRequest;
            self.$$incOutstandingRequestCount = function () {
                outstandingRequestCount++;
            };
            function completeOutstandingRequest(fn) {
                try {
                    fn.apply(null, sliceArgs(arguments, 1));
                } finally {
                    outstandingRequestCount--;
                    if (outstandingRequestCount === 0) {
                        while (outstandingRequestCallbacks.length) {
                            try {
                                outstandingRequestCallbacks.pop()();
                            } catch (e) {
                                $log.error(e);
                            }
                        }
                    }
                }
            }
            function getHash(url) {
                var index = url.indexOf('#');
                return index === -1 ? '' : url.substr(index);
            }
            self.notifyWhenNoOutstandingRequests = function (callback) {
                if (outstandingRequestCount === 0) {
                    callback();
                } else {
                    outstandingRequestCallbacks.push(callback);
                }
            };
            var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find('base'), pendingLocation = null;
            cacheState();
            lastHistoryState = cachedState;
            self.url = function (url, replace, state) {
                if (isUndefined(state)) {
                    state = null;
                }
                if (location !== window.location)
                    location = window.location;
                if (history !== window.history)
                    history = window.history;
                if (url) {
                    var sameState = lastHistoryState === state;
                    if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                        return self;
                    }
                    var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                    lastBrowserUrl = url;
                    lastHistoryState = state;
                    if ($sniffer.history && (!sameBase || !sameState)) {
                        history[replace ? 'replaceState' : 'pushState'](state, '', url);
                        cacheState();
                        lastHistoryState = cachedState;
                    } else {
                        if (!sameBase || pendingLocation) {
                            pendingLocation = url;
                        }
                        if (replace) {
                            location.replace(url);
                        } else if (!sameBase) {
                            location.href = url;
                        } else {
                            location.hash = getHash(url);
                        }
                        if (location.href !== url) {
                            pendingLocation = url;
                        }
                    }
                    return self;
                } else {
                    return pendingLocation || location.href.replace(/%27/g, '\'');
                }
            };
            self.state = function () {
                return cachedState;
            };
            var urlChangeListeners = [], urlChangeInit = false;
            function cacheStateAndFireUrlChange() {
                pendingLocation = null;
                cacheState();
                fireUrlChange();
            }
            function getCurrentState() {
                try {
                    return history.state;
                } catch (e) {
                }
            }
            var lastCachedState = null;
            function cacheState() {
                cachedState = getCurrentState();
                cachedState = isUndefined(cachedState) ? null : cachedState;
                if (equals(cachedState, lastCachedState)) {
                    cachedState = lastCachedState;
                }
                lastCachedState = cachedState;
            }
            function fireUrlChange() {
                if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                    return;
                }
                lastBrowserUrl = self.url();
                lastHistoryState = cachedState;
                forEach(urlChangeListeners, function (listener) {
                    listener(self.url(), cachedState);
                });
            }
            self.onUrlChange = function (callback) {
                if (!urlChangeInit) {
                    if ($sniffer.history)
                        jqLite(window).on('popstate', cacheStateAndFireUrlChange);
                    jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
                    urlChangeInit = true;
                }
                urlChangeListeners.push(callback);
                return callback;
            };
            self.$$applicationDestroyed = function () {
                jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
            };
            self.$$checkUrlChange = fireUrlChange;
            self.baseHref = function () {
                var href = baseElement.attr('href');
                return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
            };
            self.defer = function (fn, delay) {
                var timeoutId;
                outstandingRequestCount++;
                timeoutId = setTimeout(function () {
                    delete pendingDeferIds[timeoutId];
                    completeOutstandingRequest(fn);
                }, delay || 0);
                pendingDeferIds[timeoutId] = true;
                return timeoutId;
            };
            self.defer.cancel = function (deferId) {
                if (pendingDeferIds[deferId]) {
                    delete pendingDeferIds[deferId];
                    clearTimeout(deferId);
                    completeOutstandingRequest(noop);
                    return true;
                }
                return false;
            };
        }
        function $BrowserProvider() {
            this.$get = [
                '$window',
                '$log',
                '$sniffer',
                '$document',
                function ($window, $log, $sniffer, $document) {
                    return new Browser($window, $document, $log, $sniffer);
                }
            ];
        }
        function $CacheFactoryProvider() {
            this.$get = function () {
                var caches = {};
                function cacheFactory(cacheId, options) {
                    if (cacheId in caches) {
                        throw minErr('$cacheFactory')('iid', 'CacheId \'{0}\' is already taken!', cacheId);
                    }
                    var size = 0, stats = extend({}, options, { id: cacheId }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                    return caches[cacheId] = {
                        put: function (key, value) {
                            if (isUndefined(value))
                                return;
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
                                refresh(lruEntry);
                            }
                            if (!(key in data))
                                size++;
                            data[key] = value;
                            if (size > capacity) {
                                this.remove(staleEnd.key);
                            }
                            return value;
                        },
                        get: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry)
                                    return;
                                refresh(lruEntry);
                            }
                            return data[key];
                        },
                        remove: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry)
                                    return;
                                if (lruEntry == freshEnd)
                                    freshEnd = lruEntry.p;
                                if (lruEntry == staleEnd)
                                    staleEnd = lruEntry.n;
                                link(lruEntry.n, lruEntry.p);
                                delete lruHash[key];
                            }
                            if (!(key in data))
                                return;
                            delete data[key];
                            size--;
                        },
                        removeAll: function () {
                            data = createMap();
                            size = 0;
                            lruHash = createMap();
                            freshEnd = staleEnd = null;
                        },
                        destroy: function () {
                            data = null;
                            stats = null;
                            lruHash = null;
                            delete caches[cacheId];
                        },
                        info: function () {
                            return extend({}, stats, { size: size });
                        }
                    };
                    function refresh(entry) {
                        if (entry != freshEnd) {
                            if (!staleEnd) {
                                staleEnd = entry;
                            } else if (staleEnd == entry) {
                                staleEnd = entry.n;
                            }
                            link(entry.n, entry.p);
                            link(entry, freshEnd);
                            freshEnd = entry;
                            freshEnd.n = null;
                        }
                    }
                    function link(nextEntry, prevEntry) {
                        if (nextEntry != prevEntry) {
                            if (nextEntry)
                                nextEntry.p = prevEntry;
                            if (prevEntry)
                                prevEntry.n = nextEntry;
                        }
                    }
                }
                cacheFactory.info = function () {
                    var info = {};
                    forEach(caches, function (cache, cacheId) {
                        info[cacheId] = cache.info();
                    });
                    return info;
                };
                cacheFactory.get = function (cacheId) {
                    return caches[cacheId];
                };
                return cacheFactory;
            };
        }
        function $TemplateCacheProvider() {
            this.$get = [
                '$cacheFactory',
                function ($cacheFactory) {
                    return $cacheFactory('templates');
                }
            ];
        }
        var $compileMinErr = minErr('$compile');
        $CompileProvider.$inject = [
            '$provide',
            '$$sanitizeUriProvider'
        ];
        function $CompileProvider($provide, $$sanitizeUriProvider) {
            var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
            var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
            function parseIsolateBindings(scope, directiveName, isController) {
                var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
                var bindings = {};
                forEach(scope, function (definition, scopeName) {
                    var match = definition.match(LOCAL_REGEXP);
                    if (!match) {
                        throw $compileMinErr('iscp', 'Invalid {3} for directive \'{0}\'.' + ' Definition: {... {1}: \'{2}\' ...}', directiveName, scopeName, definition, isController ? 'controller bindings definition' : 'isolate scope definition');
                    }
                    bindings[scopeName] = {
                        mode: match[1][0],
                        collection: match[2] === '*',
                        optional: match[3] === '?',
                        attrName: match[4] || scopeName
                    };
                });
                return bindings;
            }
            function parseDirectiveBindings(directive, directiveName) {
                var bindings = {
                    isolateScope: null,
                    bindToController: null
                };
                if (isObject(directive.scope)) {
                    if (directive.bindToController === true) {
                        bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                        bindings.isolateScope = {};
                    } else {
                        bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                    }
                }
                if (isObject(directive.bindToController)) {
                    bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
                }
                if (isObject(bindings.bindToController)) {
                    var controller = directive.controller;
                    var controllerAs = directive.controllerAs;
                    if (!controller) {
                        throw $compileMinErr('noctrl', 'Cannot bind to controller without directive \'{0}\'s controller.', directiveName);
                    } else if (!identifierForController(controller, controllerAs)) {
                        throw $compileMinErr('noident', 'Cannot bind to controller without identifier for directive \'{0}\'.', directiveName);
                    }
                }
                return bindings;
            }
            function assertValidDirectiveName(name) {
                var letter = name.charAt(0);
                if (!letter || letter !== lowercase(letter)) {
                    throw $compileMinErr('baddir', 'Directive name \'{0}\' is invalid. The first character must be a lowercase letter', name);
                }
                if (name !== name.trim()) {
                    throw $compileMinErr('baddir', 'Directive name \'{0}\' is invalid. The name should not contain leading or trailing whitespaces', name);
                }
            }
            this.directive = function registerDirective(name, directiveFactory) {
                assertNotHasOwnProperty(name, 'directive');
                if (isString(name)) {
                    assertValidDirectiveName(name);
                    assertArg(directiveFactory, 'directiveFactory');
                    if (!hasDirectives.hasOwnProperty(name)) {
                        hasDirectives[name] = [];
                        $provide.factory(name + Suffix, [
                            '$injector',
                            '$exceptionHandler',
                            function ($injector, $exceptionHandler) {
                                var directives = [];
                                forEach(hasDirectives[name], function (directiveFactory, index) {
                                    try {
                                        var directive = $injector.invoke(directiveFactory);
                                        if (isFunction(directive)) {
                                            directive = { compile: valueFn(directive) };
                                        } else if (!directive.compile && directive.link) {
                                            directive.compile = valueFn(directive.link);
                                        }
                                        directive.priority = directive.priority || 0;
                                        directive.index = index;
                                        directive.name = directive.name || name;
                                        directive.require = directive.require || directive.controller && directive.name;
                                        directive.restrict = directive.restrict || 'EA';
                                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                        if (isObject(bindings.isolateScope)) {
                                            directive.$$isolateBindings = bindings.isolateScope;
                                        }
                                        directive.$$moduleName = directiveFactory.$$moduleName;
                                        directives.push(directive);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                });
                                return directives;
                            }
                        ]);
                    }
                    hasDirectives[name].push(directiveFactory);
                } else {
                    forEach(name, reverseParams(registerDirective));
                }
                return this;
            };
            this.aHrefSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                    return this;
                } else {
                    return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
                }
            };
            this.imgSrcSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                    return this;
                } else {
                    return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
                }
            };
            var debugInfoEnabled = true;
            this.debugInfoEnabled = function (enabled) {
                if (isDefined(enabled)) {
                    debugInfoEnabled = enabled;
                    return this;
                }
                return debugInfoEnabled;
            };
            this.$get = [
                '$injector',
                '$interpolate',
                '$exceptionHandler',
                '$templateRequest',
                '$parse',
                '$controller',
                '$rootScope',
                '$document',
                '$sce',
                '$animate',
                '$$sanitizeUri',
                function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
                    var Attributes = function (element, attributesToCopy) {
                        if (attributesToCopy) {
                            var keys = Object.keys(attributesToCopy);
                            var i, l, key;
                            for (i = 0, l = keys.length; i < l; i++) {
                                key = keys[i];
                                this[key] = attributesToCopy[key];
                            }
                        } else {
                            this.$attr = {};
                        }
                        this.$$element = element;
                    };
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function (classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.addClass(this.$$element, classVal);
                            }
                        },
                        $removeClass: function (classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.removeClass(this.$$element, classVal);
                            }
                        },
                        $updateClass: function (newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            if (toAdd && toAdd.length) {
                                $animate.addClass(this.$$element, toAdd);
                            }
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            if (toRemove && toRemove.length) {
                                $animate.removeClass(this.$$element, toRemove);
                            }
                        },
                        $set: function (key, value, writeAttr, attrName) {
                            var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                            if (booleanKey) {
                                this.$$element.prop(key, value);
                                attrName = booleanKey;
                            } else if (aliasedKey) {
                                this[aliasedKey] = value;
                                observer = aliasedKey;
                            }
                            this[key] = value;
                            if (attrName) {
                                this.$attr[key] = attrName;
                            } else {
                                attrName = this.$attr[key];
                                if (!attrName) {
                                    this.$attr[key] = attrName = snake_case(key, '-');
                                }
                            }
                            nodeName = nodeName_(this.$$element);
                            if (nodeName === 'a' && key === 'href' || nodeName === 'img' && key === 'src') {
                                this[key] = value = $$sanitizeUri(value, key === 'src');
                            } else if (nodeName === 'img' && key === 'srcset') {
                                var result = '';
                                var trimmedSrcset = trim(value);
                                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                                var rawUris = trimmedSrcset.split(pattern);
                                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                                for (var i = 0; i < nbrUrisWith2parts; i++) {
                                    var innerIdx = i * 2;
                                    result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                                    result += ' ' + trim(rawUris[innerIdx + 1]);
                                }
                                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                                result += $$sanitizeUri(trim(lastTuple[0]), true);
                                if (lastTuple.length === 2) {
                                    result += ' ' + trim(lastTuple[1]);
                                }
                                this[key] = value = result;
                            }
                            if (writeAttr !== false) {
                                if (value === null || isUndefined(value)) {
                                    this.$$element.removeAttr(attrName);
                                } else {
                                    this.$$element.attr(attrName, value);
                                }
                            }
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[observer], function (fn) {
                                try {
                                    fn(value);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            });
                        },
                        $observe: function (key, fn) {
                            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                            listeners.push(fn);
                            $rootScope.$evalAsync(function () {
                                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                                    fn(attrs[key]);
                                }
                            });
                            return function () {
                                arrayRemove(listeners, fn);
                            };
                        }
                    };
                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className);
                        } catch (e) {
                        }
                    }
                    var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' || endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
                            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                        }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                    var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                        var bindings = $element.data('$binding') || [];
                        if (isArray(binding)) {
                            bindings = bindings.concat(binding);
                        } else {
                            bindings.push(binding);
                        }
                        $element.data('$binding', bindings);
                    } : noop;
                    compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                        safeAddClass($element, 'ng-binding');
                    } : noop;
                    compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope';
                        $element.data(dataName, scope);
                    } : noop;
                    compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                        safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
                    } : noop;
                    return compile;
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        if (!($compileNodes instanceof jqLite)) {
                            $compileNodes = jqLite($compileNodes);
                        }
                        forEach($compileNodes, function (node, index) {
                            if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
                            }
                        });
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function publicLinkFn(scope, cloneConnectFn, options) {
                            assertArg(scope, 'scope');
                            if (previousCompileContext && previousCompileContext.needsNewScope) {
                                scope = scope.$parent.$new();
                            }
                            options = options || {};
                            var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                            }
                            if (!namespace) {
                                namespace = detectNamespaceForChildElements(futureParentElement);
                            }
                            var $linkNode;
                            if (namespace !== 'html') {
                                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
                            } else if (cloneConnectFn) {
                                $linkNode = JQLitePrototype.clone.call($compileNodes);
                            } else {
                                $linkNode = $compileNodes;
                            }
                            if (transcludeControllers) {
                                for (var controllerName in transcludeControllers) {
                                    $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                                }
                            }
                            compile.$$addScopeInfo($linkNode, scope);
                            if (cloneConnectFn)
                                cloneConnectFn($linkNode, scope);
                            if (compositeLinkFn)
                                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                            return $linkNode;
                        };
                    }
                    function detectNamespaceForChildElements(parentElement) {
                        var node = parentElement && parentElement[0];
                        if (!node) {
                            return 'html';
                        } else {
                            return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
                        }
                    }
                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                        for (var i = 0; i < nodeList.length; i++) {
                            attrs = new Attributes();
                            directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                            if (nodeLinkFn && nodeLinkFn.scope) {
                                compile.$$addScopeClass(attrs.$$element);
                            }
                            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                            if (nodeLinkFn || childLinkFn) {
                                linkFns.push(i, nodeLinkFn, childLinkFn);
                                linkFnFound = true;
                                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                            }
                            previousCompileContext = null;
                        }
                        return linkFnFound ? compositeLinkFn : null;
                        function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                            var stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                stableNodeList = new Array(nodeListLength);
                                for (i = 0; i < linkFns.length; i += 3) {
                                    idx = linkFns[i];
                                    stableNodeList[idx] = nodeList[idx];
                                }
                            } else {
                                stableNodeList = nodeList;
                            }
                            for (i = 0, ii = linkFns.length; i < ii;) {
                                node = stableNodeList[linkFns[i++]];
                                nodeLinkFn = linkFns[i++];
                                childLinkFn = linkFns[i++];
                                if (nodeLinkFn) {
                                    if (nodeLinkFn.scope) {
                                        childScope = scope.$new();
                                        compile.$$addScopeInfo(jqLite(node), childScope);
                                    } else {
                                        childScope = scope;
                                    }
                                    if (nodeLinkFn.transcludeOnThisElement) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                                    } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                        childBoundTranscludeFn = parentBoundTranscludeFn;
                                    } else if (!parentBoundTranscludeFn && transcludeFn) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                                    } else {
                                        childBoundTranscludeFn = null;
                                    }
                                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                                } else if (childLinkFn) {
                                    childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                                }
                            }
                        }
                    }
                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        var boundTranscludeFn = function (transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            if (!transcludedScope) {
                                transcludedScope = scope.$new(false, containingScope);
                                transcludedScope.$$transcluded = true;
                            }
                            return transcludeFn(transcludedScope, cloneFn, {
                                parentBoundTranscludeFn: previousBoundTranscludeFn,
                                transcludeControllers: controllers,
                                futureParentElement: futureParentElement
                            });
                        };
                        return boundTranscludeFn;
                    }
                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                        switch (nodeType) {
                        case NODE_TYPE_ELEMENT:
                            addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                            for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                var attrStartName = false;
                                var attrEndName = false;
                                attr = nAttrs[j];
                                name = attr.name;
                                value = trim(attr.value);
                                ngAttrName = directiveNormalize(name);
                                if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function (match, letter) {
                                        return letter.toUpperCase();
                                    });
                                }
                                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                                if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                                    attrStartName = name;
                                    attrEndName = name.substr(0, name.length - 5) + 'end';
                                    name = name.substr(0, name.length - 6);
                                }
                                nName = directiveNormalize(name.toLowerCase());
                                attrsMap[nName] = name;
                                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                    attrs[nName] = value;
                                    if (getBooleanAttrName(node, nName)) {
                                        attrs[nName] = true;
                                    }
                                }
                                addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                                addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                            }
                            className = node.className;
                            if (isObject(className)) {
                                className = className.animVal;
                            }
                            if (isString(className) && className !== '') {
                                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                                    nName = directiveNormalize(match[2]);
                                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                                        attrs[nName] = trim(match[3]);
                                    }
                                    className = className.substr(match.index + match[0].length);
                                }
                            }
                            break;
                        case NODE_TYPE_TEXT:
                            if (msie === 11) {
                                while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                                    node.parentNode.removeChild(node.nextSibling);
                                }
                            }
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;
                        case NODE_TYPE_COMMENT:
                            try {
                                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                                if (match) {
                                    nName = directiveNormalize(match[1]);
                                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                                        attrs[nName] = trim(match[2]);
                                    }
                                }
                            } catch (e) {
                            }
                            break;
                        }
                        directives.sort(byPriority);
                        return directives;
                    }
                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [];
                        var depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                            do {
                                if (!node) {
                                    throw $compileMinErr('uterdir', 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.', attrStart, attrEnd);
                                }
                                if (node.nodeType == NODE_TYPE_ELEMENT) {
                                    if (node.hasAttribute(attrStart))
                                        depth++;
                                    if (node.hasAttribute(attrEnd))
                                        depth--;
                                }
                                nodes.push(node);
                                node = node.nextSibling;
                            } while (depth > 0);
                        } else {
                            nodes.push(node);
                        }
                        return jqLite(nodes);
                    }
                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function (scope, element, attrs, controllers, transcludeFn) {
                            element = groupScan(element[0], attrStart, attrEnd);
                            return linkFn(scope, element, attrs, controllers, transcludeFn);
                        };
                    }
                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        previousCompileContext = previousCompileContext || {};
                        var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
                        for (var i = 0, ii = directives.length; i < ii; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start;
                            var attrEnd = directive.$$end;
                            if (attrStart) {
                                $compileNode = groupScan(compileNode, attrStart, attrEnd);
                            }
                            $template = undefined;
                            if (terminalPriority > directive.priority) {
                                break;
                            }
                            if (directiveValue = directive.scope) {
                                if (!directive.templateUrl) {
                                    if (isObject(directiveValue)) {
                                        assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                        newIsolateScopeDirective = directive;
                                    } else {
                                        assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                                    }
                                }
                                newScopeDirective = newScopeDirective || directive;
                            }
                            directiveName = directive.name;
                            if (!directive.templateUrl && directive.controller) {
                                directiveValue = directive.controller;
                                controllerDirectives = controllerDirectives || createMap();
                                assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
                                controllerDirectives[directiveName] = directive;
                            }
                            if (directiveValue = directive.transclude) {
                                hasTranscludeDirective = true;
                                if (!directive.$$tlb) {
                                    assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                                    nonTlbTranscludeDirective = directive;
                                }
                                if (directiveValue == 'element') {
                                    hasElementTranscludeDirective = true;
                                    terminalPriority = directive.priority;
                                    $template = $compileNode;
                                    $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                                    compileNode = $compileNode[0];
                                    replaceWith(jqCollection, sliceArgs($template), compileNode);
                                    childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, { nonTlbTranscludeDirective: nonTlbTranscludeDirective });
                                } else {
                                    $template = jqLite(jqLiteClone(compileNode)).contents();
                                    $compileNode.empty();
                                    childTranscludeFn = compile($template, transcludeFn, undefined, undefined, { needsNewScope: directive.$$isolateScope || directive.$$newScope });
                                }
                            }
                            if (directive.template) {
                                hasTemplate = true;
                                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                                directiveValue = denormalizeTemplate(directiveValue);
                                if (directive.replace) {
                                    replaceDirective = directive;
                                    if (jqLiteIsTextNode(directiveValue)) {
                                        $template = [];
                                    } else {
                                        $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                                    }
                                    compileNode = $template[0];
                                    if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                        throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', directiveName, '');
                                    }
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = { $attr: {} };
                                    var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                                    var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    if (newIsolateScopeDirective || newScopeDirective) {
                                        markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                                    }
                                    directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                                    mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                                    ii = directives.length;
                                } else {
                                    $compileNode.html(directiveValue);
                                }
                            }
                            if (directive.templateUrl) {
                                hasTemplate = true;
                                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                if (directive.replace) {
                                    replaceDirective = directive;
                                }
                                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                    controllerDirectives: controllerDirectives,
                                    newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                    newIsolateScopeDirective: newIsolateScopeDirective,
                                    templateDirective: templateDirective,
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                });
                                ii = directives.length;
                            } else if (directive.compile) {
                                try {
                                    linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                    if (isFunction(linkFn)) {
                                        addLinkFns(null, linkFn, attrStart, attrEnd);
                                    } else if (linkFn) {
                                        addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                                    }
                                } catch (e) {
                                    $exceptionHandler(e, startingTag($compileNode));
                                }
                            }
                            if (directive.terminal) {
                                nodeLinkFn.terminal = true;
                                terminalPriority = Math.max(terminalPriority, directive.priority);
                            }
                        }
                        nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                        nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                        nodeLinkFn.templateOnThisElement = hasTemplate;
                        nodeLinkFn.transclude = childTranscludeFn;
                        previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                        return nodeLinkFn;
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            if (pre) {
                                if (attrStart)
                                    pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                                pre.require = directive.require;
                                pre.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    pre = cloneAndAnnotateFn(pre, { isolateScope: true });
                                }
                                preLinkFns.push(pre);
                            }
                            if (post) {
                                if (attrStart)
                                    post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                                post.require = directive.require;
                                post.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    post = cloneAndAnnotateFn(post, { isolateScope: true });
                                }
                                postLinkFns.push(post);
                            }
                        }
                        function getControllers(directiveName, require, $element, elementControllers) {
                            var value;
                            if (isString(require)) {
                                var match = require.match(REQUIRE_PREFIX_REGEXP);
                                var name = require.substring(match[0].length);
                                var inheritType = match[1] || match[3];
                                var optional = match[2] === '?';
                                if (inheritType === '^^') {
                                    $element = $element.parent();
                                } else {
                                    value = elementControllers && elementControllers[name];
                                    value = value && value.instance;
                                }
                                if (!value) {
                                    var dataName = '$' + name + 'Controller';
                                    value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                                }
                                if (!value && !optional) {
                                    throw $compileMinErr('ctreq', 'Controller \'{0}\', required by directive \'{1}\', can\'t be found!', name, directiveName);
                                }
                            } else if (isArray(require)) {
                                value = [];
                                for (var i = 0, ii = require.length; i < ii; i++) {
                                    value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                                }
                            }
                            return value || null;
                        }
                        function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
                            var elementControllers = createMap();
                            for (var controllerKey in controllerDirectives) {
                                var directive = controllerDirectives[controllerKey];
                                var locals = {
                                    $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                    $element: $element,
                                    $attrs: attrs,
                                    $transclude: transcludeFn
                                };
                                var controller = directive.controller;
                                if (controller == '@') {
                                    controller = attrs[directive.name];
                                }
                                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                                elementControllers[directive.name] = controllerInstance;
                                if (!hasElementTranscludeDirective) {
                                    $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                                }
                            }
                            return elementControllers;
                        }
                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            var linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, removeScopeBindingWatches, removeControllerBindingWatches;
                            if (compileNode === linkNode) {
                                attrs = templateAttrs;
                                $element = templateAttrs.$$element;
                            } else {
                                $element = jqLite(linkNode);
                                attrs = new Attributes($element, templateAttrs);
                            }
                            controllerScope = scope;
                            if (newIsolateScopeDirective) {
                                isolateScope = scope.$new(true);
                            } else if (newScopeDirective) {
                                controllerScope = scope.$parent;
                            }
                            if (boundTranscludeFn) {
                                transcludeFn = controllersBoundTransclude;
                                transcludeFn.$$boundTransclude = boundTranscludeFn;
                            }
                            if (controllerDirectives) {
                                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
                            }
                            if (newIsolateScopeDirective) {
                                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                                compile.$$addScopeClass($element, true);
                                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                                removeScopeBindingWatches = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                                if (removeScopeBindingWatches) {
                                    isolateScope.$on('$destroy', removeScopeBindingWatches);
                                }
                            }
                            for (var name in elementControllers) {
                                var controllerDirective = controllerDirectives[name];
                                var controller = elementControllers[name];
                                var bindings = controllerDirective.$$bindings.bindToController;
                                if (controller.identifier && bindings) {
                                    removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                }
                                var controllerResult = controller();
                                if (controllerResult !== controller.instance) {
                                    controller.instance = controllerResult;
                                    $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                                    removeControllerBindingWatches && removeControllerBindingWatches();
                                    removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                }
                            }
                            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                                linkFn = preLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            var scopeToChild = scope;
                            if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                                scopeToChild = isolateScope;
                            }
                            childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                            for (i = postLinkFns.length - 1; i >= 0; i--) {
                                linkFn = postLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                                var transcludeControllers;
                                if (!isScope(scope)) {
                                    futureParentElement = cloneAttachFn;
                                    cloneAttachFn = scope;
                                    scope = undefined;
                                }
                                if (hasElementTranscludeDirective) {
                                    transcludeControllers = elementControllers;
                                }
                                if (!futureParentElement) {
                                    futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                                }
                                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            }
                        }
                    }
                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) {
                            directives[j] = inherit(directives[j], {
                                $$isolateScope: isolateScope,
                                $$newScope: newScope
                            });
                        }
                    }
                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective)
                            return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                try {
                                    directive = directives[i];
                                    if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                        if (startAttrName) {
                                            directive = inherit(directive, {
                                                $$start: startAttrName,
                                                $$end: endAttrName
                                            });
                                        }
                                        tDirectives.push(directive);
                                        match = directive;
                                    }
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                        }
                        return match;
                    }
                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                directive = directives[i];
                                if (directive.multiElement) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                        forEach(dst, function (value, key) {
                            if (key.charAt(0) != '$') {
                                if (src[key] && src[key] !== value) {
                                    value += (key === 'style' ? ';' : ' ') + src[key];
                                }
                                dst.$set(key, value, true, srcAttr[key]);
                            }
                        });
                        forEach(src, function (value, key) {
                            if (key == 'class') {
                                safeAddClass($element, value);
                                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
                            } else if (key == 'style') {
                                $element.attr('style', $element.attr('style') + ';' + value);
                                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
                            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                                dst[key] = value;
                                dstAttr[key] = srcAttr[key];
                            }
                        });
                    }
                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                                templateUrl: null,
                                transclude: null,
                                replace: null,
                                $$originalDirective: origAsyncDirective
                            }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                        $compileNode.empty();
                        $templateRequest(templateUrl).then(function (content) {
                            var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                            content = denormalizeTemplate(content);
                            if (origAsyncDirective.replace) {
                                if (jqLiteIsTextNode(content)) {
                                    $template = [];
                                } else {
                                    $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                                }
                                compileNode = $template[0];
                                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                    throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', origAsyncDirective.name, templateUrl);
                                }
                                tempTemplateAttrs = { $attr: {} };
                                replaceWith($rootElement, $compileNode, compileNode);
                                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                if (isObject(origAsyncDirective.scope)) {
                                    markDirectiveScope(templateDirectives, true);
                                }
                                directives = templateDirectives.concat(directives);
                                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else {
                                compileNode = beforeTemplateCompileNode;
                                $compileNode.html(content);
                            }
                            directives.unshift(derivedSyncDirective);
                            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                            forEach($rootElement, function (node, i) {
                                if (node == compileNode) {
                                    $rootElement[i] = $compileNode[0];
                                }
                            });
                            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                            while (linkQueue.length) {
                                var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                                if (scope.$$destroyed)
                                    continue;
                                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                    var oldClasses = beforeTemplateLinkNode.className;
                                    if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                        linkNode = jqLiteClone(compileNode);
                                    }
                                    replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                                    safeAddClass(jqLite(linkNode), oldClasses);
                                }
                                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                    childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                } else {
                                    childBoundTranscludeFn = boundTranscludeFn;
                                }
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                            }
                            linkQueue = null;
                        });
                        return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                            var childBoundTranscludeFn = boundTranscludeFn;
                            if (scope.$$destroyed)
                                return;
                            if (linkQueue) {
                                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                            } else {
                                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                    childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                }
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                            }
                        };
                    }
                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        if (diff !== 0)
                            return diff;
                        if (a.name !== b.name)
                            return a.name < b.name ? -1 : 1;
                        return a.index - b.index;
                    }
                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? ' (module: ' + moduleName + ')' : '';
                        }
                        if (previousDirective) {
                            throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                        }
                    }
                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, true);
                        if (interpolateFn) {
                            directives.push({
                                priority: 0,
                                compile: function textInterpolateCompileFn(templateNode) {
                                    var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                                    if (hasCompileParent)
                                        compile.$$addBindingClass(templateNodeParent);
                                    return function textInterpolateLinkFn(scope, node) {
                                        var parent = node.parent();
                                        if (!hasCompileParent)
                                            compile.$$addBindingClass(parent);
                                        compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                        scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                            node[0].nodeValue = value;
                                        });
                                    };
                                }
                            });
                        }
                    }
                    function wrapTemplate(type, template) {
                        type = lowercase(type || 'html');
                        switch (type) {
                        case 'svg':
                        case 'math':
                            var wrapper = document.createElement('div');
                            wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                            return wrapper.childNodes[0].childNodes;
                        default:
                            return template;
                        }
                    }
                    function getTrustedContext(node, attrNormalizedName) {
                        if (attrNormalizedName == 'srcdoc') {
                            return $sce.HTML;
                        }
                        var tag = nodeName_(node);
                        if (attrNormalizedName == 'xlinkHref' || tag == 'form' && attrNormalizedName == 'action' || tag != 'img' && (attrNormalizedName == 'src' || attrNormalizedName == 'ngSrc')) {
                            return $sce.RESOURCE_URL;
                        }
                    }
                    function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                        var trustedContext = getTrustedContext(node, name);
                        allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                        var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
                        if (!interpolateFn)
                            return;
                        if (name === 'multiple' && nodeName_(node) === 'select') {
                            throw $compileMinErr('selmulti', 'Binding to the \'multiple\' attribute is not supported. Element: {0}', startingTag(node));
                        }
                        directives.push({
                            priority: 100,
                            compile: function () {
                                return {
                                    pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                        var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                        if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                            throw $compileMinErr('nodomevents', 'Interpolations for HTML DOM event attributes are disallowed.  Please use the ' + 'ng- versions (such as ng-click instead of onclick) instead.');
                                        }
                                        var newValue = attr[name];
                                        if (newValue !== value) {
                                            interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                            value = newValue;
                                        }
                                        if (!interpolateFn)
                                            return;
                                        attr[name] = interpolateFn(scope);
                                        ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                        (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                            if (name === 'class' && newValue != oldValue) {
                                                attr.$updateClass(newValue, oldValue);
                                            } else {
                                                attr.$set(name, newValue);
                                            }
                                        });
                                    }
                                };
                            }
                        });
                    }
                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                        if ($rootElement) {
                            for (i = 0, ii = $rootElement.length; i < ii; i++) {
                                if ($rootElement[i] == firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                                        if (j2 < jj) {
                                            $rootElement[j] = $rootElement[j2];
                                        } else {
                                            delete $rootElement[j];
                                        }
                                    }
                                    $rootElement.length -= removeCount - 1;
                                    if ($rootElement.context === firstElementToRemove) {
                                        $rootElement.context = newNode;
                                    }
                                    break;
                                }
                            }
                        }
                        if (parent) {
                            parent.replaceChild(newNode, firstElementToRemove);
                        }
                        var fragment = document.createDocumentFragment();
                        fragment.appendChild(firstElementToRemove);
                        if (jqLite.hasData(firstElementToRemove)) {
                            jqLite.data(newNode, jqLite.data(firstElementToRemove));
                            if (!jQuery) {
                                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                            } else {
                                skipDestroyOnNextJQueryCleanData = true;
                                jQuery.cleanData([firstElementToRemove]);
                            }
                        }
                        for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                            var element = elementsToRemove[k];
                            jqLite(element).remove();
                            fragment.appendChild(element);
                            delete elementsToRemove[k];
                        }
                        elementsToRemove[0] = newNode;
                        elementsToRemove.length = 1;
                    }
                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(function () {
                            return fn.apply(null, arguments);
                        }, fn, annotation);
                    }
                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        var removeWatchCollection = [];
                        forEach(bindings, function (definition, scopeName) {
                            var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare;
                            switch (mode) {
                            case '@':
                                if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                                    destination[scopeName] = attrs[attrName] = void 0;
                                }
                                attrs.$observe(attrName, function (value) {
                                    if (isString(value)) {
                                        destination[scopeName] = value;
                                    }
                                });
                                attrs.$$observers[attrName].$$scope = scope;
                                if (isString(attrs[attrName])) {
                                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                                }
                                break;
                            case '=':
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional)
                                        break;
                                    attrs[attrName] = void 0;
                                }
                                if (optional && !attrs[attrName])
                                    break;
                                parentGet = $parse(attrs[attrName]);
                                if (parentGet.literal) {
                                    compare = equals;
                                } else {
                                    compare = function (a, b) {
                                        return a === b || a !== a && b !== b;
                                    };
                                }
                                parentSet = parentGet.assign || function () {
                                    lastValue = destination[scopeName] = parentGet(scope);
                                    throw $compileMinErr('nonassign', 'Expression \'{0}\' used with directive \'{1}\' is non-assignable!', attrs[attrName], directive.name);
                                };
                                lastValue = destination[scopeName] = parentGet(scope);
                                var parentValueWatch = function parentValueWatch(parentValue) {
                                    if (!compare(parentValue, destination[scopeName])) {
                                        if (!compare(parentValue, lastValue)) {
                                            destination[scopeName] = parentValue;
                                        } else {
                                            parentSet(scope, parentValue = destination[scopeName]);
                                        }
                                    }
                                    return lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = true;
                                var removeWatch;
                                if (definition.collection) {
                                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                } else {
                                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                }
                                removeWatchCollection.push(removeWatch);
                                break;
                            case '&':
                                parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                                if (parentGet === noop && optional)
                                    break;
                                destination[scopeName] = function (locals) {
                                    return parentGet(scope, locals);
                                };
                                break;
                            }
                        });
                        return removeWatchCollection.length && function removeWatches() {
                            for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                                removeWatchCollection[i]();
                            }
                        };
                    }
                }
            ];
        }
        var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
        function directiveNormalize(name) {
            return camelCase(name.replace(PREFIX_REGEXP, ''));
        }
        function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
        }
        function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
        }
        function tokenDifference(str1, str2) {
            var values = '', tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
            outer:
                for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j])
                            continue outer;
                    }
                    values += (values.length > 0 ? ' ' : '') + token;
                }
            return values;
        }
        function removeComments(jqNodes) {
            jqNodes = jqLite(jqNodes);
            var i = jqNodes.length;
            if (i <= 1) {
                return jqNodes;
            }
            while (i--) {
                var node = jqNodes[i];
                if (node.nodeType === NODE_TYPE_COMMENT) {
                    splice.call(jqNodes, i, 1);
                }
            }
            return jqNodes;
        }
        var $controllerMinErr = minErr('$controller');
        var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        function identifierForController(controller, ident) {
            if (ident && isString(ident))
                return ident;
            if (isString(controller)) {
                var match = CNTRL_REG.exec(controller);
                if (match)
                    return match[3];
            }
        }
        function $ControllerProvider() {
            var controllers = {}, globals = false;
            this.register = function (name, constructor) {
                assertNotHasOwnProperty(name, 'controller');
                if (isObject(name)) {
                    extend(controllers, name);
                } else {
                    controllers[name] = constructor;
                }
            };
            this.allowGlobals = function () {
                globals = true;
            };
            this.$get = [
                '$injector',
                '$window',
                function ($injector, $window) {
                    return function (expression, locals, later, ident) {
                        var instance, match, constructor, identifier;
                        later = later === true;
                        if (ident && isString(ident)) {
                            identifier = ident;
                        }
                        if (isString(expression)) {
                            match = expression.match(CNTRL_REG);
                            if (!match) {
                                throw $controllerMinErr('ctrlfmt', 'Badly formed controller string \'{0}\'. ' + 'Must match `__name__ as __id__` or `__name__`.', expression);
                            }
                            constructor = match[1], identifier = identifier || match[3];
                            expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                            assertArgFn(expression, constructor, true);
                        }
                        if (later) {
                            var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                            instance = Object.create(controllerPrototype || null);
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                            var instantiate;
                            return instantiate = extend(function () {
                                var result = $injector.invoke(expression, instance, locals, constructor);
                                if (result !== instance && (isObject(result) || isFunction(result))) {
                                    instance = result;
                                    if (identifier) {
                                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                                    }
                                }
                                return instance;
                            }, {
                                instance: instance,
                                identifier: identifier
                            });
                        }
                        instance = $injector.instantiate(expression, locals, constructor);
                        if (identifier) {
                            addIdentifier(locals, identifier, instance, constructor || expression.name);
                        }
                        return instance;
                    };
                    function addIdentifier(locals, identifier, instance, name) {
                        if (!(locals && isObject(locals.$scope))) {
                            throw minErr('$controller')('noscp', 'Cannot export controller \'{0}\' as \'{1}\'! No $scope object provided via `locals`.', name, identifier);
                        }
                        locals.$scope[identifier] = instance;
                    }
                }
            ];
        }
        function $DocumentProvider() {
            this.$get = [
                '$window',
                function (window) {
                    return jqLite(window.document);
                }
            ];
        }
        function $ExceptionHandlerProvider() {
            this.$get = [
                '$log',
                function ($log) {
                    return function (exception, cause) {
                        $log.error.apply($log, arguments);
                    };
                }
            ];
        }
        var $$ForceReflowProvider = function () {
            this.$get = [
                '$document',
                function ($document) {
                    return function (domNode) {
                        if (domNode) {
                            if (!domNode.nodeType && domNode instanceof jqLite) {
                                domNode = domNode[0];
                            }
                        } else {
                            domNode = $document[0].body;
                        }
                        return domNode.offsetWidth + 1;
                    };
                }
            ];
        };
        var APPLICATION_JSON = 'application/json';
        var CONTENT_TYPE_APPLICATION_JSON = { 'Content-Type': APPLICATION_JSON + ';charset=utf-8' };
        var JSON_START = /^\[|^\{(?!\{)/;
        var JSON_ENDS = {
            '[': /]$/,
            '{': /}$/
        };
        var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
        var $httpMinErr = minErr('$http');
        var $httpMinErrLegacyFn = function (method) {
            return function () {
                throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
            };
        };
        function serializeValue(v) {
            if (isObject(v)) {
                return isDate(v) ? v.toISOString() : toJson(v);
            }
            return v;
        }
        function $HttpParamSerializerProvider() {
            this.$get = function () {
                return function ngParamSerializer(params) {
                    if (!params)
                        return '';
                    var parts = [];
                    forEachSorted(params, function (value, key) {
                        if (value === null || isUndefined(value))
                            return;
                        if (isArray(value)) {
                            forEach(value, function (v, k) {
                                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                            });
                        } else {
                            parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
                        }
                    });
                    return parts.join('&');
                };
            };
        }
        function $HttpParamSerializerJQLikeProvider() {
            this.$get = function () {
                return function jQueryLikeParamSerializer(params) {
                    if (!params)
                        return '';
                    var parts = [];
                    serialize(params, '', true);
                    return parts.join('&');
                    function serialize(toSerialize, prefix, topLevel) {
                        if (toSerialize === null || isUndefined(toSerialize))
                            return;
                        if (isArray(toSerialize)) {
                            forEach(toSerialize, function (value, index) {
                                serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                            });
                        } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                            forEachSorted(toSerialize, function (value, key) {
                                serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                            });
                        } else {
                            parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
                        }
                    }
                };
            };
        }
        function defaultHttpResponseTransform(data, headers) {
            if (isString(data)) {
                var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
                if (tempData) {
                    var contentType = headers('Content-Type');
                    if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                        data = fromJson(tempData);
                    }
                }
            }
            return data;
        }
        function isJsonLike(str) {
            var jsonStart = str.match(JSON_START);
            return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
        }
        function parseHeaders(headers) {
            var parsed = createMap(), i;
            function fillInParsed(key, val) {
                if (key) {
                    parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                }
            }
            if (isString(headers)) {
                forEach(headers.split('\n'), function (line) {
                    i = line.indexOf(':');
                    fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
                });
            } else if (isObject(headers)) {
                forEach(headers, function (headerVal, headerKey) {
                    fillInParsed(lowercase(headerKey), trim(headerVal));
                });
            }
            return parsed;
        }
        function headersGetter(headers) {
            var headersObj;
            return function (name) {
                if (!headersObj)
                    headersObj = parseHeaders(headers);
                if (name) {
                    var value = headersObj[lowercase(name)];
                    if (value === void 0) {
                        value = null;
                    }
                    return value;
                }
                return headersObj;
            };
        }
        function transformData(data, headers, status, fns) {
            if (isFunction(fns)) {
                return fns(data, headers, status);
            }
            forEach(fns, function (fn) {
                data = fn(data, headers, status);
            });
            return data;
        }
        function isSuccess(status) {
            return 200 <= status && status < 300;
        }
        function $HttpProvider() {
            var defaults = this.defaults = {
                transformResponse: [defaultHttpResponseTransform],
                transformRequest: [function (d) {
                        return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
                    }],
                headers: {
                    common: { 'Accept': 'application/json, text/plain, */*' },
                    post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                    put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                    patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                },
                xsrfCookieName: 'XSRF-TOKEN',
                xsrfHeaderName: 'X-XSRF-TOKEN',
                paramSerializer: '$httpParamSerializer'
            };
            var useApplyAsync = false;
            this.useApplyAsync = function (value) {
                if (isDefined(value)) {
                    useApplyAsync = !!value;
                    return this;
                }
                return useApplyAsync;
            };
            var useLegacyPromise = true;
            this.useLegacyPromiseExtensions = function (value) {
                if (isDefined(value)) {
                    useLegacyPromise = !!value;
                    return this;
                }
                return useLegacyPromise;
            };
            var interceptorFactories = this.interceptors = [];
            this.$get = [
                '$httpBackend',
                '$$cookieReader',
                '$cacheFactory',
                '$rootScope',
                '$q',
                '$injector',
                function ($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
                    var defaultCache = $cacheFactory('$http');
                    defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                    var reversedInterceptors = [];
                    forEach(interceptorFactories, function (interceptorFactory) {
                        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                    });
                    function $http(requestConfig) {
                        if (!angular.isObject(requestConfig)) {
                            throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
                        }
                        var config = extend({
                            method: 'get',
                            transformRequest: defaults.transformRequest,
                            transformResponse: defaults.transformResponse,
                            paramSerializer: defaults.paramSerializer
                        }, requestConfig);
                        config.headers = mergeHeaders(requestConfig);
                        config.method = uppercase(config.method);
                        config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                        var serverRequest = function (config) {
                            var headers = config.headers;
                            var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                            if (isUndefined(reqData)) {
                                forEach(headers, function (value, header) {
                                    if (lowercase(header) === 'content-type') {
                                        delete headers[header];
                                    }
                                });
                            }
                            if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                                config.withCredentials = defaults.withCredentials;
                            }
                            return sendReq(config, reqData).then(transformResponse, transformResponse);
                        };
                        var chain = [
                            serverRequest,
                            undefined
                        ];
                        var promise = $q.when(config);
                        forEach(reversedInterceptors, function (interceptor) {
                            if (interceptor.request || interceptor.requestError) {
                                chain.unshift(interceptor.request, interceptor.requestError);
                            }
                            if (interceptor.response || interceptor.responseError) {
                                chain.push(interceptor.response, interceptor.responseError);
                            }
                        });
                        while (chain.length) {
                            var thenFn = chain.shift();
                            var rejectFn = chain.shift();
                            promise = promise.then(thenFn, rejectFn);
                        }
                        if (useLegacyPromise) {
                            promise.success = function (fn) {
                                assertArgFn(fn, 'fn');
                                promise.then(function (response) {
                                    fn(response.data, response.status, response.headers, config);
                                });
                                return promise;
                            };
                            promise.error = function (fn) {
                                assertArgFn(fn, 'fn');
                                promise.then(null, function (response) {
                                    fn(response.data, response.status, response.headers, config);
                                });
                                return promise;
                            };
                        } else {
                            promise.success = $httpMinErrLegacyFn('success');
                            promise.error = $httpMinErrLegacyFn('error');
                        }
                        return promise;
                        function transformResponse(response) {
                            var resp = extend({}, response);
                            resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                            return isSuccess(response.status) ? resp : $q.reject(resp);
                        }
                        function executeHeaderFns(headers, config) {
                            var headerContent, processedHeaders = {};
                            forEach(headers, function (headerFn, header) {
                                if (isFunction(headerFn)) {
                                    headerContent = headerFn(config);
                                    if (headerContent != null) {
                                        processedHeaders[header] = headerContent;
                                    }
                                } else {
                                    processedHeaders[header] = headerFn;
                                }
                            });
                            return processedHeaders;
                        }
                        function mergeHeaders(config) {
                            var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                            defaultHeadersIteration:
                                for (defHeaderName in defHeaders) {
                                    lowercaseDefHeaderName = lowercase(defHeaderName);
                                    for (reqHeaderName in reqHeaders) {
                                        if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                            continue defaultHeadersIteration;
                                        }
                                    }
                                    reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                                }
                            return executeHeaderFns(reqHeaders, shallowCopy(config));
                        }
                    }
                    $http.pendingRequests = [];
                    createShortMethods('get', 'delete', 'head', 'jsonp');
                    createShortMethodsWithData('post', 'put', 'patch');
                    $http.defaults = defaults;
                    return $http;
                    function createShortMethods(names) {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url
                                }));
                            };
                        });
                    }
                    function createShortMethodsWithData(name) {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, data, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url,
                                    data: data
                                }));
                            };
                        });
                    }
                    function sendReq(config, reqData) {
                        var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.paramSerializer(config.params));
                        $http.pendingRequests.push(config);
                        promise.then(removePendingReq, removePendingReq);
                        if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
                            cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                        }
                        if (cache) {
                            cachedResp = cache.get(url);
                            if (isDefined(cachedResp)) {
                                if (isPromiseLike(cachedResp)) {
                                    cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                                } else {
                                    if (isArray(cachedResp)) {
                                        resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                                    } else {
                                        resolvePromise(cachedResp, 200, {}, 'OK');
                                    }
                                }
                            } else {
                                cache.put(url, promise);
                            }
                        }
                        if (isUndefined(cachedResp)) {
                            var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                            if (xsrfValue) {
                                reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                            }
                            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                        }
                        return promise;
                        function done(status, response, headersString, statusText) {
                            if (cache) {
                                if (isSuccess(status)) {
                                    cache.put(url, [
                                        status,
                                        response,
                                        parseHeaders(headersString),
                                        statusText
                                    ]);
                                } else {
                                    cache.remove(url);
                                }
                            }
                            function resolveHttpPromise() {
                                resolvePromise(response, status, headersString, statusText);
                            }
                            if (useApplyAsync) {
                                $rootScope.$applyAsync(resolveHttpPromise);
                            } else {
                                resolveHttpPromise();
                                if (!$rootScope.$$phase)
                                    $rootScope.$apply();
                            }
                        }
                        function resolvePromise(response, status, headers, statusText) {
                            status = status >= -1 ? status : 0;
                            (isSuccess(status) ? deferred.resolve : deferred.reject)({
                                data: response,
                                status: status,
                                headers: headersGetter(headers),
                                config: config,
                                statusText: statusText
                            });
                        }
                        function resolvePromiseWithResult(result) {
                            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                        }
                        function removePendingReq() {
                            var idx = $http.pendingRequests.indexOf(config);
                            if (idx !== -1)
                                $http.pendingRequests.splice(idx, 1);
                        }
                    }
                    function buildUrl(url, serializedParams) {
                        if (serializedParams.length > 0) {
                            url += (url.indexOf('?') == -1 ? '?' : '&') + serializedParams;
                        }
                        return url;
                    }
                }
            ];
        }
        function $xhrFactoryProvider() {
            this.$get = function () {
                return function createXhr() {
                    return new window.XMLHttpRequest();
                };
            };
        }
        function $HttpBackendProvider() {
            this.$get = [
                '$browser',
                '$window',
                '$document',
                '$xhrFactory',
                function ($browser, $window, $document, $xhrFactory) {
                    return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
                }
            ];
        }
        function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
            return function (method, url, post, callback, headers, timeout, withCredentials, responseType) {
                $browser.$$incOutstandingRequestCount();
                url = url || $browser.url();
                if (lowercase(method) == 'jsonp') {
                    var callbackId = '_' + (callbacks.counter++).toString(36);
                    callbacks[callbackId] = function (data) {
                        callbacks[callbackId].data = data;
                        callbacks[callbackId].called = true;
                    };
                    var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function (status, text) {
                        completeRequest(callback, status, callbacks[callbackId].data, '', text);
                        callbacks[callbackId] = noop;
                    });
                } else {
                    var xhr = createXhr(method, url);
                    xhr.open(method, url, true);
                    forEach(headers, function (value, key) {
                        if (isDefined(value)) {
                            xhr.setRequestHeader(key, value);
                        }
                    });
                    xhr.onload = function requestLoaded() {
                        var statusText = xhr.statusText || '';
                        var response = 'response' in xhr ? xhr.response : xhr.responseText;
                        var status = xhr.status === 1223 ? 204 : xhr.status;
                        if (status === 0) {
                            status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
                        }
                        completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                    };
                    var requestError = function () {
                        completeRequest(callback, -1, null, null, '');
                    };
                    xhr.onerror = requestError;
                    xhr.onabort = requestError;
                    if (withCredentials) {
                        xhr.withCredentials = true;
                    }
                    if (responseType) {
                        try {
                            xhr.responseType = responseType;
                        } catch (e) {
                            if (responseType !== 'json') {
                                throw e;
                            }
                        }
                    }
                    xhr.send(isUndefined(post) ? null : post);
                }
                if (timeout > 0) {
                    var timeoutId = $browserDefer(timeoutRequest, timeout);
                } else if (isPromiseLike(timeout)) {
                    timeout.then(timeoutRequest);
                }
                function timeoutRequest() {
                    jsonpDone && jsonpDone();
                    xhr && xhr.abort();
                }
                function completeRequest(callback, status, response, headersString, statusText) {
                    if (isDefined(timeoutId)) {
                        $browserDefer.cancel(timeoutId);
                    }
                    jsonpDone = xhr = null;
                    callback(status, response, headersString, statusText);
                    $browser.$$completeOutstandingRequest(noop);
                }
            };
            function jsonpReq(url, callbackId, done) {
                var script = rawDocument.createElement('script'), callback = null;
                script.type = 'text/javascript';
                script.src = url;
                script.async = true;
                callback = function (event) {
                    removeEventListenerFn(script, 'load', callback);
                    removeEventListenerFn(script, 'error', callback);
                    rawDocument.body.removeChild(script);
                    script = null;
                    var status = -1;
                    var text = 'unknown';
                    if (event) {
                        if (event.type === 'load' && !callbacks[callbackId].called) {
                            event = { type: 'error' };
                        }
                        text = event.type;
                        status = event.type === 'error' ? 404 : 200;
                    }
                    if (done) {
                        done(status, text);
                    }
                };
                addEventListenerFn(script, 'load', callback);
                addEventListenerFn(script, 'error', callback);
                rawDocument.body.appendChild(script);
                return callback;
            }
        }
        var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
        $interpolateMinErr.throwNoconcat = function (text) {
            throw $interpolateMinErr('noconcat', 'Error while interpolating: {0}\nStrict Contextual Escaping disallows ' + 'interpolations that concatenate multiple expressions when a trusted value is ' + 'required.  See http://docs.angularjs.org/api/ng.$sce', text);
        };
        $interpolateMinErr.interr = function (text, err) {
            return $interpolateMinErr('interr', 'Can\'t interpolate: {0}\n{1}', text, err.toString());
        };
        function $InterpolateProvider() {
            var startSymbol = '{{';
            var endSymbol = '}}';
            this.startSymbol = function (value) {
                if (value) {
                    startSymbol = value;
                    return this;
                } else {
                    return startSymbol;
                }
            };
            this.endSymbol = function (value) {
                if (value) {
                    endSymbol = value;
                    return this;
                } else {
                    return endSymbol;
                }
            };
            this.$get = [
                '$parse',
                '$exceptionHandler',
                '$sce',
                function ($parse, $exceptionHandler, $sce) {
                    var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
                    function escape(ch) {
                        return '\\\\\\' + ch;
                    }
                    function unescapeText(text) {
                        return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                    }
                    function stringify(value) {
                        if (value == null) {
                            return '';
                        }
                        switch (typeof value) {
                        case 'string':
                            break;
                        case 'number':
                            value = '' + value;
                            break;
                        default:
                            value = toJson(value);
                        }
                        return value;
                    }
                    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                        allOrNothing = !!allOrNothing;
                        var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                        while (index < textLength) {
                            if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                                if (index !== startIndex) {
                                    concat.push(unescapeText(text.substring(index, startIndex)));
                                }
                                exp = text.substring(startIndex + startSymbolLength, endIndex);
                                expressions.push(exp);
                                parseFns.push($parse(exp, parseStringifyInterceptor));
                                index = endIndex + endSymbolLength;
                                expressionPositions.push(concat.length);
                                concat.push('');
                            } else {
                                if (index !== textLength) {
                                    concat.push(unescapeText(text.substring(index)));
                                }
                                break;
                            }
                        }
                        if (trustedContext && concat.length > 1) {
                            $interpolateMinErr.throwNoconcat(text);
                        }
                        if (!mustHaveExpression || expressions.length) {
                            var compute = function (values) {
                                for (var i = 0, ii = expressions.length; i < ii; i++) {
                                    if (allOrNothing && isUndefined(values[i]))
                                        return;
                                    concat[expressionPositions[i]] = values[i];
                                }
                                return concat.join('');
                            };
                            var getValue = function (value) {
                                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                            };
                            return extend(function interpolationFn(context) {
                                var i = 0;
                                var ii = expressions.length;
                                var values = new Array(ii);
                                try {
                                    for (; i < ii; i++) {
                                        values[i] = parseFns[i](context);
                                    }
                                    return compute(values);
                                } catch (err) {
                                    $exceptionHandler($interpolateMinErr.interr(text, err));
                                }
                            }, {
                                exp: text,
                                expressions: expressions,
                                $$watchDelegate: function (scope, listener) {
                                    var lastValue;
                                    return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                        var currValue = compute(values);
                                        if (isFunction(listener)) {
                                            listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                        }
                                        lastValue = currValue;
                                    });
                                }
                            });
                        }
                        function parseStringifyInterceptor(value) {
                            try {
                                value = getValue(value);
                                return allOrNothing && !isDefined(value) ? value : stringify(value);
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err));
                            }
                        }
                    }
                    $interpolate.startSymbol = function () {
                        return startSymbol;
                    };
                    $interpolate.endSymbol = function () {
                        return endSymbol;
                    };
                    return $interpolate;
                }
            ];
        }
        function $IntervalProvider() {
            this.$get = [
                '$rootScope',
                '$window',
                '$q',
                '$$q',
                function ($rootScope, $window, $q, $$q) {
                    var intervals = {};
                    function interval(fn, delay, count, invokeApply) {
                        var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                        count = isDefined(count) ? count : 0;
                        promise.then(null, null, !hasParams ? fn : function () {
                            fn.apply(null, args);
                        });
                        promise.$$intervalId = setInterval(function tick() {
                            deferred.notify(iteration++);
                            if (count > 0 && iteration >= count) {
                                deferred.resolve(iteration);
                                clearInterval(promise.$$intervalId);
                                delete intervals[promise.$$intervalId];
                            }
                            if (!skipApply)
                                $rootScope.$apply();
                        }, delay);
                        intervals[promise.$$intervalId] = deferred;
                        return promise;
                    }
                    interval.cancel = function (promise) {
                        if (promise && promise.$$intervalId in intervals) {
                            intervals[promise.$$intervalId].reject('canceled');
                            $window.clearInterval(promise.$$intervalId);
                            delete intervals[promise.$$intervalId];
                            return true;
                        }
                        return false;
                    };
                    return interval;
                }
            ];
        }
        var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
                'http': 80,
                'https': 443,
                'ftp': 21
            };
        var $locationMinErr = minErr('$location');
        function encodePath(path) {
            var segments = path.split('/'), i = segments.length;
            while (i--) {
                segments[i] = encodeUriSegment(segments[i]);
            }
            return segments.join('/');
        }
        function parseAbsoluteUrl(absoluteUrl, locationObj) {
            var parsedUrl = urlResolve(absoluteUrl);
            locationObj.$$protocol = parsedUrl.protocol;
            locationObj.$$host = parsedUrl.hostname;
            locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
        }
        function parseAppUrl(relativeUrl, locationObj) {
            var prefixed = relativeUrl.charAt(0) !== '/';
            if (prefixed) {
                relativeUrl = '/' + relativeUrl;
            }
            var match = urlResolve(relativeUrl);
            locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
            locationObj.$$search = parseKeyValue(match.search);
            locationObj.$$hash = decodeURIComponent(match.hash);
            if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
                locationObj.$$path = '/' + locationObj.$$path;
            }
        }
        function beginsWith(begin, whole) {
            if (whole.indexOf(begin) === 0) {
                return whole.substr(begin.length);
            }
        }
        function stripHash(url) {
            var index = url.indexOf('#');
            return index == -1 ? url : url.substr(0, index);
        }
        function trimEmptyHash(url) {
            return url.replace(/(#.+)|#$/, '$1');
        }
        function stripFile(url) {
            return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
        }
        function serverBase(url) {
            return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
        }
        function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
            this.$$html5 = true;
            basePrefix = basePrefix || '';
            parseAbsoluteUrl(appBase, this);
            this.$$parse = function (url) {
                var pathUrl = beginsWith(appBaseNoFile, url);
                if (!isString(pathUrl)) {
                    throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                }
                parseAppUrl(pathUrl, this);
                if (!this.$$path) {
                    this.$$path = '/';
                }
                this.$$compose();
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
            };
            this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && relHref[0] === '#') {
                    this.hash(relHref.slice(1));
                    return true;
                }
                var appUrl, prevAppUrl;
                var rewrittenUrl;
                if (isDefined(appUrl = beginsWith(appBase, url))) {
                    prevAppUrl = appUrl;
                    if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
                        rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
                    } else {
                        rewrittenUrl = appBase + prevAppUrl;
                    }
                } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
                    rewrittenUrl = appBaseNoFile + appUrl;
                } else if (appBaseNoFile == url + '/') {
                    rewrittenUrl = appBaseNoFile;
                }
                if (rewrittenUrl) {
                    this.$$parse(rewrittenUrl);
                }
                return !!rewrittenUrl;
            };
        }
        function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
            parseAbsoluteUrl(appBase, this);
            this.$$parse = function (url) {
                var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
                var withoutHashUrl;
                if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
                    withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
                    if (isUndefined(withoutHashUrl)) {
                        withoutHashUrl = withoutBaseUrl;
                    }
                } else {
                    if (this.$$html5) {
                        withoutHashUrl = withoutBaseUrl;
                    } else {
                        withoutHashUrl = '';
                        if (isUndefined(withoutBaseUrl)) {
                            appBase = url;
                            this.replace();
                        }
                    }
                }
                parseAppUrl(withoutHashUrl, this);
                this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
                this.$$compose();
                function removeWindowsDriveName(path, url, base) {
                    var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                    var firstPathSegmentMatch;
                    if (url.indexOf(base) === 0) {
                        url = url.replace(base, '');
                    }
                    if (windowsFilePathExp.exec(url)) {
                        return path;
                    }
                    firstPathSegmentMatch = windowsFilePathExp.exec(path);
                    return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
                }
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
            };
            this.$$parseLinkUrl = function (url, relHref) {
                if (stripHash(appBase) == stripHash(url)) {
                    this.$$parse(url);
                    return true;
                }
                return false;
            };
        }
        function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
            this.$$html5 = true;
            LocationHashbangUrl.apply(this, arguments);
            this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && relHref[0] === '#') {
                    this.hash(relHref.slice(1));
                    return true;
                }
                var rewrittenUrl;
                var appUrl;
                if (appBase == stripHash(url)) {
                    rewrittenUrl = url;
                } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                    rewrittenUrl = appBase + hashPrefix + appUrl;
                } else if (appBaseNoFile === url + '/') {
                    rewrittenUrl = appBaseNoFile;
                }
                if (rewrittenUrl) {
                    this.$$parse(rewrittenUrl);
                }
                return !!rewrittenUrl;
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                this.$$absUrl = appBase + hashPrefix + this.$$url;
            };
        }
        var locationPrototype = {
            $$html5: false,
            $$replace: false,
            absUrl: locationGetter('$$absUrl'),
            url: function (url) {
                if (isUndefined(url)) {
                    return this.$$url;
                }
                var match = PATH_MATCH.exec(url);
                if (match[1] || url === '')
                    this.path(decodeURIComponent(match[1]));
                if (match[2] || match[1] || url === '')
                    this.search(match[3] || '');
                this.hash(match[5] || '');
                return this;
            },
            protocol: locationGetter('$$protocol'),
            host: locationGetter('$$host'),
            port: locationGetter('$$port'),
            path: locationGetterSetter('$$path', function (path) {
                path = path !== null ? path.toString() : '';
                return path.charAt(0) == '/' ? path : '/' + path;
            }),
            search: function (search, paramValue) {
                switch (arguments.length) {
                case 0:
                    return this.$$search;
                case 1:
                    if (isString(search) || isNumber(search)) {
                        search = search.toString();
                        this.$$search = parseKeyValue(search);
                    } else if (isObject(search)) {
                        search = copy(search, {});
                        forEach(search, function (value, key) {
                            if (value == null)
                                delete search[key];
                        });
                        this.$$search = search;
                    } else {
                        throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
                    }
                    break;
                default:
                    if (isUndefined(paramValue) || paramValue === null) {
                        delete this.$$search[search];
                    } else {
                        this.$$search[search] = paramValue;
                    }
                }
                this.$$compose();
                return this;
            },
            hash: locationGetterSetter('$$hash', function (hash) {
                return hash !== null ? hash.toString() : '';
            }),
            replace: function () {
                this.$$replace = true;
                return this;
            }
        };
        forEach([
            LocationHashbangInHtml5Url,
            LocationHashbangUrl,
            LocationHtml5Url
        ], function (Location) {
            Location.prototype = Object.create(locationPrototype);
            Location.prototype.state = function (state) {
                if (!arguments.length) {
                    return this.$$state;
                }
                if (Location !== LocationHtml5Url || !this.$$html5) {
                    throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
                }
                this.$$state = isUndefined(state) ? null : state;
                return this;
            };
        });
        function locationGetter(property) {
            return function () {
                return this[property];
            };
        }
        function locationGetterSetter(property, preprocess) {
            return function (value) {
                if (isUndefined(value)) {
                    return this[property];
                }
                this[property] = preprocess(value);
                this.$$compose();
                return this;
            };
        }
        function $LocationProvider() {
            var hashPrefix = '', html5Mode = {
                    enabled: false,
                    requireBase: true,
                    rewriteLinks: true
                };
            this.hashPrefix = function (prefix) {
                if (isDefined(prefix)) {
                    hashPrefix = prefix;
                    return this;
                } else {
                    return hashPrefix;
                }
            };
            this.html5Mode = function (mode) {
                if (isBoolean(mode)) {
                    html5Mode.enabled = mode;
                    return this;
                } else if (isObject(mode)) {
                    if (isBoolean(mode.enabled)) {
                        html5Mode.enabled = mode.enabled;
                    }
                    if (isBoolean(mode.requireBase)) {
                        html5Mode.requireBase = mode.requireBase;
                    }
                    if (isBoolean(mode.rewriteLinks)) {
                        html5Mode.rewriteLinks = mode.rewriteLinks;
                    }
                    return this;
                } else {
                    return html5Mode;
                }
            };
            this.$get = [
                '$rootScope',
                '$browser',
                '$sniffer',
                '$rootElement',
                '$window',
                function ($rootScope, $browser, $sniffer, $rootElement, $window) {
                    var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
                    if (html5Mode.enabled) {
                        if (!baseHref && html5Mode.requireBase) {
                            throw $locationMinErr('nobase', '$location in HTML5 mode requires a <base> tag to be present!');
                        }
                        appBase = serverBase(initialUrl) + (baseHref || '/');
                        LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                    } else {
                        appBase = stripHash(initialUrl);
                        LocationMode = LocationHashbangUrl;
                    }
                    var appBaseNoFile = stripFile(appBase);
                    $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
                    $location.$$parseLinkUrl(initialUrl, initialUrl);
                    $location.$$state = $browser.state();
                    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                    function setBrowserUrlWithFallback(url, replace, state) {
                        var oldUrl = $location.url();
                        var oldState = $location.$$state;
                        try {
                            $browser.url(url, replace, state);
                            $location.$$state = $browser.state();
                        } catch (e) {
                            $location.url(oldUrl);
                            $location.$$state = oldState;
                            throw e;
                        }
                    }
                    $rootElement.on('click', function (event) {
                        if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
                            return;
                        var elm = jqLite(event.target);
                        while (nodeName_(elm[0]) !== 'a') {
                            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                                return;
                        }
                        var absHref = elm.prop('href');
                        var relHref = elm.attr('href') || elm.attr('xlink:href');
                        if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
                            absHref = urlResolve(absHref.animVal).href;
                        }
                        if (IGNORE_URI_REGEXP.test(absHref))
                            return;
                        if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
                            if ($location.$$parseLinkUrl(absHref, relHref)) {
                                event.preventDefault();
                                if ($location.absUrl() != $browser.url()) {
                                    $rootScope.$apply();
                                    $window.angular['ff-684208-preventDefault'] = true;
                                }
                            }
                        }
                    });
                    if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
                        $browser.url($location.absUrl(), true);
                    }
                    var initializing = true;
                    $browser.onUrlChange(function (newUrl, newState) {
                        if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
                            $window.location.href = newUrl;
                            return;
                        }
                        $rootScope.$evalAsync(function () {
                            var oldUrl = $location.absUrl();
                            var oldState = $location.$$state;
                            var defaultPrevented;
                            newUrl = trimEmptyHash(newUrl);
                            $location.$$parse(newUrl);
                            $location.$$state = newState;
                            defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
                            if ($location.absUrl() !== newUrl)
                                return;
                            if (defaultPrevented) {
                                $location.$$parse(oldUrl);
                                $location.$$state = oldState;
                                setBrowserUrlWithFallback(oldUrl, false, oldState);
                            } else {
                                initializing = false;
                                afterLocationChange(oldUrl, oldState);
                            }
                        });
                        if (!$rootScope.$$phase)
                            $rootScope.$digest();
                    });
                    $rootScope.$watch(function $locationWatch() {
                        var oldUrl = trimEmptyHash($browser.url());
                        var newUrl = trimEmptyHash($location.absUrl());
                        var oldState = $browser.state();
                        var currentReplace = $location.$$replace;
                        var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                        if (initializing || urlOrStateChanged) {
                            initializing = false;
                            $rootScope.$evalAsync(function () {
                                var newUrl = $location.absUrl();
                                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                                if ($location.absUrl() !== newUrl)
                                    return;
                                if (defaultPrevented) {
                                    $location.$$parse(oldUrl);
                                    $location.$$state = oldState;
                                } else {
                                    if (urlOrStateChanged) {
                                        setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                                    }
                                    afterLocationChange(oldUrl, oldState);
                                }
                            });
                        }
                        $location.$$replace = false;
                    });
                    return $location;
                    function afterLocationChange(oldUrl, oldState) {
                        $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
                    }
                }
            ];
        }
        function $LogProvider() {
            var debug = true, self = this;
            this.debugEnabled = function (flag) {
                if (isDefined(flag)) {
                    debug = flag;
                    return this;
                } else {
                    return debug;
                }
            };
            this.$get = [
                '$window',
                function ($window) {
                    return {
                        log: consoleLog('log'),
                        info: consoleLog('info'),
                        warn: consoleLog('warn'),
                        error: consoleLog('error'),
                        debug: function () {
                            var fn = consoleLog('debug');
                            return function () {
                                if (debug) {
                                    fn.apply(self, arguments);
                                }
                            };
                        }()
                    };
                    function formatError(arg) {
                        if (arg instanceof Error) {
                            if (arg.stack) {
                                arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
                            } else if (arg.sourceURL) {
                                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
                            }
                        }
                        return arg;
                    }
                    function consoleLog(type) {
                        var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                        try {
                            hasApply = !!logFn.apply;
                        } catch (e) {
                        }
                        if (hasApply) {
                            return function () {
                                var args = [];
                                forEach(arguments, function (arg) {
                                    args.push(formatError(arg));
                                });
                                return logFn.apply(console, args);
                            };
                        }
                        return function (arg1, arg2) {
                            logFn(arg1, arg2 == null ? '' : arg2);
                        };
                    }
                }
            ];
        }
        var $parseMinErr = minErr('$parse');
        function ensureSafeMemberName(name, fullExpression) {
            if (name === '__defineGetter__' || name === '__defineSetter__' || name === '__lookupGetter__' || name === '__lookupSetter__' || name === '__proto__') {
                throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
            }
            return name;
        }
        function getStringValue(name, fullExpression) {
            name = name + '';
            if (!isString(name)) {
                throw $parseMinErr('iseccst', 'Cannot convert object to primitive value! ' + 'Expression: {0}', fullExpression);
            }
            return name;
        }
        function ensureSafeObject(obj, fullExpression) {
            if (obj) {
                if (obj.constructor === obj) {
                    throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj.window === obj) {
                    throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                    throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj === Object) {
                    throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
                }
            }
            return obj;
        }
        var CALL = Function.prototype.call;
        var APPLY = Function.prototype.apply;
        var BIND = Function.prototype.bind;
        function ensureSafeFunction(obj, fullExpression) {
            if (obj) {
                if (obj.constructor === obj) {
                    throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj === CALL || obj === APPLY || obj === BIND) {
                    throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
                }
            }
        }
        function ensureSafeAssignContext(obj, fullExpression) {
            if (obj) {
                if (obj === 0..constructor || obj === false.constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
                    throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
                }
            }
        }
        var OPERATORS = createMap();
        forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (operator) {
            OPERATORS[operator] = true;
        });
        var ESCAPE = {
            'n': '\n',
            'f': '\f',
            'r': '\r',
            't': '\t',
            'v': '\x0B',
            '\'': '\'',
            '"': '"'
        };
        var Lexer = function (options) {
            this.options = options;
        };
        Lexer.prototype = {
            constructor: Lexer,
            lex: function (text) {
                this.text = text;
                this.index = 0;
                this.tokens = [];
                while (this.index < this.text.length) {
                    var ch = this.text.charAt(this.index);
                    if (ch === '"' || ch === '\'') {
                        this.readString(ch);
                    } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
                        this.readNumber();
                    } else if (this.isIdent(ch)) {
                        this.readIdent();
                    } else if (this.is(ch, '(){}[].,;:?')) {
                        this.tokens.push({
                            index: this.index,
                            text: ch
                        });
                        this.index++;
                    } else if (this.isWhitespace(ch)) {
                        this.index++;
                    } else {
                        var ch2 = ch + this.peek();
                        var ch3 = ch2 + this.peek(2);
                        var op1 = OPERATORS[ch];
                        var op2 = OPERATORS[ch2];
                        var op3 = OPERATORS[ch3];
                        if (op1 || op2 || op3) {
                            var token = op3 ? ch3 : op2 ? ch2 : ch;
                            this.tokens.push({
                                index: this.index,
                                text: token,
                                operator: true
                            });
                            this.index += token.length;
                        } else {
                            this.throwError('Unexpected next character ', this.index, this.index + 1);
                        }
                    }
                }
                return this.tokens;
            },
            is: function (ch, chars) {
                return chars.indexOf(ch) !== -1;
            },
            peek: function (i) {
                var num = i || 1;
                return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
            },
            isNumber: function (ch) {
                return '0' <= ch && ch <= '9' && typeof ch === 'string';
            },
            isWhitespace: function (ch) {
                return ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\x0B' || ch === '\xA0';
            },
            isIdent: function (ch) {
                return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$';
            },
            isExpOperator: function (ch) {
                return ch === '-' || ch === '+' || this.isNumber(ch);
            },
            throwError: function (error, start, end) {
                end = end || this.index;
                var colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end;
                throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
            },
            readNumber: function () {
                var number = '';
                var start = this.index;
                while (this.index < this.text.length) {
                    var ch = lowercase(this.text.charAt(this.index));
                    if (ch == '.' || this.isNumber(ch)) {
                        number += ch;
                    } else {
                        var peekCh = this.peek();
                        if (ch == 'e' && this.isExpOperator(peekCh)) {
                            number += ch;
                        } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                            number += ch;
                        } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                            this.throwError('Invalid exponent');
                        } else {
                            break;
                        }
                    }
                    this.index++;
                }
                this.tokens.push({
                    index: start,
                    text: number,
                    constant: true,
                    value: Number(number)
                });
            },
            readIdent: function () {
                var start = this.index;
                while (this.index < this.text.length) {
                    var ch = this.text.charAt(this.index);
                    if (!(this.isIdent(ch) || this.isNumber(ch))) {
                        break;
                    }
                    this.index++;
                }
                this.tokens.push({
                    index: start,
                    text: this.text.slice(start, this.index),
                    identifier: true
                });
            },
            readString: function (quote) {
                var start = this.index;
                this.index++;
                var string = '';
                var rawString = quote;
                var escape = false;
                while (this.index < this.text.length) {
                    var ch = this.text.charAt(this.index);
                    rawString += ch;
                    if (escape) {
                        if (ch === 'u') {
                            var hex = this.text.substring(this.index + 1, this.index + 5);
                            if (!hex.match(/[\da-f]{4}/i)) {
                                this.throwError('Invalid unicode escape [\\u' + hex + ']');
                            }
                            this.index += 4;
                            string += String.fromCharCode(parseInt(hex, 16));
                        } else {
                            var rep = ESCAPE[ch];
                            string = string + (rep || ch);
                        }
                        escape = false;
                    } else if (ch === '\\') {
                        escape = true;
                    } else if (ch === quote) {
                        this.index++;
                        this.tokens.push({
                            index: start,
                            text: rawString,
                            constant: true,
                            value: string
                        });
                        return;
                    } else {
                        string += ch;
                    }
                    this.index++;
                }
                this.throwError('Unterminated quote', start);
            }
        };
        var AST = function (lexer, options) {
            this.lexer = lexer;
            this.options = options;
        };
        AST.Program = 'Program';
        AST.ExpressionStatement = 'ExpressionStatement';
        AST.AssignmentExpression = 'AssignmentExpression';
        AST.ConditionalExpression = 'ConditionalExpression';
        AST.LogicalExpression = 'LogicalExpression';
        AST.BinaryExpression = 'BinaryExpression';
        AST.UnaryExpression = 'UnaryExpression';
        AST.CallExpression = 'CallExpression';
        AST.MemberExpression = 'MemberExpression';
        AST.Identifier = 'Identifier';
        AST.Literal = 'Literal';
        AST.ArrayExpression = 'ArrayExpression';
        AST.Property = 'Property';
        AST.ObjectExpression = 'ObjectExpression';
        AST.ThisExpression = 'ThisExpression';
        AST.NGValueParameter = 'NGValueParameter';
        AST.prototype = {
            ast: function (text) {
                this.text = text;
                this.tokens = this.lexer.lex(text);
                var value = this.program();
                if (this.tokens.length !== 0) {
                    this.throwError('is an unexpected token', this.tokens[0]);
                }
                return value;
            },
            program: function () {
                var body = [];
                while (true) {
                    if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
                        body.push(this.expressionStatement());
                    if (!this.expect(';')) {
                        return {
                            type: AST.Program,
                            body: body
                        };
                    }
                }
            },
            expressionStatement: function () {
                return {
                    type: AST.ExpressionStatement,
                    expression: this.filterChain()
                };
            },
            filterChain: function () {
                var left = this.expression();
                var token;
                while (token = this.expect('|')) {
                    left = this.filter(left);
                }
                return left;
            },
            expression: function () {
                return this.assignment();
            },
            assignment: function () {
                var result = this.ternary();
                if (this.expect('=')) {
                    result = {
                        type: AST.AssignmentExpression,
                        left: result,
                        right: this.assignment(),
                        operator: '='
                    };
                }
                return result;
            },
            ternary: function () {
                var test = this.logicalOR();
                var alternate;
                var consequent;
                if (this.expect('?')) {
                    alternate = this.expression();
                    if (this.consume(':')) {
                        consequent = this.expression();
                        return {
                            type: AST.ConditionalExpression,
                            test: test,
                            alternate: alternate,
                            consequent: consequent
                        };
                    }
                }
                return test;
            },
            logicalOR: function () {
                var left = this.logicalAND();
                while (this.expect('||')) {
                    left = {
                        type: AST.LogicalExpression,
                        operator: '||',
                        left: left,
                        right: this.logicalAND()
                    };
                }
                return left;
            },
            logicalAND: function () {
                var left = this.equality();
                while (this.expect('&&')) {
                    left = {
                        type: AST.LogicalExpression,
                        operator: '&&',
                        left: left,
                        right: this.equality()
                    };
                }
                return left;
            },
            equality: function () {
                var left = this.relational();
                var token;
                while (token = this.expect('==', '!=', '===', '!==')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.relational()
                    };
                }
                return left;
            },
            relational: function () {
                var left = this.additive();
                var token;
                while (token = this.expect('<', '>', '<=', '>=')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.additive()
                    };
                }
                return left;
            },
            additive: function () {
                var left = this.multiplicative();
                var token;
                while (token = this.expect('+', '-')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.multiplicative()
                    };
                }
                return left;
            },
            multiplicative: function () {
                var left = this.unary();
                var token;
                while (token = this.expect('*', '/', '%')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.unary()
                    };
                }
                return left;
            },
            unary: function () {
                var token;
                if (token = this.expect('+', '-', '!')) {
                    return {
                        type: AST.UnaryExpression,
                        operator: token.text,
                        prefix: true,
                        argument: this.unary()
                    };
                } else {
                    return this.primary();
                }
            },
            primary: function () {
                var primary;
                if (this.expect('(')) {
                    primary = this.filterChain();
                    this.consume(')');
                } else if (this.expect('[')) {
                    primary = this.arrayDeclaration();
                } else if (this.expect('{')) {
                    primary = this.object();
                } else if (this.constants.hasOwnProperty(this.peek().text)) {
                    primary = copy(this.constants[this.consume().text]);
                } else if (this.peek().identifier) {
                    primary = this.identifier();
                } else if (this.peek().constant) {
                    primary = this.constant();
                } else {
                    this.throwError('not a primary expression', this.peek());
                }
                var next;
                while (next = this.expect('(', '[', '.')) {
                    if (next.text === '(') {
                        primary = {
                            type: AST.CallExpression,
                            callee: primary,
                            arguments: this.parseArguments()
                        };
                        this.consume(')');
                    } else if (next.text === '[') {
                        primary = {
                            type: AST.MemberExpression,
                            object: primary,
                            property: this.expression(),
                            computed: true
                        };
                        this.consume(']');
                    } else if (next.text === '.') {
                        primary = {
                            type: AST.MemberExpression,
                            object: primary,
                            property: this.identifier(),
                            computed: false
                        };
                    } else {
                        this.throwError('IMPOSSIBLE');
                    }
                }
                return primary;
            },
            filter: function (baseExpression) {
                var args = [baseExpression];
                var result = {
                    type: AST.CallExpression,
                    callee: this.identifier(),
                    arguments: args,
                    filter: true
                };
                while (this.expect(':')) {
                    args.push(this.expression());
                }
                return result;
            },
            parseArguments: function () {
                var args = [];
                if (this.peekToken().text !== ')') {
                    do {
                        args.push(this.expression());
                    } while (this.expect(','));
                }
                return args;
            },
            identifier: function () {
                var token = this.consume();
                if (!token.identifier) {
                    this.throwError('is not a valid identifier', token);
                }
                return {
                    type: AST.Identifier,
                    name: token.text
                };
            },
            constant: function () {
                return {
                    type: AST.Literal,
                    value: this.consume().value
                };
            },
            arrayDeclaration: function () {
                var elements = [];
                if (this.peekToken().text !== ']') {
                    do {
                        if (this.peek(']')) {
                            break;
                        }
                        elements.push(this.expression());
                    } while (this.expect(','));
                }
                this.consume(']');
                return {
                    type: AST.ArrayExpression,
                    elements: elements
                };
            },
            object: function () {
                var properties = [], property;
                if (this.peekToken().text !== '}') {
                    do {
                        if (this.peek('}')) {
                            break;
                        }
                        property = {
                            type: AST.Property,
                            kind: 'init'
                        };
                        if (this.peek().constant) {
                            property.key = this.constant();
                        } else if (this.peek().identifier) {
                            property.key = this.identifier();
                        } else {
                            this.throwError('invalid key', this.peek());
                        }
                        this.consume(':');
                        property.value = this.expression();
                        properties.push(property);
                    } while (this.expect(','));
                }
                this.consume('}');
                return {
                    type: AST.ObjectExpression,
                    properties: properties
                };
            },
            throwError: function (msg, token) {
                throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
            },
            consume: function (e1) {
                if (this.tokens.length === 0) {
                    throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
                }
                var token = this.expect(e1);
                if (!token) {
                    this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
                }
                return token;
            },
            peekToken: function () {
                if (this.tokens.length === 0) {
                    throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
                }
                return this.tokens[0];
            },
            peek: function (e1, e2, e3, e4) {
                return this.peekAhead(0, e1, e2, e3, e4);
            },
            peekAhead: function (i, e1, e2, e3, e4) {
                if (this.tokens.length > i) {
                    var token = this.tokens[i];
                    var t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                        return token;
                    }
                }
                return false;
            },
            expect: function (e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                if (token) {
                    this.tokens.shift();
                    return token;
                }
                return false;
            },
            constants: {
                'true': {
                    type: AST.Literal,
                    value: true
                },
                'false': {
                    type: AST.Literal,
                    value: false
                },
                'null': {
                    type: AST.Literal,
                    value: null
                },
                'undefined': {
                    type: AST.Literal,
                    value: undefined
                },
                'this': { type: AST.ThisExpression }
            }
        };
        function ifDefined(v, d) {
            return typeof v !== 'undefined' ? v : d;
        }
        function plusFn(l, r) {
            if (typeof l === 'undefined')
                return r;
            if (typeof r === 'undefined')
                return l;
            return l + r;
        }
        function isStateless($filter, filterName) {
            var fn = $filter(filterName);
            return !fn.$stateful;
        }
        function findConstantAndWatchExpressions(ast, $filter) {
            var allConstants;
            var argsToWatch;
            switch (ast.type) {
            case AST.Program:
                allConstants = true;
                forEach(ast.body, function (expr) {
                    findConstantAndWatchExpressions(expr.expression, $filter);
                    allConstants = allConstants && expr.expression.constant;
                });
                ast.constant = allConstants;
                break;
            case AST.Literal:
                ast.constant = true;
                ast.toWatch = [];
                break;
            case AST.UnaryExpression:
                findConstantAndWatchExpressions(ast.argument, $filter);
                ast.constant = ast.argument.constant;
                ast.toWatch = ast.argument.toWatch;
                break;
            case AST.BinaryExpression:
                findConstantAndWatchExpressions(ast.left, $filter);
                findConstantAndWatchExpressions(ast.right, $filter);
                ast.constant = ast.left.constant && ast.right.constant;
                ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                break;
            case AST.LogicalExpression:
                findConstantAndWatchExpressions(ast.left, $filter);
                findConstantAndWatchExpressions(ast.right, $filter);
                ast.constant = ast.left.constant && ast.right.constant;
                ast.toWatch = ast.constant ? [] : [ast];
                break;
            case AST.ConditionalExpression:
                findConstantAndWatchExpressions(ast.test, $filter);
                findConstantAndWatchExpressions(ast.alternate, $filter);
                findConstantAndWatchExpressions(ast.consequent, $filter);
                ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
                ast.toWatch = ast.constant ? [] : [ast];
                break;
            case AST.Identifier:
                ast.constant = false;
                ast.toWatch = [ast];
                break;
            case AST.MemberExpression:
                findConstantAndWatchExpressions(ast.object, $filter);
                if (ast.computed) {
                    findConstantAndWatchExpressions(ast.property, $filter);
                }
                ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
                ast.toWatch = [ast];
                break;
            case AST.CallExpression:
                allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
                argsToWatch = [];
                forEach(ast.arguments, function (expr) {
                    findConstantAndWatchExpressions(expr, $filter);
                    allConstants = allConstants && expr.constant;
                    if (!expr.constant) {
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    }
                });
                ast.constant = allConstants;
                ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
                break;
            case AST.AssignmentExpression:
                findConstantAndWatchExpressions(ast.left, $filter);
                findConstantAndWatchExpressions(ast.right, $filter);
                ast.constant = ast.left.constant && ast.right.constant;
                ast.toWatch = [ast];
                break;
            case AST.ArrayExpression:
                allConstants = true;
                argsToWatch = [];
                forEach(ast.elements, function (expr) {
                    findConstantAndWatchExpressions(expr, $filter);
                    allConstants = allConstants && expr.constant;
                    if (!expr.constant) {
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    }
                });
                ast.constant = allConstants;
                ast.toWatch = argsToWatch;
                break;
            case AST.ObjectExpression:
                allConstants = true;
                argsToWatch = [];
                forEach(ast.properties, function (property) {
                    findConstantAndWatchExpressions(property.value, $filter);
                    allConstants = allConstants && property.value.constant;
                    if (!property.value.constant) {
                        argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                    }
                });
                ast.constant = allConstants;
                ast.toWatch = argsToWatch;
                break;
            case AST.ThisExpression:
                ast.constant = false;
                ast.toWatch = [];
                break;
            }
        }
        function getInputs(body) {
            if (body.length != 1)
                return;
            var lastExpression = body[0].expression;
            var candidate = lastExpression.toWatch;
            if (candidate.length !== 1)
                return candidate;
            return candidate[0] !== lastExpression ? candidate : undefined;
        }
        function isAssignable(ast) {
            return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
        }
        function assignableAST(ast) {
            if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
                return {
                    type: AST.AssignmentExpression,
                    left: ast.body[0].expression,
                    right: { type: AST.NGValueParameter },
                    operator: '='
                };
            }
        }
        function isLiteral(ast) {
            return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
        }
        function isConstant(ast) {
            return ast.constant;
        }
        function ASTCompiler(astBuilder, $filter) {
            this.astBuilder = astBuilder;
            this.$filter = $filter;
        }
        ASTCompiler.prototype = {
            compile: function (expression, expensiveChecks) {
                var self = this;
                var ast = this.astBuilder.ast(expression);
                this.state = {
                    nextId: 0,
                    filters: {},
                    expensiveChecks: expensiveChecks,
                    fn: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    assign: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    inputs: []
                };
                findConstantAndWatchExpressions(ast, self.$filter);
                var extra = '';
                var assignable;
                this.stage = 'assign';
                if (assignable = assignableAST(ast)) {
                    this.state.computing = 'assign';
                    var result = this.nextId();
                    this.recurse(assignable, result);
                    this.return_(result);
                    extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
                }
                var toWatch = getInputs(ast.body);
                self.stage = 'inputs';
                forEach(toWatch, function (watch, key) {
                    var fnKey = 'fn' + key;
                    self.state[fnKey] = {
                        vars: [],
                        body: [],
                        own: {}
                    };
                    self.state.computing = fnKey;
                    var intoId = self.nextId();
                    self.recurse(watch, intoId);
                    self.return_(intoId);
                    self.state.inputs.push(fnKey);
                    watch.watchId = key;
                });
                this.state.computing = 'fn';
                this.stage = 'main';
                this.recurse(ast);
                var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
                var fn = new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
                this.state = this.stage = undefined;
                fn.literal = isLiteral(ast);
                fn.constant = isConstant(ast);
                return fn;
            },
            USE: 'use',
            STRICT: 'strict',
            watchFns: function () {
                var result = [];
                var fns = this.state.inputs;
                var self = this;
                forEach(fns, function (name) {
                    result.push('var ' + name + '=' + self.generateFunction(name, 's'));
                });
                if (fns.length) {
                    result.push('fn.inputs=[' + fns.join(',') + '];');
                }
                return result.join('');
            },
            generateFunction: function (name, params) {
                return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
            },
            filterPrefix: function () {
                var parts = [];
                var self = this;
                forEach(this.state.filters, function (id, filter) {
                    parts.push(id + '=$filter(' + self.escape(filter) + ')');
                });
                if (parts.length)
                    return 'var ' + parts.join(',') + ';';
                return '';
            },
            varsPrefix: function (section) {
                return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
            },
            body: function (section) {
                return this.state[section].body.join('');
            },
            recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var left, right, self = this, args, expression;
                recursionFn = recursionFn || noop;
                if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                    intoId = intoId || this.nextId();
                    this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                    return;
                }
                switch (ast.type) {
                case AST.Program:
                    forEach(ast.body, function (expression, pos) {
                        self.recurse(expression.expression, undefined, undefined, function (expr) {
                            right = expr;
                        });
                        if (pos !== ast.body.length - 1) {
                            self.current().body.push(right, ';');
                        } else {
                            self.return_(right);
                        }
                    });
                    break;
                case AST.Literal:
                    expression = this.escape(ast.value);
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.UnaryExpression:
                    this.recurse(ast.argument, undefined, undefined, function (expr) {
                        right = expr;
                    });
                    expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.BinaryExpression:
                    this.recurse(ast.left, undefined, undefined, function (expr) {
                        left = expr;
                    });
                    this.recurse(ast.right, undefined, undefined, function (expr) {
                        right = expr;
                    });
                    if (ast.operator === '+') {
                        expression = this.plus(left, right);
                    } else if (ast.operator === '-') {
                        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                    } else {
                        expression = '(' + left + ')' + ast.operator + '(' + right + ')';
                    }
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.LogicalExpression:
                    intoId = intoId || this.nextId();
                    self.recurse(ast.left, intoId);
                    self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                    recursionFn(intoId);
                    break;
                case AST.ConditionalExpression:
                    intoId = intoId || this.nextId();
                    self.recurse(ast.test, intoId);
                    self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                    recursionFn(intoId);
                    break;
                case AST.Identifier:
                    intoId = intoId || this.nextId();
                    if (nameId) {
                        nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                        nameId.computed = false;
                        nameId.name = ast.name;
                    }
                    ensureSafeMemberName(ast.name);
                    self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {
                        self.if_(self.stage === 'inputs' || 's', function () {
                            if (create && create !== 1) {
                                self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                            }
                            self.assign(intoId, self.nonComputedMember('s', ast.name));
                        });
                    }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                        self.addEnsureSafeObject(intoId);
                    }
                    recursionFn(intoId);
                    break;
                case AST.MemberExpression:
                    left = nameId && (nameId.context = this.nextId()) || this.nextId();
                    intoId = intoId || this.nextId();
                    self.recurse(ast.object, left, undefined, function () {
                        self.if_(self.notNull(left), function () {
                            if (ast.computed) {
                                right = self.nextId();
                                self.recurse(ast.property, right);
                                self.getStringValue(right);
                                self.addEnsureSafeMemberName(right);
                                if (create && create !== 1) {
                                    self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                                }
                                expression = self.ensureSafeObject(self.computedMember(left, right));
                                self.assign(intoId, expression);
                                if (nameId) {
                                    nameId.computed = true;
                                    nameId.name = right;
                                }
                            } else {
                                ensureSafeMemberName(ast.property.name);
                                if (create && create !== 1) {
                                    self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                                }
                                expression = self.nonComputedMember(left, ast.property.name);
                                if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                                    expression = self.ensureSafeObject(expression);
                                }
                                self.assign(intoId, expression);
                                if (nameId) {
                                    nameId.computed = false;
                                    nameId.name = ast.property.name;
                                }
                            }
                        }, function () {
                            self.assign(intoId, 'undefined');
                        });
                        recursionFn(intoId);
                    }, !!create);
                    break;
                case AST.CallExpression:
                    intoId = intoId || this.nextId();
                    if (ast.filter) {
                        right = self.filter(ast.callee.name);
                        args = [];
                        forEach(ast.arguments, function (expr) {
                            var argument = self.nextId();
                            self.recurse(expr, argument);
                            args.push(argument);
                        });
                        expression = right + '(' + args.join(',') + ')';
                        self.assign(intoId, expression);
                        recursionFn(intoId);
                    } else {
                        right = self.nextId();
                        left = {};
                        args = [];
                        self.recurse(ast.callee, right, left, function () {
                            self.if_(self.notNull(right), function () {
                                self.addEnsureSafeFunction(right);
                                forEach(ast.arguments, function (expr) {
                                    self.recurse(expr, self.nextId(), undefined, function (argument) {
                                        args.push(self.ensureSafeObject(argument));
                                    });
                                });
                                if (left.name) {
                                    if (!self.state.expensiveChecks) {
                                        self.addEnsureSafeObject(left.context);
                                    }
                                    expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                                } else {
                                    expression = right + '(' + args.join(',') + ')';
                                }
                                expression = self.ensureSafeObject(expression);
                                self.assign(intoId, expression);
                            }, function () {
                                self.assign(intoId, 'undefined');
                            });
                            recursionFn(intoId);
                        });
                    }
                    break;
                case AST.AssignmentExpression:
                    right = this.nextId();
                    left = {};
                    if (!isAssignable(ast.left)) {
                        throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
                    }
                    this.recurse(ast.left, undefined, left, function () {
                        self.if_(self.notNull(left.context), function () {
                            self.recurse(ast.right, right);
                            self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                            self.addEnsureSafeAssignContext(left.context);
                            expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                            self.assign(intoId, expression);
                            recursionFn(intoId || expression);
                        });
                    }, 1);
                    break;
                case AST.ArrayExpression:
                    args = [];
                    forEach(ast.elements, function (expr) {
                        self.recurse(expr, self.nextId(), undefined, function (argument) {
                            args.push(argument);
                        });
                    });
                    expression = '[' + args.join(',') + ']';
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.ObjectExpression:
                    args = [];
                    forEach(ast.properties, function (property) {
                        self.recurse(property.value, self.nextId(), undefined, function (expr) {
                            args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : '' + property.key.value) + ':' + expr);
                        });
                    });
                    expression = '{' + args.join(',') + '}';
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.ThisExpression:
                    this.assign(intoId, 's');
                    recursionFn('s');
                    break;
                case AST.NGValueParameter:
                    this.assign(intoId, 'v');
                    recursionFn('v');
                    break;
                }
            },
            getHasOwnProperty: function (element, property) {
                var key = element + '.' + property;
                var own = this.current().own;
                if (!own.hasOwnProperty(key)) {
                    own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
                }
                return own[key];
            },
            assign: function (id, value) {
                if (!id)
                    return;
                this.current().body.push(id, '=', value, ';');
                return id;
            },
            filter: function (filterName) {
                if (!this.state.filters.hasOwnProperty(filterName)) {
                    this.state.filters[filterName] = this.nextId(true);
                }
                return this.state.filters[filterName];
            },
            ifDefined: function (id, defaultValue) {
                return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
            },
            plus: function (left, right) {
                return 'plus(' + left + ',' + right + ')';
            },
            return_: function (id) {
                this.current().body.push('return ', id, ';');
            },
            if_: function (test, alternate, consequent) {
                if (test === true) {
                    alternate();
                } else {
                    var body = this.current().body;
                    body.push('if(', test, '){');
                    alternate();
                    body.push('}');
                    if (consequent) {
                        body.push('else{');
                        consequent();
                        body.push('}');
                    }
                }
            },
            not: function (expression) {
                return '!(' + expression + ')';
            },
            notNull: function (expression) {
                return expression + '!=null';
            },
            nonComputedMember: function (left, right) {
                return left + '.' + right;
            },
            computedMember: function (left, right) {
                return left + '[' + right + ']';
            },
            member: function (left, right, computed) {
                if (computed)
                    return this.computedMember(left, right);
                return this.nonComputedMember(left, right);
            },
            addEnsureSafeObject: function (item) {
                this.current().body.push(this.ensureSafeObject(item), ';');
            },
            addEnsureSafeMemberName: function (item) {
                this.current().body.push(this.ensureSafeMemberName(item), ';');
            },
            addEnsureSafeFunction: function (item) {
                this.current().body.push(this.ensureSafeFunction(item), ';');
            },
            addEnsureSafeAssignContext: function (item) {
                this.current().body.push(this.ensureSafeAssignContext(item), ';');
            },
            ensureSafeObject: function (item) {
                return 'ensureSafeObject(' + item + ',text)';
            },
            ensureSafeMemberName: function (item) {
                return 'ensureSafeMemberName(' + item + ',text)';
            },
            ensureSafeFunction: function (item) {
                return 'ensureSafeFunction(' + item + ',text)';
            },
            getStringValue: function (item) {
                this.assign(item, 'getStringValue(' + item + ',text)');
            },
            ensureSafeAssignContext: function (item) {
                return 'ensureSafeAssignContext(' + item + ',text)';
            },
            lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var self = this;
                return function () {
                    self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
                };
            },
            lazyAssign: function (id, value) {
                var self = this;
                return function () {
                    self.assign(id, value);
                };
            },
            stringEscapeRegex: /[^ a-zA-Z0-9]/g,
            stringEscapeFn: function (c) {
                return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
            },
            escape: function (value) {
                if (isString(value))
                    return '\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\'';
                if (isNumber(value))
                    return value.toString();
                if (value === true)
                    return 'true';
                if (value === false)
                    return 'false';
                if (value === null)
                    return 'null';
                if (typeof value === 'undefined')
                    return 'undefined';
                throw $parseMinErr('esc', 'IMPOSSIBLE');
            },
            nextId: function (skip, init) {
                var id = 'v' + this.state.nextId++;
                if (!skip) {
                    this.current().vars.push(id + (init ? '=' + init : ''));
                }
                return id;
            },
            current: function () {
                return this.state[this.state.computing];
            }
        };
        function ASTInterpreter(astBuilder, $filter) {
            this.astBuilder = astBuilder;
            this.$filter = $filter;
        }
        ASTInterpreter.prototype = {
            compile: function (expression, expensiveChecks) {
                var self = this;
                var ast = this.astBuilder.ast(expression);
                this.expression = expression;
                this.expensiveChecks = expensiveChecks;
                findConstantAndWatchExpressions(ast, self.$filter);
                var assignable;
                var assign;
                if (assignable = assignableAST(ast)) {
                    assign = this.recurse(assignable);
                }
                var toWatch = getInputs(ast.body);
                var inputs;
                if (toWatch) {
                    inputs = [];
                    forEach(toWatch, function (watch, key) {
                        var input = self.recurse(watch);
                        watch.input = input;
                        inputs.push(input);
                        watch.watchId = key;
                    });
                }
                var expressions = [];
                forEach(ast.body, function (expression) {
                    expressions.push(self.recurse(expression.expression));
                });
                var fn = ast.body.length === 0 ? function () {
                } : ast.body.length === 1 ? expressions[0] : function (scope, locals) {
                    var lastValue;
                    forEach(expressions, function (exp) {
                        lastValue = exp(scope, locals);
                    });
                    return lastValue;
                };
                if (assign) {
                    fn.assign = function (scope, value, locals) {
                        return assign(scope, locals, value);
                    };
                }
                if (inputs) {
                    fn.inputs = inputs;
                }
                fn.literal = isLiteral(ast);
                fn.constant = isConstant(ast);
                return fn;
            },
            recurse: function (ast, context, create) {
                var left, right, self = this, args, expression;
                if (ast.input) {
                    return this.inputs(ast.input, ast.watchId);
                }
                switch (ast.type) {
                case AST.Literal:
                    return this.value(ast.value, context);
                case AST.UnaryExpression:
                    right = this.recurse(ast.argument);
                    return this['unary' + ast.operator](right, context);
                case AST.BinaryExpression:
                    left = this.recurse(ast.left);
                    right = this.recurse(ast.right);
                    return this['binary' + ast.operator](left, right, context);
                case AST.LogicalExpression:
                    left = this.recurse(ast.left);
                    right = this.recurse(ast.right);
                    return this['binary' + ast.operator](left, right, context);
                case AST.ConditionalExpression:
                    return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
                case AST.Identifier:
                    ensureSafeMemberName(ast.name, self.expression);
                    return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
                case AST.MemberExpression:
                    left = this.recurse(ast.object, false, !!create);
                    if (!ast.computed) {
                        ensureSafeMemberName(ast.property.name, self.expression);
                        right = ast.property.name;
                    }
                    if (ast.computed)
                        right = this.recurse(ast.property);
                    return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
                case AST.CallExpression:
                    args = [];
                    forEach(ast.arguments, function (expr) {
                        args.push(self.recurse(expr));
                    });
                    if (ast.filter)
                        right = this.$filter(ast.callee.name);
                    if (!ast.filter)
                        right = this.recurse(ast.callee, true);
                    return ast.filter ? function (scope, locals, assign, inputs) {
                        var values = [];
                        for (var i = 0; i < args.length; ++i) {
                            values.push(args[i](scope, locals, assign, inputs));
                        }
                        var value = right.apply(undefined, values, inputs);
                        return context ? {
                            context: undefined,
                            name: undefined,
                            value: value
                        } : value;
                    } : function (scope, locals, assign, inputs) {
                        var rhs = right(scope, locals, assign, inputs);
                        var value;
                        if (rhs.value != null) {
                            ensureSafeObject(rhs.context, self.expression);
                            ensureSafeFunction(rhs.value, self.expression);
                            var values = [];
                            for (var i = 0; i < args.length; ++i) {
                                values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                            }
                            value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                        }
                        return context ? { value: value } : value;
                    };
                case AST.AssignmentExpression:
                    left = this.recurse(ast.left, true, 1);
                    right = this.recurse(ast.right);
                    return function (scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs = right(scope, locals, assign, inputs);
                        ensureSafeObject(lhs.value, self.expression);
                        ensureSafeAssignContext(lhs.context);
                        lhs.context[lhs.name] = rhs;
                        return context ? { value: rhs } : rhs;
                    };
                case AST.ArrayExpression:
                    args = [];
                    forEach(ast.elements, function (expr) {
                        args.push(self.recurse(expr));
                    });
                    return function (scope, locals, assign, inputs) {
                        var value = [];
                        for (var i = 0; i < args.length; ++i) {
                            value.push(args[i](scope, locals, assign, inputs));
                        }
                        return context ? { value: value } : value;
                    };
                case AST.ObjectExpression:
                    args = [];
                    forEach(ast.properties, function (property) {
                        args.push({
                            key: property.key.type === AST.Identifier ? property.key.name : '' + property.key.value,
                            value: self.recurse(property.value)
                        });
                    });
                    return function (scope, locals, assign, inputs) {
                        var value = {};
                        for (var i = 0; i < args.length; ++i) {
                            value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                        }
                        return context ? { value: value } : value;
                    };
                case AST.ThisExpression:
                    return function (scope) {
                        return context ? { value: scope } : scope;
                    };
                case AST.NGValueParameter:
                    return function (scope, locals, assign, inputs) {
                        return context ? { value: assign } : assign;
                    };
                }
            },
            'unary+': function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    if (isDefined(arg)) {
                        arg = +arg;
                    } else {
                        arg = 0;
                    }
                    return context ? { value: arg } : arg;
                };
            },
            'unary-': function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    if (isDefined(arg)) {
                        arg = -arg;
                    } else {
                        arg = 0;
                    }
                    return context ? { value: arg } : arg;
                };
            },
            'unary!': function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = !argument(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary+': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    var arg = plusFn(lhs, rhs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary-': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                    return context ? { value: arg } : arg;
                };
            },
            'binary*': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary/': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary%': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary===': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary!==': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary==': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary!=': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary<': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary>': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary<=': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary>=': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary&&': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary||': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'ternary?:': function (test, alternate, consequent, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            value: function (value, context) {
                return function () {
                    return context ? {
                        context: undefined,
                        name: undefined,
                        value: value
                    } : value;
                };
            },
            identifier: function (name, expensiveChecks, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var base = locals && name in locals ? locals : scope;
                    if (create && create !== 1 && base && !base[name]) {
                        base[name] = {};
                    }
                    var value = base ? base[name] : undefined;
                    if (expensiveChecks) {
                        ensureSafeObject(value, expression);
                    }
                    if (context) {
                        return {
                            context: base,
                            name: name,
                            value: value
                        };
                    } else {
                        return value;
                    }
                };
            },
            computedMember: function (left, right, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs;
                    var value;
                    if (lhs != null) {
                        rhs = right(scope, locals, assign, inputs);
                        rhs = getStringValue(rhs);
                        ensureSafeMemberName(rhs, expression);
                        if (create && create !== 1 && lhs && !lhs[rhs]) {
                            lhs[rhs] = {};
                        }
                        value = lhs[rhs];
                        ensureSafeObject(value, expression);
                    }
                    if (context) {
                        return {
                            context: lhs,
                            name: rhs,
                            value: value
                        };
                    } else {
                        return value;
                    }
                };
            },
            nonComputedMember: function (left, right, expensiveChecks, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    if (create && create !== 1 && lhs && !lhs[right]) {
                        lhs[right] = {};
                    }
                    var value = lhs != null ? lhs[right] : undefined;
                    if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
                        ensureSafeObject(value, expression);
                    }
                    if (context) {
                        return {
                            context: lhs,
                            name: right,
                            value: value
                        };
                    } else {
                        return value;
                    }
                };
            },
            inputs: function (input, watchId) {
                return function (scope, value, locals, inputs) {
                    if (inputs)
                        return inputs[watchId];
                    return input(scope, value, locals);
                };
            }
        };
        var Parser = function (lexer, $filter, options) {
            this.lexer = lexer;
            this.$filter = $filter;
            this.options = options;
            this.ast = new AST(this.lexer);
            this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
        };
        Parser.prototype = {
            constructor: Parser,
            parse: function (text) {
                return this.astCompiler.compile(text, this.options.expensiveChecks);
            }
        };
        var getterFnCacheDefault = createMap();
        var getterFnCacheExpensive = createMap();
        function isPossiblyDangerousMemberName(name) {
            return name == 'constructor';
        }
        var objectValueOf = Object.prototype.valueOf;
        function getValueOf(value) {
            return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
        }
        function $ParseProvider() {
            var cacheDefault = createMap();
            var cacheExpensive = createMap();
            this.$get = [
                '$filter',
                function ($filter) {
                    var noUnsafeEval = csp().noUnsafeEval;
                    var $parseOptions = {
                            csp: noUnsafeEval,
                            expensiveChecks: false
                        }, $parseOptionsExpensive = {
                            csp: noUnsafeEval,
                            expensiveChecks: true
                        };
                    return function $parse(exp, interceptorFn, expensiveChecks) {
                        var parsedExpression, oneTime, cacheKey;
                        switch (typeof exp) {
                        case 'string':
                            exp = exp.trim();
                            cacheKey = exp;
                            var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                            parsedExpression = cache[cacheKey];
                            if (!parsedExpression) {
                                if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                                    oneTime = true;
                                    exp = exp.substring(2);
                                }
                                var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                                var lexer = new Lexer(parseOptions);
                                var parser = new Parser(lexer, $filter, parseOptions);
                                parsedExpression = parser.parse(exp);
                                if (parsedExpression.constant) {
                                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                                } else if (oneTime) {
                                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                                } else if (parsedExpression.inputs) {
                                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                                }
                                cache[cacheKey] = parsedExpression;
                            }
                            return addInterceptor(parsedExpression, interceptorFn);
                        case 'function':
                            return addInterceptor(exp, interceptorFn);
                        default:
                            return noop;
                        }
                    };
                    function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                        if (newValue == null || oldValueOfValue == null) {
                            return newValue === oldValueOfValue;
                        }
                        if (typeof newValue === 'object') {
                            newValue = getValueOf(newValue);
                            if (typeof newValue === 'object') {
                                return false;
                            }
                        }
                        return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
                    }
                    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var inputExpressions = parsedExpression.inputs;
                        var lastResult;
                        if (inputExpressions.length === 1) {
                            var oldInputValueOf = expressionInputDirtyCheck;
                            inputExpressions = inputExpressions[0];
                            return scope.$watch(function expressionInputWatch(scope) {
                                var newInputValue = inputExpressions(scope);
                                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                                    lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                                    oldInputValueOf = newInputValue && getValueOf(newInputValue);
                                }
                                return lastResult;
                            }, listener, objectEquality, prettyPrintExpression);
                        }
                        var oldInputValueOfValues = [];
                        var oldInputValues = [];
                        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                            oldInputValueOfValues[i] = expressionInputDirtyCheck;
                            oldInputValues[i] = null;
                        }
                        return scope.$watch(function expressionInputsWatch(scope) {
                            var changed = false;
                            for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                                var newInputValue = inputExpressions[i](scope);
                                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                                    oldInputValues[i] = newInputValue;
                                    oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                                }
                            }
                            if (changed) {
                                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                            }
                            return lastResult;
                        }, listener, objectEquality, prettyPrintExpression);
                    }
                    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch, lastValue;
                        return unwatch = scope.$watch(function oneTimeWatch(scope) {
                            return parsedExpression(scope);
                        }, function oneTimeListener(value, old, scope) {
                            lastValue = value;
                            if (isFunction(listener)) {
                                listener.apply(this, arguments);
                            }
                            if (isDefined(value)) {
                                scope.$$postDigest(function () {
                                    if (isDefined(lastValue)) {
                                        unwatch();
                                    }
                                });
                            }
                        }, objectEquality);
                    }
                    function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch, lastValue;
                        return unwatch = scope.$watch(function oneTimeWatch(scope) {
                            return parsedExpression(scope);
                        }, function oneTimeListener(value, old, scope) {
                            lastValue = value;
                            if (isFunction(listener)) {
                                listener.call(this, value, old, scope);
                            }
                            if (isAllDefined(value)) {
                                scope.$$postDigest(function () {
                                    if (isAllDefined(lastValue))
                                        unwatch();
                                });
                            }
                        }, objectEquality);
                        function isAllDefined(value) {
                            var allDefined = true;
                            forEach(value, function (val) {
                                if (!isDefined(val))
                                    allDefined = false;
                            });
                            return allDefined;
                        }
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch;
                        return unwatch = scope.$watch(function constantWatch(scope) {
                            return parsedExpression(scope);
                        }, function constantListener(value, old, scope) {
                            if (isFunction(listener)) {
                                listener.apply(this, arguments);
                            }
                            unwatch();
                        }, objectEquality);
                    }
                    function addInterceptor(parsedExpression, interceptorFn) {
                        if (!interceptorFn)
                            return parsedExpression;
                        var watchDelegate = parsedExpression.$$watchDelegate;
                        var useInputs = false;
                        var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                        var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value, scope, locals);
                        } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                            var value = parsedExpression(scope, locals, assign, inputs);
                            var result = interceptorFn(value, scope, locals);
                            return isDefined(value) ? result : value;
                        };
                        if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                            fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                        } else if (!interceptorFn.$stateful) {
                            fn.$$watchDelegate = inputsWatchDelegate;
                            useInputs = !parsedExpression.inputs;
                            fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
                        }
                        return fn;
                    }
                }
            ];
        }
        function $QProvider() {
            this.$get = [
                '$rootScope',
                '$exceptionHandler',
                function ($rootScope, $exceptionHandler) {
                    return qFactory(function (callback) {
                        $rootScope.$evalAsync(callback);
                    }, $exceptionHandler);
                }
            ];
        }
        function $$QProvider() {
            this.$get = [
                '$browser',
                '$exceptionHandler',
                function ($browser, $exceptionHandler) {
                    return qFactory(function (callback) {
                        $browser.defer(callback);
                    }, $exceptionHandler);
                }
            ];
        }
        function qFactory(nextTick, exceptionHandler) {
            var $qMinErr = minErr('$q', TypeError);
            function callOnce(self, resolveFn, rejectFn) {
                var called = false;
                function wrap(fn) {
                    return function (value) {
                        if (called)
                            return;
                        called = true;
                        fn.call(self, value);
                    };
                }
                return [
                    wrap(resolveFn),
                    wrap(rejectFn)
                ];
            }
            var defer = function () {
                return new Deferred();
            };
            function Promise() {
                this.$$state = { status: 0 };
            }
            extend(Promise.prototype, {
                then: function (onFulfilled, onRejected, progressBack) {
                    if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                        return this;
                    }
                    var result = new Deferred();
                    this.$$state.pending = this.$$state.pending || [];
                    this.$$state.pending.push([
                        result,
                        onFulfilled,
                        onRejected,
                        progressBack
                    ]);
                    if (this.$$state.status > 0)
                        scheduleProcessQueue(this.$$state);
                    return result.promise;
                },
                'catch': function (callback) {
                    return this.then(null, callback);
                },
                'finally': function (callback, progressBack) {
                    return this.then(function (value) {
                        return handleCallback(value, true, callback);
                    }, function (error) {
                        return handleCallback(error, false, callback);
                    }, progressBack);
                }
            });
            function simpleBind(context, fn) {
                return function (value) {
                    fn.call(context, value);
                };
            }
            function processQueue(state) {
                var fn, deferred, pending;
                pending = state.pending;
                state.processScheduled = false;
                state.pending = undefined;
                for (var i = 0, ii = pending.length; i < ii; ++i) {
                    deferred = pending[i][0];
                    fn = pending[i][state.status];
                    try {
                        if (isFunction(fn)) {
                            deferred.resolve(fn(state.value));
                        } else if (state.status === 1) {
                            deferred.resolve(state.value);
                        } else {
                            deferred.reject(state.value);
                        }
                    } catch (e) {
                        deferred.reject(e);
                        exceptionHandler(e);
                    }
                }
            }
            function scheduleProcessQueue(state) {
                if (state.processScheduled || !state.pending)
                    return;
                state.processScheduled = true;
                nextTick(function () {
                    processQueue(state);
                });
            }
            function Deferred() {
                this.promise = new Promise();
                this.resolve = simpleBind(this, this.resolve);
                this.reject = simpleBind(this, this.reject);
                this.notify = simpleBind(this, this.notify);
            }
            extend(Deferred.prototype, {
                resolve: function (val) {
                    if (this.promise.$$state.status)
                        return;
                    if (val === this.promise) {
                        this.$$reject($qMinErr('qcycle', 'Expected promise to be resolved with value other than itself \'{0}\'', val));
                    } else {
                        this.$$resolve(val);
                    }
                },
                $$resolve: function (val) {
                    var then, fns;
                    fns = callOnce(this, this.$$resolve, this.$$reject);
                    try {
                        if (isObject(val) || isFunction(val))
                            then = val && val.then;
                        if (isFunction(then)) {
                            this.promise.$$state.status = -1;
                            then.call(val, fns[0], fns[1], this.notify);
                        } else {
                            this.promise.$$state.value = val;
                            this.promise.$$state.status = 1;
                            scheduleProcessQueue(this.promise.$$state);
                        }
                    } catch (e) {
                        fns[1](e);
                        exceptionHandler(e);
                    }
                },
                reject: function (reason) {
                    if (this.promise.$$state.status)
                        return;
                    this.$$reject(reason);
                },
                $$reject: function (reason) {
                    this.promise.$$state.value = reason;
                    this.promise.$$state.status = 2;
                    scheduleProcessQueue(this.promise.$$state);
                },
                notify: function (progress) {
                    var callbacks = this.promise.$$state.pending;
                    if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                        nextTick(function () {
                            var callback, result;
                            for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                result = callbacks[i][0];
                                callback = callbacks[i][3];
                                try {
                                    result.notify(isFunction(callback) ? callback(progress) : progress);
                                } catch (e) {
                                    exceptionHandler(e);
                                }
                            }
                        });
                    }
                }
            });
            var reject = function (reason) {
                var result = new Deferred();
                result.reject(reason);
                return result.promise;
            };
            var makePromise = function makePromise(value, resolved) {
                var result = new Deferred();
                if (resolved) {
                    result.resolve(value);
                } else {
                    result.reject(value);
                }
                return result.promise;
            };
            var handleCallback = function handleCallback(value, isResolved, callback) {
                var callbackOutput = null;
                try {
                    if (isFunction(callback))
                        callbackOutput = callback();
                } catch (e) {
                    return makePromise(e, false);
                }
                if (isPromiseLike(callbackOutput)) {
                    return callbackOutput.then(function () {
                        return makePromise(value, isResolved);
                    }, function (error) {
                        return makePromise(error, false);
                    });
                } else {
                    return makePromise(value, isResolved);
                }
            };
            var when = function (value, callback, errback, progressBack) {
                var result = new Deferred();
                result.resolve(value);
                return result.promise.then(callback, errback, progressBack);
            };
            var resolve = when;
            function all(promises) {
                var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
                forEach(promises, function (promise, key) {
                    counter++;
                    when(promise).then(function (value) {
                        if (results.hasOwnProperty(key))
                            return;
                        results[key] = value;
                        if (!--counter)
                            deferred.resolve(results);
                    }, function (reason) {
                        if (results.hasOwnProperty(key))
                            return;
                        deferred.reject(reason);
                    });
                });
                if (counter === 0) {
                    deferred.resolve(results);
                }
                return deferred.promise;
            }
            var $Q = function Q(resolver) {
                if (!isFunction(resolver)) {
                    throw $qMinErr('norslvr', 'Expected resolverFn, got \'{0}\'', resolver);
                }
                if (!(this instanceof Q)) {
                    return new Q(resolver);
                }
                var deferred = new Deferred();
                function resolveFn(value) {
                    deferred.resolve(value);
                }
                function rejectFn(reason) {
                    deferred.reject(reason);
                }
                resolver(resolveFn, rejectFn);
                return deferred.promise;
            };
            $Q.defer = defer;
            $Q.reject = reject;
            $Q.when = when;
            $Q.resolve = resolve;
            $Q.all = all;
            return $Q;
        }
        function $$RAFProvider() {
            this.$get = [
                '$window',
                '$timeout',
                function ($window, $timeout) {
                    var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
                    var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
                    var rafSupported = !!requestAnimationFrame;
                    var raf = rafSupported ? function (fn) {
                        var id = requestAnimationFrame(fn);
                        return function () {
                            cancelAnimationFrame(id);
                        };
                    } : function (fn) {
                        var timer = $timeout(fn, 16.66, false);
                        return function () {
                            $timeout.cancel(timer);
                        };
                    };
                    raf.supported = rafSupported;
                    return raf;
                }
            ];
        }
        function $RootScopeProvider() {
            var TTL = 10;
            var $rootScopeMinErr = minErr('$rootScope');
            var lastDirtyWatch = null;
            var applyAsyncId = null;
            this.digestTtl = function (value) {
                if (arguments.length) {
                    TTL = value;
                }
                return TTL;
            };
            function createChildScopeClass(parent) {
                function ChildScope() {
                    this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                    this.$$listeners = {};
                    this.$$listenerCount = {};
                    this.$$watchersCount = 0;
                    this.$id = nextUid();
                    this.$$ChildScope = null;
                }
                ChildScope.prototype = parent;
                return ChildScope;
            }
            this.$get = [
                '$injector',
                '$exceptionHandler',
                '$parse',
                '$browser',
                function ($injector, $exceptionHandler, $parse, $browser) {
                    function destroyChildScope($event) {
                        $event.currentScope.$$destroyed = true;
                    }
                    function cleanUpScope($scope) {
                        if (msie === 9) {
                            $scope.$$childHead && cleanUpScope($scope.$$childHead);
                            $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
                        }
                        $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                    }
                    function Scope() {
                        this.$id = nextUid();
                        this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                        this.$root = this;
                        this.$$destroyed = false;
                        this.$$listeners = {};
                        this.$$listenerCount = {};
                        this.$$watchersCount = 0;
                        this.$$isolateBindings = null;
                    }
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function (isolate, parent) {
                            var child;
                            parent = parent || this;
                            if (isolate) {
                                child = new Scope();
                                child.$root = this.$root;
                            } else {
                                if (!this.$$ChildScope) {
                                    this.$$ChildScope = createChildScopeClass(this);
                                }
                                child = new this.$$ChildScope();
                            }
                            child.$parent = parent;
                            child.$$prevSibling = parent.$$childTail;
                            if (parent.$$childHead) {
                                parent.$$childTail.$$nextSibling = child;
                                parent.$$childTail = child;
                            } else {
                                parent.$$childHead = parent.$$childTail = child;
                            }
                            if (isolate || parent != this)
                                child.$on('$destroy', destroyChildScope);
                            return child;
                        },
                        $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {
                            var get = $parse(watchExp);
                            if (get.$$watchDelegate) {
                                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                            }
                            var scope = this, array = scope.$$watchers, watcher = {
                                    fn: listener,
                                    last: initWatchVal,
                                    get: get,
                                    exp: prettyPrintExpression || watchExp,
                                    eq: !!objectEquality
                                };
                            lastDirtyWatch = null;
                            if (!isFunction(listener)) {
                                watcher.fn = noop;
                            }
                            if (!array) {
                                array = scope.$$watchers = [];
                            }
                            array.unshift(watcher);
                            incrementWatchersCount(this, 1);
                            return function deregisterWatch() {
                                if (arrayRemove(array, watcher) >= 0) {
                                    incrementWatchersCount(scope, -1);
                                }
                                lastDirtyWatch = null;
                            };
                        },
                        $watchGroup: function (watchExpressions, listener) {
                            var oldValues = new Array(watchExpressions.length);
                            var newValues = new Array(watchExpressions.length);
                            var deregisterFns = [];
                            var self = this;
                            var changeReactionScheduled = false;
                            var firstRun = true;
                            if (!watchExpressions.length) {
                                var shouldCall = true;
                                self.$evalAsync(function () {
                                    if (shouldCall)
                                        listener(newValues, newValues, self);
                                });
                                return function deregisterWatchGroup() {
                                    shouldCall = false;
                                };
                            }
                            if (watchExpressions.length === 1) {
                                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                                    newValues[0] = value;
                                    oldValues[0] = oldValue;
                                    listener(newValues, value === oldValue ? newValues : oldValues, scope);
                                });
                            }
                            forEach(watchExpressions, function (expr, i) {
                                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                                    newValues[i] = value;
                                    oldValues[i] = oldValue;
                                    if (!changeReactionScheduled) {
                                        changeReactionScheduled = true;
                                        self.$evalAsync(watchGroupAction);
                                    }
                                });
                                deregisterFns.push(unwatchFn);
                            });
                            function watchGroupAction() {
                                changeReactionScheduled = false;
                                if (firstRun) {
                                    firstRun = false;
                                    listener(newValues, newValues, self);
                                } else {
                                    listener(newValues, oldValues, self);
                                }
                            }
                            return function deregisterWatchGroup() {
                                while (deregisterFns.length) {
                                    deregisterFns.shift()();
                                }
                            };
                        },
                        $watchCollection: function (obj, listener) {
                            $watchCollectionInterceptor.$stateful = true;
                            var self = this;
                            var newValue;
                            var oldValue;
                            var veryOldValue;
                            var trackVeryOldValue = listener.length > 1;
                            var changeDetected = 0;
                            var changeDetector = $parse(obj, $watchCollectionInterceptor);
                            var internalArray = [];
                            var internalObject = {};
                            var initRun = true;
                            var oldLength = 0;
                            function $watchCollectionInterceptor(_value) {
                                newValue = _value;
                                var newLength, key, bothNaN, newItem, oldItem;
                                if (isUndefined(newValue))
                                    return;
                                if (!isObject(newValue)) {
                                    if (oldValue !== newValue) {
                                        oldValue = newValue;
                                        changeDetected++;
                                    }
                                } else if (isArrayLike(newValue)) {
                                    if (oldValue !== internalArray) {
                                        oldValue = internalArray;
                                        oldLength = oldValue.length = 0;
                                        changeDetected++;
                                    }
                                    newLength = newValue.length;
                                    if (oldLength !== newLength) {
                                        changeDetected++;
                                        oldValue.length = oldLength = newLength;
                                    }
                                    for (var i = 0; i < newLength; i++) {
                                        oldItem = oldValue[i];
                                        newItem = newValue[i];
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[i] = newItem;
                                        }
                                    }
                                } else {
                                    if (oldValue !== internalObject) {
                                        oldValue = internalObject = {};
                                        oldLength = 0;
                                        changeDetected++;
                                    }
                                    newLength = 0;
                                    for (key in newValue) {
                                        if (hasOwnProperty.call(newValue, key)) {
                                            newLength++;
                                            newItem = newValue[key];
                                            oldItem = oldValue[key];
                                            if (key in oldValue) {
                                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                                if (!bothNaN && oldItem !== newItem) {
                                                    changeDetected++;
                                                    oldValue[key] = newItem;
                                                }
                                            } else {
                                                oldLength++;
                                                oldValue[key] = newItem;
                                                changeDetected++;
                                            }
                                        }
                                    }
                                    if (oldLength > newLength) {
                                        changeDetected++;
                                        for (key in oldValue) {
                                            if (!hasOwnProperty.call(newValue, key)) {
                                                oldLength--;
                                                delete oldValue[key];
                                            }
                                        }
                                    }
                                }
                                return changeDetected;
                            }
                            function $watchCollectionAction() {
                                if (initRun) {
                                    initRun = false;
                                    listener(newValue, newValue, self);
                                } else {
                                    listener(newValue, veryOldValue, self);
                                }
                                if (trackVeryOldValue) {
                                    if (!isObject(newValue)) {
                                        veryOldValue = newValue;
                                    } else if (isArrayLike(newValue)) {
                                        veryOldValue = new Array(newValue.length);
                                        for (var i = 0; i < newValue.length; i++) {
                                            veryOldValue[i] = newValue[i];
                                        }
                                    } else {
                                        veryOldValue = {};
                                        for (var key in newValue) {
                                            if (hasOwnProperty.call(newValue, key)) {
                                                veryOldValue[key] = newValue[key];
                                            }
                                        }
                                    }
                                }
                            }
                            return this.$watch(changeDetector, $watchCollectionAction);
                        },
                        $digest: function () {
                            var watch, value, last, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
                            beginPhase('$digest');
                            $browser.$$checkUrlChange();
                            if (this === $rootScope && applyAsyncId !== null) {
                                $browser.defer.cancel(applyAsyncId);
                                flushApplyAsync();
                            }
                            lastDirtyWatch = null;
                            do {
                                dirty = false;
                                current = target;
                                while (asyncQueue.length) {
                                    try {
                                        asyncTask = asyncQueue.shift();
                                        asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    lastDirtyWatch = null;
                                }
                                traverseScopesLoop:
                                    do {
                                        if (watchers = current.$$watchers) {
                                            length = watchers.length;
                                            while (length--) {
                                                try {
                                                    watch = watchers[length];
                                                    if (watch) {
                                                        if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last))) {
                                                            dirty = true;
                                                            lastDirtyWatch = watch;
                                                            watch.last = watch.eq ? copy(value, null) : value;
                                                            watch.fn(value, last === initWatchVal ? value : last, current);
                                                            if (ttl < 5) {
                                                                logIdx = 4 - ttl;
                                                                if (!watchLog[logIdx])
                                                                    watchLog[logIdx] = [];
                                                                watchLog[logIdx].push({
                                                                    msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                                    newVal: value,
                                                                    oldVal: last
                                                                });
                                                            }
                                                        } else if (watch === lastDirtyWatch) {
                                                            dirty = false;
                                                            break traverseScopesLoop;
                                                        }
                                                    }
                                                } catch (e) {
                                                    $exceptionHandler(e);
                                                }
                                            }
                                        }
                                        if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                            while (current !== target && !(next = current.$$nextSibling)) {
                                                current = current.$parent;
                                            }
                                        }
                                    } while (current = next);
                                if ((dirty || asyncQueue.length) && !ttl--) {
                                    clearPhase();
                                    throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                                }
                            } while (dirty || asyncQueue.length);
                            clearPhase();
                            while (postDigestQueue.length) {
                                try {
                                    postDigestQueue.shift()();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                        },
                        $destroy: function () {
                            if (this.$$destroyed)
                                return;
                            var parent = this.$parent;
                            this.$broadcast('$destroy');
                            this.$$destroyed = true;
                            if (this === $rootScope) {
                                $browser.$$applicationDestroyed();
                            }
                            incrementWatchersCount(this, -this.$$watchersCount);
                            for (var eventName in this.$$listenerCount) {
                                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            }
                            if (parent && parent.$$childHead == this)
                                parent.$$childHead = this.$$nextSibling;
                            if (parent && parent.$$childTail == this)
                                parent.$$childTail = this.$$prevSibling;
                            if (this.$$prevSibling)
                                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                            if (this.$$nextSibling)
                                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                            this.$on = this.$watch = this.$watchGroup = function () {
                                return noop;
                            };
                            this.$$listeners = {};
                            this.$$nextSibling = null;
                            cleanUpScope(this);
                        },
                        $eval: function (expr, locals) {
                            return $parse(expr)(this, locals);
                        },
                        $evalAsync: function (expr, locals) {
                            if (!$rootScope.$$phase && !asyncQueue.length) {
                                $browser.defer(function () {
                                    if (asyncQueue.length) {
                                        $rootScope.$digest();
                                    }
                                });
                            }
                            asyncQueue.push({
                                scope: this,
                                expression: expr,
                                locals: locals
                            });
                        },
                        $$postDigest: function (fn) {
                            postDigestQueue.push(fn);
                        },
                        $apply: function (expr) {
                            try {
                                beginPhase('$apply');
                                try {
                                    return this.$eval(expr);
                                } finally {
                                    clearPhase();
                                }
                            } catch (e) {
                                $exceptionHandler(e);
                            } finally {
                                try {
                                    $rootScope.$digest();
                                } catch (e) {
                                    $exceptionHandler(e);
                                    throw e;
                                }
                            }
                        },
                        $applyAsync: function (expr) {
                            var scope = this;
                            expr && applyAsyncQueue.push($applyAsyncExpression);
                            scheduleApplyAsync();
                            function $applyAsyncExpression() {
                                scope.$eval(expr);
                            }
                        },
                        $on: function (name, listener) {
                            var namedListeners = this.$$listeners[name];
                            if (!namedListeners) {
                                this.$$listeners[name] = namedListeners = [];
                            }
                            namedListeners.push(listener);
                            var current = this;
                            do {
                                if (!current.$$listenerCount[name]) {
                                    current.$$listenerCount[name] = 0;
                                }
                                current.$$listenerCount[name]++;
                            } while (current = current.$parent);
                            var self = this;
                            return function () {
                                var indexOfListener = namedListeners.indexOf(listener);
                                if (indexOfListener !== -1) {
                                    namedListeners[indexOfListener] = null;
                                    decrementListenerCount(self, 1, name);
                                }
                            };
                        },
                        $emit: function (name, args) {
                            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                                    name: name,
                                    targetScope: scope,
                                    stopPropagation: function () {
                                        stopPropagation = true;
                                    },
                                    preventDefault: function () {
                                        event.defaultPrevented = true;
                                    },
                                    defaultPrevented: false
                                }, listenerArgs = concat([event], arguments, 1), i, length;
                            do {
                                namedListeners = scope.$$listeners[name] || empty;
                                event.currentScope = scope;
                                for (i = 0, length = namedListeners.length; i < length; i++) {
                                    if (!namedListeners[i]) {
                                        namedListeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        namedListeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (stopPropagation) {
                                    event.currentScope = null;
                                    return event;
                                }
                                scope = scope.$parent;
                            } while (scope);
                            event.currentScope = null;
                            return event;
                        },
                        $broadcast: function (name, args) {
                            var target = this, current = target, next = target, event = {
                                    name: name,
                                    targetScope: target,
                                    preventDefault: function () {
                                        event.defaultPrevented = true;
                                    },
                                    defaultPrevented: false
                                };
                            if (!target.$$listenerCount[name])
                                return event;
                            var listenerArgs = concat([event], arguments, 1), listeners, i, length;
                            while (current = next) {
                                event.currentScope = current;
                                listeners = current.$$listeners[name] || [];
                                for (i = 0, length = listeners.length; i < length; i++) {
                                    if (!listeners[i]) {
                                        listeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        listeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                                    while (current !== target && !(next = current.$$nextSibling)) {
                                        current = current.$parent;
                                    }
                                }
                            }
                            event.currentScope = null;
                            return event;
                        }
                    };
                    var $rootScope = new Scope();
                    var asyncQueue = $rootScope.$$asyncQueue = [];
                    var postDigestQueue = $rootScope.$$postDigestQueue = [];
                    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
                    return $rootScope;
                    function beginPhase(phase) {
                        if ($rootScope.$$phase) {
                            throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
                        }
                        $rootScope.$$phase = phase;
                    }
                    function clearPhase() {
                        $rootScope.$$phase = null;
                    }
                    function incrementWatchersCount(current, count) {
                        do {
                            current.$$watchersCount += count;
                        } while (current = current.$parent);
                    }
                    function decrementListenerCount(current, count, name) {
                        do {
                            current.$$listenerCount[name] -= count;
                            if (current.$$listenerCount[name] === 0) {
                                delete current.$$listenerCount[name];
                            }
                        } while (current = current.$parent);
                    }
                    function initWatchVal() {
                    }
                    function flushApplyAsync() {
                        while (applyAsyncQueue.length) {
                            try {
                                applyAsyncQueue.shift()();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        applyAsyncId = null;
                    }
                    function scheduleApplyAsync() {
                        if (applyAsyncId === null) {
                            applyAsyncId = $browser.defer(function () {
                                $rootScope.$apply(flushApplyAsync);
                            });
                        }
                    }
                }
            ];
        }
        function $$SanitizeUriProvider() {
            var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
            this.aHrefSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    aHrefSanitizationWhitelist = regexp;
                    return this;
                }
                return aHrefSanitizationWhitelist;
            };
            this.imgSrcSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    imgSrcSanitizationWhitelist = regexp;
                    return this;
                }
                return imgSrcSanitizationWhitelist;
            };
            this.$get = function () {
                return function sanitizeUri(uri, isImage) {
                    var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                    var normalizedVal;
                    normalizedVal = urlResolve(uri).href;
                    if (normalizedVal !== '' && !normalizedVal.match(regex)) {
                        return 'unsafe:' + normalizedVal;
                    }
                    return uri;
                };
            };
        }
        var $sceMinErr = minErr('$sce');
        var SCE_CONTEXTS = {
            HTML: 'html',
            CSS: 'css',
            URL: 'url',
            RESOURCE_URL: 'resourceUrl',
            JS: 'js'
        };
        function adjustMatcher(matcher) {
            if (matcher === 'self') {
                return matcher;
            } else if (isString(matcher)) {
                if (matcher.indexOf('***') > -1) {
                    throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
                }
                matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
                return new RegExp('^' + matcher + '$');
            } else if (isRegExp(matcher)) {
                return new RegExp('^' + matcher.source + '$');
            } else {
                throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
            }
        }
        function adjustMatchers(matchers) {
            var adjustedMatchers = [];
            if (isDefined(matchers)) {
                forEach(matchers, function (matcher) {
                    adjustedMatchers.push(adjustMatcher(matcher));
                });
            }
            return adjustedMatchers;
        }
        function $SceDelegateProvider() {
            this.SCE_CONTEXTS = SCE_CONTEXTS;
            var resourceUrlWhitelist = ['self'], resourceUrlBlacklist = [];
            this.resourceUrlWhitelist = function (value) {
                if (arguments.length) {
                    resourceUrlWhitelist = adjustMatchers(value);
                }
                return resourceUrlWhitelist;
            };
            this.resourceUrlBlacklist = function (value) {
                if (arguments.length) {
                    resourceUrlBlacklist = adjustMatchers(value);
                }
                return resourceUrlBlacklist;
            };
            this.$get = [
                '$injector',
                function ($injector) {
                    var htmlSanitizer = function htmlSanitizer(html) {
                        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                    };
                    if ($injector.has('$sanitize')) {
                        htmlSanitizer = $injector.get('$sanitize');
                    }
                    function matchUrl(matcher, parsedUrl) {
                        if (matcher === 'self') {
                            return urlIsSameOrigin(parsedUrl);
                        } else {
                            return !!matcher.exec(parsedUrl.href);
                        }
                    }
                    function isResourceUrlAllowedByPolicy(url) {
                        var parsedUrl = urlResolve(url.toString());
                        var i, n, allowed = false;
                        for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                                allowed = true;
                                break;
                            }
                        }
                        if (allowed) {
                            for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                    allowed = false;
                                    break;
                                }
                            }
                        }
                        return allowed;
                    }
                    function generateHolderType(Base) {
                        var holderType = function TrustedValueHolderType(trustedValue) {
                            this.$$unwrapTrustedValue = function () {
                                return trustedValue;
                            };
                        };
                        if (Base) {
                            holderType.prototype = new Base();
                        }
                        holderType.prototype.valueOf = function sceValueOf() {
                            return this.$$unwrapTrustedValue();
                        };
                        holderType.prototype.toString = function sceToString() {
                            return this.$$unwrapTrustedValue().toString();
                        };
                        return holderType;
                    }
                    var trustedValueHolderBase = generateHolderType(), byType = {};
                    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
                    function trustAs(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) {
                            throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
                        }
                        if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
                            return trustedValue;
                        }
                        if (typeof trustedValue !== 'string') {
                            throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
                        }
                        return new Constructor(trustedValue);
                    }
                    function valueOf(maybeTrusted) {
                        if (maybeTrusted instanceof trustedValueHolderBase) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        } else {
                            return maybeTrusted;
                        }
                    }
                    function getTrusted(type, maybeTrusted) {
                        if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
                            return maybeTrusted;
                        }
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        }
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                                return maybeTrusted;
                            } else {
                                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
                            }
                        } else if (type === SCE_CONTEXTS.HTML) {
                            return htmlSanitizer(maybeTrusted);
                        }
                        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                    }
                    return {
                        trustAs: trustAs,
                        getTrusted: getTrusted,
                        valueOf: valueOf
                    };
                }
            ];
        }
        function $SceProvider() {
            var enabled = true;
            this.enabled = function (value) {
                if (arguments.length) {
                    enabled = !!value;
                }
                return enabled;
            };
            this.$get = [
                '$parse',
                '$sceDelegate',
                function ($parse, $sceDelegate) {
                    if (enabled && msie < 8) {
                        throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
                    }
                    var sce = shallowCopy(SCE_CONTEXTS);
                    sce.isEnabled = function () {
                        return enabled;
                    };
                    sce.trustAs = $sceDelegate.trustAs;
                    sce.getTrusted = $sceDelegate.getTrusted;
                    sce.valueOf = $sceDelegate.valueOf;
                    if (!enabled) {
                        sce.trustAs = sce.getTrusted = function (type, value) {
                            return value;
                        };
                        sce.valueOf = identity;
                    }
                    sce.parseAs = function sceParseAs(type, expr) {
                        var parsed = $parse(expr);
                        if (parsed.literal && parsed.constant) {
                            return parsed;
                        } else {
                            return $parse(expr, function (value) {
                                return sce.getTrusted(type, value);
                            });
                        }
                    };
                    var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                    forEach(SCE_CONTEXTS, function (enumValue, name) {
                        var lName = lowercase(name);
                        sce[camelCase('parse_as_' + lName)] = function (expr) {
                            return parse(enumValue, expr);
                        };
                        sce[camelCase('get_trusted_' + lName)] = function (value) {
                            return getTrusted(enumValue, value);
                        };
                        sce[camelCase('trust_as_' + lName)] = function (value) {
                            return trustAs(enumValue, value);
                        };
                    });
                    return sce;
                }
            ];
        }
        function $SnifferProvider() {
            this.$get = [
                '$window',
                '$document',
                function ($window, $document) {
                    var eventSupport = {}, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
                    if (bodyStyle) {
                        for (var prop in bodyStyle) {
                            if (match = vendorRegex.exec(prop)) {
                                vendorPrefix = match[0];
                                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                                break;
                            }
                        }
                        if (!vendorPrefix) {
                            vendorPrefix = 'WebkitOpacity' in bodyStyle && 'webkit';
                        }
                        transitions = !!('transition' in bodyStyle || vendorPrefix + 'Transition' in bodyStyle);
                        animations = !!('animation' in bodyStyle || vendorPrefix + 'Animation' in bodyStyle);
                        if (android && (!transitions || !animations)) {
                            transitions = isString(bodyStyle.webkitTransition);
                            animations = isString(bodyStyle.webkitAnimation);
                        }
                    }
                    return {
                        history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                        hasEvent: function (event) {
                            if (event === 'input' && msie <= 11)
                                return false;
                            if (isUndefined(eventSupport[event])) {
                                var divElm = document.createElement('div');
                                eventSupport[event] = 'on' + event in divElm;
                            }
                            return eventSupport[event];
                        },
                        csp: csp(),
                        vendorPrefix: vendorPrefix,
                        transitions: transitions,
                        animations: animations,
                        android: android
                    };
                }
            ];
        }
        var $compileMinErr = minErr('$compile');
        function $TemplateRequestProvider() {
            this.$get = [
                '$templateCache',
                '$http',
                '$q',
                '$sce',
                function ($templateCache, $http, $q, $sce) {
                    function handleRequestFn(tpl, ignoreRequestError) {
                        handleRequestFn.totalPendingRequests++;
                        if (!isString(tpl) || !$templateCache.get(tpl)) {
                            tpl = $sce.getTrustedResourceUrl(tpl);
                        }
                        var transformResponse = $http.defaults && $http.defaults.transformResponse;
                        if (isArray(transformResponse)) {
                            transformResponse = transformResponse.filter(function (transformer) {
                                return transformer !== defaultHttpResponseTransform;
                            });
                        } else if (transformResponse === defaultHttpResponseTransform) {
                            transformResponse = null;
                        }
                        var httpOptions = {
                            cache: $templateCache,
                            transformResponse: transformResponse
                        };
                        return $http.get(tpl, httpOptions)['finally'](function () {
                            handleRequestFn.totalPendingRequests--;
                        }).then(function (response) {
                            $templateCache.put(tpl, response.data);
                            return response.data;
                        }, handleError);
                        function handleError(resp) {
                            if (!ignoreRequestError) {
                                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
                            }
                            return $q.reject(resp);
                        }
                    }
                    handleRequestFn.totalPendingRequests = 0;
                    return handleRequestFn;
                }
            ];
        }
        function $$TestabilityProvider() {
            this.$get = [
                '$rootScope',
                '$browser',
                '$location',
                function ($rootScope, $browser, $location) {
                    var testability = {};
                    testability.findBindings = function (element, expression, opt_exactMatch) {
                        var bindings = element.getElementsByClassName('ng-binding');
                        var matches = [];
                        forEach(bindings, function (binding) {
                            var dataBinding = angular.element(binding).data('$binding');
                            if (dataBinding) {
                                forEach(dataBinding, function (bindingName) {
                                    if (opt_exactMatch) {
                                        var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                                        if (matcher.test(bindingName)) {
                                            matches.push(binding);
                                        }
                                    } else {
                                        if (bindingName.indexOf(expression) != -1) {
                                            matches.push(binding);
                                        }
                                    }
                                });
                            }
                        });
                        return matches;
                    };
                    testability.findModels = function (element, expression, opt_exactMatch) {
                        var prefixes = [
                            'ng-',
                            'data-ng-',
                            'ng\\:'
                        ];
                        for (var p = 0; p < prefixes.length; ++p) {
                            var attributeEquals = opt_exactMatch ? '=' : '*=';
                            var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
                            var elements = element.querySelectorAll(selector);
                            if (elements.length) {
                                return elements;
                            }
                        }
                    };
                    testability.getLocation = function () {
                        return $location.url();
                    };
                    testability.setLocation = function (url) {
                        if (url !== $location.url()) {
                            $location.url(url);
                            $rootScope.$digest();
                        }
                    };
                    testability.whenStable = function (callback) {
                        $browser.notifyWhenNoOutstandingRequests(callback);
                    };
                    return testability;
                }
            ];
        }
        function $TimeoutProvider() {
            this.$get = [
                '$rootScope',
                '$browser',
                '$q',
                '$$q',
                '$exceptionHandler',
                function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
                    var deferreds = {};
                    function timeout(fn, delay, invokeApply) {
                        if (!isFunction(fn)) {
                            invokeApply = delay;
                            delay = fn;
                            fn = noop;
                        }
                        var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                        timeoutId = $browser.defer(function () {
                            try {
                                deferred.resolve(fn.apply(null, args));
                            } catch (e) {
                                deferred.reject(e);
                                $exceptionHandler(e);
                            } finally {
                                delete deferreds[promise.$$timeoutId];
                            }
                            if (!skipApply)
                                $rootScope.$apply();
                        }, delay);
                        promise.$$timeoutId = timeoutId;
                        deferreds[timeoutId] = deferred;
                        return promise;
                    }
                    timeout.cancel = function (promise) {
                        if (promise && promise.$$timeoutId in deferreds) {
                            deferreds[promise.$$timeoutId].reject('canceled');
                            delete deferreds[promise.$$timeoutId];
                            return $browser.defer.cancel(promise.$$timeoutId);
                        }
                        return false;
                    };
                    return timeout;
                }
            ];
        }
        var urlParsingNode = document.createElement('a');
        var originUrl = urlResolve(window.location.href);
        function urlResolve(url) {
            var href = url;
            if (msie) {
                urlParsingNode.setAttribute('href', href);
                href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute('href', href);
            return {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
            };
        }
        function urlIsSameOrigin(requestUrl) {
            var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
            return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
        }
        function $WindowProvider() {
            this.$get = valueFn(window);
        }
        function $$CookieReader($document) {
            var rawDocument = $document[0] || {};
            var lastCookies = {};
            var lastCookieString = '';
            function safeDecodeURIComponent(str) {
                try {
                    return decodeURIComponent(str);
                } catch (e) {
                    return str;
                }
            }
            return function () {
                var cookieArray, cookie, i, index, name;
                var currentCookieString = rawDocument.cookie || '';
                if (currentCookieString !== lastCookieString) {
                    lastCookieString = currentCookieString;
                    cookieArray = lastCookieString.split('; ');
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf('=');
                        if (index > 0) {
                            name = safeDecodeURIComponent(cookie.substring(0, index));
                            if (isUndefined(lastCookies[name])) {
                                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            };
        }
        $$CookieReader.$inject = ['$document'];
        function $$CookieReaderProvider() {
            this.$get = $$CookieReader;
        }
        $FilterProvider.$inject = ['$provide'];
        function $FilterProvider($provide) {
            var suffix = 'Filter';
            function register(name, factory) {
                if (isObject(name)) {
                    var filters = {};
                    forEach(name, function (filter, key) {
                        filters[key] = register(key, filter);
                    });
                    return filters;
                } else {
                    return $provide.factory(name + suffix, factory);
                }
            }
            this.register = register;
            this.$get = [
                '$injector',
                function ($injector) {
                    return function (name) {
                        return $injector.get(name + suffix);
                    };
                }
            ];
            register('currency', currencyFilter);
            register('date', dateFilter);
            register('filter', filterFilter);
            register('json', jsonFilter);
            register('limitTo', limitToFilter);
            register('lowercase', lowercaseFilter);
            register('number', numberFilter);
            register('orderBy', orderByFilter);
            register('uppercase', uppercaseFilter);
        }
        function filterFilter() {
            return function (array, expression, comparator) {
                if (!isArrayLike(array)) {
                    if (array == null) {
                        return array;
                    } else {
                        throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
                    }
                }
                var expressionType = getTypeForFilter(expression);
                var predicateFn;
                var matchAgainstAnyProp;
                switch (expressionType) {
                case 'function':
                    predicateFn = expression;
                    break;
                case 'boolean':
                case 'null':
                case 'number':
                case 'string':
                    matchAgainstAnyProp = true;
                case 'object':
                    predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                    break;
                default:
                    return array;
                }
                return Array.prototype.filter.call(array, predicateFn);
            };
        }
        function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
            var shouldMatchPrimitives = isObject(expression) && '$' in expression;
            var predicateFn;
            if (comparator === true) {
                comparator = equals;
            } else if (!isFunction(comparator)) {
                comparator = function (actual, expected) {
                    if (isUndefined(actual)) {
                        return false;
                    }
                    if (actual === null || expected === null) {
                        return actual === expected;
                    }
                    if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
                        return false;
                    }
                    actual = lowercase('' + actual);
                    expected = lowercase('' + expected);
                    return actual.indexOf(expected) !== -1;
                };
            }
            predicateFn = function (item) {
                if (shouldMatchPrimitives && !isObject(item)) {
                    return deepCompare(item, expression.$, comparator, false);
                }
                return deepCompare(item, expression, comparator, matchAgainstAnyProp);
            };
            return predicateFn;
        }
        function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
            var actualType = getTypeForFilter(actual);
            var expectedType = getTypeForFilter(expected);
            if (expectedType === 'string' && expected.charAt(0) === '!') {
                return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
            } else if (isArray(actual)) {
                return actual.some(function (item) {
                    return deepCompare(item, expected, comparator, matchAgainstAnyProp);
                });
            }
            switch (actualType) {
            case 'object':
                var key;
                if (matchAgainstAnyProp) {
                    for (key in actual) {
                        if (key.charAt(0) !== '$' && deepCompare(actual[key], expected, comparator, true)) {
                            return true;
                        }
                    }
                    return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
                } else if (expectedType === 'object') {
                    for (key in expected) {
                        var expectedVal = expected[key];
                        if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                            continue;
                        }
                        var matchAnyProperty = key === '$';
                        var actualVal = matchAnyProperty ? actual : actual[key];
                        if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return comparator(actual, expected);
                }
                break;
            case 'function':
                return false;
            default:
                return comparator(actual, expected);
            }
        }
        function getTypeForFilter(val) {
            return val === null ? 'null' : typeof val;
        }
        currencyFilter.$inject = ['$locale'];
        function currencyFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (amount, currencySymbol, fractionSize) {
                if (isUndefined(currencySymbol)) {
                    currencySymbol = formats.CURRENCY_SYM;
                }
                if (isUndefined(fractionSize)) {
                    fractionSize = formats.PATTERNS[1].maxFrac;
                }
                return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
            };
        }
        numberFilter.$inject = ['$locale'];
        function numberFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (number, fractionSize) {
                return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
            };
        }
        var DECIMAL_SEP = '.';
        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
            if (isObject(number))
                return '';
            var isNegative = number < 0;
            number = Math.abs(number);
            var isInfinity = number === Infinity;
            if (!isInfinity && !isFinite(number))
                return '';
            var numStr = number + '', formatedText = '', hasExponent = false, parts = [];
            if (isInfinity)
                formatedText = '\u221E';
            if (!isInfinity && numStr.indexOf('e') !== -1) {
                var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
                if (match && match[2] == '-' && match[3] > fractionSize + 1) {
                    number = 0;
                } else {
                    formatedText = numStr;
                    hasExponent = true;
                }
            }
            if (!isInfinity && !hasExponent) {
                var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
                if (isUndefined(fractionSize)) {
                    fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
                }
                number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
                var fraction = ('' + number).split(DECIMAL_SEP);
                var whole = fraction[0];
                fraction = fraction[1] || '';
                var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
                if (whole.length >= lgroup + group) {
                    pos = whole.length - lgroup;
                    for (i = 0; i < pos; i++) {
                        if ((pos - i) % group === 0 && i !== 0) {
                            formatedText += groupSep;
                        }
                        formatedText += whole.charAt(i);
                    }
                }
                for (i = pos; i < whole.length; i++) {
                    if ((whole.length - i) % lgroup === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
                while (fraction.length < fractionSize) {
                    fraction += '0';
                }
                if (fractionSize && fractionSize !== '0')
                    formatedText += decimalSep + fraction.substr(0, fractionSize);
            } else {
                if (fractionSize > 0 && number < 1) {
                    formatedText = number.toFixed(fractionSize);
                    number = parseFloat(formatedText);
                    formatedText = formatedText.replace(DECIMAL_SEP, decimalSep);
                }
            }
            if (number === 0) {
                isNegative = false;
            }
            parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
            return parts.join('');
        }
        function padNumber(num, digits, trim) {
            var neg = '';
            if (num < 0) {
                neg = '-';
                num = -num;
            }
            num = '' + num;
            while (num.length < digits)
                num = '0' + num;
            if (trim) {
                num = num.substr(num.length - digits);
            }
            return neg + num;
        }
        function dateGetter(name, size, offset, trim) {
            offset = offset || 0;
            return function (date) {
                var value = date['get' + name]();
                if (offset > 0 || value > -offset) {
                    value += offset;
                }
                if (value === 0 && offset == -12)
                    value = 12;
                return padNumber(value, size, trim);
            };
        }
        function dateStrGetter(name, shortForm) {
            return function (date, formats) {
                var value = date['get' + name]();
                var get = uppercase(shortForm ? 'SHORT' + name : name);
                return formats[get][value];
            };
        }
        function timeZoneGetter(date, formats, offset) {
            var zone = -1 * offset;
            var paddedZone = zone >= 0 ? '+' : '';
            paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
            return paddedZone;
        }
        function getFirstThursdayOfYear(year) {
            var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
            return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
        }
        function getThursdayThisWeek(datetime) {
            return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
        }
        function weekGetter(size) {
            return function (date) {
                var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
                var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 604800000);
                return padNumber(result, size);
            };
        }
        function ampmGetter(date, formats) {
            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
        }
        function eraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
        }
        function longEraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
        }
        var DATE_FORMATS = {
            yyyy: dateGetter('FullYear', 4),
            yy: dateGetter('FullYear', 2, 0, true),
            y: dateGetter('FullYear', 1),
            MMMM: dateStrGetter('Month'),
            MMM: dateStrGetter('Month', true),
            MM: dateGetter('Month', 2, 1),
            M: dateGetter('Month', 1, 1),
            dd: dateGetter('Date', 2),
            d: dateGetter('Date', 1),
            HH: dateGetter('Hours', 2),
            H: dateGetter('Hours', 1),
            hh: dateGetter('Hours', 2, -12),
            h: dateGetter('Hours', 1, -12),
            mm: dateGetter('Minutes', 2),
            m: dateGetter('Minutes', 1),
            ss: dateGetter('Seconds', 2),
            s: dateGetter('Seconds', 1),
            sss: dateGetter('Milliseconds', 3),
            EEEE: dateStrGetter('Day'),
            EEE: dateStrGetter('Day', true),
            a: ampmGetter,
            Z: timeZoneGetter,
            ww: weekGetter(2),
            w: weekGetter(1),
            G: eraGetter,
            GG: eraGetter,
            GGG: eraGetter,
            GGGG: longEraGetter
        };
        var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
        dateFilter.$inject = ['$locale'];
        function dateFilter($locale) {
            var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
            function jsonStringToDate(string) {
                var match;
                if (match = string.match(R_ISO8601_STR)) {
                    var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                    if (match[9]) {
                        tzHour = toInt(match[9] + match[10]);
                        tzMin = toInt(match[9] + match[11]);
                    }
                    dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                    var h = toInt(match[4] || 0) - tzHour;
                    var m = toInt(match[5] || 0) - tzMin;
                    var s = toInt(match[6] || 0);
                    var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
                    timeSetter.call(date, h, m, s, ms);
                    return date;
                }
                return string;
            }
            return function (date, format, timezone) {
                var text = '', parts = [], fn, match;
                format = format || 'mediumDate';
                format = $locale.DATETIME_FORMATS[format] || format;
                if (isString(date)) {
                    date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
                }
                if (isNumber(date)) {
                    date = new Date(date);
                }
                if (!isDate(date) || !isFinite(date.getTime())) {
                    return date;
                }
                while (format) {
                    match = DATE_FORMATS_SPLIT.exec(format);
                    if (match) {
                        parts = concat(parts, match, 1);
                        format = parts.pop();
                    } else {
                        parts.push(format);
                        format = null;
                    }
                }
                var dateTimezoneOffset = date.getTimezoneOffset();
                if (timezone) {
                    dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
                    date = convertTimezoneToLocal(date, timezone, true);
                }
                forEach(parts, function (value) {
                    fn = DATE_FORMATS[value];
                    text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
                });
                return text;
            };
        }
        function jsonFilter() {
            return function (object, spacing) {
                if (isUndefined(spacing)) {
                    spacing = 2;
                }
                return toJson(object, spacing);
            };
        }
        var lowercaseFilter = valueFn(lowercase);
        var uppercaseFilter = valueFn(uppercase);
        function limitToFilter() {
            return function (input, limit, begin) {
                if (Math.abs(Number(limit)) === Infinity) {
                    limit = Number(limit);
                } else {
                    limit = toInt(limit);
                }
                if (isNaN(limit))
                    return input;
                if (isNumber(input))
                    input = input.toString();
                if (!isArray(input) && !isString(input))
                    return input;
                begin = !begin || isNaN(begin) ? 0 : toInt(begin);
                begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
                if (limit >= 0) {
                    return input.slice(begin, begin + limit);
                } else {
                    if (begin === 0) {
                        return input.slice(limit, input.length);
                    } else {
                        return input.slice(Math.max(0, begin + limit), begin);
                    }
                }
            };
        }
        orderByFilter.$inject = ['$parse'];
        function orderByFilter($parse) {
            return function (array, sortPredicate, reverseOrder) {
                if (!isArrayLike(array))
                    return array;
                if (!isArray(sortPredicate)) {
                    sortPredicate = [sortPredicate];
                }
                if (sortPredicate.length === 0) {
                    sortPredicate = ['+'];
                }
                var predicates = processPredicates(sortPredicate, reverseOrder);
                predicates.push({
                    get: function () {
                        return {};
                    },
                    descending: reverseOrder ? -1 : 1
                });
                var compareValues = Array.prototype.map.call(array, getComparisonObject);
                compareValues.sort(doComparison);
                array = compareValues.map(function (item) {
                    return item.value;
                });
                return array;
                function getComparisonObject(value, index) {
                    return {
                        value: value,
                        predicateValues: predicates.map(function (predicate) {
                            return getPredicateValue(predicate.get(value), index);
                        })
                    };
                }
                function doComparison(v1, v2) {
                    var result = 0;
                    for (var index = 0, length = predicates.length; index < length; ++index) {
                        result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
                        if (result)
                            break;
                    }
                    return result;
                }
            };
            function processPredicates(sortPredicate, reverseOrder) {
                reverseOrder = reverseOrder ? -1 : 1;
                return sortPredicate.map(function (predicate) {
                    var descending = 1, get = identity;
                    if (isFunction(predicate)) {
                        get = predicate;
                    } else if (isString(predicate)) {
                        if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
                            descending = predicate.charAt(0) == '-' ? -1 : 1;
                            predicate = predicate.substring(1);
                        }
                        if (predicate !== '') {
                            get = $parse(predicate);
                            if (get.constant) {
                                var key = get();
                                get = function (value) {
                                    return value[key];
                                };
                            }
                        }
                    }
                    return {
                        get: get,
                        descending: descending * reverseOrder
                    };
                });
            }
            function isPrimitive(value) {
                switch (typeof value) {
                case 'number':
                case 'boolean':
                case 'string':
                    return true;
                default:
                    return false;
                }
            }
            function objectValue(value, index) {
                if (typeof value.valueOf === 'function') {
                    value = value.valueOf();
                    if (isPrimitive(value))
                        return value;
                }
                if (hasCustomToString(value)) {
                    value = value.toString();
                    if (isPrimitive(value))
                        return value;
                }
                return index;
            }
            function getPredicateValue(value, index) {
                var type = typeof value;
                if (value === null) {
                    type = 'string';
                    value = 'null';
                } else if (type === 'string') {
                    value = value.toLowerCase();
                } else if (type === 'object') {
                    value = objectValue(value, index);
                }
                return {
                    value: value,
                    type: type
                };
            }
            function compare(v1, v2) {
                var result = 0;
                if (v1.type === v2.type) {
                    if (v1.value !== v2.value) {
                        result = v1.value < v2.value ? -1 : 1;
                    }
                } else {
                    result = v1.type < v2.type ? -1 : 1;
                }
                return result;
            }
        }
        function ngDirective(directive) {
            if (isFunction(directive)) {
                directive = { link: directive };
            }
            directive.restrict = directive.restrict || 'AC';
            return valueFn(directive);
        }
        var htmlAnchorDirective = valueFn({
            restrict: 'E',
            compile: function (element, attr) {
                if (!attr.href && !attr.xlinkHref) {
                    return function (scope, element) {
                        if (element[0].nodeName.toLowerCase() !== 'a')
                            return;
                        var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
                        element.on('click', function (event) {
                            if (!element.attr(href)) {
                                event.preventDefault();
                            }
                        });
                    };
                }
            }
        });
        var ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, function (propName, attrName) {
            if (propName == 'multiple')
                return;
            function defaultLinkFn(scope, element, attr) {
                scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                    attr.$set(attrName, !!value);
                });
            }
            var normalized = directiveNormalize('ng-' + attrName);
            var linkFn = defaultLinkFn;
            if (propName === 'checked') {
                linkFn = function (scope, element, attr) {
                    if (attr.ngModel !== attr[normalized]) {
                        defaultLinkFn(scope, element, attr);
                    }
                };
            }
            ngAttributeAliasDirectives[normalized] = function () {
                return {
                    restrict: 'A',
                    priority: 100,
                    link: linkFn
                };
            };
        });
        forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
            ngAttributeAliasDirectives[ngAttr] = function () {
                return {
                    priority: 100,
                    link: function (scope, element, attr) {
                        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) == '/') {
                            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                            if (match) {
                                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                                return;
                            }
                        }
                        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                            attr.$set(ngAttr, value);
                        });
                    }
                };
            };
        });
        forEach([
            'src',
            'srcset',
            'href'
        ], function (attrName) {
            var normalized = directiveNormalize('ng-' + attrName);
            ngAttributeAliasDirectives[normalized] = function () {
                return {
                    priority: 99,
                    link: function (scope, element, attr) {
                        var propName = attrName, name = attrName;
                        if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                            name = 'xlinkHref';
                            attr.$attr[name] = 'xlink:href';
                            propName = null;
                        }
                        attr.$observe(normalized, function (value) {
                            if (!value) {
                                if (attrName === 'href') {
                                    attr.$set(name, null);
                                }
                                return;
                            }
                            attr.$set(name, value);
                            if (msie && propName)
                                element.prop(propName, attr[name]);
                        });
                    }
                };
            };
        });
        var nullFormCtrl = {
                $addControl: noop,
                $$renameControl: nullFormRenameControl,
                $removeControl: noop,
                $setValidity: noop,
                $setDirty: noop,
                $setPristine: noop,
                $setSubmitted: noop
            }, SUBMITTED_CLASS = 'ng-submitted';
        function nullFormRenameControl(control, name) {
            control.$name = name;
        }
        FormController.$inject = [
            '$element',
            '$attrs',
            '$scope',
            '$animate',
            '$interpolate'
        ];
        function FormController(element, attrs, $scope, $animate, $interpolate) {
            var form = this, controls = [];
            form.$error = {};
            form.$$success = {};
            form.$pending = undefined;
            form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
            form.$dirty = false;
            form.$pristine = true;
            form.$valid = true;
            form.$invalid = false;
            form.$submitted = false;
            form.$$parentForm = nullFormCtrl;
            form.$rollbackViewValue = function () {
                forEach(controls, function (control) {
                    control.$rollbackViewValue();
                });
            };
            form.$commitViewValue = function () {
                forEach(controls, function (control) {
                    control.$commitViewValue();
                });
            };
            form.$addControl = function (control) {
                assertNotHasOwnProperty(control.$name, 'input');
                controls.push(control);
                if (control.$name) {
                    form[control.$name] = control;
                }
                control.$$parentForm = form;
            };
            form.$$renameControl = function (control, newName) {
                var oldName = control.$name;
                if (form[oldName] === control) {
                    delete form[oldName];
                }
                form[newName] = control;
                control.$name = newName;
            };
            form.$removeControl = function (control) {
                if (control.$name && form[control.$name] === control) {
                    delete form[control.$name];
                }
                forEach(form.$pending, function (value, name) {
                    form.$setValidity(name, null, control);
                });
                forEach(form.$error, function (value, name) {
                    form.$setValidity(name, null, control);
                });
                forEach(form.$$success, function (value, name) {
                    form.$setValidity(name, null, control);
                });
                arrayRemove(controls, control);
                control.$$parentForm = nullFormCtrl;
            };
            addSetValidityMethod({
                ctrl: this,
                $element: element,
                set: function (object, property, controller) {
                    var list = object[property];
                    if (!list) {
                        object[property] = [controller];
                    } else {
                        var index = list.indexOf(controller);
                        if (index === -1) {
                            list.push(controller);
                        }
                    }
                },
                unset: function (object, property, controller) {
                    var list = object[property];
                    if (!list) {
                        return;
                    }
                    arrayRemove(list, controller);
                    if (list.length === 0) {
                        delete object[property];
                    }
                },
                $animate: $animate
            });
            form.$setDirty = function () {
                $animate.removeClass(element, PRISTINE_CLASS);
                $animate.addClass(element, DIRTY_CLASS);
                form.$dirty = true;
                form.$pristine = false;
                form.$$parentForm.$setDirty();
            };
            form.$setPristine = function () {
                $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
                form.$dirty = false;
                form.$pristine = true;
                form.$submitted = false;
                forEach(controls, function (control) {
                    control.$setPristine();
                });
            };
            form.$setUntouched = function () {
                forEach(controls, function (control) {
                    control.$setUntouched();
                });
            };
            form.$setSubmitted = function () {
                $animate.addClass(element, SUBMITTED_CLASS);
                form.$submitted = true;
                form.$$parentForm.$setSubmitted();
            };
        }
        var formDirectiveFactory = function (isNgForm) {
            return [
                '$timeout',
                '$parse',
                function ($timeout, $parse) {
                    var formDirective = {
                        name: 'form',
                        restrict: isNgForm ? 'EAC' : 'E',
                        require: [
                            'form',
                            '^^?form'
                        ],
                        controller: FormController,
                        compile: function ngFormCompile(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false;
                            return {
                                pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!('action' in attr)) {
                                        var handleFormSubmission = function (event) {
                                            scope.$apply(function () {
                                                controller.$commitViewValue();
                                                controller.$setSubmitted();
                                            });
                                            event.preventDefault();
                                        };
                                        addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                                        formElement.on('$destroy', function () {
                                            $timeout(function () {
                                                removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                                            }, 0, false);
                                        });
                                    }
                                    var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                                    parentFormCtrl.$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    if (nameAttr) {
                                        setter(scope, controller);
                                        attr.$observe(nameAttr, function (newValue) {
                                            if (controller.$name === newValue)
                                                return;
                                            setter(scope, undefined);
                                            controller.$$parentForm.$$renameControl(controller, newValue);
                                            setter = getSetter(controller.$name);
                                            setter(scope, controller);
                                        });
                                    }
                                    formElement.on('$destroy', function () {
                                        controller.$$parentForm.$removeControl(controller);
                                        setter(scope, undefined);
                                        extend(controller, nullFormCtrl);
                                    });
                                }
                            };
                        }
                    };
                    return formDirective;
                    function getSetter(expression) {
                        if (expression === '') {
                            return $parse('this[""]').assign;
                        }
                        return $parse(expression).assign || noop;
                    }
                }
            ];
        };
        var formDirective = formDirectiveFactory();
        var ngFormDirective = formDirectiveFactory(true);
        var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
        var URL_REGEXP = /^[A-Za-z][A-Za-z\d.+-]*:\/*(?:\w+(?::\w+)?@)?[^\s\/]+(?::\d+)?(?:\/[\w#!:.?+=&%@\-\/]*)?$/;
        var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
        var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
        var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
        var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
        var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
        var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var inputType = {
            'text': textInputType,
            'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, [
                'yyyy',
                'MM',
                'dd'
            ]), 'yyyy-MM-dd'),
            'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [
                'yyyy',
                'MM',
                'dd',
                'HH',
                'mm',
                'ss',
                'sss'
            ]), 'yyyy-MM-ddTHH:mm:ss.sss'),
            'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, [
                'HH',
                'mm',
                'ss',
                'sss'
            ]), 'HH:mm:ss.sss'),
            'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
            'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, [
                'yyyy',
                'MM'
            ]), 'yyyy-MM'),
            'number': numberInputType,
            'url': urlInputType,
            'email': emailInputType,
            'radio': radioInputType,
            'checkbox': checkboxInputType,
            'hidden': noop,
            'button': noop,
            'submit': noop,
            'reset': noop,
            'file': noop
        };
        function stringBasedInputType(ctrl) {
            ctrl.$formatters.push(function (value) {
                return ctrl.$isEmpty(value) ? value : value.toString();
            });
        }
        function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
        }
        function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            var type = lowercase(element[0].type);
            if (!$sniffer.android) {
                var composing = false;
                element.on('compositionstart', function (data) {
                    composing = true;
                });
                element.on('compositionend', function () {
                    composing = false;
                    listener();
                });
            }
            var listener = function (ev) {
                if (timeout) {
                    $browser.defer.cancel(timeout);
                    timeout = null;
                }
                if (composing)
                    return;
                var value = element.val(), event = ev && ev.type;
                if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
                    value = trim(value);
                }
                if (ctrl.$viewValue !== value || value === '' && ctrl.$$hasNativeValidators) {
                    ctrl.$setViewValue(value, event);
                }
            };
            if ($sniffer.hasEvent('input')) {
                element.on('input', listener);
            } else {
                var timeout;
                var deferListener = function (ev, input, origValue) {
                    if (!timeout) {
                        timeout = $browser.defer(function () {
                            timeout = null;
                            if (!input || input.value !== origValue) {
                                listener(ev);
                            }
                        });
                    }
                };
                element.on('keydown', function (event) {
                    var key = event.keyCode;
                    if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
                        return;
                    deferListener(event, this, this.value);
                });
                if ($sniffer.hasEvent('paste')) {
                    element.on('paste cut', deferListener);
                }
            }
            element.on('change', listener);
            ctrl.$render = function () {
                var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
                if (element.val() !== value) {
                    element.val(value);
                }
            };
        }
        function weekParser(isoWeek, existingDate) {
            if (isDate(isoWeek)) {
                return isoWeek;
            }
            if (isString(isoWeek)) {
                WEEK_REGEXP.lastIndex = 0;
                var parts = WEEK_REGEXP.exec(isoWeek);
                if (parts) {
                    var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                    if (existingDate) {
                        hours = existingDate.getHours();
                        minutes = existingDate.getMinutes();
                        seconds = existingDate.getSeconds();
                        milliseconds = existingDate.getMilliseconds();
                    }
                    return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                }
            }
            return NaN;
        }
        function createDateParser(regexp, mapping) {
            return function (iso, date) {
                var parts, map;
                if (isDate(iso)) {
                    return iso;
                }
                if (isString(iso)) {
                    if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
                        iso = iso.substring(1, iso.length - 1);
                    }
                    if (ISO_DATE_REGEXP.test(iso)) {
                        return new Date(iso);
                    }
                    regexp.lastIndex = 0;
                    parts = regexp.exec(iso);
                    if (parts) {
                        parts.shift();
                        if (date) {
                            map = {
                                yyyy: date.getFullYear(),
                                MM: date.getMonth() + 1,
                                dd: date.getDate(),
                                HH: date.getHours(),
                                mm: date.getMinutes(),
                                ss: date.getSeconds(),
                                sss: date.getMilliseconds() / 1000
                            };
                        } else {
                            map = {
                                yyyy: 1970,
                                MM: 1,
                                dd: 1,
                                HH: 0,
                                mm: 0,
                                ss: 0,
                                sss: 0
                            };
                        }
                        forEach(parts, function (part, index) {
                            if (index < mapping.length) {
                                map[mapping[index]] = +part;
                            }
                        });
                        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
                    }
                }
                return NaN;
            };
        }
        function createDateInputType(type, regexp, parseDate, format) {
            return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
                badInputChecker(scope, element, attr, ctrl);
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
                var previousDate;
                ctrl.$$parserName = type;
                ctrl.$parsers.push(function (value) {
                    if (ctrl.$isEmpty(value))
                        return null;
                    if (regexp.test(value)) {
                        var parsedDate = parseDate(value, previousDate);
                        if (timezone) {
                            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                        }
                        return parsedDate;
                    }
                    return undefined;
                });
                ctrl.$formatters.push(function (value) {
                    if (value && !isDate(value)) {
                        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
                    }
                    if (isValidDate(value)) {
                        previousDate = value;
                        if (previousDate && timezone) {
                            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                        }
                        return $filter('date')(value, format, timezone);
                    } else {
                        previousDate = null;
                        return '';
                    }
                });
                if (isDefined(attr.min) || attr.ngMin) {
                    var minVal;
                    ctrl.$validators.min = function (value) {
                        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                    };
                    attr.$observe('min', function (val) {
                        minVal = parseObservedDateValue(val);
                        ctrl.$validate();
                    });
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal;
                    ctrl.$validators.max = function (value) {
                        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                    };
                    attr.$observe('max', function (val) {
                        maxVal = parseObservedDateValue(val);
                        ctrl.$validate();
                    });
                }
                function isValidDate(value) {
                    return value && !(value.getTime && value.getTime() !== value.getTime());
                }
                function parseObservedDateValue(val) {
                    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
                }
            };
        }
        function badInputChecker(scope, element, attr, ctrl) {
            var node = element[0];
            var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
            if (nativeValidation) {
                ctrl.$parsers.push(function (value) {
                    var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                    return validity.badInput && !validity.typeMismatch ? undefined : value;
                });
            }
        }
        function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            badInputChecker(scope, element, attr, ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            ctrl.$$parserName = 'number';
            ctrl.$parsers.push(function (value) {
                if (ctrl.$isEmpty(value))
                    return null;
                if (NUMBER_REGEXP.test(value))
                    return parseFloat(value);
                return undefined;
            });
            ctrl.$formatters.push(function (value) {
                if (!ctrl.$isEmpty(value)) {
                    if (!isNumber(value)) {
                        throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
                    }
                    value = value.toString();
                }
                return value;
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
                };
                attr.$observe('min', function (val) {
                    if (isDefined(val) && !isNumber(val)) {
                        val = parseFloat(val, 10);
                    }
                    minVal = isNumber(val) && !isNaN(val) ? val : undefined;
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
                };
                attr.$observe('max', function (val) {
                    if (isDefined(val) && !isNumber(val)) {
                        val = parseFloat(val, 10);
                    }
                    maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
                    ctrl.$validate();
                });
            }
        }
        function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
            ctrl.$$parserName = 'url';
            ctrl.$validators.url = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
            };
        }
        function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
            ctrl.$$parserName = 'email';
            ctrl.$validators.email = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
            };
        }
        function radioInputType(scope, element, attr, ctrl) {
            if (isUndefined(attr.name)) {
                element.attr('name', nextUid());
            }
            var listener = function (ev) {
                if (element[0].checked) {
                    ctrl.$setViewValue(attr.value, ev && ev.type);
                }
            };
            element.on('click', listener);
            ctrl.$render = function () {
                var value = attr.value;
                element[0].checked = value == ctrl.$viewValue;
            };
            attr.$observe('value', ctrl.$render);
        }
        function parseConstantExpr($parse, context, name, expression, fallback) {
            var parseFn;
            if (isDefined(expression)) {
                parseFn = $parse(expression);
                if (!parseFn.constant) {
                    throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
                }
                return parseFn(context);
            }
            return fallback;
        }
        function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
            var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
            var listener = function (ev) {
                ctrl.$setViewValue(element[0].checked, ev && ev.type);
            };
            element.on('click', listener);
            ctrl.$render = function () {
                element[0].checked = ctrl.$viewValue;
            };
            ctrl.$isEmpty = function (value) {
                return value === false;
            };
            ctrl.$formatters.push(function (value) {
                return equals(value, trueValue);
            });
            ctrl.$parsers.push(function (value) {
                return value ? trueValue : falseValue;
            });
        }
        var inputDirective = [
            '$browser',
            '$sniffer',
            '$filter',
            '$parse',
            function ($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: 'E',
                    require: ['?ngModel'],
                    link: {
                        pre: function (scope, element, attr, ctrls) {
                            if (ctrls[0]) {
                                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                            }
                        }
                    }
                };
            }
        ];
        var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
        var ngValueDirective = function () {
            return {
                restrict: 'A',
                priority: 100,
                compile: function (tpl, tplAttr) {
                    if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                        return function ngValueConstantLink(scope, elm, attr) {
                            attr.$set('value', scope.$eval(attr.ngValue));
                        };
                    } else {
                        return function ngValueLink(scope, elm, attr) {
                            scope.$watch(attr.ngValue, function valueWatchAction(value) {
                                attr.$set('value', value);
                            });
                        };
                    }
                }
            };
        };
        var ngBindDirective = [
            '$compile',
            function ($compile) {
                return {
                    restrict: 'AC',
                    compile: function ngBindCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBind);
                            element = element[0];
                            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                                element.textContent = isUndefined(value) ? '' : value;
                            });
                        };
                    }
                };
            }
        ];
        var ngBindTemplateDirective = [
            '$interpolate',
            '$compile',
            function ($interpolate, $compile) {
                return {
                    compile: function ngBindTemplateCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindTemplateLink(scope, element, attr) {
                            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                            $compile.$$addBindingInfo(element, interpolateFn.expressions);
                            element = element[0];
                            attr.$observe('ngBindTemplate', function (value) {
                                element.textContent = isUndefined(value) ? '' : value;
                            });
                        };
                    }
                };
            }
        ];
        var ngBindHtmlDirective = [
            '$sce',
            '$parse',
            '$compile',
            function ($sce, $parse, $compile) {
                return {
                    restrict: 'A',
                    compile: function ngBindHtmlCompile(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                        var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
                            return (value || '').toString();
                        });
                        $compile.$$addBindingClass(tElement);
                        return function ngBindHtmlLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBindHtml);
                            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
                            });
                        };
                    }
                };
            }
        ];
        var ngChangeDirective = valueFn({
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, element, attr, ctrl) {
                ctrl.$viewChangeListeners.push(function () {
                    scope.$eval(attr.ngChange);
                });
            }
        });
        function classDirective(name, selector) {
            name = 'ngClass' + name;
            return [
                '$animate',
                function ($animate) {
                    return {
                        restrict: 'AC',
                        link: function (scope, element, attr) {
                            var oldVal;
                            scope.$watch(attr[name], ngClassWatchAction, true);
                            attr.$observe('class', function (value) {
                                ngClassWatchAction(scope.$eval(attr[name]));
                            });
                            if (name !== 'ngClass') {
                                scope.$watch('$index', function ($index, old$index) {
                                    var mod = $index & 1;
                                    if (mod !== (old$index & 1)) {
                                        var classes = arrayClasses(scope.$eval(attr[name]));
                                        mod === selector ? addClasses(classes) : removeClasses(classes);
                                    }
                                });
                            }
                            function addClasses(classes) {
                                var newClasses = digestClassCounts(classes, 1);
                                attr.$addClass(newClasses);
                            }
                            function removeClasses(classes) {
                                var newClasses = digestClassCounts(classes, -1);
                                attr.$removeClass(newClasses);
                            }
                            function digestClassCounts(classes, count) {
                                var classCounts = element.data('$classCounts') || createMap();
                                var classesToUpdate = [];
                                forEach(classes, function (className) {
                                    if (count > 0 || classCounts[className]) {
                                        classCounts[className] = (classCounts[className] || 0) + count;
                                        if (classCounts[className] === +(count > 0)) {
                                            classesToUpdate.push(className);
                                        }
                                    }
                                });
                                element.data('$classCounts', classCounts);
                                return classesToUpdate.join(' ');
                            }
                            function updateClasses(oldClasses, newClasses) {
                                var toAdd = arrayDifference(newClasses, oldClasses);
                                var toRemove = arrayDifference(oldClasses, newClasses);
                                toAdd = digestClassCounts(toAdd, 1);
                                toRemove = digestClassCounts(toRemove, -1);
                                if (toAdd && toAdd.length) {
                                    $animate.addClass(element, toAdd);
                                }
                                if (toRemove && toRemove.length) {
                                    $animate.removeClass(element, toRemove);
                                }
                            }
                            function ngClassWatchAction(newVal) {
                                if (selector === true || scope.$index % 2 === selector) {
                                    var newClasses = arrayClasses(newVal || []);
                                    if (!oldVal) {
                                        addClasses(newClasses);
                                    } else if (!equals(newVal, oldVal)) {
                                        var oldClasses = arrayClasses(oldVal);
                                        updateClasses(oldClasses, newClasses);
                                    }
                                }
                                oldVal = shallowCopy(newVal);
                            }
                        }
                    };
                    function arrayDifference(tokens1, tokens2) {
                        var values = [];
                        outer:
                            for (var i = 0; i < tokens1.length; i++) {
                                var token = tokens1[i];
                                for (var j = 0; j < tokens2.length; j++) {
                                    if (token == tokens2[j])
                                        continue outer;
                                }
                                values.push(token);
                            }
                        return values;
                    }
                    function arrayClasses(classVal) {
                        var classes = [];
                        if (isArray(classVal)) {
                            forEach(classVal, function (v) {
                                classes = classes.concat(arrayClasses(v));
                            });
                            return classes;
                        } else if (isString(classVal)) {
                            return classVal.split(' ');
                        } else if (isObject(classVal)) {
                            forEach(classVal, function (v, k) {
                                if (v) {
                                    classes = classes.concat(k.split(' '));
                                }
                            });
                            return classes;
                        }
                        return classVal;
                    }
                }
            ];
        }
        var ngClassDirective = classDirective('', true);
        var ngClassOddDirective = classDirective('Odd', 0);
        var ngClassEvenDirective = classDirective('Even', 1);
        var ngCloakDirective = ngDirective({
            compile: function (element, attr) {
                attr.$set('ngCloak', undefined);
                element.removeClass('ng-cloak');
            }
        });
        var ngControllerDirective = [function () {
                return {
                    restrict: 'A',
                    scope: true,
                    controller: '@',
                    priority: 500
                };
            }];
        var ngEventDirectives = {};
        var forceAsyncEvents = {
            'blur': true,
            'focus': true
        };
        forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function (eventName) {
            var directiveName = directiveNormalize('ng-' + eventName);
            ngEventDirectives[directiveName] = [
                '$parse',
                '$rootScope',
                function ($parse, $rootScope) {
                    return {
                        restrict: 'A',
                        compile: function ($element, attr) {
                            var fn = $parse(attr[directiveName], null, true);
                            return function ngEventHandler(scope, element) {
                                element.on(eventName, function (event) {
                                    var callback = function () {
                                        fn(scope, { $event: event });
                                    };
                                    if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                        scope.$evalAsync(callback);
                                    } else {
                                        scope.$apply(callback);
                                    }
                                });
                            };
                        }
                    };
                }
            ];
        });
        var ngIfDirective = [
            '$animate',
            function ($animate) {
                return {
                    multiElement: true,
                    transclude: 'element',
                    priority: 600,
                    terminal: true,
                    restrict: 'A',
                    $$tlb: true,
                    link: function ($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                            if (value) {
                                if (!childScope) {
                                    $transclude(function (clone, newScope) {
                                        childScope = newScope;
                                        clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                                        block = { clone: clone };
                                        $animate.enter(clone, $element.parent(), $element);
                                    });
                                }
                            } else {
                                if (previousElements) {
                                    previousElements.remove();
                                    previousElements = null;
                                }
                                if (childScope) {
                                    childScope.$destroy();
                                    childScope = null;
                                }
                                if (block) {
                                    previousElements = getBlockNodes(block.clone);
                                    $animate.leave(previousElements).then(function () {
                                        previousElements = null;
                                    });
                                    block = null;
                                }
                            }
                        });
                    }
                };
            }
        ];
        var ngIncludeDirective = [
            '$templateRequest',
            '$anchorScroll',
            '$animate',
            function ($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: 'ECA',
                    priority: 400,
                    terminal: true,
                    transclude: 'element',
                    controller: angular.noop,
                    compile: function (element, attr) {
                        var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
                        return function (scope, $element, $attr, ctrl, $transclude) {
                            var changeCounter = 0, currentScope, previousElement, currentElement;
                            var cleanupLastIncludeContent = function () {
                                if (previousElement) {
                                    previousElement.remove();
                                    previousElement = null;
                                }
                                if (currentScope) {
                                    currentScope.$destroy();
                                    currentScope = null;
                                }
                                if (currentElement) {
                                    $animate.leave(currentElement).then(function () {
                                        previousElement = null;
                                    });
                                    previousElement = currentElement;
                                    currentElement = null;
                                }
                            };
                            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                                var afterAnimation = function () {
                                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                        $anchorScroll();
                                    }
                                };
                                var thisChangeId = ++changeCounter;
                                if (src) {
                                    $templateRequest(src, true).then(function (response) {
                                        if (thisChangeId !== changeCounter)
                                            return;
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, function (clone) {
                                            cleanupLastIncludeContent();
                                            $animate.enter(clone, null, $element).then(afterAnimation);
                                        });
                                        currentScope = newScope;
                                        currentElement = clone;
                                        currentScope.$emit('$includeContentLoaded', src);
                                        scope.$eval(onloadExp);
                                    }, function () {
                                        if (thisChangeId === changeCounter) {
                                            cleanupLastIncludeContent();
                                            scope.$emit('$includeContentError', src);
                                        }
                                    });
                                    scope.$emit('$includeContentRequested', src);
                                } else {
                                    cleanupLastIncludeContent();
                                    ctrl.template = null;
                                }
                            });
                        };
                    }
                };
            }
        ];
        var ngIncludeFillContentDirective = [
            '$compile',
            function ($compile) {
                return {
                    restrict: 'ECA',
                    priority: -400,
                    require: 'ngInclude',
                    link: function (scope, $element, $attr, ctrl) {
                        if (/SVG/.test($element[0].toString())) {
                            $element.empty();
                            $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                                $element.append(clone);
                            }, { futureParentElement: $element });
                            return;
                        }
                        $element.html(ctrl.template);
                        $compile($element.contents())(scope);
                    }
                };
            }
        ];
        var ngInitDirective = ngDirective({
            priority: 450,
            compile: function () {
                return {
                    pre: function (scope, element, attrs) {
                        scope.$eval(attrs.ngInit);
                    }
                };
            }
        });
        var ngListDirective = function () {
            return {
                restrict: 'A',
                priority: 100,
                require: 'ngModel',
                link: function (scope, element, attr, ctrl) {
                    var ngList = element.attr(attr.$attr.ngList) || ', ';
                    var trimValues = attr.ngTrim !== 'false';
                    var separator = trimValues ? trim(ngList) : ngList;
                    var parse = function (viewValue) {
                        if (isUndefined(viewValue))
                            return;
                        var list = [];
                        if (viewValue) {
                            forEach(viewValue.split(separator), function (value) {
                                if (value)
                                    list.push(trimValues ? trim(value) : value);
                            });
                        }
                        return list;
                    };
                    ctrl.$parsers.push(parse);
                    ctrl.$formatters.push(function (value) {
                        if (isArray(value)) {
                            return value.join(ngList);
                        }
                        return undefined;
                    });
                    ctrl.$isEmpty = function (value) {
                        return !value || !value.length;
                    };
                }
            };
        };
        var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty', UNTOUCHED_CLASS = 'ng-untouched', TOUCHED_CLASS = 'ng-touched', PENDING_CLASS = 'ng-pending';
        var ngModelMinErr = minErr('ngModel');
        var NgModelController = [
            '$scope',
            '$exceptionHandler',
            '$attrs',
            '$element',
            '$parse',
            '$animate',
            '$timeout',
            '$rootScope',
            '$q',
            '$interpolate',
            function ($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
                this.$viewValue = Number.NaN;
                this.$modelValue = Number.NaN;
                this.$$rawModelValue = undefined;
                this.$validators = {};
                this.$asyncValidators = {};
                this.$parsers = [];
                this.$formatters = [];
                this.$viewChangeListeners = [];
                this.$untouched = true;
                this.$touched = false;
                this.$pristine = true;
                this.$dirty = false;
                this.$valid = true;
                this.$invalid = false;
                this.$error = {};
                this.$$success = {};
                this.$pending = undefined;
                this.$name = $interpolate($attr.name || '', false)($scope);
                this.$$parentForm = nullFormCtrl;
                var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, parserValid, ctrl = this;
                this.$$setOptions = function (options) {
                    ctrl.$options = options;
                    if (options && options.getterSetter) {
                        var invokeModelGetter = $parse($attr.ngModel + '()'), invokeModelSetter = $parse($attr.ngModel + '($$$p)');
                        ngModelGet = function ($scope) {
                            var modelValue = parsedNgModel($scope);
                            if (isFunction(modelValue)) {
                                modelValue = invokeModelGetter($scope);
                            }
                            return modelValue;
                        };
                        ngModelSet = function ($scope, newValue) {
                            if (isFunction(parsedNgModel($scope))) {
                                invokeModelSetter($scope, { $$$p: ctrl.$modelValue });
                            } else {
                                parsedNgModelAssign($scope, ctrl.$modelValue);
                            }
                        };
                    } else if (!parsedNgModel.assign) {
                        throw ngModelMinErr('nonassign', 'Expression \'{0}\' is non-assignable. Element: {1}', $attr.ngModel, startingTag($element));
                    }
                };
                this.$render = noop;
                this.$isEmpty = function (value) {
                    return isUndefined(value) || value === '' || value === null || value !== value;
                };
                var currentValidationRunId = 0;
                addSetValidityMethod({
                    ctrl: this,
                    $element: $element,
                    set: function (object, property) {
                        object[property] = true;
                    },
                    unset: function (object, property) {
                        delete object[property];
                    },
                    $animate: $animate
                });
                this.$setPristine = function () {
                    ctrl.$dirty = false;
                    ctrl.$pristine = true;
                    $animate.removeClass($element, DIRTY_CLASS);
                    $animate.addClass($element, PRISTINE_CLASS);
                };
                this.$setDirty = function () {
                    ctrl.$dirty = true;
                    ctrl.$pristine = false;
                    $animate.removeClass($element, PRISTINE_CLASS);
                    $animate.addClass($element, DIRTY_CLASS);
                    ctrl.$$parentForm.$setDirty();
                };
                this.$setUntouched = function () {
                    ctrl.$touched = false;
                    ctrl.$untouched = true;
                    $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
                };
                this.$setTouched = function () {
                    ctrl.$touched = true;
                    ctrl.$untouched = false;
                    $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
                };
                this.$rollbackViewValue = function () {
                    $timeout.cancel(pendingDebounce);
                    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
                    ctrl.$render();
                };
                this.$validate = function () {
                    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                        return;
                    }
                    var viewValue = ctrl.$$lastCommittedViewValue;
                    var modelValue = ctrl.$$rawModelValue;
                    var prevValid = ctrl.$valid;
                    var prevModelValue = ctrl.$modelValue;
                    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                    ctrl.$$runValidators(modelValue, viewValue, function (allValid) {
                        if (!allowInvalid && prevValid !== allValid) {
                            ctrl.$modelValue = allValid ? modelValue : undefined;
                            if (ctrl.$modelValue !== prevModelValue) {
                                ctrl.$$writeModelToScope();
                            }
                        }
                    });
                };
                this.$$runValidators = function (modelValue, viewValue, doneCallback) {
                    currentValidationRunId++;
                    var localValidationRunId = currentValidationRunId;
                    if (!processParseErrors()) {
                        validationDone(false);
                        return;
                    }
                    if (!processSyncValidators()) {
                        validationDone(false);
                        return;
                    }
                    processAsyncValidators();
                    function processParseErrors() {
                        var errorKey = ctrl.$$parserName || 'parse';
                        if (isUndefined(parserValid)) {
                            setValidity(errorKey, null);
                        } else {
                            if (!parserValid) {
                                forEach(ctrl.$validators, function (v, name) {
                                    setValidity(name, null);
                                });
                                forEach(ctrl.$asyncValidators, function (v, name) {
                                    setValidity(name, null);
                                });
                            }
                            setValidity(errorKey, parserValid);
                            return parserValid;
                        }
                        return true;
                    }
                    function processSyncValidators() {
                        var syncValidatorsValid = true;
                        forEach(ctrl.$validators, function (validator, name) {
                            var result = validator(modelValue, viewValue);
                            syncValidatorsValid = syncValidatorsValid && result;
                            setValidity(name, result);
                        });
                        if (!syncValidatorsValid) {
                            forEach(ctrl.$asyncValidators, function (v, name) {
                                setValidity(name, null);
                            });
                            return false;
                        }
                        return true;
                    }
                    function processAsyncValidators() {
                        var validatorPromises = [];
                        var allValid = true;
                        forEach(ctrl.$asyncValidators, function (validator, name) {
                            var promise = validator(modelValue, viewValue);
                            if (!isPromiseLike(promise)) {
                                throw ngModelMinErr('$asyncValidators', 'Expected asynchronous validator to return a promise but got \'{0}\' instead.', promise);
                            }
                            setValidity(name, undefined);
                            validatorPromises.push(promise.then(function () {
                                setValidity(name, true);
                            }, function (error) {
                                allValid = false;
                                setValidity(name, false);
                            }));
                        });
                        if (!validatorPromises.length) {
                            validationDone(true);
                        } else {
                            $q.all(validatorPromises).then(function () {
                                validationDone(allValid);
                            }, noop);
                        }
                    }
                    function setValidity(name, isValid) {
                        if (localValidationRunId === currentValidationRunId) {
                            ctrl.$setValidity(name, isValid);
                        }
                    }
                    function validationDone(allValid) {
                        if (localValidationRunId === currentValidationRunId) {
                            doneCallback(allValid);
                        }
                    }
                };
                this.$commitViewValue = function () {
                    var viewValue = ctrl.$viewValue;
                    $timeout.cancel(pendingDebounce);
                    if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
                        return;
                    }
                    ctrl.$$lastCommittedViewValue = viewValue;
                    if (ctrl.$pristine) {
                        this.$setDirty();
                    }
                    this.$$parseAndValidate();
                };
                this.$$parseAndValidate = function () {
                    var viewValue = ctrl.$$lastCommittedViewValue;
                    var modelValue = viewValue;
                    parserValid = isUndefined(modelValue) ? undefined : true;
                    if (parserValid) {
                        for (var i = 0; i < ctrl.$parsers.length; i++) {
                            modelValue = ctrl.$parsers[i](modelValue);
                            if (isUndefined(modelValue)) {
                                parserValid = false;
                                break;
                            }
                        }
                    }
                    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                        ctrl.$modelValue = ngModelGet($scope);
                    }
                    var prevModelValue = ctrl.$modelValue;
                    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                    ctrl.$$rawModelValue = modelValue;
                    if (allowInvalid) {
                        ctrl.$modelValue = modelValue;
                        writeToModelIfNeeded();
                    }
                    ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function (allValid) {
                        if (!allowInvalid) {
                            ctrl.$modelValue = allValid ? modelValue : undefined;
                            writeToModelIfNeeded();
                        }
                    });
                    function writeToModelIfNeeded() {
                        if (ctrl.$modelValue !== prevModelValue) {
                            ctrl.$$writeModelToScope();
                        }
                    }
                };
                this.$$writeModelToScope = function () {
                    ngModelSet($scope, ctrl.$modelValue);
                    forEach(ctrl.$viewChangeListeners, function (listener) {
                        try {
                            listener();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                };
                this.$setViewValue = function (value, trigger) {
                    ctrl.$viewValue = value;
                    if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                        ctrl.$$debounceViewValueCommit(trigger);
                    }
                };
                this.$$debounceViewValueCommit = function (trigger) {
                    var debounceDelay = 0, options = ctrl.$options, debounce;
                    if (options && isDefined(options.debounce)) {
                        debounce = options.debounce;
                        if (isNumber(debounce)) {
                            debounceDelay = debounce;
                        } else if (isNumber(debounce[trigger])) {
                            debounceDelay = debounce[trigger];
                        } else if (isNumber(debounce['default'])) {
                            debounceDelay = debounce['default'];
                        }
                    }
                    $timeout.cancel(pendingDebounce);
                    if (debounceDelay) {
                        pendingDebounce = $timeout(function () {
                            ctrl.$commitViewValue();
                        }, debounceDelay);
                    } else if ($rootScope.$$phase) {
                        ctrl.$commitViewValue();
                    } else {
                        $scope.$apply(function () {
                            ctrl.$commitViewValue();
                        });
                    }
                };
                $scope.$watch(function ngModelWatch() {
                    var modelValue = ngModelGet($scope);
                    if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                        ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                        parserValid = undefined;
                        var formatters = ctrl.$formatters, idx = formatters.length;
                        var viewValue = modelValue;
                        while (idx--) {
                            viewValue = formatters[idx](viewValue);
                        }
                        if (ctrl.$viewValue !== viewValue) {
                            ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                            ctrl.$render();
                            ctrl.$$runValidators(modelValue, viewValue, noop);
                        }
                    }
                    return modelValue;
                });
            }
        ];
        var ngModelDirective = [
            '$rootScope',
            function ($rootScope) {
                return {
                    restrict: 'A',
                    require: [
                        'ngModel',
                        '^?form',
                        '^?ngModelOptions'
                    ],
                    controller: NgModelController,
                    priority: 1,
                    compile: function ngModelCompile(element) {
                        element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                        return {
                            pre: function ngModelPreLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                                formCtrl.$addControl(modelCtrl);
                                attr.$observe('name', function (newValue) {
                                    if (modelCtrl.$name !== newValue) {
                                        modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                                    }
                                });
                                scope.$on('$destroy', function () {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                                });
                            },
                            post: function ngModelPostLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0];
                                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                                    element.on(modelCtrl.$options.updateOn, function (ev) {
                                        modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                                    });
                                }
                                element.on('blur', function (ev) {
                                    if (modelCtrl.$touched)
                                        return;
                                    if ($rootScope.$$phase) {
                                        scope.$evalAsync(modelCtrl.$setTouched);
                                    } else {
                                        scope.$apply(modelCtrl.$setTouched);
                                    }
                                });
                            }
                        };
                    }
                };
            }
        ];
        var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
        var ngModelOptionsDirective = function () {
            return {
                restrict: 'A',
                controller: [
                    '$scope',
                    '$attrs',
                    function ($scope, $attrs) {
                        var that = this;
                        this.$options = copy($scope.$eval($attrs.ngModelOptions));
                        if (isDefined(this.$options.updateOn)) {
                            this.$options.updateOnDefault = false;
                            this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function () {
                                that.$options.updateOnDefault = true;
                                return ' ';
                            }));
                        } else {
                            this.$options.updateOnDefault = true;
                        }
                    }
                ]
            };
        };
        function addSetValidityMethod(context) {
            var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, $animate = context.$animate;
            classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
            ctrl.$setValidity = setValidity;
            function setValidity(validationErrorKey, state, controller) {
                if (isUndefined(state)) {
                    createAndSet('$pending', validationErrorKey, controller);
                } else {
                    unsetAndCleanup('$pending', validationErrorKey, controller);
                }
                if (!isBoolean(state)) {
                    unset(ctrl.$error, validationErrorKey, controller);
                    unset(ctrl.$$success, validationErrorKey, controller);
                } else {
                    if (state) {
                        unset(ctrl.$error, validationErrorKey, controller);
                        set(ctrl.$$success, validationErrorKey, controller);
                    } else {
                        set(ctrl.$error, validationErrorKey, controller);
                        unset(ctrl.$$success, validationErrorKey, controller);
                    }
                }
                if (ctrl.$pending) {
                    cachedToggleClass(PENDING_CLASS, true);
                    ctrl.$valid = ctrl.$invalid = undefined;
                    toggleValidationCss('', null);
                } else {
                    cachedToggleClass(PENDING_CLASS, false);
                    ctrl.$valid = isObjectEmpty(ctrl.$error);
                    ctrl.$invalid = !ctrl.$valid;
                    toggleValidationCss('', ctrl.$valid);
                }
                var combinedState;
                if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                    combinedState = undefined;
                } else if (ctrl.$error[validationErrorKey]) {
                    combinedState = false;
                } else if (ctrl.$$success[validationErrorKey]) {
                    combinedState = true;
                } else {
                    combinedState = null;
                }
                toggleValidationCss(validationErrorKey, combinedState);
                ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
            }
            function createAndSet(name, value, controller) {
                if (!ctrl[name]) {
                    ctrl[name] = {};
                }
                set(ctrl[name], value, controller);
            }
            function unsetAndCleanup(name, value, controller) {
                if (ctrl[name]) {
                    unset(ctrl[name], value, controller);
                }
                if (isObjectEmpty(ctrl[name])) {
                    ctrl[name] = undefined;
                }
            }
            function cachedToggleClass(className, switchValue) {
                if (switchValue && !classCache[className]) {
                    $animate.addClass($element, className);
                    classCache[className] = true;
                } else if (!switchValue && classCache[className]) {
                    $animate.removeClass($element, className);
                    classCache[className] = false;
                }
            }
            function toggleValidationCss(validationErrorKey, isValid) {
                validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
                cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
                cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
            }
        }
        function isObjectEmpty(obj) {
            if (obj) {
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        return false;
                    }
                }
            }
            return true;
        }
        var ngNonBindableDirective = ngDirective({
            terminal: true,
            priority: 1000
        });
        var ngOptionsMinErr = minErr('ngOptions');
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
        var ngOptionsDirective = [
            '$compile',
            '$parse',
            function ($compile, $parse) {
                function parseOptionsExpression(optionsExp, selectElement, scope) {
                    var match = optionsExp.match(NG_OPTIONS_REGEXP);
                    if (!match) {
                        throw ngOptionsMinErr('iexp', 'Expected expression in form of ' + '\'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'{0}\'. Element: {1}', optionsExp, startingTag(selectElement));
                    }
                    var valueName = match[5] || match[7];
                    var keyName = match[6];
                    var selectAs = / as /.test(match[0]) && match[1];
                    var trackBy = match[9];
                    var valueFn = $parse(match[2] ? match[1] : valueName);
                    var selectAsFn = selectAs && $parse(selectAs);
                    var viewValueFn = selectAsFn || valueFn;
                    var trackByFn = trackBy && $parse(trackBy);
                    var getTrackByValueFn = trackBy ? function (value, locals) {
                        return trackByFn(scope, locals);
                    } : function getHashOfValue(value) {
                        return hashKey(value);
                    };
                    var getTrackByValue = function (value, key) {
                        return getTrackByValueFn(value, getLocals(value, key));
                    };
                    var displayFn = $parse(match[2] || match[1]);
                    var groupByFn = $parse(match[3] || '');
                    var disableWhenFn = $parse(match[4] || '');
                    var valuesFn = $parse(match[8]);
                    var locals = {};
                    var getLocals = keyName ? function (value, key) {
                        locals[keyName] = key;
                        locals[valueName] = value;
                        return locals;
                    } : function (value) {
                        locals[valueName] = value;
                        return locals;
                    };
                    function Option(selectValue, viewValue, label, group, disabled) {
                        this.selectValue = selectValue;
                        this.viewValue = viewValue;
                        this.label = label;
                        this.group = group;
                        this.disabled = disabled;
                    }
                    function getOptionValuesKeys(optionValues) {
                        var optionValuesKeys;
                        if (!keyName && isArrayLike(optionValues)) {
                            optionValuesKeys = optionValues;
                        } else {
                            optionValuesKeys = [];
                            for (var itemKey in optionValues) {
                                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                                    optionValuesKeys.push(itemKey);
                                }
                            }
                        }
                        return optionValuesKeys;
                    }
                    return {
                        trackBy: trackBy,
                        getTrackByValue: getTrackByValue,
                        getWatchables: $parse(valuesFn, function (optionValues) {
                            var watchedArray = [];
                            optionValues = optionValues || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(optionValues[key], key);
                                var selectValue = getTrackByValueFn(optionValues[key], locals);
                                watchedArray.push(selectValue);
                                if (match[2] || match[1]) {
                                    var label = displayFn(scope, locals);
                                    watchedArray.push(label);
                                }
                                if (match[4]) {
                                    var disableWhen = disableWhenFn(scope, locals);
                                    watchedArray.push(disableWhen);
                                }
                            }
                            return watchedArray;
                        }),
                        getOptions: function () {
                            var optionItems = [];
                            var selectValueMap = {};
                            var optionValues = valuesFn(scope) || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(value, key);
                                var viewValue = viewValueFn(scope, locals);
                                var selectValue = getTrackByValueFn(viewValue, locals);
                                var label = displayFn(scope, locals);
                                var group = groupByFn(scope, locals);
                                var disabled = disableWhenFn(scope, locals);
                                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                                optionItems.push(optionItem);
                                selectValueMap[selectValue] = optionItem;
                            }
                            return {
                                items: optionItems,
                                selectValueMap: selectValueMap,
                                getOptionFromViewValue: function (value) {
                                    return selectValueMap[getTrackByValue(value)];
                                },
                                getViewValueFromOption: function (option) {
                                    return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                                }
                            };
                        }
                    };
                }
                var optionTemplate = document.createElement('option'), optGroupTemplate = document.createElement('optgroup');
                function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                    var ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl)
                        return;
                    var selectCtrl = ctrls[0];
                    var multiple = attr.multiple;
                    var emptyOption;
                    for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                        if (children[i].value === '') {
                            emptyOption = children.eq(i);
                            break;
                        }
                    }
                    var providedEmptyOption = !!emptyOption;
                    var unknownOption = jqLite(optionTemplate.cloneNode(false));
                    unknownOption.val('?');
                    var options;
                    var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
                    var renderEmptyOption = function () {
                        if (!providedEmptyOption) {
                            selectElement.prepend(emptyOption);
                        }
                        selectElement.val('');
                        emptyOption.prop('selected', true);
                        emptyOption.attr('selected', true);
                    };
                    var removeEmptyOption = function () {
                        if (!providedEmptyOption) {
                            emptyOption.remove();
                        }
                    };
                    var renderUnknownOption = function () {
                        selectElement.prepend(unknownOption);
                        selectElement.val('?');
                        unknownOption.prop('selected', true);
                        unknownOption.attr('selected', true);
                    };
                    var removeUnknownOption = function () {
                        unknownOption.remove();
                    };
                    if (!multiple) {
                        selectCtrl.writeValue = function writeNgOptionsValue(value) {
                            var option = options.getOptionFromViewValue(value);
                            if (option && !option.disabled) {
                                if (selectElement[0].value !== option.selectValue) {
                                    removeUnknownOption();
                                    removeEmptyOption();
                                    selectElement[0].value = option.selectValue;
                                    option.element.selected = true;
                                    option.element.setAttribute('selected', 'selected');
                                }
                            } else {
                                if (value === null || providedEmptyOption) {
                                    removeUnknownOption();
                                    renderEmptyOption();
                                } else {
                                    removeEmptyOption();
                                    renderUnknownOption();
                                }
                            }
                        };
                        selectCtrl.readValue = function readNgOptionsValue() {
                            var selectedOption = options.selectValueMap[selectElement.val()];
                            if (selectedOption && !selectedOption.disabled) {
                                removeEmptyOption();
                                removeUnknownOption();
                                return options.getViewValueFromOption(selectedOption);
                            }
                            return null;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watch(function () {
                                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                            }, function () {
                                ngModelCtrl.$render();
                            });
                        }
                    } else {
                        ngModelCtrl.$isEmpty = function (value) {
                            return !value || value.length === 0;
                        };
                        selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                            options.items.forEach(function (option) {
                                option.element.selected = false;
                            });
                            if (value) {
                                value.forEach(function (item) {
                                    var option = options.getOptionFromViewValue(item);
                                    if (option && !option.disabled)
                                        option.element.selected = true;
                                });
                            }
                        };
                        selectCtrl.readValue = function readNgOptionsMultiple() {
                            var selectedValues = selectElement.val() || [], selections = [];
                            forEach(selectedValues, function (value) {
                                var option = options.selectValueMap[value];
                                if (option && !option.disabled)
                                    selections.push(options.getViewValueFromOption(option));
                            });
                            return selections;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watchCollection(function () {
                                if (isArray(ngModelCtrl.$viewValue)) {
                                    return ngModelCtrl.$viewValue.map(function (value) {
                                        return ngOptions.getTrackByValue(value);
                                    });
                                }
                            }, function () {
                                ngModelCtrl.$render();
                            });
                        }
                    }
                    if (providedEmptyOption) {
                        emptyOption.remove();
                        $compile(emptyOption)(scope);
                        emptyOption.removeClass('ng-scope');
                    } else {
                        emptyOption = jqLite(optionTemplate.cloneNode(false));
                    }
                    updateOptions();
                    scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                    function updateOptionElement(option, element) {
                        option.element = element;
                        element.disabled = option.disabled;
                        if (option.label !== element.label) {
                            element.label = option.label;
                            element.textContent = option.label;
                        }
                        if (option.value !== element.value)
                            element.value = option.selectValue;
                    }
                    function addOrReuseElement(parent, current, type, templateElement) {
                        var element;
                        if (current && lowercase(current.nodeName) === type) {
                            element = current;
                        } else {
                            element = templateElement.cloneNode(false);
                            if (!current) {
                                parent.appendChild(element);
                            } else {
                                parent.insertBefore(element, current);
                            }
                        }
                        return element;
                    }
                    function removeExcessElements(current) {
                        var next;
                        while (current) {
                            next = current.nextSibling;
                            jqLiteRemove(current);
                            current = next;
                        }
                    }
                    function skipEmptyAndUnknownOptions(current) {
                        var emptyOption_ = emptyOption && emptyOption[0];
                        var unknownOption_ = unknownOption && unknownOption[0];
                        if (emptyOption_ || unknownOption_) {
                            while (current && (current === emptyOption_ || current === unknownOption_ || current.nodeType === NODE_TYPE_COMMENT || current.value === '')) {
                                current = current.nextSibling;
                            }
                        }
                        return current;
                    }
                    function updateOptions() {
                        var previousValue = options && selectCtrl.readValue();
                        options = ngOptions.getOptions();
                        var groupMap = {};
                        var currentElement = selectElement[0].firstChild;
                        if (providedEmptyOption) {
                            selectElement.prepend(emptyOption);
                        }
                        currentElement = skipEmptyAndUnknownOptions(currentElement);
                        options.items.forEach(function updateOption(option) {
                            var group;
                            var groupElement;
                            var optionElement;
                            if (option.group) {
                                group = groupMap[option.group];
                                if (!group) {
                                    groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                                    currentElement = groupElement.nextSibling;
                                    groupElement.label = option.group;
                                    group = groupMap[option.group] = {
                                        groupElement: groupElement,
                                        currentOptionElement: groupElement.firstChild
                                    };
                                }
                                optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                                updateOptionElement(option, optionElement);
                                group.currentOptionElement = optionElement.nextSibling;
                            } else {
                                optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                                updateOptionElement(option, optionElement);
                                currentElement = optionElement.nextSibling;
                            }
                        });
                        Object.keys(groupMap).forEach(function (key) {
                            removeExcessElements(groupMap[key].currentOptionElement);
                        });
                        removeExcessElements(currentElement);
                        ngModelCtrl.$render();
                        if (!ngModelCtrl.$isEmpty(previousValue)) {
                            var nextValue = selectCtrl.readValue();
                            if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                                ngModelCtrl.$setViewValue(nextValue);
                                ngModelCtrl.$render();
                            }
                        }
                    }
                }
                return {
                    restrict: 'A',
                    terminal: true,
                    require: [
                        'select',
                        '?ngModel'
                    ],
                    link: {
                        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop;
                        },
                        post: ngOptionsPostLink
                    }
                };
            }
        ];
        var ngPluralizeDirective = [
            '$locale',
            '$interpolate',
            '$log',
            function ($locale, $interpolate, $log) {
                var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function (scope, element, attr) {
                        var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol, watchRemover = angular.noop, lastCount;
                        forEach(attr, function (expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName]);
                            }
                        });
                        forEach(whens, function (expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                        });
                        scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                            var count = parseFloat(newVal);
                            var countIsNaN = isNaN(count);
                            if (!countIsNaN && !(count in whens)) {
                                count = $locale.pluralCat(count - offset);
                            }
                            if (count !== lastCount && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                if (isUndefined(whenExpFn)) {
                                    if (newVal != null) {
                                        $log.debug('ngPluralize: no rule defined for \'' + count + '\' in ' + whenExp);
                                    }
                                    watchRemover = noop;
                                    updateElementText();
                                } else {
                                    watchRemover = scope.$watch(whenExpFn, updateElementText);
                                }
                                lastCount = count;
                            }
                        });
                        function updateElementText(newText) {
                            element.text(newText || '');
                        }
                    }
                };
            }
        ];
        var ngRepeatDirective = [
            '$parse',
            '$animate',
            function ($parse, $animate) {
                var NG_REMOVED = '$$NG_REMOVED';
                var ngRepeatMinErr = minErr('ngRepeat');
                var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                    scope[valueIdentifier] = value;
                    if (keyIdentifier)
                        scope[keyIdentifier] = key;
                    scope.$index = index;
                    scope.$first = index === 0;
                    scope.$last = index === arrayLength - 1;
                    scope.$middle = !(scope.$first || scope.$last);
                    scope.$odd = !(scope.$even = (index & 1) === 0);
                };
                var getBlockStart = function (block) {
                    return block.clone[0];
                };
                var getBlockEnd = function (block) {
                    return block.clone[block.clone.length - 1];
                };
                return {
                    restrict: 'A',
                    multiElement: true,
                    transclude: 'element',
                    priority: 1000,
                    terminal: true,
                    $$tlb: true,
                    compile: function ngRepeatCompile($element, $attr) {
                        var expression = $attr.ngRepeat;
                        var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
                        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) {
                            throw ngRepeatMinErr('iexp', 'Expected expression in form of \'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.', expression);
                        }
                        var lhs = match[1];
                        var rhs = match[2];
                        var aliasAs = match[3];
                        var trackByExp = match[4];
                        match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                        if (!match) {
                            throw ngRepeatMinErr('iidexp', '\'_item_\' in \'_item_ in _collection_\' should be an identifier or \'(_key_, _value_)\' expression, but got \'{0}\'.', lhs);
                        }
                        var valueIdentifier = match[3] || match[1];
                        var keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                            throw ngRepeatMinErr('badident', 'alias \'{0}\' is invalid --- must be a valid JS identifier which is not a reserved name.', aliasAs);
                        }
                        var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                        var hashFnLocals = { $id: hashKey };
                        if (trackByExp) {
                            trackByExpGetter = $parse(trackByExp);
                        } else {
                            trackByIdArrayFn = function (key, value) {
                                return hashKey(value);
                            };
                            trackByIdObjFn = function (key) {
                                return key;
                            };
                        }
                        return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                            if (trackByExpGetter) {
                                trackByIdExpFn = function (key, value, index) {
                                    if (keyIdentifier)
                                        hashFnLocals[keyIdentifier] = key;
                                    hashFnLocals[valueIdentifier] = value;
                                    hashFnLocals.$index = index;
                                    return trackByExpGetter($scope, hashFnLocals);
                                };
                            }
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                                var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                                if (aliasAs) {
                                    $scope[aliasAs] = collection;
                                }
                                if (isArrayLike(collection)) {
                                    collectionKeys = collection;
                                    trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                } else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                                    collectionKeys = [];
                                    for (var itemKey in collection) {
                                        if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                                            collectionKeys.push(itemKey);
                                        }
                                    }
                                }
                                collectionLength = collectionKeys.length;
                                nextBlockOrder = new Array(collectionLength);
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    trackById = trackByIdFn(key, value, index);
                                    if (lastBlockMap[trackById]) {
                                        block = lastBlockMap[trackById];
                                        delete lastBlockMap[trackById];
                                        nextBlockMap[trackById] = block;
                                        nextBlockOrder[index] = block;
                                    } else if (nextBlockMap[trackById]) {
                                        forEach(nextBlockOrder, function (block) {
                                            if (block && block.scope)
                                                lastBlockMap[block.id] = block;
                                        });
                                        throw ngRepeatMinErr('dupes', 'Duplicates in a repeater are not allowed. Use \'track by\' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}', expression, trackById, value);
                                    } else {
                                        nextBlockOrder[index] = {
                                            id: trackById,
                                            scope: undefined,
                                            clone: undefined
                                        };
                                        nextBlockMap[trackById] = true;
                                    }
                                }
                                for (var blockKey in lastBlockMap) {
                                    block = lastBlockMap[blockKey];
                                    elementsToRemove = getBlockNodes(block.clone);
                                    $animate.leave(elementsToRemove);
                                    if (elementsToRemove[0].parentNode) {
                                        for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                            elementsToRemove[index][NG_REMOVED] = true;
                                        }
                                    }
                                    block.scope.$destroy();
                                }
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    block = nextBlockOrder[index];
                                    if (block.scope) {
                                        nextNode = previousNode;
                                        do {
                                            nextNode = nextNode.nextSibling;
                                        } while (nextNode && nextNode[NG_REMOVED]);
                                        if (getBlockStart(block) != nextNode) {
                                            $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                                        }
                                        previousNode = getBlockEnd(block);
                                        updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                    } else {
                                        $transclude(function ngRepeatTransclude(clone, scope) {
                                            block.scope = scope;
                                            var endNode = ngRepeatEndComment.cloneNode(false);
                                            clone[clone.length++] = endNode;
                                            $animate.enter(clone, null, jqLite(previousNode));
                                            previousNode = endNode;
                                            block.clone = clone;
                                            nextBlockMap[block.id] = block;
                                            updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                        });
                                    }
                                }
                                lastBlockMap = nextBlockMap;
                            });
                        };
                    }
                };
            }
        ];
        var NG_HIDE_CLASS = 'ng-hide';
        var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
        var ngShowDirective = [
            '$animate',
            function ($animate) {
                return {
                    restrict: 'A',
                    multiElement: true,
                    link: function (scope, element, attr) {
                        scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                            $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                        });
                    }
                };
            }
        ];
        var ngHideDirective = [
            '$animate',
            function ($animate) {
                return {
                    restrict: 'A',
                    multiElement: true,
                    link: function (scope, element, attr) {
                        scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                            $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                        });
                    }
                };
            }
        ];
        var ngStyleDirective = ngDirective(function (scope, element, attr) {
            scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
                if (oldStyles && newStyles !== oldStyles) {
                    forEach(oldStyles, function (val, style) {
                        element.css(style, '');
                    });
                }
                if (newStyles)
                    element.css(newStyles);
            }, true);
        });
        var ngSwitchDirective = [
            '$animate',
            function ($animate) {
                return {
                    require: 'ngSwitch',
                    controller: [
                        '$scope',
                        function ngSwitchController() {
                            this.cases = {};
                        }
                    ],
                    link: function (scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                        var spliceFactory = function (array, index) {
                            return function () {
                                array.splice(index, 1);
                            };
                        };
                        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                            var i, ii;
                            for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                                $animate.cancel(previousLeaveAnimations[i]);
                            }
                            previousLeaveAnimations.length = 0;
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy();
                                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                                promise.then(spliceFactory(previousLeaveAnimations, i));
                            }
                            selectedElements.length = 0;
                            selectedScopes.length = 0;
                            if (selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?']) {
                                forEach(selectedTranscludes, function (selectedTransclude) {
                                    selectedTransclude.transclude(function (caseElement, selectedScope) {
                                        selectedScopes.push(selectedScope);
                                        var anchor = selectedTransclude.element;
                                        caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                                        var block = { clone: caseElement };
                                        selectedElements.push(block);
                                        $animate.enter(caseElement, anchor.parent(), anchor);
                                    });
                                });
                            }
                        });
                    }
                };
            }
        ];
        var ngSwitchWhenDirective = ngDirective({
            transclude: 'element',
            priority: 1200,
            require: '^ngSwitch',
            multiElement: true,
            link: function (scope, element, attrs, ctrl, $transclude) {
                ctrl.cases['!' + attrs.ngSwitchWhen] = ctrl.cases['!' + attrs.ngSwitchWhen] || [];
                ctrl.cases['!' + attrs.ngSwitchWhen].push({
                    transclude: $transclude,
                    element: element
                });
            }
        });
        var ngSwitchDefaultDirective = ngDirective({
            transclude: 'element',
            priority: 1200,
            require: '^ngSwitch',
            multiElement: true,
            link: function (scope, element, attr, ctrl, $transclude) {
                ctrl.cases['?'] = ctrl.cases['?'] || [];
                ctrl.cases['?'].push({
                    transclude: $transclude,
                    element: element
                });
            }
        });
        var ngTranscludeDirective = ngDirective({
            restrict: 'EAC',
            link: function ($scope, $element, $attrs, controller, $transclude) {
                if (!$transclude) {
                    throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
                }
                $transclude(function (clone) {
                    $element.empty();
                    $element.append(clone);
                });
            }
        });
        var scriptDirective = [
            '$templateCache',
            function ($templateCache) {
                return {
                    restrict: 'E',
                    terminal: true,
                    compile: function (element, attr) {
                        if (attr.type == 'text/ng-template') {
                            var templateUrl = attr.id, text = element[0].text;
                            $templateCache.put(templateUrl, text);
                        }
                    }
                };
            }
        ];
        var noopNgModelController = {
            $setViewValue: noop,
            $render: noop
        };
        function chromeHack(optionElement) {
            if (optionElement[0].hasAttribute('selected')) {
                optionElement[0].selected = true;
            }
        }
        var SelectController = [
            '$element',
            '$scope',
            '$attrs',
            function ($element, $scope, $attrs) {
                var self = this, optionsMap = new HashMap();
                self.ngModelCtrl = noopNgModelController;
                self.unknownOption = jqLite(document.createElement('option'));
                self.renderUnknownOption = function (val) {
                    var unknownVal = '? ' + hashKey(val) + ' ?';
                    self.unknownOption.val(unknownVal);
                    $element.prepend(self.unknownOption);
                    $element.val(unknownVal);
                };
                $scope.$on('$destroy', function () {
                    self.renderUnknownOption = noop;
                });
                self.removeUnknownOption = function () {
                    if (self.unknownOption.parent())
                        self.unknownOption.remove();
                };
                self.readValue = function readSingleValue() {
                    self.removeUnknownOption();
                    return $element.val();
                };
                self.writeValue = function writeSingleValue(value) {
                    if (self.hasOption(value)) {
                        self.removeUnknownOption();
                        $element.val(value);
                        if (value === '')
                            self.emptyOption.prop('selected', true);
                    } else {
                        if (value == null && self.emptyOption) {
                            self.removeUnknownOption();
                            $element.val('');
                        } else {
                            self.renderUnknownOption(value);
                        }
                    }
                };
                self.addOption = function (value, element) {
                    assertNotHasOwnProperty(value, '"option value"');
                    if (value === '') {
                        self.emptyOption = element;
                    }
                    var count = optionsMap.get(value) || 0;
                    optionsMap.put(value, count + 1);
                    self.ngModelCtrl.$render();
                    chromeHack(element);
                };
                self.removeOption = function (value) {
                    var count = optionsMap.get(value);
                    if (count) {
                        if (count === 1) {
                            optionsMap.remove(value);
                            if (value === '') {
                                self.emptyOption = undefined;
                            }
                        } else {
                            optionsMap.put(value, count - 1);
                        }
                    }
                };
                self.hasOption = function (value) {
                    return !!optionsMap.get(value);
                };
                self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    if (interpolateValueFn) {
                        var oldVal;
                        optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
                            if (isDefined(oldVal)) {
                                self.removeOption(oldVal);
                            }
                            oldVal = newVal;
                            self.addOption(newVal, optionElement);
                        });
                    } else if (interpolateTextFn) {
                        optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                            optionAttrs.$set('value', newVal);
                            if (oldVal !== newVal) {
                                self.removeOption(oldVal);
                            }
                            self.addOption(newVal, optionElement);
                        });
                    } else {
                        self.addOption(optionAttrs.value, optionElement);
                    }
                    optionElement.on('$destroy', function () {
                        self.removeOption(optionAttrs.value);
                        self.ngModelCtrl.$render();
                    });
                };
            }
        ];
        var selectDirective = function () {
            return {
                restrict: 'E',
                require: [
                    'select',
                    '?ngModel'
                ],
                controller: SelectController,
                priority: 1,
                link: { pre: selectPreLink }
            };
            function selectPreLink(scope, element, attr, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (!ngModelCtrl)
                    return;
                var selectCtrl = ctrls[0];
                selectCtrl.ngModelCtrl = ngModelCtrl;
                ngModelCtrl.$render = function () {
                    selectCtrl.writeValue(ngModelCtrl.$viewValue);
                };
                element.on('change', function () {
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(selectCtrl.readValue());
                    });
                });
                if (attr.multiple) {
                    selectCtrl.readValue = function readMultipleValue() {
                        var array = [];
                        forEach(element.find('option'), function (option) {
                            if (option.selected) {
                                array.push(option.value);
                            }
                        });
                        return array;
                    };
                    selectCtrl.writeValue = function writeMultipleValue(value) {
                        var items = new HashMap(value);
                        forEach(element.find('option'), function (option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };
                    var lastView, lastViewRef = NaN;
                    scope.$watch(function selectMultipleWatch() {
                        if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                            lastView = shallowCopy(ngModelCtrl.$viewValue);
                            ngModelCtrl.$render();
                        }
                        lastViewRef = ngModelCtrl.$viewValue;
                    });
                    ngModelCtrl.$isEmpty = function (value) {
                        return !value || value.length === 0;
                    };
                }
            }
        };
        var optionDirective = [
            '$interpolate',
            function ($interpolate) {
                return {
                    restrict: 'E',
                    priority: 100,
                    compile: function (element, attr) {
                        if (isDefined(attr.value)) {
                            var interpolateValueFn = $interpolate(attr.value, true);
                        } else {
                            var interpolateTextFn = $interpolate(element.text(), true);
                            if (!interpolateTextFn) {
                                attr.$set('value', element.text());
                            }
                        }
                        return function (scope, element, attr) {
                            var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                            if (selectCtrl) {
                                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                            }
                        };
                    }
                };
            }
        ];
        var styleDirective = valueFn({
            restrict: 'E',
            terminal: false
        });
        var requiredDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    attr.required = true;
                    ctrl.$validators.required = function (modelValue, viewValue) {
                        return !attr.required || !ctrl.$isEmpty(viewValue);
                    };
                    attr.$observe('required', function () {
                        ctrl.$validate();
                    });
                }
            };
        };
        var patternDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe('pattern', function (regex) {
                        if (isString(regex) && regex.length > 0) {
                            regex = new RegExp('^' + regex + '$');
                        }
                        if (regex && !regex.test) {
                            throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
                        }
                        regexp = regex || undefined;
                        ctrl.$validate();
                    });
                    ctrl.$validators.pattern = function (modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                }
            };
        };
        var maxlengthDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    var maxlength = -1;
                    attr.$observe('maxlength', function (value) {
                        var intVal = toInt(value);
                        maxlength = isNaN(intVal) ? -1 : intVal;
                        ctrl.$validate();
                    });
                    ctrl.$validators.maxlength = function (modelValue, viewValue) {
                        return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                }
            };
        };
        var minlengthDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    var minlength = 0;
                    attr.$observe('minlength', function (value) {
                        minlength = toInt(value) || 0;
                        ctrl.$validate();
                    });
                    ctrl.$validators.minlength = function (modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                }
            };
        };
        if (window.angular.bootstrap) {
            console.log('WARNING: Tried to load angular more than once.');
            return;
        }
        bindJQuery();
        publishExternalAPI(angular);
        angular.module('ngLocale', [], [
            '$provide',
            function ($provide) {
                var PLURAL_CATEGORY = {
                    ZERO: 'zero',
                    ONE: 'one',
                    TWO: 'two',
                    FEW: 'few',
                    MANY: 'many',
                    OTHER: 'other'
                };
                function getDecimals(n) {
                    n = n + '';
                    var i = n.indexOf('.');
                    return i == -1 ? 0 : n.length - i - 1;
                }
                function getVF(n, opt_precision) {
                    var v = opt_precision;
                    if (undefined === v) {
                        v = Math.min(getDecimals(n), 3);
                    }
                    var base = Math.pow(10, v);
                    var f = (n * base | 0) % base;
                    return {
                        v: v,
                        f: f
                    };
                }
                $provide.value('$locale', {
                    'DATETIME_FORMATS': {
                        'AMPMS': [
                            'AM',
                            'PM'
                        ],
                        'DAY': [
                            'Sunday',
                            'Monday',
                            'Tuesday',
                            'Wednesday',
                            'Thursday',
                            'Friday',
                            'Saturday'
                        ],
                        'ERANAMES': [
                            'Before Christ',
                            'Anno Domini'
                        ],
                        'ERAS': [
                            'BC',
                            'AD'
                        ],
                        'FIRSTDAYOFWEEK': 6,
                        'MONTH': [
                            'January',
                            'February',
                            'March',
                            'April',
                            'May',
                            'June',
                            'July',
                            'August',
                            'September',
                            'October',
                            'November',
                            'December'
                        ],
                        'SHORTDAY': [
                            'Sun',
                            'Mon',
                            'Tue',
                            'Wed',
                            'Thu',
                            'Fri',
                            'Sat'
                        ],
                        'SHORTMONTH': [
                            'Jan',
                            'Feb',
                            'Mar',
                            'Apr',
                            'May',
                            'Jun',
                            'Jul',
                            'Aug',
                            'Sep',
                            'Oct',
                            'Nov',
                            'Dec'
                        ],
                        'WEEKENDRANGE': [
                            5,
                            6
                        ],
                        'fullDate': 'EEEE, MMMM d, y',
                        'longDate': 'MMMM d, y',
                        'medium': 'MMM d, y h:mm:ss a',
                        'mediumDate': 'MMM d, y',
                        'mediumTime': 'h:mm:ss a',
                        'short': 'M/d/yy h:mm a',
                        'shortDate': 'M/d/yy',
                        'shortTime': 'h:mm a'
                    },
                    'NUMBER_FORMATS': {
                        'CURRENCY_SYM': '$',
                        'DECIMAL_SEP': '.',
                        'GROUP_SEP': ',',
                        'PATTERNS': [
                            {
                                'gSize': 3,
                                'lgSize': 3,
                                'maxFrac': 3,
                                'minFrac': 0,
                                'minInt': 1,
                                'negPre': '-',
                                'negSuf': '',
                                'posPre': '',
                                'posSuf': ''
                            },
                            {
                                'gSize': 3,
                                'lgSize': 3,
                                'maxFrac': 2,
                                'minFrac': 2,
                                'minInt': 1,
                                'negPre': '-\xA4',
                                'negSuf': '',
                                'posPre': '\xA4',
                                'posSuf': ''
                            }
                        ]
                    },
                    'id': 'en-us',
                    'pluralCat': function (n, opt_precision) {
                        var i = n | 0;
                        var vf = getVF(n, opt_precision);
                        if (i == 1 && vf.v == 0) {
                            return PLURAL_CATEGORY.ONE;
                        }
                        return PLURAL_CATEGORY.OTHER;
                    }
                });
            }
        ]);
        jqLite(document).ready(function () {
            angularInit(document, bootstrap);
        });
    }(window, document));
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
});
/*angular@1.4.8#index*/
define('angular@1.4.8#index', function (require, exports, module) {
    require('./angular');
    module.exports = angular;
});
/*lodash@2.4.2#dist/lodash*/
;
(function () {
    var undefined;
    var arrayPool = [], objectPool = [];
    var idCounter = 0;
    var keyPrefix = +new Date() + '';
    var largeArraySize = 75;
    var maxPoolSize = 40;
    var whitespace = ' \t\x0B\f\xA0\uFEFF' + '\n\r\u2028\u2029' + '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000';
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
    var reNoMatch = /($^)/;
    var reThis = /\bthis\b/;
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    var contextProps = [
        'Array',
        'Boolean',
        'Date',
        'Function',
        'Math',
        'Number',
        'Object',
        'RegExp',
        'String',
        '_',
        'attachEvent',
        'clearTimeout',
        'isFinite',
        'isNaN',
        'parseInt',
        'setTimeout'
    ];
    var templateCounter = 0;
    var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
    var cloneableClasses = {};
    cloneableClasses[funcClass] = false;
    cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
    var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
    };
    var descriptor = {
        'configurable': false,
        'enumerable': false,
        'value': null,
        'writable': false
    };
    var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    };
    var stringEscapes = {
        '\\': '\\',
        '\'': '\'',
        '\n': 'n',
        '\r': 'r',
        '\t': 't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
    }
    function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == 'boolean' || value == null) {
            return cache[value] ? 0 : -1;
        }
        if (type != 'number' && type != 'string') {
            type = 'object';
        }
        var key = type == 'number' ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == 'object' ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
    }
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == 'boolean' || value == null) {
            cache[value] = true;
        } else {
            if (type != 'number' && type != 'string') {
                type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            if (type == 'object') {
                (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
                typeCache[key] = true;
            }
        }
    }
    function charAtCallback(value) {
        return value.charCodeAt(0);
    }
    function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
        while (++index < length) {
            var value = ac[index], other = bc[index];
            if (value !== other) {
                if (value > other || typeof value == 'undefined') {
                    return 1;
                }
                if (value < other || typeof other == 'undefined') {
                    return -1;
                }
            }
        }
        return a.index - b.index;
    }
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object') {
            return false;
        }
        var cache = getObject();
        cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
            result.push(array[index]);
        }
        return result;
    }
    function escapeStringChar(match) {
        return '\\' + stringEscapes[match];
    }
    function getArray() {
        return arrayPool.pop() || [];
    }
    function getObject() {
        return objectPool.pop() || {
            'array': null,
            'cache': null,
            'criteria': null,
            'false': false,
            'index': 0,
            'null': false,
            'number': null,
            'object': null,
            'push': null,
            'string': null,
            'true': false,
            'undefined': false,
            'value': null
        };
    }
    function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
        }
    }
    function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
            releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
        }
    }
    function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == 'undefined') {
            end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
            result[index] = array[start + index];
        }
        return result;
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
        var defineProperty = function () {
            try {
                var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
            } catch (e) {
            }
            return result;
        }();
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
            return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
        support.funcNames = typeof Function.name == 'string';
        lodash.templateSettings = {
            'escape': /<%-([\s\S]+?)%>/g,
            'evaluate': /<%([\s\S]+?)%>/g,
            'interpolate': reInterpolate,
            'variable': '',
            'imports': { '_': lodash }
        };
        function baseBind(bindData) {
            var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
            function bound() {
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (this instanceof bound) {
                    var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
                var result = callback(value);
                if (typeof result != 'undefined') {
                    return result;
                }
            }
            var isObj = isObject(value);
            if (isObj) {
                var className = toString.call(value);
                if (!cloneableClasses[className]) {
                    return value;
                }
                var ctor = ctorByClass[className];
                switch (className) {
                case boolClass:
                case dateClass:
                    return new ctor(+value);
                case numberClass:
                case stringClass:
                    return new ctor(value);
                case regexpClass:
                    result = ctor(value.source, reFlags.exec(value));
                    result.lastIndex = value.lastIndex;
                    return result;
                }
            } else {
                return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length];
                    }
                }
                result = isArr ? ctor(value.length) : {};
            } else {
                result = isArr ? slice(value) : assign({}, value);
            }
            if (isArr) {
                if (hasOwnProperty.call(value, 'index')) {
                    result.index = value.index;
                }
                if (hasOwnProperty.call(value, 'input')) {
                    result.input = value.input;
                }
            }
            if (!isDeep) {
                return result;
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? forEach : forOwn)(value, function (objValue, key) {
                result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
            baseCreate = function () {
                function Object() {
                }
                return function (prototype) {
                    if (isObject(prototype)) {
                        Object.prototype = prototype;
                        var result = new Object();
                        Object.prototype = null;
                    }
                    return result || context.Object();
                };
            }();
        }
        function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
                return identity;
            }
            if (typeof thisArg == 'undefined' || !('prototype' in func)) {
                return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == 'undefined') {
                if (support.funcNames) {
                    bindData = !func.name;
                }
                bindData = bindData || !support.funcDecomp;
                if (!bindData) {
                    var source = fnToString.call(func);
                    if (!support.funcNames) {
                        bindData = !reFuncName.test(source);
                    }
                    if (!bindData) {
                        bindData = reThis.test(source);
                        setBindData(func, bindData);
                    }
                }
            }
            if (bindData === false || bindData !== true && bindData[1] & 1) {
                return func;
            }
            switch (argCount) {
            case 1:
                return function (value) {
                    return func.call(thisArg, value);
                };
            case 2:
                return function (a, b) {
                    return func.call(thisArg, a, b);
                };
            case 3:
                return function (value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };
            case 4:
                return function (accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            }
            return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
            var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
            function bound() {
                var thisBinding = isBind ? thisArg : this;
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (partialRightArgs || isCurry) {
                    args || (args = slice(arguments));
                    if (partialRightArgs) {
                        push.apply(args, partialRightArgs);
                    }
                    if (isCurry && args.length < arity) {
                        bitmask |= 16 & ~32;
                        return baseCreateWrapper([
                            func,
                            isCurryBound ? bitmask : bitmask & ~3,
                            args,
                            null,
                            thisArg,
                            arity
                        ]);
                    }
                }
                args || (args = arguments);
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (this instanceof bound) {
                    thisBinding = baseCreate(func.prototype);
                    var result = func.apply(thisBinding, args);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseDifference(array, values) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
            if (isLarge) {
                var cache = createCache(values);
                if (cache) {
                    indexOf = cacheIndexOf;
                    values = cache;
                } else {
                    isLarge = false;
                }
            }
            while (++index < length) {
                var value = array[index];
                if (indexOf(values, value) < 0) {
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseObject(values);
            }
            return result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value && typeof value == 'object' && typeof value.length == 'number' && (isArray(value) || isArguments(value))) {
                    if (!isShallow) {
                        value = baseFlatten(value, isShallow, isStrict);
                    }
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    result.length += valLength;
                    while (++valIndex < valLength) {
                        result[resIndex++] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result.push(value);
                }
            }
            return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            if (callback) {
                var result = callback(a, b);
                if (typeof result != 'undefined') {
                    return !!result;
                }
            }
            if (a === b) {
                return a !== 0 || 1 / a == 1 / b;
            }
            var type = typeof a, otherType = typeof b;
            if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                return false;
            }
            if (a == null || b == null) {
                return a === b;
            }
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass) {
                className = objectClass;
            }
            if (otherClass == argsClass) {
                otherClass = objectClass;
            }
            if (className != otherClass) {
                return false;
            }
            switch (className) {
            case boolClass:
            case dateClass:
                return +a == +b;
            case numberClass:
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
            case regexpClass:
            case stringClass:
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                var aWrapped = hasOwnProperty.call(a, '__wrapped__'), bWrapped = hasOwnProperty.call(b, '__wrapped__');
                if (aWrapped || bWrapped) {
                    return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                }
                if (className != objectClass) {
                    return false;
                }
                var ctorA = a.constructor, ctorB = b.constructor;
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
                    return false;
                }
            }
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == a) {
                    return stackB[length] == b;
                }
            }
            var size = 0;
            result = true;
            stackA.push(a);
            stackB.push(b);
            if (isArr) {
                length = a.length;
                size = b.length;
                result = size == length;
                if (result || isWhere) {
                    while (size--) {
                        var index = length, value = b[size];
                        if (isWhere) {
                            while (index--) {
                                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                    break;
                                }
                            }
                        } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                            break;
                        }
                    }
                }
            } else {
                forIn(b, function (value, key, b) {
                    if (hasOwnProperty.call(b, key)) {
                        size++;
                        return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                    }
                });
                if (result && !isWhere) {
                    forIn(a, function (value, key, a) {
                        if (hasOwnProperty.call(a, key)) {
                            return result = --size > -1;
                        }
                    });
                }
            }
            stackA.pop();
            stackB.pop();
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function (source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    var stackLength = stackA.length;
                    while (stackLength--) {
                        if (found = stackA[stackLength] == source) {
                            value = stackB[stackLength];
                            break;
                        }
                    }
                    if (!found) {
                        var isShallow;
                        if (callback) {
                            result = callback(value, source);
                            if (isShallow = typeof result != 'undefined') {
                                value = result;
                            }
                        }
                        if (!isShallow) {
                            value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                        }
                        stackA.push(source);
                        stackB.push(value);
                        if (!isShallow) {
                            baseMerge(value, source, callback, stackA, stackB);
                        }
                    }
                } else {
                    if (callback) {
                        result = callback(value, source);
                        if (typeof result == 'undefined') {
                            result = source;
                        }
                    }
                    if (typeof result != 'undefined') {
                        value = result;
                    }
                }
                object[key] = value;
            });
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                indexOf = cacheIndexOf;
                seen = cache;
            }
            while (++index < length) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                    if (callback || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseArray(seen.array);
                releaseObject(seen);
            } else if (callback) {
                releaseArray(seen);
            }
            return result;
        }
        function createAggregator(setter) {
            return function (collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg, 3);
                var index = -1, length = collection ? collection.length : 0;
                if (typeof length == 'number') {
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, callback(value, index, collection), collection);
                    }
                } else {
                    forOwn(collection, function (value, key, collection) {
                        setter(result, value, callback(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
            if (!isBindKey && !isFunction(func)) {
                throw new TypeError();
            }
            if (isPartial && !partialArgs.length) {
                bitmask &= ~16;
                isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
                bitmask &= ~32;
                isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
                bindData = slice(bindData);
                if (bindData[2]) {
                    bindData[2] = slice(bindData[2]);
                }
                if (bindData[3]) {
                    bindData[3] = slice(bindData[3]);
                }
                if (isBind && !(bindData[1] & 1)) {
                    bindData[4] = thisArg;
                }
                if (!isBind && bindData[1] & 1) {
                    bitmask |= 8;
                }
                if (isCurry && !(bindData[1] & 4)) {
                    bindData[5] = arity;
                }
                if (isPartial) {
                    push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                }
                if (isPartialRight) {
                    unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                }
                bindData[1] |= bitmask;
                return createWrapper.apply(null, bindData);
            }
            var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
            return creater([
                func,
                bitmask,
                partialArgs,
                partialRightArgs,
                thisArg,
                arity
            ]);
        }
        function escapeHtmlChar(match) {
            return htmlEscapes[match];
        }
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
        }
        function isNative(value) {
            return typeof value == 'function' && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function (func, value) {
            descriptor.value = value;
            defineProperty(func, '__bindData__', descriptor);
            descriptor.value = null;
        };
        function shimIsPlainObject(value) {
            var ctor, result;
            if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
                return false;
            }
            forIn(value, function (value, key) {
                result = key;
            });
            return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
        }
        function isArguments(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;
        }
        var isArray = nativeIsArray || function (value) {
            return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;
        };
        var shimKeys = function (object) {
            var index, iterable = object, result = [];
            if (!iterable)
                return result;
            if (!objectTypes[typeof object])
                return result;
            for (index in iterable) {
                if (hasOwnProperty.call(iterable, index)) {
                    result.push(index);
                }
            }
            return result;
        };
        var keys = !nativeKeys ? shimKeys : function (object) {
            if (!isObject(object)) {
                return [];
            }
            return nativeKeys(object);
        };
        var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#39;'
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'), reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
        var assign = function (object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable)
                return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
            if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
                var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
            } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
                callback = args[--argsLength];
            }
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                    }
                }
            }
            return result;
        };
        function clone(value, isDeep, callback, thisArg) {
            if (typeof isDeep != 'boolean' && isDeep != null) {
                thisArg = callback;
                callback = isDeep;
                isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
        }
        var defaults = function (object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable)
                return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        if (typeof result[index] == 'undefined')
                            result[index] = iterable[index];
                    }
                }
            }
            return result;
        };
        function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function (value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function (value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        var forIn = function (collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable)
                return result;
            if (!objectTypes[typeof iterable])
                return result;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            for (index in iterable) {
                if (callback(iterable[index], index, collection) === false)
                    return result;
            }
            return result;
        };
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function (value, key) {
                pairs.push(key, value);
            });
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(pairs[length--], pairs[length], object) === false) {
                    break;
                }
            }
            return object;
        }
        var forOwn = function (collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable)
                return result;
            if (!objectTypes[typeof iterable])
                return result;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
            while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (callback(iterable[index], index, collection) === false)
                    return result;
            }
            return result;
        };
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                var key = props[length];
                if (callback(object[key], key, object) === false) {
                    break;
                }
            }
            return object;
        }
        function functions(object) {
            var result = [];
            forIn(object, function (value, key) {
                if (isFunction(value)) {
                    result.push(key);
                }
            });
            return result.sort();
        }
        function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                result[object[key]] = key;
            }
            return result;
        }
        function isBoolean(value) {
            return value === true || value === false || value && typeof value == 'object' && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
            return value && typeof value == 'object' && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
            return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
            var result = true;
            if (!value) {
                return result;
            }
            var className = toString.call(value), length = value.length;
            if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
                return !length;
            }
            forOwn(value, function () {
                return result = false;
            });
            return result;
        }
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
            return typeof value == 'function';
        }
        function isObject(value) {
            return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == 'number' || value && typeof value == 'object' && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
            if (!(value && toString.call(value) == objectClass)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
            return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
            return typeof value == 'undefined';
        }
        function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function (value, key, object) {
                result[key] = callback(value, key, object);
            });
            return result;
        }
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) {
                return object;
            }
            if (typeof args[2] != 'number') {
                length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == 'function') {
                var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == 'function') {
                callback = args[--length];
            }
            var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
            while (++index < length) {
                baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
        }
        function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
                var props = [];
                forIn(object, function (value, key) {
                    props.push(key);
                });
                props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                var index = -1, length = props.length;
                while (++index < length) {
                    var key = props[index];
                    result[key] = object[key];
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function (value, key, object) {
                    if (!callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [
                    key,
                    object[key]
                ];
            }
            return result;
        }
        function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
                var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                while (++index < length) {
                    var key = props[index];
                    if (key in object) {
                        result[key] = object[key];
                    }
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function (value, key, object) {
                    if (callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
                if (isArr) {
                    accumulator = [];
                } else {
                    var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                    accumulator = baseCreate(proto);
                }
            }
            if (callback) {
                callback = lodash.createCallback(callback, thisArg, 4);
                (isArr ? forEach : forOwn)(object, function (value, index, object) {
                    return callback(accumulator, value, index, object);
                });
            }
            return accumulator;
        }
        function values(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function at(collection) {
            var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
            while (++index < length) {
                result[index] = collection[props[index]];
            }
            return result;
        }
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
                result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == 'number') {
                result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
                forOwn(collection, function (value) {
                    if (++index >= fromIndex) {
                        return !(result = value === target);
                    }
                });
            }
            return result;
        }
        var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
        });
        function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    if (!(result = !!callback(collection[index], index, collection))) {
                        break;
                    }
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    return result = !!callback(value, index, collection);
                });
            }
            return result;
        }
        function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                });
            }
            return result;
        }
        function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        return value;
                    }
                }
            } else {
                var result;
                forOwn(collection, function (value, index, collection) {
                    if (callback(value, index, collection)) {
                        result = value;
                        return false;
                    }
                });
                return result;
            }
        }
        function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function (value, index, collection) {
                if (callback(value, index, collection)) {
                    result = value;
                    return false;
                }
            });
            return result;
        }
        function forEach(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
                while (++index < length) {
                    if (callback(collection[index], index, collection) === false) {
                        break;
                    }
                }
            } else {
                forOwn(collection, callback);
            }
            return collection;
        }
        function forEachRight(collection, callback, thisArg) {
            var length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
                while (length--) {
                    if (callback(collection[length], length, collection) === false) {
                        break;
                    }
                }
            } else {
                var props = keys(collection);
                length = props.length;
                forOwn(collection, function (value, key, collection) {
                    key = props ? props[--length] : --length;
                    return callback(collection[key], key, collection);
                });
            }
            return collection;
        }
        var groupBy = createAggregator(function (result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
        var indexBy = createAggregator(function (result, value, key) {
            result[key] = value;
        });
        function invoke(collection, methodName) {
            var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
            forEach(collection, function (value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
        }
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
                var result = Array(length);
                while (++index < length) {
                    result[index] = callback(collection[index], index, collection);
                }
            } else {
                result = [];
                forOwn(collection, function (value, key, collection) {
                    result[++index] = callback(value, key, collection);
                });
            }
            return result;
        }
        function max(collection, callback, thisArg) {
            var computed = -Infinity, result = computed;
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value > result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function (value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current > computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        function min(collection, callback, thisArg) {
            var computed = Infinity, result = computed;
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value < result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function (value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current < computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
            if (!collection)
                return accumulator;
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            var index = -1, length = collection.length;
            if (typeof length == 'number') {
                if (noaccum) {
                    accumulator = collection[++index];
                }
                while (++index < length) {
                    accumulator = callback(accumulator, collection[index], index, collection);
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                });
            }
            return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function (value, index, collection) {
                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
            return accumulator;
        }
        function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function (value, index, collection) {
                return !callback(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (collection && typeof collection.length != 'number') {
                collection = values(collection);
            }
            if (n == null || guard) {
                return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
        }
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
            forEach(collection, function (value) {
                var rand = baseRandom(0, ++index);
                result[index] = result[rand];
                result[rand] = value;
            });
            return result;
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == 'number' ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    if (result = callback(collection[index], index, collection)) {
                        break;
                    }
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    return !(result = callback(value, index, collection));
                });
            }
            return !!result;
        }
        function sortBy(collection, callback, thisArg) {
            var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
            if (!isArr) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function (value, key, collection) {
                var object = result[++index] = getObject();
                if (isArr) {
                    object.criteria = map(callback, function (key) {
                        return value[key];
                    });
                } else {
                    (object.criteria = getArray())[0] = callback(value, key, collection);
                }
                object.index = index;
                object.value = value;
            });
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
                var object = result[length];
                result[length] = object.value;
                if (!isArr) {
                    releaseArray(object.criteria);
                }
                releaseObject(object);
            }
            return result;
        }
        function toArray(collection) {
            if (collection && typeof collection.length == 'number') {
                return slice(collection);
            }
            return values(collection);
        }
        var where = filter;
        function compact(array) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result.push(value);
                }
            }
            return result;
        }
        function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                if (callback(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(array[length], length, array)) {
                    return length;
                }
            }
            return -1;
        }
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != 'number' && callback != null) {
                var index = -1;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[0] : undefined;
                }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
            if (typeof isShallow != 'boolean' && isShallow != null) {
                thisArg = callback;
                callback = typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array ? null : isShallow;
                isShallow = false;
            }
            if (callback != null) {
                array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == 'number') {
                var length = array ? array.length : 0;
                fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != 'number' && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArray(value) || isArguments(value)) {
                    args.push(value);
                    caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                }
            }
            var array = args[0], index = -1, length = array ? array.length : 0, result = [];
            outer:
                while (++index < length) {
                    var cache = caches[0];
                    value = array[index];
                    if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                        argsIndex = argsLength;
                        (cache || seen).push(value);
                        while (--argsIndex) {
                            cache = caches[argsIndex];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                continue outer;
                            }
                        }
                        result.push(value);
                    }
                }
            while (argsLength--) {
                cache = caches[argsLength];
                if (cache) {
                    releaseObject(cache);
                }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
        }
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != 'number' && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[length - 1] : undefined;
                }
            }
            return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == 'number') {
                index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull(array) {
            var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
            while (++argsIndex < argsLength) {
                var index = -1, value = args[argsIndex];
                while (++index < length) {
                    if (array[index] === value) {
                        splice.call(array, index--, 1);
                        length--;
                    }
                }
            }
            return array;
        }
        function range(start, end, step) {
            start = +start || 0;
            step = typeof step == 'number' ? step : +step || 1;
            if (end == null) {
                end = start;
                start = 0;
            }
            var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (callback(value, index, array)) {
                    result.push(value);
                    splice.call(array, index--, 1);
                    length--;
                }
            }
            return result;
        }
        function rest(array, callback, thisArg) {
            if (typeof callback != 'number' && callback != null) {
                var n = 0, index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
            while (low < high) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        }
        function union() {
            return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
            if (typeof isSorted != 'boolean' && isSorted != null) {
                thisArg = callback;
                callback = typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array ? null : isSorted;
                isSorted = false;
            }
            if (callback != null) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
        }
        function without(array) {
            return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArray(array) || isArguments(array)) {
                    var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                }
            }
            return result || [];
        }
        function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, 'length')) : 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = pluck(array, index);
            }
            return result;
        }
        function zipObject(keys, values) {
            var index = -1, length = keys ? keys.length : 0, result = {};
            if (!values && length && !isArray(keys[0])) {
                values = [];
            }
            while (++index < length) {
                var key = keys[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        function after(n, func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function () {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function bind(func, thisArg) {
            return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
            while (++index < length) {
                var key = funcs[index];
                object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
        }
        function bindKey(object, key) {
            return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
            var funcs = arguments, length = funcs.length;
            while (length--) {
                if (!isFunction(funcs[length])) {
                    throw new TypeError();
                }
            }
            return function () {
                var args = arguments, length = funcs.length;
                while (length--) {
                    args = [funcs[length].apply(this, args)];
                }
                return args[0];
            };
        }
        function curry(func, arity) {
            arity = typeof arity == 'number' ? arity : +arity || func.length;
            return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
                trailing = 'trailing' in options ? options.trailing : trailing;
            }
            var delayed = function () {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            };
            var maxDelayed = function () {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            };
            return function () {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            };
        }
        function defer(func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 1);
            return setTimeout(function () {
                func.apply(undefined, args);
            }, 1);
        }
        function delay(func, wait) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 2);
            return setTimeout(function () {
                func.apply(undefined, args);
            }, wait);
        }
        function memoize(func, resolver) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var memoized = function () {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
            };
            memoized.cache = {};
            return memoized;
        }
        function once(func) {
            var ran, result;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function () {
                if (ran) {
                    return result;
                }
                ran = true;
                result = func.apply(this, arguments);
                func = null;
                return result;
            };
        }
        function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = 'leading' in options ? options.leading : leading;
                trailing = 'trailing' in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [value]);
        }
        function constant(value) {
            return function () {
                return value;
            };
        }
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == 'function') {
                return baseCreateCallback(func, thisArg, argCount);
            }
            if (type != 'object') {
                return property(func);
            }
            var props = keys(func), key = props[0], a = func[key];
            if (props.length == 1 && a === a && !isObject(a)) {
                return function (object) {
                    var b = object[key];
                    return a === b && (a !== 0 || 1 / a == 1 / b);
                };
            }
            return function (object) {
                var length = props.length, result = false;
                while (length--) {
                    if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                        break;
                    }
                }
                return result;
            };
        }
        function escape(string) {
            return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
            return value;
        }
        function mixin(object, source, options) {
            var chain = true, methodNames = source && functions(source);
            if (!source || !options && !methodNames.length) {
                if (options == null) {
                    options = source;
                }
                ctor = lodashWrapper;
                source = object;
                object = lodash;
                methodNames = functions(source);
            }
            if (options === false) {
                chain = false;
            } else if (isObject(options) && 'chain' in options) {
                chain = options.chain;
            }
            var ctor = object, isFunc = isFunction(ctor);
            forEach(methodNames, function (methodName) {
                var func = object[methodName] = source[methodName];
                if (isFunc) {
                    ctor.prototype[methodName] = function () {
                        var chainAll = this.__chain__, value = this.__wrapped__, args = [value];
                        push.apply(args, arguments);
                        var result = func.apply(object, args);
                        if (chain || chainAll) {
                            if (value === result && isObject(result)) {
                                return this;
                            }
                            result = new ctor(result);
                            result.__chain__ = chainAll;
                        }
                        return result;
                    };
                }
            });
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {
        }
        var now = isNative(now = Date.now) && now || function () {
            return new Date().getTime();
        };
        var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
        };
        function property(key) {
            return function (object) {
                return object[key];
            };
        }
        function random(min, max, floating) {
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (typeof min == 'boolean' && noMax) {
                    floating = min;
                    min = 1;
                } else if (!noMax && typeof max == 'boolean') {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max);
            }
            return baseRandom(min, max);
        }
        function result(object, key) {
            if (object) {
                var value = object[key];
                return isFunction(value) ? object[key]() : value;
            }
        }
        function template(text, data, options) {
            var settings = lodash.templateSettings;
            text = String(text || '');
            options = defaults({}, options, settings);
            var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
            var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
            text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    source += '\' +\n__e(' + escapeValue + ') +\n\'';
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += '\';\n' + evaluateValue + ';\n__p += \'';
                }
                if (interpolateValue) {
                    source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                }
                index = offset + match.length;
                return match;
            });
            source += '\';\n';
            var variable = options.variable, hasVariable = variable;
            if (!hasVariable) {
                variable = 'obj';
                source = 'with (' + variable + ') {\n' + source + '\n}\n';
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
            source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + 'var __t, __p = \'\', __e = _.escape' + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
            var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';
            try {
                var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
            } catch (e) {
                e.source = source;
                throw e;
            }
            if (data) {
                return result(data);
            }
            result.source = source;
            return result;
        }
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
                result[index] = callback(index);
            }
            return result;
        }
        function unescape(string) {
            return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? '' : prefix) + id;
        }
        function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        function wrapperChain() {
            this.__chain__ = true;
            return this;
        }
        function wrapperToString() {
            return String(this.__wrapped__);
        }
        function wrapperValueOf() {
            return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function () {
            var source = {};
            forOwn(lodash, function (func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function (func, methodName) {
            var callbackable = methodName !== 'sample';
            if (!lodash.prototype[methodName]) {
                lodash.prototype[methodName] = function (n, guard) {
                    var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                    return !chainAll && (n == null || guard && !(callbackable && typeof n == 'function')) ? result : new lodashWrapper(result, chainAll);
                };
            }
        });
        lodash.VERSION = '2.4.2';
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach([
            'join',
            'pop',
            'shift'
        ], function (methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function () {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            };
        });
        forEach([
            'push',
            'reverse',
            'sort',
            'unshift'
        ], function (methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function () {
                func.apply(this.__wrapped__, arguments);
                return this;
            };
        });
        forEach([
            'concat',
            'slice',
            'splice'
        ], function (methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function () {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
        });
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define('lodash@2.4.2#dist/lodash', function () {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}.call(this));
/*mui@0.0.0#mui*/
define('mui@0.0.0#mui', [
    'angular',
    'lodash'
], function (ng, _) {
    'use strict';
    function mui(ng) {
        var _self = {};
        _self.providerMap = {
            service: 'service',
            factory: 'factory',
            directive: 'directive',
            provider: 'provider',
            controller: 'controller',
            value: 'value',
            constant: 'constant',
            animation: 'animation'
        };
        function MevError(msg) {
            this.msg = msg;
        }
        _self.inferProvider = function inferProvider(func) {
            if (typeof func !== 'function')
                throw new MevError('Compnent with name \'' + func.name + '\' is not a function, but is ' + typeof func);
            if (!func.$name)
                throw new MevError('Compnent name not specified for func ' + func.name);
            var provider = func.provider;
            if (provider) {
                if (!_self.providerMap[func.provider.toLowerCase()]) {
                    throw new MevError('Invalid angular provider \'' + func.provider + '\'');
                }
                return provider.toLowerCase();
            }
            for (var curProvider in _self.providerMap) {
                if (_self.providerMap.hasOwnProperty(curProvider)) {
                    if (func.$name.toLowerCase().indexOf(curProvider) > -1)
                        provider = curProvider;
                }
            }
            if (!provider)
                throw new MevError('Could not infer provider for component: ' + JSON.stringify(func));
            func.provider = provider.toLowerCase();
            return func.provider;
        };
        _self.selectNgModules = function (deps) {
            return deps.filter(function (dep) {
                if (dep instanceof String || typeof dep === 'string')
                    return true;
                if (Array.isArray(dep.requires) && typeof dep.provider === 'function')
                    return true;
            }).map(function (dep) {
                if (dep instanceof String || typeof dep === 'string')
                    return dep;
                else
                    return dep.name;
            });
        };
        _self.formatComponentName = function (func) {
            var name = func.$name;
            if (name.toLowerCase().indexOf(func.provider, this.length - func.provider.length) !== -1) {
                name = name.substring(0, name.length - func.provider.length);
            }
            if (func.provider === 'directive')
                name = name.substr(0, 1).toLowerCase() + name.substr(1);
            func.$name = name;
            return name;
        };
        _self.register = function (func) {
            var provider = _self.inferProvider(func);
            var name = _self.formatComponentName(func);
            return this[provider](name, func);
        };
        _self.registerAll = function (components) {
            var result;
            for (var i = 0; i < components.length; i++) {
                try {
                    result = this.mevRegister(components[i]);
                    console.debug('registerAll - regitered', components[i].$name);
                } catch (e) {
                    if (e instanceof MevError)
                        console.debug('registerAll - skipping component ', e);
                    else
                        throw e;
                }
            }
            return result ? result : this;
        };
        _self._module = ng.module;
        ng.module = function (name, deps, args) {
            if (typeof deps === 'undefined')
                return _self._module(name);
            var modules = [];
            if (Array.isArray(deps)) {
                modules = modules.concat(_self.selectNgModules(deps));
            } else if (typeof deps.length !== 'undefined') {
                deps = Array.prototype.slice.call(deps);
                modules = modules.concat(_self.selectNgModules(deps));
            }
            ;
            if (args) {
                var aArgs = Array.prototype.slice.call(args);
                modules = modules.concat(_self.selectNgModules(aArgs));
            }
            modules = _.uniq(modules);
            var module = _self._module(name, modules);
            console.info('registered module ' + module.name + ' with ' + modules.length + ' dependencies ', modules);
            module.mevRegister = _self.register.bind(module);
            module.mevRegisterAll = _self.registerAll.bind(module);
            if (args) {
                module.mevRegisterAll(args);
            }
            return module;
        };
        return ng;
    }
    ;
    return mui(ng);
});
/*d3@3.5.12#d3*/
!function () {
    var d3 = { version: '3.5.12' };
    var d3_arraySlice = [].slice, d3_array = function (list) {
            return d3_arraySlice.call(list);
        };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) {
        try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
            d3_array = function (list) {
                var i = list.length, array = new Array(i);
                while (i--)
                    array[i] = list[i];
                return array;
            };
        }
    }
    if (!Date.now)
        Date.now = function () {
            return +new Date();
        };
    if (d3_document) {
        try {
            d3_document.createElement('DIV').style.setProperty('opacity', 0, '');
        } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function (name, value) {
                d3_element_setAttribute.call(this, name, value + '');
            };
            d3_element_prototype.setAttributeNS = function (space, local, value) {
                d3_element_setAttributeNS.call(this, space, local, value + '');
            };
            d3_style_prototype.setProperty = function (name, value, priority) {
                d3_style_setProperty.call(this, name, value + '', priority);
            };
        }
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && a > b)
                    a = b;
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && a > b)
                    a = b;
        }
        return a;
    };
    d3.max = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && b > a)
                    a = b;
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b > a)
                    a = b;
        }
        return a;
    };
    d3.extent = function (array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        }
        return [
            a,
            c
        ];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function (array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = +array[i]))
                    s += a;
        } else {
            while (++i < n)
                if (d3_numeric(a = +f.call(array, array[i], i)))
                    s += a;
        }
        return s;
    };
    d3.mean = function (array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    s += a;
                else
                    --j;
        } else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    s += a;
                else
                    --j;
        }
        if (j)
            return s / j;
    };
    d3.quantile = function (values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function (array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    numbers.push(a);
        } else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    numbers.push(a);
        }
        if (numbers.length)
            return d3.quantile(numbers.sort(d3_ascending), 0.5);
    };
    d3.variance = function (array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) {
                if (d3_numeric(a = d3_number(array[i]))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        } else {
            while (++i < n) {
                if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        if (j > 1)
            return s / (j - 1);
    };
    d3.deviation = function () {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function (f) {
        return d3_bisector(f.length === 1 ? function (d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function (array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2)
                i0 = 0;
        }
        var m = i1 - i0, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function (array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--)
            permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function (array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
            pairs[i] = [
                p0 = p1,
                p1 = array[++i]
            ];
        return pairs;
    };
    d3.zip = function () {
        if (!(n = arguments.length))
            return [];
        for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {
            for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {
                zip[j] = arguments[j][i];
            }
        }
        return zips;
    };
    function d3_zipLength(d) {
        return d.length;
    }
    d3.transpose = function (matrix) {
        return d3.zip.apply(d3, matrix);
    };
    d3.keys = function (map) {
        var keys = [];
        for (var key in map)
            keys.push(key);
        return keys;
    };
    d3.values = function (map) {
        var values = [];
        for (var key in map)
            values.push(map[key]);
        return values;
    };
    d3.entries = function (map) {
        var entries = [];
        for (var key in map)
            entries.push({
                key: key,
                value: map[key]
            });
        return entries;
    };
    d3.merge = function (arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function (start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity)
            throw new Error('infinite range');
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
            while ((j = start + step * ++i) > stop)
                range.push(j / k);
        else
            while ((j = start + step * ++i) < stop)
                range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
            k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
                value: properties[key],
                enumerable: false
            });
        }
    }
    d3.map = function (object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
            object.forEach(function (key, value) {
                map.set(key, value);
            });
        } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1)
                while (++i < n)
                    map.set(i, object[i]);
            else
                while (++i < n)
                    map.set(f.call(object, o = object[i], i), o);
        } else {
            for (var key in object)
                map.set(key, object[key]);
        }
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = '__proto__', d3_map_zero = '\0';
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function (key) {
            return this._[d3_map_escape(key)];
        },
        set: function (key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function () {
            var values = [];
            for (var key in this._)
                values.push(this._[key]);
            return values;
        },
        entries: function () {
            var entries = [];
            for (var key in this._)
                entries.push({
                    key: d3_map_unescape(key),
                    value: this._[key]
                });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += '') === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += '')[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._)
            keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._)
            ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this._)
            return false;
        return true;
    }
    d3.nest = function () {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length)
                return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [object]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function (keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            } else {
                object = {};
                setter = function (keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length)
                return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function (key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function (a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function (array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function (array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function (d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function (order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function (order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function (f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function (array) {
        var set = new d3_Set();
        if (array)
            for (var i = 0, n = array.length; i < n; ++i)
                set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function (key) {
            this._[d3_map_escape(key += '')] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {};
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function (target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n)
            target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function () {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object)
            return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object)
                return prefixName;
        }
    }
    var d3_vendorPrefixes = [
        'webkit',
        'ms',
        'moz',
        'Moz',
        'o',
        'O'
    ];
    function d3_noop() {
    }
    d3.dispatch = function () {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {
    }
    d3_dispatch.prototype.on = function (type, listener) {
        var i = type.indexOf('.'), name = '';
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type)
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null)
                for (type in this) {
                    if (this.hasOwnProperty(type))
                        this[type].on(name, null);
                }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n)
                if (l = z[i].on)
                    l.apply(this, arguments);
            return dispatch;
        }
        event.on = function (name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2)
                return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener)
                listeners.push(listenerByName.set(name, { on: listener }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent)
            e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function (thiz, argumentz) {
            return function (e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function (s) {
        return s.replace(d3_requote_re, '\\$&');
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function (object, prototype) {
        object.__proto__ = prototype;
    } : function (object, prototype) {
        for (var property in prototype)
            object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function (s, n) {
            return n.querySelector(s);
        }, d3_selectAll = function (s, n) {
            return n.querySelectorAll(s);
        }, d3_selectMatches = function (n, s) {
            var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, 'matchesSelector')];
            d3_selectMatches = function (n, s) {
                return d3_selectMatcher.call(n, s);
            };
            return d3_selectMatches(n, s);
        };
    if (typeof Sizzle === 'function') {
        d3_select = function (s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function () {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && '__data__' in node)
                        subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === 'function' ? selector : function () {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function (selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === 'function' ? selector : function () {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsPrefix = {
        svg: 'http://www.w3.org/2000/svg',
        xhtml: 'http://www.w3.org/1999/xhtml',
        xlink: 'http://www.w3.org/1999/xlink',
        xml: 'http://www.w3.org/XML/1998/namespace',
        xmlns: 'http://www.w3.org/2000/xmlns/'
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function (name) {
            var i = name.indexOf(':'), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== 'xmlns')
                name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string') {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name)
                this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttributeNS(name.space, name.local);
            else
                this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === 'function' ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, ' ');
    }
    d3_selectionPrototype.classed = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string') {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n)
                        if (!value.contains(name[i]))
                            return false;
                } else {
                    value = node.getAttribute('class');
                    while (++i < n)
                        if (!d3_selection_classedRe(name[i]).test(value))
                            return false;
                }
                return true;
            }
            for (value in name)
                this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp('(?:^|\\s+)' + d3.requote(name) + '(?:\\s+|$)', 'g');
    }
    function d3_selection_classes(name) {
        return (name + '').trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n)
                name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n)
                name[i](this, x);
        }
        return typeof value === 'function' ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function (node, value) {
            if (c = node.classList)
                return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute('class') || '';
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c))
                    node.setAttribute('class', d3_collapse(c + ' ' + name));
            } else {
                node.setAttribute('class', d3_collapse(c.replace(re, ' ')));
            }
        };
    }
    d3_selectionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== 'string') {
                if (n < 2)
                    value = '';
                for (priority in name)
                    this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = '';
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === 'function' ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string')
                return this.node()[name];
            for (value in name)
                this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                delete this[name];
            else
                this[name] = x;
        }
        return value == null ? propertyNull : typeof value === 'function' ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function (value) {
        return arguments.length ? this.each(typeof value === 'function' ? function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? '' : v;
        } : value == null ? function () {
            this.textContent = '';
        } : function () {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function (value) {
        return arguments.length ? this.each(typeof value === 'function' ? function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? '' : v;
        } : value == null ? function () {
            this.innerHTML = '';
        } : function () {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function (name) {
        name = d3_selection_creator(name);
        return this.select(function () {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === 'function' ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function (name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function () {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function () {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    d3_selectionPrototype.data = function (value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for (i = -1; ++i < n;) {
                    if (node = group[i]) {
                        if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                            exitNodes[i] = node;
                        } else {
                            nodeByKeyValue.set(keyValue, node);
                        }
                        keyValues[i] = keyValue;
                    }
                }
                for (i = -1; ++i < m;) {
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    } else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for (i = -1; ++i < n;) {
                    if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0;) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (; i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (; i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === 'function') {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function () {
            return enter;
        };
        update.exit = function () {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return { __data__: data };
    }
    d3_selectionPrototype.datum = function (value) {
        return arguments.length ? this.property('__data__', value) : this.property('__data__');
    };
    d3_selectionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== 'function')
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function () {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function () {
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function (comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m;)
            this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
            comparator = d3_ascending;
        return function (a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function (callback) {
        return d3_selection_each(this, function (node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i])
                    callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function (callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function () {
        return !this.node();
    };
    d3_selectionPrototype.node = function () {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    };
    d3_selectionPrototype.size = function () {
        var n = 0;
        d3_selection_each(this, function () {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m;) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function (name, before) {
        if (arguments.length < 2)
            before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function (d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0)
                j0 = j, i0 = 0;
            if (i >= i0)
                i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n);
            return node;
        };
    }
    d3.select = function (node) {
        var group;
        if (typeof node === 'string') {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
        } else {
            group = [node];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
    };
    d3.selectAll = function (nodes) {
        var group;
        if (typeof nodes === 'string') {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        } else {
            group = d3_array(nodes);
            group.parentNode = null;
        }
        return d3_selection([group]);
    };
    d3_selectionPrototype.on = function (type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== 'string') {
                if (n < 2)
                    listener = false;
                for (capture in type)
                    this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2)
                return (n = this.node()['__on' + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = '__on' + type, i = type.indexOf('.'), wrap = d3_selection_onListener;
        if (i > 0)
            type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
            type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp('^__on([^.]+)' + d3.requote(type) + '$'), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
    });
    if (d3_document) {
        d3_selection_onFilters.forEach(function (k) {
            if ('on' + k in d3_document)
                d3_selection_onFilters.remove(k);
        });
    }
    function d3_selection_onListener(listener, argumentz) {
        return function (e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function (e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = '.dragsuppress-' + ++d3_event_dragId, click = 'click' + name, w = d3.select(d3_window(node)).on('touchmove' + name, d3_eventPreventDefault).on('dragstart' + name, d3_eventPreventDefault).on('selectstart' + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
            d3_event_dragSelect = 'onselectstart' in node ? false : d3_vendorSymbol(node.style, 'userSelect');
        }
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = 'none';
        }
        return function (suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect)
                style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function () {
                    w.on(click, null);
                };
                w.on(click, function () {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function (container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches)
            e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select('body').append('svg').style({
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: 'none'
                    }, 'important');
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083)
                point.x = e.pageX, point.y = e.pageY;
            else
                point.x = e.clientX, point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [
                point.x,
                point.y
            ];
        }
        var rect = container.getBoundingClientRect();
        return [
            e.clientX - rect.left - container.clientLeft,
            e.clientY - rect.top - container.clientTop
        ];
    }
    d3.touch = function (container, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
            for (var i = 0, n = touches.length, touch; i < n; ++i) {
                if ((touch = touches[i]).identifier === identifier) {
                    return d3_mousePoint(container, touch);
                }
            }
    };
    d3.behavior.drag = function () {
        var event = d3_eventDispatch(drag, 'drag', 'dragstart', 'dragend'), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, 'mousemove', 'mouseup'), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, 'touchmove', 'touchend');
        function drag() {
            this.on('mousedown.drag', mousedown).on('touchstart.drag', touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function () {
                var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = '.drag' + (dragId == null ? '' : '-' + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [
                        dragOffset.x - position0[0],
                        dragOffset.y - position0[1]
                    ];
                } else {
                    dragOffset = [
                        0,
                        0
                    ];
                }
                dispatch({ type: 'dragstart' });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1)
                        return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: 'drag',
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId))
                        return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged);
                    dispatch({ type: 'dragend' });
                }
            };
        }
        drag.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, 'on');
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function (container, touches) {
        if (arguments.length < 2)
            touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function (touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var  = 0.000001, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? half : x < -1 ? -half : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var  = Math.SQRT2, 2 = 2, 4 = 4;
    d3.interpolateZoom = function (p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < 2) {
            S = Math.log(w1 / w0) / ;
            i = function (t) {
                return [
                    ux0 + t * dx,
                    uy0 + t * dy,
                    w0 * Math.exp( * t * S)
                ];
            };
        } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / ;
            i = function (t) {
                var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
                return [
                    ux0 + u * dx,
                    uy0 + u * dy,
                    w0 * coshr0 / d3_cosh( * s + r0)
                ];
            };
        }
        i.duration = S * 1000;
        return i;
    };
    d3.behavior.zoom = function () {
        var view = {
                x: 0,
                y: 0,
                k: 1
            }, translate0, center0, center, size = [
                960,
                500
            ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = 'mousedown.zoom', mousemove = 'mousemove.zoom', mouseup = 'mouseup.zoom', mousewheelTimer, touchstart = 'touchstart.zoom', touchtime, event = d3_eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend'), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = 'onwheel' in d3_document ? (d3_behavior_zoomDelta = function () {
                return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, 'wheel') : 'onmousewheel' in d3_document ? (d3_behavior_zoomDelta = function () {
                return d3.event.wheelDelta;
            }, 'mousewheel') : (d3_behavior_zoomDelta = function () {
                return -d3.event.detail;
            }, 'MozMousePixelScroll');
        }
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + '.zoom', mousewheeled).on('dblclick.zoom', dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function (g) {
            g.each(function () {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each('start.zoom', function () {
                        view = this.__chart__ || {
                            x: 0,
                            y: 0,
                            k: 1
                        };
                        zoomstarted(dispatch);
                    }).tween('zoom:zoom', function () {
                        var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([
                                (cx - view.x) / view.k,
                                (cy - view.y) / view.k,
                                dx / view.k
                            ], [
                                (cx - view1.x) / view1.k,
                                (cy - view1.y) / view1.k,
                                dx / view1.k
                            ]);
                        return function (t) {
                            var l = i(t), k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        };
                    }).each('interrupt.zoom', function () {
                        zoomended(dispatch);
                    }).each('end.zoom', function () {
                        zoomended(dispatch);
                    });
                } else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function (_) {
            if (!arguments.length)
                return [
                    view.x,
                    view.y
                ];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function (_) {
            if (!arguments.length)
                return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function (_) {
            if (!arguments.length)
                return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.center = function (_) {
            if (!arguments.length)
                return center;
            center = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.size = function (_) {
            if (!arguments.length)
                return size;
            size = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.duration = function (_) {
            if (!arguments.length)
                return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function (z) {
            if (!arguments.length)
                return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function (z) {
            if (!arguments.length)
                return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [
                (p[0] - view.x) / view.k,
                (p[1] - view.y) / view.k
            ];
        }
        function point(l) {
            return [
                l[0] * view.k + view.x,
                l[1] * view.k + view.y
            ];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0)
                that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1)
                x1.domain(x0.range().map(function (x) {
                    return (x - view.x) / view.k;
                }).map(x0.invert));
            if (y1)
                y1.domain(y0.range().map(function (y) {
                    return (y - view.y) / view.k;
                }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++)
                dispatch({ type: 'zoomstart' });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: 'zoom',
                scale: view.k,
                translate: [
                    view.x,
                    view.y
                ]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming)
                dispatch({ type: 'zoomend' }), center0 = null;
        }
        function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = '.zoom-' + d3.event.changedTouches[0].identifier, touchmove = 'touchmove' + zoomName, touchend = 'touchend' + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function (t) {
                    if (t.identifier in locations0)
                        locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0)
                            break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [
                        (p0[0] + p1[0]) / 2,
                        (p0[1] + p1[1]) / 2
                    ];
                    l0 = [
                        (l0[0] + l1[0]) / 2,
                        (l0[1] + l1[1]) / 2
                    ];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer)
                clearTimeout(mousewheelTimer);
            else
                d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function () {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 0.002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, 'on');
    };
    var d3_behavior_zoomInfinity = [
            0,
            Infinity
        ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() {
    }
    d3_color.prototype.toString = function () {
        return this.rgb() + '';
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse('' + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function () {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360)
                h -= 360;
            else if (h < 0)
                h += 360;
            if (h < 60)
                return m1 + (m2 - m1) * h / 60;
            if (h < 180)
                return m2;
            if (h < 240)
                return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function (k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function (k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function () {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
            h = 0;
        if (isNaN(c))
            c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function (k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function (k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function () {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse('' + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + '';
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b)
            return new d3_rgb(i, i, i);
        if (r && r < i)
            r = i;
        if (g && g < i)
            g = i;
        if (b && b < i)
            b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function () {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function () {
        return '#' + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? '0' + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
            m2 = m1[2].split(',');
            switch (m1[1]) {
            case 'hsl': {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }
            case 'rgb': {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === '#' && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            if (r == max)
                h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max)
                h = (b - r) / d + 2;
            else
                h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X), y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y), z = d3_xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === '%' ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function (key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === 'function' ? v : function () {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function (url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === 'function')
                callback = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = d3.dispatch('beforesend', 'progress', 'load', 'error'), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !('withCredentials' in request) && /^(http(s)?:)?\/\//.test(url))
            request = new XDomainRequest();
        'onload' in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function (event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        };
        xhr.header = function (name, value) {
            name = (name + '').toLowerCase();
            if (arguments.length < 2)
                return headers[name];
            if (value == null)
                delete headers[name];
            else
                headers[name] = value + '';
            return xhr;
        };
        xhr.mimeType = function (value) {
            if (!arguments.length)
                return mimeType;
            mimeType = value == null ? null : value + '';
            return xhr;
        };
        xhr.responseType = function (value) {
            if (!arguments.length)
                return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function (value) {
            response = value;
            return xhr;
        };
        [
            'get',
            'post'
        ].forEach(function (method) {
            xhr[method] = function () {
                return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
        });
        xhr.send = function (method, data, callback) {
            if (arguments.length === 2 && typeof data === 'function')
                callback = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !('accept' in headers))
                headers['accept'] = mimeType + ',*/*';
            if (request.setRequestHeader)
                for (var name in headers)
                    request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType)
                request.overrideMimeType(mimeType);
            if (responseType != null)
                request.responseType = responseType;
            if (callback != null)
                xhr.on('error', callback).on('load', function (request) {
                    callback(null, request);
                });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function () {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, 'on');
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function (error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== 'text' ? request.response : request.responseText;
    }
    d3.dsv = function (delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + '\n]'), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3)
                callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function (_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function (request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function (text, f) {
            var o;
            return dsv.parseRows(text, function (row, i) {
                if (o)
                    return o(row, i - 1);
                var a = new Function('d', 'return {' + row.map(function (name, i) {
                    return JSON.stringify(name) + ': d[' + i + ']';
                }).join(',') + '}');
                o = f ? function (row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function (text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N)
                    return EOF;
                if (eol)
                    return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34)
                                break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10)
                            ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10)
                        eol = true;
                    else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10)
                            ++I, ++k;
                    } else if (c !== delimiterCode)
                        continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null)
                    continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function (rows) {
            if (Array.isArray(rows[0]))
                return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function (row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
                return fields.map(function (field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join('\n');
        };
        dsv.formatRows = function (rows) {
            return rows.map(formatRow).join('\n');
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(',', 'text/csv');
    d3.tsv = d3.dsv('\t', 'text/tab-separated-values');
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, 'requestAnimationFrame')] || function (callback) {
            setTimeout(callback, 17);
        };
    d3.timer = function () {
        d3_timer.apply(this, arguments);
    };
    function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
            delay = 0;
        if (n < 3)
            then = Date.now();
        var time = then + delay, timer = {
                c: callback,
                t: time,
                n: null
            };
        if (d3_timer_queueTail)
            d3_timer_queueTail.n = timer;
        else
            d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
        return timer;
    }
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function () {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now(), timer = d3_timer_queueHead;
        while (timer) {
            if (now >= timer.t && timer.c(now - timer.t))
                timer.c = null;
            timer = timer.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.c) {
                if (t1.t < time)
                    time = t1.t;
                t1 = (t0 = t1).n;
            } else {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function (x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [
        'y',
        'z',
        'a',
        'f',
        'p',
        'n',
        '',
        'm',
        '',
        'k',
        'M',
        'G',
        'T',
        'P',
        'E',
        'Z',
        'Y'
    ].map(d3_formatPrefix);
    d3.formatPrefix = function (value, precision) {
        var i = 0;
        if (value = +value) {
            if (value < 0)
                value *= -1;
            if (precision)
                value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function (d) {
                return d / k;
            } : function (d) {
                return d * k;
            },
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function (value, width) {
                var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
                while (i > 0 && g > 0) {
                    if (length + g + 1 > width)
                        g = Math.max(1, width - length);
                    t.push(value.substring(i -= g, i + g));
                    if ((length += g + 1) > width)
                        break;
                    g = locale_grouping[j = (j + 1) % locale_grouping.length];
                }
                return t.reverse().join(locale_thousands);
            } : d3_identity;
        return function (specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || ' ', align = match[2] || '>', sign = match[3] || '-', symbol = match[4] || '', zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = '', suffix = '', integer = false, exponent = true;
            if (precision)
                precision = +precision.substring(1);
            if (zfill || fill === '0' && align === '=') {
                zfill = fill = '0';
                align = '=';
            }
            switch (type) {
            case 'n':
                comma = true;
                type = 'g';
                break;
            case '%':
                scale = 100;
                suffix = '%';
                type = 'f';
                break;
            case 'p':
                scale = 100;
                suffix = '%';
                type = 'r';
                break;
            case 'b':
            case 'o':
            case 'x':
            case 'X':
                if (symbol === '#')
                    prefix = '0' + type.toLowerCase();
            case 'c':
                exponent = false;
            case 'd':
                integer = true;
                precision = 0;
                break;
            case 's':
                scale = -1;
                type = 'r';
                break;
            }
            if (symbol === '$')
                prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == 'r' && !precision)
                type = 'g';
            if (precision != null) {
                if (type == 'g')
                    precision = Math.max(1, Math.min(21, precision));
                else if (type == 'e' || type == 'f')
                    precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function (value) {
                var fullSuffix = suffix;
                if (integer && value % 1)
                    return '';
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign === '-' ? '' : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf('.'), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf('e') : -1;
                    if (j < 0)
                        before = value, after = '';
                    else
                        before = value.substring(0, j), after = value.substring(j);
                } else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma)
                    before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : '';
                if (zcomma)
                    before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === '<' ? negative + value + padding : align === '>' ? padding + negative + value : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function (x) {
            return x.toString(2);
        },
        c: function (x) {
            return String.fromCharCode(x);
        },
        o: function (x) {
            return x.toString(8);
        },
        x: function (x) {
            return x.toString(16);
        },
        X: function (x) {
            return x.toString(16).toUpperCase();
        },
        g: function (x, p) {
            return x.toPrecision(p);
        },
        e: function (x, p) {
            return x.toExponential(p);
        },
        f: function (x, p) {
            return x.toFixed(p);
        },
        r: function (x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + '';
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function () {
            return this._.getUTCDate();
        },
        getDay: function () {
            return this._.getUTCDay();
        },
        getFullYear: function () {
            return this._.getUTCFullYear();
        },
        getHours: function () {
            return this._.getUTCHours();
        },
        getMilliseconds: function () {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function () {
            return this._.getUTCMinutes();
        },
        getMonth: function () {
            return this._.getUTCMonth();
        },
        getSeconds: function () {
            return this._.getUTCSeconds();
        },
        getTime: function () {
            return this._.getTime();
        },
        getTimezoneOffset: function () {
            return 0;
        },
        valueOf: function () {
            return this._.valueOf();
        },
        setDate: function () {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function () {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function () {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function () {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function () {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function () {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function () {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function () {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function () {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt))
                        times.push(new Date(+time));
                    step(time, 1);
                }
            } else {
                while (time < t1)
                    times.push(new Date(+time)), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function (date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function (date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function (date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function (date) {
        var day = new d3_date(2000, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function (date, offset) {
        date.setDate(date.getDate() + offset);
    }, function (date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function (date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 60000) / 86400000);
    };
    [
        'sunday',
        'monday',
        'tuesday',
        'wednesday',
        'thursday',
        'friday',
        'saturday'
    ].forEach(function (day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function (date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function (date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + 's'] = interval.range;
        d3_time[day + 's'].utc = interval.utc.range;
        d3_time[day + 'OfYear'] = function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.slice(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                            c = template.charAt(++i);
                        if (f = d3_time_formats[c])
                            c = f(date, p == null ? c === 'e' ? ' ' : '0' : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.slice(j, i));
                return string.join('');
            }
            format.parse = function (string) {
                var d = {
                        y: 1900,
                        m: 0,
                        d: 1,
                        H: 0,
                        M: 0,
                        S: 0,
                        L: 0,
                        Z: null
                    }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length)
                    return null;
                if ('p' in d)
                    d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ('j' in d)
                    date.setFullYear(d.y, 0, d.j);
                else if ('W' in d || 'U' in d) {
                    if (!('w' in d))
                        d.w = 'W' in d ? 1 : 0;
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, 'W' in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else
                    date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function () {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0)
                        return -1;
                } else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function (template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally {
                    d3_date = Date;
                }
            }
            format.parse = function (string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally {
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function (p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function (d) {
                return locale_shortDays[d.getDay()];
            },
            A: function (d) {
                return locale_days[d.getDay()];
            },
            b: function (d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function (d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function (d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function (d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function (d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function (d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function (d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function (d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function (d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function (d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function (d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function (d) {
                return d.getDay();
            },
            W: function (d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 10000, p, 4);
            },
            Z: d3_time_zone,
            '%': function () {
                return '%';
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            '%': d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
            '-': '',
            _: ' ',
            '0': '0'
        }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? '-' : '', string = (sign ? -value : value) + '', length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp('^(?:' + names.map(d3.requote).join('|') + ')', 'i');
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n)
            map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2000);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? '-' : '+', zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, '0', 2) + d3_time_formatPad(zm, '0', 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while (++i < n)
            formats[i][0] = this(formats[i][0]);
        return function (date) {
            var i = 0, f = formats[i];
            while (!f[1](date))
                f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function (locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: '.',
        thousands: ',',
        grouping: [3],
        currency: [
            '$',
            ''
        ],
        dateTime: '%a %b %e %X %Y',
        date: '%m/%d/%Y',
        time: '%H:%M:%S',
        periods: [
            'AM',
            'PM'
        ],
        days: [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ],
        shortDays: [
            'Sun',
            'Mon',
            'Tue',
            'Wed',
            'Thu',
            'Fri',
            'Sat'
        ],
        months: [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ],
        shortMonths: [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {
    }
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function (y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s)
                this.t += d3_adderTemp.t;
            else
                this.s = d3_adderTemp.t;
        },
        reset: function () {
            this.s = this.t = 0;
        },
        valueOf: function () {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function (object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function (feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function (object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n)
                d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function (object, listener) {
            listener.sphere();
        },
        Point: function (object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function (object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function (object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function (object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n)
                d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n)
            coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function (object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function () {
            d3_geo_areaSum += 4 * ;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function () {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 *  + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var 00, 00, 0, cos0, sin0;
        d3_geo_area.point = function (, ) {
            d3_geo_area.point = nextPoint;
            0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), sin0 = Math.sin();
        };
        function nextPoint(, ) {
             *= d3_radians;
             =  * d3_radians / 2 +  / 4;
            var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            0 = , cos0 = cos, sin0 = sin;
        }
        d3_geo_area.lineEnd = function () {
            nextPoint(00, 00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var  = spherical[0],  = spherical[1], cos = Math.cos();
        return [
            cos * Math.cos(),
            cos * Math.sin(),
            Math.sin()
        ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0]
        ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [
            vector[0] * k,
            vector[1] * k,
            vector[2] * k
        ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [
            Math.atan2(cartesian[1], cartesian[0]),
            d3_asin(cartesian[2])
        ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
    }
    d3.geo.bounds = function () {
        var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function () {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0)
                    0 = -(1 = 180), 0 = -(1 = 90);
                else if (dSum > )
                    1 = 90;
                else if (dSum < -)
                    0 = -90;
                range[0] = 0, range[1] = 1;
            }
        };
        function point(, ) {
            ranges.push(range = [
                0 = ,
                1 = 
            ]);
            if ( < 0)
                0 = ;
            if ( > 1)
                1 = ;
        }
        function linePoint(, ) {
            var p = d3_geo_cartesian([
                 * d3_radians,
                 * d3_radians
            ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [
                        normal[1],
                        -normal[0],
                        0
                    ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
                if (antimeridian ^ (s * _ < i && i < s * )) {
                    var i = inflection[1] * d3_degrees;
                    if (i > 1)
                        1 = i;
                } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
                    var i = -inflection[1] * d3_degrees;
                    if (i < 0)
                        0 = i;
                } else {
                    if ( < 0)
                        0 = ;
                    if ( > 1)
                        1 = ;
                }
                if (antimeridian) {
                    if ( < _) {
                        if (angle(0, ) > angle(0, 1))
                            1 = ;
                    } else {
                        if (angle(, 1) > angle(0, 1))
                            0 = ;
                    }
                } else {
                    if (1 >= 0) {
                        if ( < 0)
                            0 = ;
                        if ( > 1)
                            1 = ;
                    } else {
                        if ( > _) {
                            if (angle(0, ) > angle(0, 1))
                                1 = ;
                        } else {
                            if (angle(, 1) > angle(0, 1))
                                0 = ;
                        }
                    }
                }
            } else {
                point(, );
            }
            p0 = p, _ = ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = 0, range[1] = 1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(, ) {
            if (p0) {
                var d =  - _;
                dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
            } else
                __ = , __ = ;
            d3_geo_area.point(, );
            linePoint(, );
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(__, __);
            d3_geo_area.lineEnd();
            if (abs(dSum) > )
                0 = -(1 = 180);
            range[0] = 0, range[1] = 1;
            p0 = null;
        }
        function angle(0, 1) {
            return (1 -= 0) < 0 ? 1 + 360 : 1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function (feature) {
            1 = 1 = -(0 = 0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1]))
                            a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1]))
                            a[0] = b[0];
                    } else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, d;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                    b = merged[i];
                    if ((d = angle(a[1], b[0])) > best)
                        best = d, 0 = b[0], 1 = a[1];
                }
            }
            ranges = range = null;
            return 0 === Infinity || 0 === Infinity ? [
                [
                    NaN,
                    NaN
                ],
                [
                    NaN,
                    NaN
                ]
            ] : [
                [
                    0,
                    0
                ],
                [
                    1,
                    1
                ]
            ];
        };
    }();
    d3.geo.centroid = function (object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < 2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < )
                x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < 2)
                return [
                    NaN,
                    NaN
                ];
        }
        return [
            Math.atan2(y, x) * d3_degrees,
            d3_asin(z / Math.sqrt(m)) * d3_degrees
        ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(, ) {
         *= d3_radians;
        var cos = Math.cos( *= d3_radians);
        d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function (, ) {
             *= d3_radians;
            var cos = Math.cos( *= d3_radians);
            x0 = cos * Math.cos();
            y0 = cos * Math.sin();
            z0 = Math.sin();
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(, ) {
             *= d3_radians;
            var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var 00, 00, x0, y0, z0;
        d3_geo_centroid.point = function (, ) {
            00 = , 00 = ;
            d3_geo_centroid.point = nextPoint;
             *= d3_radians;
            var cos = Math.cos( *= d3_radians);
            x0 = cos * Math.cos();
            y0 = cos * Math.sin();
            z0 = Math.sin();
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function () {
            nextPoint(00, 00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(, ) {
             *= d3_radians;
            var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
            compose.invert = function (x, y) {
                return x = b.invert(x, y), x && a.invert(x[0], x[1]);
            };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function (segment) {
            if ((n = segment.length - 1) <= 0)
                return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i)
                    listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
            return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start, isSubject = true;
            while (current.v)
                if ((current = current.n) === start)
                    return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
            return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function (rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function () {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted)
                        listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function () {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(, ) {
                var point = rotate(, );
                if (pointVisible( = point[0],  = point[1]))
                    listener.point(, );
            }
            function pointLine(, ) {
                var point = rotate(, );
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(, ) {
                ring.push([
                    ,
                    
                ]);
                var point = rotate(, );
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n)
                    return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while (++i < n)
                            listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function () {
                lines.push(line = []);
            },
            point: function (, ) {
                line.push([
                    ,
                    
                ]);
            },
            lineEnd: d3_noop,
            buffer: function () {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function () {
                if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [
        -,
        - / 2
    ]);
    function d3_geo_clipAntimeridianLine(listener) {
        var 0 = NaN, 0 = NaN, s0 = NaN, clean;
        return {
            lineStart: function () {
                listener.lineStart();
                clean = 1;
            },
            point: function (1, 1) {
                var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
                if (abs(d - ) < ) {
                    listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
                    listener.point(s0, 0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(s1, 0);
                    listener.point(1, 0);
                    clean = 0;
                } else if (s0 !== s1 && d >= ) {
                    if (abs(0 - s0) < )
                        0 -= s0 * ;
                    if (abs(1 - s1) < )
                        1 -= s1 * ;
                    0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
                    listener.point(s0, 0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(s1, 0);
                    clean = 0;
                }
                listener.point(0 = 1, 0 = 1);
                s0 = s1;
            },
            lineEnd: function () {
                listener.lineEnd();
                0 = 0 = NaN;
            },
            clean: function () {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
        var cos0, cos1, sin0_1 = Math.sin(0 - 1);
        return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var ;
        if (from == null) {
             = direction * half;
            listener.point(-, );
            listener.point(0, );
            listener.point(, );
            listener.point(, 0);
            listener.point(, -);
            listener.point(0, -);
            listener.point(-, -);
            listener.point(-, 0);
            listener.point(-, );
        } else if (abs(from[0] - to[0]) > ) {
            var s = from[0] < to[0] ?  : -;
             = direction * s / 2;
            listener.point(-s, );
            listener.point(0, );
            listener.point(s, );
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [
                Math.sin(meridian),
                -Math.cos(meridian),
                0
            ], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i], m = ring.length;
            if (!m)
                continue;
            var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
            while (true) {
                if (j === m)
                    j = 0;
                point = ring[j];
                var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
                d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
                polarAngle += antimeridian ? d + sd *  : d;
                if (antimeridian ^ 0 >= meridian ^  >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ d >= 0 ? 1 : -1;
                    }
                }
                if (!j++)
                    break;
                0 = , sin0 = sin, cos0 = cos, point0 = point;
            }
        }
        return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < 0) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [
            0,
            -radius
        ] : [
            -,
            radius - 
        ]);
        function visible(, ) {
            return Math.cos() * Math.cos() > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function () {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function (, ) {
                    var point1 = [
                            ,
                            
                        ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
                    if (!point0 && (v00 = v0 = v))
                        listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ;
                            point1[1] += ;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function () {
                    if (v0)
                        listener.lineEnd();
                    point0 = null;
                },
                clean: function () {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [
                    1,
                    0,
                    0
                ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant)
                return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0)
                return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two)
                return q;
            var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
            if (1 < 0)
                z = 0, 0 = 1, 1 = z;
            var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
            if (!polar && 1 < 0)
                z = 0, 0 = 1, 1 = z;
            if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [
                    q,
                    d3_geo_spherical(q1)
                ];
            }
        }
        function code(, ) {
            var r = smallRadius ? radius :  - radius, code = 0;
            if ( < -r)
                code |= 1;
            else if ( > r)
                code |= 2;
            if ( < -r)
                code |= 4;
            else if ( > r)
                code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function (line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dx > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dx > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dy > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dy > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            if (t0 > 0)
                line.a = {
                    x: ax + t0 * dx,
                    y: ay + t0 * dy
                };
            if (t1 < 1)
                line.b = {
                    x: ax + t1 * dx,
                    y: ay + t1 * dy
                };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1000000000;
    d3.geo.clipExtent = function () {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
                stream: function (output) {
                    if (stream)
                        stream.valid = false;
                    stream = clip(output);
                    stream.valid = true;
                    return stream;
                },
                extent: function (_) {
                    if (!arguments.length)
                        return [
                            [
                                x0,
                                y0
                            ],
                            [
                                x1,
                                y1
                            ]
                        ];
                    clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                    if (stream)
                        stream.valid = false, stream = null;
                    return clipExtent;
                }
            };
        return clipExtent.extent([
            [
                0,
                0
            ],
            [
                960,
                500
            ]
        ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function (listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function () {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([
                            x0,
                            y1
                        ]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0)
                                ++wn;
                        } else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                                --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y))
                    listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon)
                    polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_)
                        bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_)
                    listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon)
                    ring.push([
                        x,
                        y
                    ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_)
                        listener.point(x, y);
                    else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v)
                                listener.lineEnd();
                            clean = false;
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_conic(projectAt) {
        var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
        p.parallels = function (_) {
            if (!arguments.length)
                return [
                    0 /  * 180,
                    1 /  * 180
                ];
            return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(0, 1) {
        var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
        function forward(, ) {
            var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
            return [
                 * Math.sin( *= n),
                0 -  * Math.cos()
            ];
        }
        forward.invert = function (x, y) {
            var 0_y = 0 - y;
            return [
                Math.atan2(x, 0_y) / n,
                d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n))
            ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function () {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function () {
        return d3.geo.conicEqualArea().rotate([
            96,
            0
        ]).center([
            -0.6,
            38.7
        ]).parallels([
            29.5,
            45.5
        ]).scale(1070);
    };
    d3.geo.albersUsa = function () {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([
            154,
            0
        ]).center([
            -2,
            58.5
        ]).parallels([
            55,
            65
        ]);
        var hawaii = d3.geo.conicEqualArea().rotate([
            157,
            0
        ]).center([
            -3,
            19.9
        ]).parallels([
            8,
            18
        ]);
        var point, pointStream = {
                point: function (x, y) {
                    point = [
                        x,
                        y
                    ];
                }
            }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function (coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function (x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function () {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function () {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function () {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function () {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function () {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function (_) {
            if (!arguments.length)
                return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function (_) {
            if (!arguments.length)
                return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * 0.35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
            if (!arguments.length)
                return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([
                [
                    x - 0.455 * k,
                    y - 0.238 * k
                ],
                [
                    x + 0.455 * k,
                    y + 0.238 * k
                ]
            ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([
                x - 0.307 * k,
                y + 0.201 * k
            ]).clipExtent([
                [
                    x - 0.425 * k + ,
                    y + 0.12 * k + 
                ],
                [
                    x - 0.214 * k - ,
                    y + 0.234 * k - 
                ]
            ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([
                x - 0.205 * k,
                y + 0.212 * k
            ]).clipExtent([
                [
                    x - 0.214 * k + ,
                    y + 0.166 * k + 
                ],
                [
                    x - 0.115 * k - ,
                    y + 0.234 * k - 
                ]
            ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function () {
                d3_geo_pathAreaPolygon = 0;
                d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function () {
                d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
                d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
        };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function (x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
            d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
            d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
            d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
            d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function () {
                if (buffer.length) {
                    var result = buffer.join('');
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push('M', x, ',', y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push('M', x, ',', y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push('L', x, ',', y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push('Z');
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return 'm0,' + radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + -2 * radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + 2 * radius + 'z';
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function () {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, );
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var 2 = 0.5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function (x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function () {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(, ) {
                var c = d3_geo_cartesian([
                        ,
                        
                    ]), p = project(, );
                resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(, ) {
                linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * 2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function (_) {
            if (!arguments.length)
                return Math.sqrt(2);
            maxDepth = (2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.path = function () {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === 'function')
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid)
                    cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function (object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function (object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [
                d3_geo_centroidX2 / d3_geo_centroidZ2,
                d3_geo_centroidY2 / d3_geo_centroidZ2
            ] : d3_geo_centroidZ1 ? [
                d3_geo_centroidX1 / d3_geo_centroidZ1,
                d3_geo_centroidY1 / d3_geo_centroidZ1
            ] : d3_geo_centroidZ0 ? [
                d3_geo_centroidX0 / d3_geo_centroidZ0,
                d3_geo_centroidY0 / d3_geo_centroidZ0
            ] : [
                NaN,
                NaN
            ];
        };
        path.bounds = function (object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [
                [
                    d3_geo_pathBoundsX0,
                    d3_geo_pathBoundsY0
                ],
                [
                    d3_geo_pathBoundsX1,
                    d3_geo_pathBoundsY1
                ]
            ];
        };
        path.projection = function (_) {
            if (!arguments.length)
                return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function (_) {
            if (!arguments.length)
                return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== 'function')
                contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function (_) {
            if (!arguments.length)
                return pointRadius;
            pointRadius = typeof _ === 'function' ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function (x, y) {
            return project([
                x * d3_degrees,
                y * d3_degrees
            ]);
        });
        return function (stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function (methods) {
        return {
            stream: function (stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods)
                    transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function (x, y) {
            this.stream.point(x, y);
        },
        sphere: function () {
            this.stream.sphere();
        },
        lineStart: function () {
            this.stream.lineStart();
        },
        lineEnd: function () {
            this.stream.lineEnd();
        },
        polygonStart: function () {
            this.stream.polygonStart();
        },
        polygonEnd: function () {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function () {
                stream.sphere();
            },
            lineStart: function () {
                stream.lineStart();
            },
            lineEnd: function () {
                stream.lineEnd();
            },
            polygonStart: function () {
                stream.polygonStart();
            },
            polygonEnd: function () {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function () {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function (x, y) {
                x = project(x, y);
                return [
                    x[0] * k + x,
                    y - x[1] * k
                ];
            }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [
                point[0] * k + x,
                y - point[1] * k
            ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
            return point && [
                point[0] * d3_degrees,
                point[1] * d3_degrees
            ];
        }
        projection.stream = function (output) {
            if (stream)
                stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function (_) {
            if (!arguments.length)
                return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function (_) {
            if (!arguments.length)
                return k;
            k = +_;
            return reset();
        };
        projection.translate = function (_) {
            if (!arguments.length)
                return [
                    x,
                    y
                ];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function (_) {
            if (!arguments.length)
                return [
                     * d3_degrees,
                     * d3_degrees
                ];
             = _[0] % 360 * d3_radians;
             = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function (_) {
            if (!arguments.length)
                return [
                     * d3_degrees,
                     * d3_degrees,
                     * d3_degrees
                ];
             = _[0] % 360 * d3_radians;
             = _[1] % 360 * d3_radians;
             = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, 'precision');
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
            var center = project(, );
            x = x - center[0] * k;
            y = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream)
                stream.valid = false, stream = null;
            return projection;
        }
        return function () {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function (x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(, ) {
        return [
            ,
            
        ];
    }
    (d3.geo.equirectangular = function () {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function (rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function (coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(, ) {
        return [
             >  ?  -  :  < - ?  +  : ,
            
        ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(, , ) {
        return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotation() {
        return function (, ) {
            return  += , [
                 >  ?  -  :  < - ?  +  : ,
                
            ];
        };
    }
    function d3_geo_rotation() {
        var rotation = d3_geo_forwardRotation();
        rotation.invert = d3_geo_forwardRotation(-);
        return rotation;
    }
    function d3_geo_rotation(, ) {
        var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
        function rotation(, ) {
            var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
            return [
                Math.atan2(y * cos - k * sin, x * cos - z * sin),
                d3_asin(k * cos + y * sin)
            ];
        }
        rotation.invert = function (, ) {
            var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
            return [
                Math.atan2(y * cos + z * sin, x * cos + k * sin),
                d3_asin(k * cos - x * sin)
            ];
        };
        return rotation;
    }
    d3.geo.circle = function () {
        var origin = [
                0,
                0
            ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === 'function' ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function (x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: 'Polygon',
                coordinates: [ring]
            };
        }
        circle.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return circle;
        };
        circle.angle = function (x) {
            if (!arguments.length)
                return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function (_) {
            if (!arguments.length)
                return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function (from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to)
                    from += direction * ;
            } else {
                from = radius + direction * ;
                to = radius - 0.5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([
                    cr,
                    -sr * Math.cos(t),
                    -sr * Math.sin(t)
                ]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
    }
    d3.geo.distance = function (a, b) {
        var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
        return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
    };
    d3.geo.graticule = function () {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: 'MultiLineString',
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
                return abs(x % DX) > ;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
                return abs(y % DY) > ;
            }).map(y));
        }
        graticule.lines = function () {
            return lines().map(function (coordinates) {
                return {
                    type: 'LineString',
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function () {
            return {
                type: 'Polygon',
                coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
            };
        };
        graticule.extent = function (_) {
            if (!arguments.length)
                return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function (_) {
            if (!arguments.length)
                return [
                    [
                        X0,
                        Y0
                    ],
                    [
                        X1,
                        Y1
                    ]
                ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1)
                _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1)
                _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function (_) {
            if (!arguments.length)
                return [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1)
                _ = x0, x0 = x1, x1 = _;
            if (y0 > y1)
                _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function (_) {
            if (!arguments.length)
                return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function (_) {
            if (!arguments.length)
                return [
                    DX,
                    DY
                ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function (_) {
            if (!arguments.length)
                return [
                    dx,
                    dy
                ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function (_) {
            if (!arguments.length)
                return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([
            [
                -180,
                -90 + 
            ],
            [
                180,
                90 - 
            ]
        ]).minorExtent([
            [
                -180,
                -80 - 
            ],
            [
                180,
                80 + 
            ]
        ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - , dy).concat(y1);
        return function (x) {
            return y.map(function (y) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - , dx).concat(x1);
        return function (y) {
            return x.map(function (x) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function () {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: 'LineString',
                coordinates: [
                    source_ || source.apply(this, arguments),
                    target_ || target.apply(this, arguments)
                ]
            };
        }
        greatArc.distance = function () {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function (_) {
            if (!arguments.length)
                return source;
            source = _, source_ = typeof _ === 'function' ? null : _;
            return greatArc;
        };
        greatArc.target = function (_) {
            if (!arguments.length)
                return target;
            target = _, target_ = typeof _ === 'function' ? null : _;
            return greatArc;
        };
        greatArc.precision = function () {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function (source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function (t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [
                Math.atan2(y, x) * d3_degrees,
                Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees
            ];
        } : function () {
            return [
                x0 * d3_degrees,
                y0 * d3_degrees
            ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function (object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var 0, sin0, cos0;
        d3_geo_length.point = function (, ) {
            0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function () {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(, ) {
            var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
            0 = , sin0 = sin, cos0 = cos;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(, ) {
            var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
            return [
                k * cos * Math.sin(),
                k * Math.sin()
            ];
        }
        azimuthal.invert = function (x, y) {
            var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
            return [
                Math.atan2(x * sinc,  * cosc),
                Math.asin( && y * sinc / )
            ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (coscos) {
        return Math.sqrt(2 / (1 + coscos));
    }, function () {
        return 2 * Math.asin( / 2);
    });
    (d3.geo.azimuthalEqualArea = function () {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (coscos) {
        var c = Math.acos(coscos);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function () {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(0, 1) {
        var cos0 = Math.cos(0), t = function () {
                return Math.tan( / 4 +  / 2);
            }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
        if (!n)
            return d3_geo_mercator;
        function forward(, ) {
            if (F > 0) {
                if ( < -half + )
                     = -half + ;
            } else {
                if ( > half - )
                     = half - ;
            }
            var  = F / Math.pow(t(), n);
            return [
                 * Math.sin(n * ),
                F -  * Math.cos(n * )
            ];
        }
        forward.invert = function (x, y) {
            var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
            return [
                Math.atan2(x, 0_y) / n,
                2 * Math.atan(Math.pow(F / , 1 / n)) - half
            ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function () {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(0, 1) {
        var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
        if (abs(n) < )
            return d3_geo_equirectangular;
        function forward(, ) {
            var  = G - ;
            return [
                 * Math.sin(n * ),
                G -  * Math.cos(n * )
            ];
        }
        forward.invert = function (x, y) {
            var 0_y = G - y;
            return [
                Math.atan2(x, 0_y) / n,
                G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y)
            ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function () {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function (coscos) {
        return 1 / coscos;
    }, Math.atan);
    (d3.geo.gnomonic = function () {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(, ) {
        return [
            ,
            Math.log(Math.tan( / 4 +  / 2))
        ];
    }
    d3_geo_mercator.invert = function (x, y) {
        return [
            x,
            2 * Math.atan(Math.exp(y)) - half
        ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function () {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function () {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function (_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k =  * scale(), t = translate();
                    clipExtent([
                        [
                            t[0] - k,
                            t[1] - k
                        ],
                        [
                            t[0] + k,
                            t[1] + k
                        ]
                    ]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function () {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function () {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function () {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function (coscos) {
        return 1 / (1 + coscos);
    }, function () {
        return 2 * Math.atan();
    });
    (d3.geo.stereographic = function () {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(, ) {
        return [
            Math.log(Math.tan( / 4 +  / 2)),
            -
        ];
    }
    d3_geo_transverseMercator.invert = function (x, y) {
        return [
            -y,
            2 * Math.atan(Math.exp(x)) - half
        ];
    };
    (d3.geo.transverseMercator = function () {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function (_) {
            return _ ? center([
                -_[1],
                _[0]
            ]) : (_ = center(), [
                _[1],
                -_[0]
            ]);
        };
        projection.rotate = function (_) {
            return _ ? rotate([
                _[0],
                _[1],
                _.length > 2 ? _[2] + 90 : 90
            ]) : (_ = rotate(), [
                _[0],
                _[1],
                _[2] - 90
            ]);
        };
        return rotate([
            0,
            0,
            90
        ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function (vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length)
            return hull(vertices);
        function hull(data) {
            if (data.length < 3)
                return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([
                    +fx.call(this, data[i], i),
                    +fy.call(this, data[i], i),
                    i
                ]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++)
                flippedPoints.push([
                    points[i][0],
                    -points[i][1]
                ]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i)
                polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i)
                polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function (_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function (_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [
                0,
                1
            ], hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
                --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function (coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function () {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * 0.5;
    };
    d3_geom_polygonPrototype.centroid = function (k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length)
            k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [
            x * k,
            y * k
        ];
    };
    d3_geom_polygonPrototype.clip = function (subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed)
                subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [
            x1 + ua * x21,
            y1 + ua * y21
        ];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
                x: x,
                y: y
            }, previous = beach.P, next = beach.N, disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > )
                node = node.L;
            else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > ) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -) {
                        lArc = node;
                        rArc = node.N;
                    } else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
            return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
                x: (cy * hb - by * hc) / d + ax,
                y: (bx * hc - cx * hb) / d + ay
            };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2)
            return rfocx;
        var lArc = arc.P;
        if (!lArc)
            return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2)
            return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2)
            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
            return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function () {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a)
                halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare())
                continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
                        x: x0,
                        y: abs(x2 - x0) <  ? y2 : y1
                    } : abs(y3 - y1) <  && x1 - x3 >  ? {
                        x: abs(y2 - y1) <  ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) <  && y3 - y0 >  ? {
                        x: x1,
                        y: abs(x2 - x1) <  ? y2 : y0
                    } : abs(y3 - y0) <  && x3 - x0 >  ? {
                        x: abs(y2 - y0) <  ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc)
            return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite)
            return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -2)
            return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L)
                    node = node.L;
                else {
                    before = node.P;
                    break;
                }
            } else {
                if (node.R)
                    node = node.R;
                else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
            d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P)
                d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
            return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1)
                return;
            if (lx > rx) {
                if (!va)
                    va = {
                        x: fx,
                        y: y0
                    };
                else if (va.y >= y1)
                    return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va)
                    va = {
                        x: fx,
                        y: y1
                    };
                else if (va.y < y0)
                    return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va)
                        va = {
                            x: (y0 - fb) / fm,
                            y: y0
                        };
                    else if (va.y >= y1)
                        return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va)
                        va = {
                            x: (y1 - fb) / fm,
                            y: y1
                        };
                    else if (va.y < y0)
                        return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else {
                if (ly < ry) {
                    if (!va)
                        va = {
                            x: x0,
                            y: fm * x0 + fb
                        };
                    else if (va.x >= x1)
                        return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                } else {
                    if (!va)
                        va = {
                            x: x1,
                            y: fm * x1 + fb
                        };
                    else if (va.x < x0)
                        return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
            d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
            d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) {
            edge.b = vertex;
        } else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function () {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function () {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function (after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N)
                    after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L)
                        after = after.L;
                    after.L = node;
                } else {
                    after.R = node;
                }
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function (node) {
            if (node.N)
                node.N.P = node.P;
            if (node.P)
                node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left)
                next = right;
            else if (!right)
                next = left;
            else
                next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node)
                    parent.L = next;
                else
                    parent.R = next;
            } else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node)
                node.U = parent;
            if (red)
                return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._)
                    break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node)
                node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
            p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
            p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
            node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
                break;
            }
        }
        if (bbox)
            d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function (points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points)
            return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function (e) {
                        var s = e.start();
                        return [
                            s.x,
                            s.y
                        ];
                    }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [
                        [
                            x0,
                            y1
                        ],
                        [
                            x1,
                            y1
                        ],
                        [
                            x1,
                            y0
                        ],
                        [
                            x0,
                            y0
                        ]
                    ] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function (d, i) {
                return {
                    x: Math.round(fx(d, i) / ) * ,
                    y: Math.round(fy(d, i) / ) * ,
                    i: i
                };
            });
        }
        voronoi.links = function (data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {
                return edge.l && edge.r;
            }).map(function (edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function (data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([
                            data[i],
                            data[s0.i],
                            data[s1.i]
                        ]);
                    }
                }
            });
            return triangles;
        };
        voronoi.x = function (_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function (_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [
                [
                    0,
                    0
                ],
                _
            ]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [
        [
            -1000000,
            -1000000
        ],
        [
            1000000,
            1000000
        ]
    ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function (vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function (points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat)
                    for (i = 0; i < n; ++i) {
                        d = data[i];
                        if (d.x < x1_)
                            x1_ = d.x;
                        if (d.y < y1_)
                            y1_ = d.y;
                        if (d.x > x2_)
                            x2_ = d.x;
                        if (d.y > y2_)
                            y2_ = d.y;
                        xs.push(d.x);
                        ys.push(d.y);
                    }
                else
                    for (i = 0; i < n; ++i) {
                        var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                        if (x_ < x1_)
                            x1_ = x_;
                        if (y_ < y1_)
                            y1_ = y_;
                        if (x_ > x2_)
                            x2_ = x_;
                        if (y_ > y2_)
                            y2_ = y_;
                        xs.push(x_);
                        ys.push(y_);
                    }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy)
                y2_ = y1_ + dx;
            else
                x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y))
                    return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < 0.01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right)
                    x1 = xm;
                else
                    x2 = xm;
                if (below)
                    y1 = ym;
                else
                    y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function (d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function (f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function (point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else
                data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function (_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function (_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [
                    [
                        x1,
                        y1
                    ],
                    [
                        x2,
                        y2
                    ]
                ];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [
                    x2 - x1,
                    y2 - y1
                ];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0])
                d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1])
                d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2])
                d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3])
                d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
                return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3])
                    switch (i & 3) {
                    case 0:
                        find(node, x1, y1, xm, ym);
                        break;
                    case 1:
                        find(node, xm, y1, x2, ym);
                        break;
                    case 2:
                        find(node, x1, ym, xm, y2);
                        break;
                    case 3:
                        find(node, xm, ym, x2, y2);
                        break;
                    }
            }
        }(root, x0, y0, x3, y3));
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function (t) {
            return '#' + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function (t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + '', b = b + '';
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs;
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i])
                    s[i] += bm;
                else
                    s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs;
            else
                s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {
            return b(t) + '';
        }) : function () {
            return b;
        } : (b = q.length, function (t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join('');
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, 'g');
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
        return f;
    }
    d3.interpolators = [function (a, b) {
            var t = typeof b;
            return (t === 'string' ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === 'object' && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i)
            x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
            c[i] = a[i];
        for (; i < nb; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; i < n0; ++i)
                c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function () {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function () {
            return d3_ease_quad;
        },
        cubic: function () {
            return d3_ease_cubic;
        },
        sin: function () {
            return d3_ease_sin;
        },
        exp: function () {
            return d3_ease_exp;
        },
        circle: function () {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function () {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        'in': d3_identity,
        out: d3_ease_reverse,
        'in-out': d3_ease_reflect,
        'out-in': function (f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function (name) {
        var i = name.indexOf('-'), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : 'in';
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function (t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function (t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function (t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0)
            return 0;
        if (t >= 1)
            return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    }
    function d3_ease_poly(e) {
        return function (t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * half);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
            p = 0.45;
        if (arguments.length)
            s = p /  * Math.asin(1 / a);
        else
            a = 1, s = p / 4;
        return function (t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
        };
    }
    function d3_ease_back(s) {
        if (!s)
            s = 1.70158;
        return function (t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc))
            bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + '';
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs))
            bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + '';
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function (t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + '';
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function (t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function (string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, 'g');
        return (d3.transform = function (string) {
            if (string != null) {
                g.setAttribute('transform', string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [
                m.a,
                m.b
            ], r1 = [
                m.c,
                m.d
            ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [
            m.e,
            m.f
        ];
        this.scale = [
            kx,
            ky
        ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function () {
        return 'translate(' + this.translate + ')rotate(' + this.rotate + ')skewX(' + this.skew + ')scale(' + this.scale + ')';
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + ',' : '';
    }
    function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push('translate(', null, ',', null, ')');
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push('translate(' + tb + ')');
        }
    }
    function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
            if (ra - rb > 180)
                rb += 360;
            else if (rb - ra > 180)
                ra += 360;
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + 'rotate(', null, ')') - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(d3_interpolateTransformPop(s) + 'rotate(' + rb + ')');
        }
    }
    function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) {
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + 'skewX(', null, ')') - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(d3_interpolateTransformPop(s) + 'skewX(' + wb + ')');
        }
    }
    function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + 'scale(', null, ',', null, ')');
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(d3_interpolateTransformPop(s) + 'scale(' + kb + ')');
        }
    }
    function d3_interpolateTransform(a, b) {
        var s = [], q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function (t) {
            var i = -1, n = q.length, o;
            while (++i < n)
                s[(o = q[i]).i] = o.x(t);
            return s.join('');
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function () {
        return function (links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n)
                paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
            return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function () {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function (a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function (d, i) {
                    d.sort(function (a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = ( - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + '-' + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: groupSums[di]
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + '-' + j], target = subgroups[j + '-' + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords)
                resort();
        }
        function resort() {
            chords.sort(function (a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function (x) {
            if (!arguments.length)
                return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function (x) {
            if (!arguments.length)
                return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function (x) {
            if (!arguments.length)
                return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function (x) {
            if (!arguments.length)
                return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function (x) {
            if (!arguments.length)
                return sortChords;
            sortChords = x;
            if (chords)
                resort();
            return chord;
        };
        chord.chords = function () {
            if (!chords)
                relayout();
            return chords;
        };
        chord.groups = function () {
            if (!groups)
                relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function () {
        var force = {}, event = d3.dispatch('start', 'tick', 'end'), timer, size = [
                1,
                1
            ], drag, alpha, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function (quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function () {
            if ((alpha *= 0.99) < 0.005) {
                timer = null;
                event.end({
                    type: 'end',
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : 0.5);
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k)
                    while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: 'tick',
                alpha: alpha
            });
        };
        force.nodes = function (x) {
            if (!arguments.length)
                return nodes;
            nodes = x;
            return force;
        };
        force.links = function (x) {
            if (!arguments.length)
                return links;
            links = x;
            return force;
        };
        force.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return force;
        };
        force.linkDistance = function (x) {
            if (!arguments.length)
                return linkDistance;
            linkDistance = typeof x === 'function' ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function (x) {
            if (!arguments.length)
                return linkStrength;
            linkStrength = typeof x === 'function' ? x : +x;
            return force;
        };
        force.friction = function (x) {
            if (!arguments.length)
                return friction;
            friction = +x;
            return force;
        };
        force.charge = function (x) {
            if (!arguments.length)
                return charge;
            charge = typeof x === 'function' ? x : +x;
            return force;
        };
        force.chargeDistance = function (x) {
            if (!arguments.length)
                return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function (x) {
            if (!arguments.length)
                return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function (x) {
            if (!arguments.length)
                return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function (x) {
            if (!arguments.length)
                return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) {
                    alpha = x;
                } else {
                    timer.c = null, timer.t = NaN, timer = null;
                    event.end({
                        type: 'end',
                        alpha: alpha = 0
                    });
                }
            } else if (x > 0) {
                event.start({
                    type: 'start',
                    alpha: alpha = x
                });
                timer = d3_timer(force.tick);
            }
            return force;
        };
        force.start = function () {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == 'number')
                    o.source = nodes[o.source];
                if (typeof o.target == 'number')
                    o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x))
                    o.x = position('x', w);
                if (isNaN(o.y))
                    o.y = position('y', h);
                if (isNaN(o.px))
                    o.px = o.x;
                if (isNaN(o.py))
                    o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === 'function')
                for (i = 0; i < m; ++i)
                    distances[i] = +linkDistance.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === 'function')
                for (i = 0; i < m; ++i)
                    strengths[i] = +linkStrength.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === 'function')
                for (i = 0; i < n; ++i)
                    charges[i] = +charge.call(this, nodes[i], i);
            else
                for (i = 0; i < n; ++i)
                    charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l)
                    if (!isNaN(x = candidates[j][dimension]))
                        return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function () {
            return force.alpha(0.1);
        };
        force.stop = function () {
            return force.alpha(0);
        };
        force.drag = function () {
            if (!drag)
                drag = d3.behavior.drag().origin(d3_identity).on('dragstart.force', d3_layout_forceDragstart).on('drag.force', dragmove).on('dragend.force', d3_layout_forceDragend);
            if (!arguments.length)
                return drag;
            this.on('mouseover.force', d3_layout_forceMouseover).on('mouseout.force', d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, 'on');
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null)
                    continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - 0.5;
                quad.point.y += Math.random() - 0.5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function () {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value)
                        node.value = 0;
                    node.children = childs;
                } else {
                    if (value)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var childs, parent;
                if (sort && (childs = node.children))
                    childs.sort(sort);
                if (value && (parent = node.parent))
                    parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function (x) {
            if (!arguments.length)
                return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function (x) {
            if (!arguments.length)
                return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function (x) {
            if (!arguments.length)
                return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function (root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function (node) {
                    if (node.children)
                        node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function (node) {
                    var parent;
                    if (!node.children)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent)
                        parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, 'sort', 'children', 'value');
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0)
                    nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n)
                    nodes.push(children[i]);
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function (parent) {
            return (parent.children || []).map(function (child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function () {
        var hierarchy = d3.layout.hierarchy(), size = [
                1,
                1
            ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n)
                    d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function () {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function (d, i) {
                    return +value.call(pie, d, i);
                }), a = +(typeof startAngle === 'function' ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === 'function' ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === 'function' ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null)
                index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {
                    return values[j] - values[i];
                } : function (i, j) {
                    return sort(data[i], data[j]);
                });
            index.forEach(function (i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function (_) {
            if (!arguments.length)
                return value;
            value = _;
            return pie;
        };
        pie.sort = function (_) {
            if (!arguments.length)
                return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function (_) {
            if (!arguments.length)
                return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function (_) {
            if (!arguments.length)
                return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function (_) {
            if (!arguments.length)
                return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function () {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length))
                return data;
            var series = data.map(function (d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function (d) {
                return d.map(function (v, i) {
                    return [
                        x.call(stack, v, i),
                        y.call(stack, v, i)
                    ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function (x) {
            if (!arguments.length)
                return values;
            values = x;
            return stack;
        };
        stack.order = function (x) {
            if (!arguments.length)
                return order;
            order = typeof x === 'function' ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function (x) {
            if (!arguments.length)
                return offset;
            offset = typeof x === 'function' ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            return stack;
        };
        stack.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            return stack;
        };
        stack.out = function (z) {
            if (!arguments.length)
                return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        'inside-out': function (data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function (a, b) {
                    return max[a] - max[b];
                }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function (data) {
            return d3.range(data.length).reverse();
        },
        'default': d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function (data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o > max)
                    max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function (data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i)
                    s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0)
                    o0 = o;
            }
            for (j = 0; j < m; ++j)
                y0[j] -= o0;
            return y0;
        },
        expand: function (data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o)
                    for (i = 0; i < n; i++)
                        data[i][j][1] /= o;
                else
                    for (i = 0; i < n; i++)
                        data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j)
                y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m)
            y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function () {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function (x) {
            if (!arguments.length)
                return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function (x) {
            if (!arguments.length)
                return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function (x) {
            if (!arguments.length)
                return binner;
            binner = typeof x === 'number' ? function (range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function (x) {
            if (!arguments.length)
                return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n)
            f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [
            d3.min(values),
            d3.max(values)
        ];
    }
    d3.layout.pack = function () {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [
                1,
                1
            ], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === 'function' ? radius : function () {
                    return radius;
                };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function (d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function (_) {
            if (!arguments.length)
                return size;
            size = _;
            return pack;
        };
        pack.radius = function (_) {
            if (!arguments.length)
                return radius;
            radius = _ == null || typeof _ === 'function' ? _ : +_;
            return pack;
        };
        pack.padding = function (_) {
            if (!arguments.length)
                return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return 0.999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
            return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r)
                            d3_layout_packSplice(a, b = j);
                        else
                            d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n)
                d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = 0.5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
                1,
                1
            ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize)
                d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    if (node.x < left.x)
                        left = node;
                    if (node.x > right.x)
                        right = node;
                    if (node.depth > bottom.depth)
                        bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                    A: null,
                    children: [root0]
                }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return tree;
        };
        tree.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
                1,
                1
            ], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function (node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function (child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function (x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function () {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [
                1,
                1
            ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = 'squarify', ratio = 0.5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === 'slice' ? rect.dx : mode === 'dice' ? rect.dy : mode === 'slice-dice' ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== 'squarify' || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area))
                    continue;
                if (r < rmin)
                    rmin = r;
                if (r > rmax)
                    rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy)
                    v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx)
                    v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value)
                root.dx = size[0], root.dy = size[1];
            else
                root.dx = root.dy = 0;
            if (stickies)
                hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky)
                stickies = nodes;
            return nodes;
        }
        treemap.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return treemap;
        };
        treemap.padding = function (x) {
            if (!arguments.length)
                return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === 'number' ? [
                    p,
                    p,
                    p,
                    p
                ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === 'function' ? padFunction : type === 'number' ? (x = [
                x,
                x,
                x,
                x
            ], padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function (x) {
            if (!arguments.length)
                return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function (x) {
            if (!arguments.length)
                return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function (x) {
            if (!arguments.length)
                return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function (x) {
            if (!arguments.length)
                return mode;
            mode = x + '';
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function (, ) {
            var n = arguments.length;
            if (n < 2)
                 = 1;
            if (n < 1)
                 = 0;
            return function () {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function () {
            var random = d3.random.normal.apply(d3, arguments);
            return function () {
                return Math.exp(random());
            };
        },
        bates: function (m) {
            var random = d3.random.irwinHall(m);
            return function () {
                return random() / m;
            };
        },
        irwinHall: function (m) {
            return function () {
                for (var s = 0, j = 0; j < m; j++)
                    s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [
            start,
            stop
        ] : [
            stop,
            start
        ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function (x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function (x) {
                return Math.floor(x / step) * step;
            },
            ceil: function (x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function (x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function () {
        return d3_scale_linear([
            0,
            1
        ], [
            0,
            1
        ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function (y) {
            return input(y);
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function (x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function (x) {
            if (!arguments.length)
                return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function (x) {
            if (!arguments.length)
                return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function () {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, 'range', 'rangeRound', 'interpolate', 'clamp');
    }
    function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null)
            m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= 0.15)
            step *= 10;
        else if (err <= 0.35)
            step *= 5;
        else if (err <= 0.75)
            step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === 's') {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7])
                    match[7] = '.' + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = 'f';
                format = d3.format(match.join(''));
                return function (d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7])
                match[7] = '.' + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join('');
        } else {
            format = ',.' + d3_scale_linearPrecision(range[2]) + 'f';
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== 'e') : p - (type === '%') * 2;
    }
    d3.scale.log = function () {
        return d3_scale_log(d3.scale.linear().domain([
            0,
            1
        ]), 10, true, [
            1,
            10
        ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function (x) {
            return pow(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function (_) {
            if (!arguments.length)
                return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function () {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function () {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (; i < j; i++)
                        for (var k = 1; k < n; k++)
                            ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for (; i++ < j;)
                        for (var k = n - 1; k > 0; k--)
                            ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) {
                }
                for (j = ticks.length; ticks[j - 1] > v; j--) {
                }
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function (n, format) {
            if (!arguments.length)
                return d3_scale_logFormat;
            if (arguments.length < 2)
                format = d3_scale_logFormat;
            else if (typeof format !== 'function')
                format = d3.format(format);
            var k = Math.max(1, base * n / scale.ticks().length);
            return function (d) {
                var i = d / pow(Math.round(log(d)));
                if (i * base < base - 0.5)
                    i *= base;
                return i <= k ? format(d) : '';
            };
        };
        scale.copy = function () {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format('.0e'), d3_scale_logNiceNegative = {
            floor: function (x) {
                return -Math.ceil(-x);
            },
            ceil: function (x) {
                return -Math.floor(-x);
            }
        };
    d3.scale.pow = function () {
        return d3_scale_pow(d3.scale.linear(), 1, [
            0,
            1
        ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function (x) {
            return powb(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function (x) {
            if (!arguments.length)
                return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function () {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function (x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function () {
        return d3.scale.pow().exponent(0.5);
    };
    d3.scale.ordinal = function () {
        return d3_scale_ordinal([], {
            t: 'range',
            a: [[]]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === 'range' ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function (i) {
                return start + step * i;
            });
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n)
                if (!index.has(xi = x[i]))
                    index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: 'range',
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: 'rangePoints',
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: 'rangeRoundPoints',
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse)
                range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: 'rangeBands',
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse)
                range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: 'rangeRoundBands',
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function () {
            return rangeBand;
        };
        scale.rangeExtent = function () {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function () {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function () {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function () {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function () {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function () {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [
        2062260,
        16744206,
        2924588,
        14034728,
        9725885,
        9197131,
        14907330,
        8355711,
        12369186,
        1556175
    ].map(d3_rgbString);
    var d3_category20 = [
        2062260,
        11454440,
        16744206,
        16759672,
        2924588,
        10018698,
        14034728,
        16750742,
        9725885,
        12955861,
        9197131,
        12885140,
        14907330,
        16234194,
        8355711,
        13092807,
        12369186,
        14408589,
        1556175,
        10410725
    ].map(d3_rgbString);
    var d3_category20b = [
        3750777,
        5395619,
        7040719,
        10264286,
        6519097,
        9216594,
        11915115,
        13556636,
        9202993,
        12426809,
        15186514,
        15190932,
        8666169,
        11356490,
        14049643,
        15177372,
        8077683,
        10834324,
        13528509,
        14589654
    ].map(d3_rgbString);
    var d3_category20c = [
        3244733,
        7057110,
        10406625,
        13032431,
        15095053,
        16616764,
        16625259,
        16634018,
        3253076,
        7652470,
        10607003,
        13101504,
        7695281,
        10394312,
        12369372,
        14342891,
        6513507,
        9868950,
        12434877,
        14277081
    ].map(d3_rgbString);
    d3.scale.quantile = function () {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q)
                thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x))
                return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function () {
            return thresholds;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return y < 0 ? [
                NaN,
                NaN
            ] : [
                y > 0 ? thresholds[y - 1] : domain[0],
                y < thresholds.length ? thresholds[y] : domain[domain.length - 1]
            ];
        };
        scale.copy = function () {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function () {
        return d3_scale_quantize(0, 1, [
            0,
            1
        ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return [
                    x0,
                    x1
                ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [
                y,
                y + 1 / kx
            ];
        };
        scale.copy = function () {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function () {
        return d3_scale_threshold([0.5], [
            0,
            1
        ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x)
                return range[d3.bisect(domain, x)];
        }
        scale.domain = function (_) {
            if (!arguments.length)
                return domain;
            domain = _;
            return scale;
        };
        scale.range = function (_) {
            if (!arguments.length)
                return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return [
                domain[y - 1],
                domain[y]
            ];
        };
        scale.copy = function () {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function () {
        return d3_scale_identity([
            0,
            1
        ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function () {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {};
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function () {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0)
                rc = r1, r1 = r0, r0 = rc;
            if (da >= )
                return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : '') + 'Z';
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw)
                    p1 *= -1;
                if (r1)
                    p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0)
                    p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 0.001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var rc1 = rc, rc0 = rc;
                if (da < ) {
                    var oc = x3 == null ? [
                            x2,
                            y2
                        ] : x1 == null ? [
                            x0,
                            y0
                        ] : d3_geom_polygonIntersect([
                            x0,
                            y0
                        ], [
                            x3,
                            y3
                        ], [
                            x1,
                            y1
                        ], [
                            x2,
                            y2
                        ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                    rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                    rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
                }
                if (x1 != null) {
                    var t30 = d3_svg_arcCornerTangents(x3 == null ? [
                            x2,
                            y2
                        ] : [
                            x3,
                            y3
                        ], [
                            x0,
                            y0
                        ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([
                            x1,
                            y1
                        ], [
                            x2,
                            y2
                        ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push('M', t30[0], 'A', rc1, ',', rc1, ' 0 0,', cr, ' ', t30[1], 'A', r1, ',', r1, ' 0 ', 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ',', cw, ' ', t12[1], 'A', rc1, ',', rc1, ' 0 0,', cr, ' ', t12[0]);
                    } else {
                        path.push('M', t30[0], 'A', rc1, ',', rc1, ' 0 1,', cr, ' ', t12[0]);
                    }
                } else {
                    path.push('M', x0, ',', y0);
                }
                if (x3 != null) {
                    var t03 = d3_svg_arcCornerTangents([
                            x0,
                            y0
                        ], [
                            x3,
                            y3
                        ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([
                            x2,
                            y2
                        ], x1 == null ? [
                            x0,
                            y0
                        ] : [
                            x1,
                            y1
                        ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push('L', t21[0], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t21[1], 'A', r0, ',', r0, ' 0 ', cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ',', 1 - cw, ' ', t03[1], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t03[0]);
                    } else {
                        path.push('L', t21[0], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t03[0]);
                    }
                } else {
                    path.push('L', x2, ',', y2);
                }
            } else {
                path.push('M', x0, ',', y0);
                if (x1 != null)
                    path.push('A', r1, ',', r1, ' 0 ', l1, ',', cw, ' ', x1, ',', y1);
                path.push('L', x2, ',', y2);
                if (x3 != null)
                    path.push('A', r0, ',', r0, ' 0 ', l0, ',', 1 - cw, ' ', x3, ',', y3);
            }
            path.push('Z');
            return path.join('');
        }
        function circleSegment(r1, cw) {
            return 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,' + cw + ' 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,' + cw + ' 0,' + r1;
        }
        arc.innerRadius = function (v) {
            if (!arguments.length)
                return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function (v) {
            if (!arguments.length)
                return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function (v) {
            if (!arguments.length)
                return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function (v) {
            if (!arguments.length)
                return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function (v) {
            if (!arguments.length)
                return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function () {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
            return [
                Math.cos(a) * r,
                Math.sin(a) * r
            ];
        };
        return arc;
    };
    var d3_svg_arcAuto = 'auto';
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
        return [
            [
                cx0 - ox,
                cy0 - oy
            ],
            [
                cx0 * r1 / r,
                cy0 * r1 / r
            ]
        ];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = 0.7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push('M', interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([
                        +fx.call(this, d, i),
                        +fy.call(this, d, i)
                    ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length)
                segment();
            return segments.length ? segments.join('') : null;
        }
        line.x = function (_) {
            if (!arguments.length)
                return x;
            x = _;
            return line;
        };
        line.y = function (_) {
            if (!arguments.length)
                return y;
            y = _;
            return line;
        };
        line.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return line;
        };
        line.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === 'function')
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function () {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        'linear-closed': d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        'step-before': d3_svg_lineStepBefore,
        'step-after': d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        'basis-open': d3_svg_lineBasisOpen,
        'basis-closed': d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        'cardinal-open': d3_svg_lineCardinalOpen,
        'cardinal-closed': d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function (key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join('L') : points + 'Z';
    }
    function d3_svg_lineLinearClosed(points) {
        return points.join('L') + 'Z';
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('H', (p[0] + (p = points[i])[0]) / 2, 'V', p[1]);
        if (n > 1)
            path.push('H', p[0]);
        return path.join('');
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('V', (p = points[i])[1], 'H', p[0]);
        return path.join('');
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('H', (p = points[i])[0], 'V', p[1]);
        return path.join('');
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = '', p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += 'Q' + (p[0] - t0[0] * 2 / 3) + ',' + (p[1] - t0[1] * 2 / 3) + ',' + p[0] + ',' + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += 'C' + (p0[0] + t0[0]) + ',' + (p0[1] + t0[1]) + ',' + (p[0] - t[0]) + ',' + (p[1] - t[1]) + ',' + p[0] + ',' + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += 'S' + (p[0] - t[0]) + ',' + (p[1] - t[1]) + ',' + p[0] + ',' + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += 'Q' + (p[0] + t[0] * 2 / 3) + ',' + (p[1] + t[1] * 2 / 3) + ',' + lp[0] + ',' + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([
                a * (p2[0] - p0[0]),
                a * (p2[1] - p0[1])
            ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3)
            return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [
                x0,
                x0,
                x0,
                (pi = points[1])[0]
            ], py = [
                y0,
                y0,
                y0,
                pi[1]
            ], path = [
                x0,
                ',',
                y0,
                'L',
                d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
                ',',
                d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
            ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push('L', pi);
        return path.join('');
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
            return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + ',' + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join('');
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
            ',',
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
        ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join('');
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [
            0,
            2 / 3,
            1 / 3,
            0
        ], d3_svg_lineBasisBezier2 = [
            0,
            1 / 3,
            2 / 3,
            0
        ], d3_svg_lineBasisBezier3 = [
            0,
            1 / 6,
            2 / 3,
            1 / 6
        ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push('C', d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([
                s || 0,
                m[i] * s || 0
            ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function () {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - half;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = 'L', tension = 0.7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function () {
                    return x;
                } : d3_functor(x1), fy1 = y0 === y1 ? function () {
                    return y;
                } : d3_functor(y1), x, y;
            function segment() {
                segments.push('M', interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), 'Z');
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([
                        x = +fx0.call(this, d, i),
                        y = +fy0.call(this, d, i)
                    ]);
                    points1.push([
                        +fx1.call(this, d, i),
                        +fy1.call(this, d, i)
                    ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length)
                segment();
            return segments.length ? segments.join('') : null;
        }
        area.x = function (_) {
            if (!arguments.length)
                return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function (_) {
            if (!arguments.length)
                return x0;
            x0 = _;
            return area;
        };
        area.x1 = function (_) {
            if (!arguments.length)
                return x1;
            x1 = _;
            return area;
        };
        area.y = function (_) {
            if (!arguments.length)
                return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function (_) {
            if (!arguments.length)
                return y0;
            y0 = _;
            return area;
        };
        area.y1 = function (_) {
            if (!arguments.length)
                return y1;
            y1 = _;
            return area;
        };
        area.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return area;
        };
        area.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === 'function')
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? 'M' : 'L';
            return area;
        };
        area.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function () {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function () {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function () {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return 'M' + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + 'Z';
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [
                    r * Math.cos(a0),
                    r * Math.sin(a0)
                ],
                p1: [
                    r * Math.cos(a1),
                    r * Math.sin(a1)
                ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return 'A' + r + ',' + r + ' 0 ' + +(a > ) + ',1 ' + p;
        }
        function curve(r0, p0, r1, p1) {
            return 'Q 0,0 ' + p1;
        }
        chord.radius = function (v) {
            if (!arguments.length)
                return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function (v) {
            if (!arguments.length)
                return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function (v) {
            if (!arguments.length)
                return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function () {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [
                    p0,
                    {
                        x: p0.x,
                        y: m
                    },
                    {
                        x: p3.x,
                        y: m
                    },
                    p3
                ];
            p = p.map(projection);
            return 'M' + p[0] + 'C' + p[1] + ' ' + p[2] + ' ' + p[3];
        }
        diagonal.source = function (x) {
            if (!arguments.length)
                return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function (x) {
            if (!arguments.length)
                return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function (x) {
            if (!arguments.length)
                return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [
            d.x,
            d.y
        ];
    }
    d3.svg.diagonal.radial = function () {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function (x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function () {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
            return [
                r * Math.cos(a),
                r * Math.sin(a)
            ];
        };
    }
    d3.svg.symbol = function () {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function (x) {
            if (!arguments.length)
                return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function (x) {
            if (!arguments.length)
                return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return 'circle';
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / );
        return 'M0,' + r + 'A' + r + ',' + r + ' 0 1,1 0,' + -r + 'A' + r + ',' + r + ' 0 1,1 0,' + r + 'Z';
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function (size) {
            var r = Math.sqrt(size / 5) / 2;
            return 'M' + -3 * r + ',' + -r + 'H' + -r + 'V' + -3 * r + 'H' + r + 'V' + -r + 'H' + 3 * r + 'V' + r + 'H' + r + 'V' + 3 * r + 'H' + -r + 'V' + r + 'H' + -3 * r + 'Z';
        },
        diamond: function (size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return 'M0,' + -ry + 'L' + rx + ',0' + ' 0,' + ry + ' ' + -rx + ',0' + 'Z';
        },
        square: function (size) {
            var r = Math.sqrt(size) / 2;
            return 'M' + -r + ',' + -r + 'L' + r + ',' + -r + ' ' + r + ',' + r + ' ' + -r + ',' + r + 'Z';
        },
        'triangle-down': function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return 'M0,' + ry + 'L' + rx + ',' + -ry + ' ' + -rx + ',' + -ry + 'Z';
        },
        'triangle-up': function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return 'M0,' + -ry + 'L' + rx + ',' + ry + ' ' + -rx + ',' + ry + 'Z';
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function (name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
                time: Date.now(),
                ease: d3_ease_cubicInOut,
                delay: 0,
                duration: 250
            };
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i])
                    d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function (name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function () {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
                active.timer.c = null;
                active.timer.t = NaN;
                if (--lock.count)
                    delete lock[activeId];
                else
                    delete this[ns];
                lock.active += 0.5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function (selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ('__data__' in node)
                        subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    transition = node[ns][id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o;) {
                        if (subnode = subnodes[k])
                            d3_transitionNode(subnode, k, ns, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== 'function')
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function (name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2)
            return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function (node) {
            node[ns][id].tween.remove(name);
        } : function (node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function (node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function (nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS)
                this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == 'transform' ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += '', function () {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += '', function () {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, 'attr.' + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function (nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function (t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function (t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween('attr.' + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== 'string') {
                if (n < 2)
                    value = '';
                for (priority in name)
                    this.style(priority, name[priority], value);
                return this;
            }
            priority = '';
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += '', function () {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function (t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, 'style.' + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function (name, tween, priority) {
        if (arguments.length < 3)
            priority = '';
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function (t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween('style.' + name, styleTween);
    };
    d3_transitionPrototype.text = function (value) {
        return d3_transition_tween(this, 'text', value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null)
            b = '';
        return function () {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function () {
        var ns = this.namespace;
        return this.each('end.transition', function () {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode))
                p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].ease;
        if (typeof value !== 'function')
            value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function (node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function (node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function (node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function (type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function (node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            } finally {
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        } else {
            d3_selection_each(this, function (node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch('start', 'end', 'interrupt'))).on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function () {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? '__transition__' : '__transition_' + name + '__';
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
                active: 0,
                count: 0
            }), transition = lock[id], time, timer, duration, ease, tweens;
        function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed)
                return start(elapsed - delay);
            timer.c = start;
        }
        function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
                active.timer.c = null;
                active.timer.t = NaN;
                --lock.count;
                delete lock[activeId];
                active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
                if (+cancelId < id) {
                    var cancel = lock[cancelId];
                    cancel.timer.c = null;
                    cancel.timer.t = NaN;
                    --lock.count;
                    delete lock[cancelId];
                }
            }
            timer.c = tick;
            d3_timer(function () {
                if (timer.c && tick(elapsed || 1)) {
                    timer.c = null;
                    timer.t = NaN;
                }
                return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function (key, value) {
                if (value = value.call(node, node.__data__, i)) {
                    tweens.push(value);
                }
            });
            ease = transition.ease;
            duration = transition.duration;
        }
        function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while (n > 0) {
                tweens[--n].call(node, e);
            }
            if (t >= 1) {
                transition.event && transition.event.end.call(node, node.__data__, i);
                if (--lock.count)
                    delete lock[id];
                else
                    delete node[ns];
                return 1;
            }
        }
        if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                timer: timer,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
        }
    }
    d3.svg.axis = function () {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function () {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll('.tick').data(ticks, scale1), tickEnter = tick.enter().insert('g', '.domain').attr('class', 'tick').style('opacity', ), tickExit = d3.transition(tick.exit()).style('opacity', ).remove(), tickUpdate = d3.transition(tick.order()).style('opacity', 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll('.domain').data([0]), pathUpdate = (path.enter().append('path').attr('class', 'domain'), d3.transition(path));
                tickEnter.append('line');
                tickEnter.append('text');
                var lineEnter = tickEnter.select('line'), lineUpdate = tickUpdate.select('line'), text = tick.select('text').text(tickFormat), textEnter = tickEnter.select('text'), textUpdate = tickUpdate.select('text'), sign = orient === 'top' || orient === 'left' ? -1 : 1, x1, x2, y1, y2;
                if (orient === 'bottom' || orient === 'top') {
                    tickTransform = d3_svg_axisX, x1 = 'x', y1 = 'y', x2 = 'x2', y2 = 'y2';
                    text.attr('dy', sign < 0 ? '0em' : '.71em').style('text-anchor', 'middle');
                    pathUpdate.attr('d', 'M' + range[0] + ',' + sign * outerTickSize + 'V0H' + range[1] + 'V' + sign * outerTickSize);
                } else {
                    tickTransform = d3_svg_axisY, x1 = 'y', y1 = 'x', x2 = 'y2', y2 = 'x2';
                    text.attr('dy', '.32em').style('text-anchor', sign < 0 ? 'end' : 'start');
                    pathUpdate.attr('d', 'M' + sign * outerTickSize + ',' + range[0] + 'H0V' + range[1] + 'H' + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function (d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1, scale0);
                }
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function (x) {
            if (!arguments.length)
                return scale;
            scale = x;
            return axis;
        };
        axis.orient = function (x) {
            if (!arguments.length)
                return orient;
            orient = x in d3_svg_axisOrients ? x + '' : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function () {
            if (!arguments.length)
                return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
        };
        axis.tickValues = function (x) {
            if (!arguments.length)
                return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function (x) {
            if (!arguments.length)
                return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function (x) {
            var n = arguments.length;
            if (!n)
                return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function (x) {
            if (!arguments.length)
                return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function (x) {
            if (!arguments.length)
                return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function (x) {
            if (!arguments.length)
                return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function () {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = 'bottom', d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
        };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr('transform', function (d) {
            var v0 = x0(d);
            return 'translate(' + (isFinite(v0) ? v0 : x1(d)) + ',0)';
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr('transform', function (d) {
            var v0 = y0(d);
            return 'translate(0,' + (isFinite(v0) ? v0 : y1(d)) + ')';
        });
    }
    d3.svg.brush = function () {
        var event = d3_eventDispatch(brush, 'brushstart', 'brush', 'brushend'), x = null, y = null, xExtent = [
                0,
                0
            ], yExtent = [
                0,
                0
            ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function () {
                var g = d3.select(this).style('pointer-events', 'all').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)').on('mousedown.brush', brushstart).on('touchstart.brush', brushstart);
                var background = g.selectAll('.background').data([0]);
                background.enter().append('rect').attr('class', 'background').style('visibility', 'hidden').style('cursor', 'crosshair');
                g.selectAll('.extent').data([0]).enter().append('rect').attr('class', 'extent').style('cursor', 'move');
                var resize = g.selectAll('.resize').data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append('g').attr('class', function (d) {
                    return 'resize ' + d;
                }).style('cursor', function (d) {
                    return d3_svg_brushCursor[d];
                }).append('rect').attr('x', function (d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr('y', function (d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr('width', 6).attr('height', 6).style('visibility', 'hidden');
                resize.style('display', brush.empty() ? 'none' : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr('x', range[0]).attr('width', range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr('y', range[0]).attr('height', range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function (g) {
            g.each(function () {
                var event_ = event.of(this, arguments), extent1 = {
                        x: xExtent,
                        y: yExtent,
                        i: xExtentDomain,
                        j: yExtentDomain
                    }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each('start.brush', function () {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({ type: 'brushstart' });
                    }).tween('brush:brush', function () {
                        var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function (t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: 'brush',
                                mode: 'resize'
                            });
                        };
                    }).each('end.brush', function () {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: 'brush',
                            mode: 'resize'
                        });
                        event_({ type: 'brushend' });
                    });
                } else {
                    event_({ type: 'brushstart' });
                    event_({
                        type: 'brush',
                        mode: 'resize'
                    });
                    event_({ type: 'brushend' });
                }
            });
        };
        function redraw(g) {
            g.selectAll('.resize').attr('transform', function (d) {
                return 'translate(' + xExtent[+/e$/.test(d)] + ',' + yExtent[+/^s/.test(d)] + ')';
            });
        }
        function redrawX(g) {
            g.select('.extent').attr('x', xExtent[0]);
            g.selectAll('.extent,.n>rect,.s>rect').attr('width', xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select('.extent').attr('y', yExtent[0]);
            g.selectAll('.extent,.e>rect,.w>rect').attr('height', yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed('extent'), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on('keydown.brush', keydown).on('keyup.brush', keyup);
            if (d3.event.changedTouches) {
                w.on('touchmove.brush', brushmove).on('touchend.brush', brushend);
            } else {
                w.on('mousemove.brush', brushmove).on('mouseup.brush', brushend);
            }
            g.interrupt().selectAll('*').interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [
                    xExtent[1 - ex] - origin[0],
                    yExtent[1 - ey] - origin[1]
                ];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey)
                center = origin.slice();
            g.style('pointer-events', 'none').selectAll('.resize').style('display', null);
            d3.select('body').style('cursor', eventTarget.style('cursor'));
            event_({ type: 'brushstart' });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center)
                            center = [
                                (xExtent[0] + xExtent[1]) / 2,
                                (yExtent[0] + yExtent[1]) / 2
                            ];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else
                        center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: 'brush',
                        mode: dragging ? 'move' : 'resize'
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center)
                        position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i)
                        yExtentDomain = null;
                    else
                        xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style('pointer-events', 'all').selectAll('.resize').style('display', brush.empty() ? 'none' : null);
                d3.select('body').style('cursor', null);
                w.on('mousemove.brush', null).on('mouseup.brush', null).on('touchmove.brush', null).on('touchend.brush', null).on('keydown.brush', null).on('keyup.brush', null);
                dragRestore();
                event_({ type: 'brushend' });
            }
        }
        brush.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function (z) {
            if (!arguments.length)
                return x && y ? [
                    xClamp,
                    yClamp
                ] : x ? xClamp : y ? yClamp : null;
            if (x && y)
                xClamp = !!z[0], yClamp = !!z[1];
            else if (x)
                xClamp = !!z;
            else if (y)
                yClamp = !!z;
            return brush;
        };
        brush.extent = function (z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    } else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert)
                            x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0)
                            t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    } else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert)
                            y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0)
                            t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ] : x ? [
                    x0,
                    x1
                ] : y && [
                    y0,
                    y1
                ];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y)
                    x0 = x0[0], x1 = x1[0];
                xExtentDomain = [
                    x0,
                    x1
                ];
                if (x.invert)
                    x0 = x(x0), x1 = x(x1);
                if (x1 < x0)
                    t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1])
                    xExtent = [
                        x0,
                        x1
                    ];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x)
                    y0 = y0[1], y1 = y1[1];
                yExtentDomain = [
                    y0,
                    y1
                ];
                if (y.invert)
                    y0 = y(y0), y1 = y(y1);
                if (y1 < y0)
                    t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1])
                    yExtent = [
                        y0,
                        y1
                    ];
            }
            return brush;
        };
        brush.clear = function () {
            if (!brush.empty()) {
                xExtent = [
                    0,
                    0
                ], yExtent = [
                    0,
                    0
                ];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function () {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, 'on');
    };
    var d3_svg_brushCursor = {
        n: 'ns-resize',
        e: 'ew-resize',
        s: 'ns-resize',
        w: 'ew-resize',
        nw: 'nwse-resize',
        ne: 'nesw-resize',
        se: 'nwse-resize',
        sw: 'nesw-resize'
    };
    var d3_svg_brushResizes = [
        [
            'n',
            'e',
            's',
            'w',
            'nw',
            'ne',
            'se',
            'sw'
        ],
        [
            'e',
            'w'
        ],
        [
            'n',
            's'
        ],
        []
    ];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc('%Y-%m-%dT%H:%M:%S.%LZ');
    d3_time_format.iso = Date.prototype.toISOString && +new Date('2000-01-01T00:00:00.000Z') ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function (string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 1000) * 1000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1000);
    }, function (date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 60000) * 60000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 60000);
    }, function (date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function (date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 3600000 - timezone) + timezone) * 3600000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 3600000);
    }, function (date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function (date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function (date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function (x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [
                methods.year,
                d3_scale_linearTickRange(extent.map(function (d) {
                    return d / 31536000000;
                }), count)[2]
            ] : !i ? [
                d3_time_scaleMilliseconds,
                d3_scale_linearTickRange(extent, count)[2]
            ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function (interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === 'number' && tickMethod(extent, interval);
            if (method)
                interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function (date) {
                    while (skipped(date = interval.floor(date)))
                        date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function (date) {
                    while (skipped(date = interval.ceil(date)))
                        date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function (interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === 'number' ? tickMethod(extent, interval) : !interval.range && [
                    { range: interval },
                    skip
                ];
            if (method)
                interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function () {
            return format;
        };
        scale.copy = function () {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [
        1000,
        5000,
        15000,
        30000,
        60000,
        300000,
        900000,
        1800000,
        3600000,
        10800000,
        21600000,
        43200000,
        86400000,
        172800000,
        604800000,
        2592000000,
        7776000000,
        31536000000
    ];
    var d3_time_scaleLocalMethods = [
        [
            d3_time.second,
            1
        ],
        [
            d3_time.second,
            5
        ],
        [
            d3_time.second,
            15
        ],
        [
            d3_time.second,
            30
        ],
        [
            d3_time.minute,
            1
        ],
        [
            d3_time.minute,
            5
        ],
        [
            d3_time.minute,
            15
        ],
        [
            d3_time.minute,
            30
        ],
        [
            d3_time.hour,
            1
        ],
        [
            d3_time.hour,
            3
        ],
        [
            d3_time.hour,
            6
        ],
        [
            d3_time.hour,
            12
        ],
        [
            d3_time.day,
            1
        ],
        [
            d3_time.day,
            2
        ],
        [
            d3_time.week,
            1
        ],
        [
            d3_time.month,
            1
        ],
        [
            d3_time.month,
            3
        ],
        [
            d3_time.year,
            1
        ]
    ];
    var d3_time_scaleLocalFormat = d3_time_format.multi([
        [
            '.%L',
            function (d) {
                return d.getMilliseconds();
            }
        ],
        [
            ':%S',
            function (d) {
                return d.getSeconds();
            }
        ],
        [
            '%I:%M',
            function (d) {
                return d.getMinutes();
            }
        ],
        [
            '%I %p',
            function (d) {
                return d.getHours();
            }
        ],
        [
            '%a %d',
            function (d) {
                return d.getDay() && d.getDate() != 1;
            }
        ],
        [
            '%b %d',
            function (d) {
                return d.getDate() != 1;
            }
        ],
        [
            '%B',
            function (d) {
                return d.getMonth();
            }
        ],
        [
            '%Y',
            d3_true
        ]
    ]);
    var d3_time_scaleMilliseconds = {
        range: function (start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {
        return [
            m[0].utc,
            m[1]
        ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([
        [
            '.%L',
            function (d) {
                return d.getUTCMilliseconds();
            }
        ],
        [
            ':%S',
            function (d) {
                return d.getUTCSeconds();
            }
        ],
        [
            '%I:%M',
            function (d) {
                return d.getUTCMinutes();
            }
        ],
        [
            '%I %p',
            function (d) {
                return d.getUTCHours();
            }
        ],
        [
            '%a %d',
            function (d) {
                return d.getUTCDay() && d.getUTCDate() != 1;
            }
        ],
        [
            '%b %d',
            function (d) {
                return d.getUTCDate() != 1;
            }
        ],
        [
            '%B',
            function (d) {
                return d.getUTCMonth();
            }
        ],
        [
            '%Y',
            d3_true
        ]
    ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function (request) {
        return request.responseText;
    });
    d3.json = function (url, callback) {
        return d3_xhr(url, 'application/json', d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function (url, callback) {
        return d3_xhr(url, 'text/html', d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function (request) {
        return request.responseXML;
    });
    if (typeof define === 'function' && define.amd)
        this.d3 = d3, define('d3@3.5.12#d3', d3);
    else if (typeof module === 'object' && module.exports)
        module.exports = d3;
    else
        this.d3 = d3;
}();
/*nvd3@1.8.1-dev#build/nv.d3*/
define('nvd3@1.8.1-dev#build/nv.d3', function (require, exports, module) {
    (function () {
        var nv = {};
        nv.dev = false;
        nv.tooltip = nv.tooltip || {};
        nv.utils = nv.utils || {};
        nv.models = nv.models || {};
        nv.charts = {};
        nv.logs = {};
        nv.dom = {};
        nv.dispatch = d3.dispatch('render_start', 'render_end');
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (oThis) {
                if (typeof this !== 'function') {
                    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                }
                var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {
                    }, fBound = function () {
                        return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                    };
                fNOP.prototype = this.prototype;
                fBound.prototype = new fNOP();
                return fBound;
            };
        }
        if (nv.dev) {
            nv.dispatch.on('render_start', function (e) {
                nv.logs.startTime = +new Date();
            });
            nv.dispatch.on('render_end', function (e) {
                nv.logs.endTime = +new Date();
                nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;
                nv.log('total', nv.logs.totalTime);
            });
        }
        nv.log = function () {
            if (nv.dev && window.console && console.log && console.log.apply)
                console.log.apply(console, arguments);
            else if (nv.dev && window.console && typeof console.log == 'function' && Function.prototype.bind) {
                var log = Function.prototype.bind.call(console.log, console);
                log.apply(console, arguments);
            }
            return arguments[arguments.length - 1];
        };
        nv.deprecated = function (name, info) {
            if (console && console.warn) {
                console.warn('nvd3 warning: `' + name + '` has been deprecated. ', info || '');
            }
        };
        nv.render = function render(step) {
            step = step || 1;
            nv.render.active = true;
            nv.dispatch.render_start();
            var renderLoop = function () {
                var chart, graph;
                for (var i = 0; i < step && (graph = nv.render.queue[i]); i++) {
                    chart = graph.generate();
                    if (typeof graph.callback == typeof Function)
                        graph.callback(chart);
                }
                nv.render.queue.splice(0, i);
                if (nv.render.queue.length) {
                    setTimeout(renderLoop);
                } else {
                    nv.dispatch.render_end();
                    nv.render.active = false;
                }
            };
            setTimeout(renderLoop);
        };
        nv.render.active = false;
        nv.render.queue = [];
        nv.addGraph = function (obj) {
            if (typeof arguments[0] === typeof Function) {
                obj = {
                    generate: arguments[0],
                    callback: arguments[1]
                };
            }
            nv.render.queue.push(obj);
            if (!nv.render.active) {
                nv.render();
            }
        };
        if (typeof module !== 'undefined' && typeof exports !== 'undefined') {
            module.exports = nv;
        }
        if (typeof window !== 'undefined') {
            window.nv = nv;
        }
        nv.dom.write = function (callback) {
            if (window.fastdom !== undefined) {
                return fastdom.write(callback);
            }
            return callback();
        };
        nv.dom.read = function (callback) {
            if (window.fastdom !== undefined) {
                return fastdom.read(callback);
            }
            return callback();
        };
        nv.interactiveGuideline = function () {
            'use strict';
            var margin = {
                    left: 0,
                    top: 0
                }, width = null, height = null, xScale = d3.scale.linear(), dispatch = d3.dispatch('elementMousemove', 'elementMouseout', 'elementClick', 'elementDblclick', 'elementMouseDown', 'elementMouseUp'), showGuideLine = true, svgContainer = null, tooltip = nv.models.tooltip(), isMSIE = 'ActiveXObject' in window;
            tooltip.duration(0).hideDelay(0).hidden(false);
            function layer(selection) {
                selection.each(function (data) {
                    var container = d3.select(this);
                    var availableWidth = width || 960, availableHeight = height || 400;
                    var wrap = container.selectAll('g.nv-wrap.nv-interactiveLineLayer').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', ' nv-wrap nv-interactiveLineLayer');
                    wrapEnter.append('g').attr('class', 'nv-interactiveGuideLine');
                    if (!svgContainer) {
                        return;
                    }
                    function mouseHandler() {
                        var d3mouse = d3.mouse(this);
                        var mouseX = d3mouse[0];
                        var mouseY = d3mouse[1];
                        var subtractMargin = true;
                        var mouseOutAnyReason = false;
                        if (isMSIE) {
                            mouseX = d3.event.offsetX;
                            mouseY = d3.event.offsetY;
                            if (d3.event.target.tagName !== 'svg') {
                                subtractMargin = false;
                            }
                            if (d3.event.target.className.baseVal.match('nv-legend')) {
                                mouseOutAnyReason = true;
                            }
                        }
                        if (subtractMargin) {
                            mouseX -= margin.left;
                            mouseY -= margin.top;
                        }
                        if (mouseX < 0 || mouseY < 0 || mouseX > availableWidth || mouseY > availableHeight || d3.event.relatedTarget && d3.event.relatedTarget.ownerSVGElement === undefined || mouseOutAnyReason) {
                            if (isMSIE) {
                                if (d3.event.relatedTarget && d3.event.relatedTarget.ownerSVGElement === undefined && (d3.event.relatedTarget.className === undefined || d3.event.relatedTarget.className.match(tooltip.nvPointerEventsClass))) {
                                    return;
                                }
                            }
                            dispatch.elementMouseout({
                                mouseX: mouseX,
                                mouseY: mouseY
                            });
                            layer.renderGuideLine(null);
                            tooltip.hidden(true);
                            return;
                        } else {
                            tooltip.hidden(false);
                        }
                        var pointXValue = xScale.invert(mouseX);
                        dispatch.elementMousemove({
                            mouseX: mouseX,
                            mouseY: mouseY,
                            pointXValue: pointXValue
                        });
                        if (d3.event.type === 'dblclick') {
                            dispatch.elementDblclick({
                                mouseX: mouseX,
                                mouseY: mouseY,
                                pointXValue: pointXValue
                            });
                        }
                        if (d3.event.type === 'click') {
                            dispatch.elementClick({
                                mouseX: mouseX,
                                mouseY: mouseY,
                                pointXValue: pointXValue
                            });
                        }
                        if (d3.event.type === 'mousedown') {
                            dispatch.elementMouseDown({
                                mouseX: mouseX,
                                mouseY: mouseY,
                                pointXValue: pointXValue
                            });
                        }
                        if (d3.event.type === 'mouseup') {
                            dispatch.elementMouseUp({
                                mouseX: mouseX,
                                mouseY: mouseY,
                                pointXValue: pointXValue
                            });
                        }
                    }
                    svgContainer.on('touchmove', mouseHandler).on('mousemove', mouseHandler, true).on('mouseout', mouseHandler, true).on('mousedown', mouseHandler, true).on('mouseup', mouseHandler, true).on('dblclick', mouseHandler).on('click', mouseHandler);
                    layer.guideLine = null;
                    layer.renderGuideLine = function (x) {
                        if (!showGuideLine)
                            return;
                        if (layer.guideLine && layer.guideLine.attr('x1') === x)
                            return;
                        nv.dom.write(function () {
                            var line = wrap.select('.nv-interactiveGuideLine').selectAll('line').data(x != null ? [nv.utils.NaNtoZero(x)] : [], String);
                            line.enter().append('line').attr('class', 'nv-guideline').attr('x1', function (d) {
                                return d;
                            }).attr('x2', function (d) {
                                return d;
                            }).attr('y1', availableHeight).attr('y2', 0);
                            line.exit().remove();
                        });
                    };
                });
            }
            layer.dispatch = dispatch;
            layer.tooltip = tooltip;
            layer.margin = function (_) {
                if (!arguments.length)
                    return margin;
                margin.top = typeof _.top != 'undefined' ? _.top : margin.top;
                margin.left = typeof _.left != 'undefined' ? _.left : margin.left;
                return layer;
            };
            layer.width = function (_) {
                if (!arguments.length)
                    return width;
                width = _;
                return layer;
            };
            layer.height = function (_) {
                if (!arguments.length)
                    return height;
                height = _;
                return layer;
            };
            layer.xScale = function (_) {
                if (!arguments.length)
                    return xScale;
                xScale = _;
                return layer;
            };
            layer.showGuideLine = function (_) {
                if (!arguments.length)
                    return showGuideLine;
                showGuideLine = _;
                return layer;
            };
            layer.svgContainer = function (_) {
                if (!arguments.length)
                    return svgContainer;
                svgContainer = _;
                return layer;
            };
            return layer;
        };
        nv.interactiveBisect = function (values, searchVal, xAccessor) {
            'use strict';
            if (!(values instanceof Array)) {
                return null;
            }
            var _xAccessor;
            if (typeof xAccessor !== 'function') {
                _xAccessor = function (d) {
                    return d.x;
                };
            } else {
                _xAccessor = xAccessor;
            }
            var _cmp = function (d, v) {
                return _xAccessor(d) - v;
            };
            var bisect = d3.bisector(_cmp).left;
            var index = d3.max([
                0,
                bisect(values, searchVal) - 1
            ]);
            var currentValue = _xAccessor(values[index]);
            if (typeof currentValue === 'undefined') {
                currentValue = index;
            }
            if (currentValue === searchVal) {
                return index;
            }
            var nextIndex = d3.min([
                index + 1,
                values.length - 1
            ]);
            var nextValue = _xAccessor(values[nextIndex]);
            if (typeof nextValue === 'undefined') {
                nextValue = nextIndex;
            }
            if (Math.abs(nextValue - searchVal) >= Math.abs(currentValue - searchVal)) {
                return index;
            } else {
                return nextIndex;
            }
        };
        nv.nearestValueIndex = function (values, searchVal, threshold) {
            'use strict';
            var yDistMax = Infinity, indexToHighlight = null;
            values.forEach(function (d, i) {
                var delta = Math.abs(searchVal - d);
                if (d != null && delta <= yDistMax && delta < threshold) {
                    yDistMax = delta;
                    indexToHighlight = i;
                }
            });
            return indexToHighlight;
        };
        nv.models.tooltip = function () {
            'use strict';
            var id = 'nvtooltip-' + Math.floor(Math.random() * 100000), data = null, gravity = 'w', distance = 25, snapDistance = 0, fixedTop = null, classes = null, chartContainer = null, hidden = true, hideDelay = 200, tooltip = null, lastPosition = {
                    left: null,
                    top: null
                }, enabled = true, duration = 100, headerEnabled = true, nvPointerEventsClass = 'nv-pointer-events-none';
            var position = function () {
                return {
                    left: d3.event.clientX,
                    top: d3.event.clientY
                };
            };
            var valueFormatter = function (d, i) {
                return d;
            };
            var headerFormatter = function (d) {
                return d;
            };
            var keyFormatter = function (d, i) {
                return d;
            };
            var contentGenerator = function (d) {
                if (d === null) {
                    return '';
                }
                var table = d3.select(document.createElement('table'));
                if (headerEnabled) {
                    var theadEnter = table.selectAll('thead').data([d]).enter().append('thead');
                    theadEnter.append('tr').append('td').attr('colspan', 3).append('strong').classed('x-value', true).html(headerFormatter(d.value));
                }
                var tbodyEnter = table.selectAll('tbody').data([d]).enter().append('tbody');
                var trowEnter = tbodyEnter.selectAll('tr').data(function (p) {
                    return p.series;
                }).enter().append('tr').classed('highlight', function (p) {
                    return p.highlight;
                });
                trowEnter.append('td').classed('legend-color-guide', true).append('div').style('background-color', function (p) {
                    return p.color;
                });
                trowEnter.append('td').classed('key', true).classed('total', function (p) {
                    return !!p.total;
                }).html(function (p, i) {
                    return keyFormatter(p.key, i);
                });
                trowEnter.append('td').classed('value', true).html(function (p, i) {
                    return valueFormatter(p.value, i);
                });
                trowEnter.selectAll('td').each(function (p) {
                    if (p.highlight) {
                        var opacityScale = d3.scale.linear().domain([
                            0,
                            1
                        ]).range([
                            '#fff',
                            p.color
                        ]);
                        var opacity = 0.6;
                        d3.select(this).style('border-bottom-color', opacityScale(opacity)).style('border-top-color', opacityScale(opacity));
                    }
                });
                var html = table.node().outerHTML;
                if (d.footer !== undefined)
                    html += '<div class=\'footer\'>' + d.footer + '</div>';
                return html;
            };
            var dataSeriesExists = function (d) {
                if (d && d.series) {
                    if (d.series instanceof Array) {
                        return !!d.series.length;
                    }
                    if (d.series instanceof Object) {
                        d.series = [d.series];
                        return true;
                    }
                }
                return false;
            };
            var calcGravityOffset = function (pos) {
                var height = tooltip.node().offsetHeight, width = tooltip.node().offsetWidth, clientWidth = document.documentElement.clientWidth, clientHeight = document.documentElement.clientHeight, left, top, tmp;
                switch (gravity) {
                case 'e':
                    left = -width - distance;
                    top = -(height / 2);
                    if (pos.left + left < 0)
                        left = distance;
                    if ((tmp = pos.top + top) < 0)
                        top -= tmp;
                    if ((tmp = pos.top + top + height) > clientHeight)
                        top -= tmp - clientHeight;
                    break;
                case 'w':
                    left = distance;
                    top = -(height / 2);
                    if (pos.left + left + width > clientWidth)
                        left = -width - distance;
                    if ((tmp = pos.top + top) < 0)
                        top -= tmp;
                    if ((tmp = pos.top + top + height) > clientHeight)
                        top -= tmp - clientHeight;
                    break;
                case 'n':
                    left = -(width / 2) - 5;
                    top = distance;
                    if (pos.top + top + height > clientHeight)
                        top = -height - distance;
                    if ((tmp = pos.left + left) < 0)
                        left -= tmp;
                    if ((tmp = pos.left + left + width) > clientWidth)
                        left -= tmp - clientWidth;
                    break;
                case 's':
                    left = -(width / 2);
                    top = -height - distance;
                    if (pos.top + top < 0)
                        top = distance;
                    if ((tmp = pos.left + left) < 0)
                        left -= tmp;
                    if ((tmp = pos.left + left + width) > clientWidth)
                        left -= tmp - clientWidth;
                    break;
                case 'center':
                    left = -(width / 2);
                    top = -(height / 2);
                    break;
                default:
                    left = 0;
                    top = 0;
                    break;
                }
                return {
                    'left': left,
                    'top': top
                };
            };
            var positionTooltip = function () {
                nv.dom.read(function () {
                    var pos = position(), gravityOffset = calcGravityOffset(pos), left = pos.left + gravityOffset.left, top = pos.top + gravityOffset.top;
                    if (hidden) {
                        tooltip.interrupt().transition().delay(hideDelay).duration(0).style('opacity', 0);
                    } else {
                        var old_translate = 'translate(' + lastPosition.left + 'px, ' + lastPosition.top + 'px)';
                        var new_translate = 'translate(' + left + 'px, ' + top + 'px)';
                        var translateInterpolator = d3.interpolateString(old_translate, new_translate);
                        var is_hidden = tooltip.style('opacity') < 0.1;
                        tooltip.interrupt().transition().duration(is_hidden ? 0 : duration).styleTween('transform', function (d) {
                            return translateInterpolator;
                        }, 'important').styleTween('-webkit-transform', function (d) {
                            return translateInterpolator;
                        }).style('-ms-transform', new_translate).style('opacity', 1);
                    }
                    lastPosition.left = left;
                    lastPosition.top = top;
                });
            };
            function initTooltip() {
                if (!tooltip) {
                    var container = chartContainer ? chartContainer : document.body;
                    tooltip = d3.select(container).append('div').attr('class', 'nvtooltip ' + (classes ? classes : 'xy-tooltip')).attr('id', id);
                    tooltip.style('top', 0).style('left', 0);
                    tooltip.style('opacity', 0);
                    tooltip.style('position', 'fixed');
                    tooltip.selectAll('div, table, td, tr').classed(nvPointerEventsClass, true);
                    tooltip.classed(nvPointerEventsClass, true);
                }
            }
            function nvtooltip() {
                if (!enabled)
                    return;
                if (!dataSeriesExists(data))
                    return;
                nv.dom.write(function () {
                    initTooltip();
                    var newContent = contentGenerator(data);
                    if (newContent) {
                        tooltip.node().innerHTML = newContent;
                    }
                    positionTooltip();
                });
                return nvtooltip;
            }
            nvtooltip.nvPointerEventsClass = nvPointerEventsClass;
            nvtooltip.options = nv.utils.optionsFunc.bind(nvtooltip);
            nvtooltip._options = Object.create({}, {
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                    }
                },
                gravity: {
                    get: function () {
                        return gravity;
                    },
                    set: function (_) {
                        gravity = _;
                    }
                },
                distance: {
                    get: function () {
                        return distance;
                    },
                    set: function (_) {
                        distance = _;
                    }
                },
                snapDistance: {
                    get: function () {
                        return snapDistance;
                    },
                    set: function (_) {
                        snapDistance = _;
                    }
                },
                classes: {
                    get: function () {
                        return classes;
                    },
                    set: function (_) {
                        classes = _;
                    }
                },
                chartContainer: {
                    get: function () {
                        return chartContainer;
                    },
                    set: function (_) {
                        chartContainer = _;
                    }
                },
                enabled: {
                    get: function () {
                        return enabled;
                    },
                    set: function (_) {
                        enabled = _;
                    }
                },
                hideDelay: {
                    get: function () {
                        return hideDelay;
                    },
                    set: function (_) {
                        hideDelay = _;
                    }
                },
                contentGenerator: {
                    get: function () {
                        return contentGenerator;
                    },
                    set: function (_) {
                        contentGenerator = _;
                    }
                },
                valueFormatter: {
                    get: function () {
                        return valueFormatter;
                    },
                    set: function (_) {
                        valueFormatter = _;
                    }
                },
                headerFormatter: {
                    get: function () {
                        return headerFormatter;
                    },
                    set: function (_) {
                        headerFormatter = _;
                    }
                },
                keyFormatter: {
                    get: function () {
                        return keyFormatter;
                    },
                    set: function (_) {
                        keyFormatter = _;
                    }
                },
                headerEnabled: {
                    get: function () {
                        return headerEnabled;
                    },
                    set: function (_) {
                        headerEnabled = _;
                    }
                },
                position: {
                    get: function () {
                        return position;
                    },
                    set: function (_) {
                        position = _;
                    }
                },
                hidden: {
                    get: function () {
                        return hidden;
                    },
                    set: function (_) {
                        if (hidden != _) {
                            hidden = !!_;
                            nvtooltip();
                        }
                    }
                },
                data: {
                    get: function () {
                        return data;
                    },
                    set: function (_) {
                        if (_.point) {
                            _.value = _.point.x;
                            _.series = _.series || {};
                            _.series.value = _.point.y;
                            _.series.color = _.point.color || _.series.color;
                        }
                        data = _;
                    }
                },
                node: {
                    get: function () {
                        return tooltip.node();
                    },
                    set: function (_) {
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                    }
                }
            });
            nv.utils.initOptions(nvtooltip);
            return nvtooltip;
        };
        nv.utils.windowSize = function () {
            var size = {
                width: 640,
                height: 480
            };
            if (window.innerWidth && window.innerHeight) {
                size.width = window.innerWidth;
                size.height = window.innerHeight;
                return size;
            }
            if (document.compatMode == 'CSS1Compat' && document.documentElement && document.documentElement.offsetWidth) {
                size.width = document.documentElement.offsetWidth;
                size.height = document.documentElement.offsetHeight;
                return size;
            }
            if (document.body && document.body.offsetWidth) {
                size.width = document.body.offsetWidth;
                size.height = document.body.offsetHeight;
                return size;
            }
            return size;
        };
        nv.utils.windowResize = function (handler) {
            if (window.addEventListener) {
                window.addEventListener('resize', handler);
            } else {
                nv.log('ERROR: Failed to bind to window.resize with: ', handler);
            }
            return {
                callback: handler,
                clear: function () {
                    window.removeEventListener('resize', handler);
                }
            };
        };
        nv.utils.getColor = function (color) {
            if (color === undefined) {
                return nv.utils.defaultColor();
            } else if (Array.isArray(color)) {
                var color_scale = d3.scale.ordinal().range(color);
                return function (d, i) {
                    var key = i === undefined ? d : i;
                    return d.color || color_scale(key);
                };
            } else {
                return color;
            }
        };
        nv.utils.defaultColor = function () {
            return nv.utils.getColor(d3.scale.category20().range());
        };
        nv.utils.customTheme = function (dictionary, getKey, defaultColors) {
            getKey = getKey || function (series) {
                return series.key;
            };
            defaultColors = defaultColors || d3.scale.category20().range();
            var defIndex = defaultColors.length;
            return function (series, index) {
                var key = getKey(series);
                if (typeof dictionary[key] === 'function') {
                    return dictionary[key]();
                } else if (dictionary[key] !== undefined) {
                    return dictionary[key];
                } else {
                    if (!defIndex) {
                        defIndex = defaultColors.length;
                    }
                    defIndex = defIndex - 1;
                    return defaultColors[defIndex];
                }
            };
        };
        nv.utils.pjax = function (links, content) {
            var load = function (href) {
                d3.html(href, function (fragment) {
                    var target = d3.select(content).node();
                    target.parentNode.replaceChild(d3.select(fragment).select(content).node(), target);
                    nv.utils.pjax(links, content);
                });
            };
            d3.selectAll(links).on('click', function () {
                history.pushState(this.href, this.textContent, this.href);
                load(this.href);
                d3.event.preventDefault();
            });
            d3.select(window).on('popstate', function () {
                if (d3.event.state) {
                    load(d3.event.state);
                }
            });
        };
        nv.utils.calcApproxTextWidth = function (svgTextElem) {
            if (typeof svgTextElem.style === 'function' && typeof svgTextElem.text === 'function') {
                var fontSize = parseInt(svgTextElem.style('font-size').replace('px', ''), 10);
                var textLength = svgTextElem.text().length;
                return textLength * fontSize * 0.5;
            }
            return 0;
        };
        nv.utils.NaNtoZero = function (n) {
            if (typeof n !== 'number' || isNaN(n) || n === null || n === Infinity || n === -Infinity) {
                return 0;
            }
            return n;
        };
        d3.selection.prototype.watchTransition = function (renderWatch) {
            var args = [this].concat([].slice.call(arguments, 1));
            return renderWatch.transition.apply(renderWatch, args);
        };
        nv.utils.renderWatch = function (dispatch, duration) {
            if (!(this instanceof nv.utils.renderWatch)) {
                return new nv.utils.renderWatch(dispatch, duration);
            }
            var _duration = duration !== undefined ? duration : 250;
            var renderStack = [];
            var self = this;
            this.models = function (models) {
                models = [].slice.call(arguments, 0);
                models.forEach(function (model) {
                    model.__rendered = false;
                    (function (m) {
                        m.dispatch.on('renderEnd', function (arg) {
                            m.__rendered = true;
                            self.renderEnd('model');
                        });
                    }(model));
                    if (renderStack.indexOf(model) < 0) {
                        renderStack.push(model);
                    }
                });
                return this;
            };
            this.reset = function (duration) {
                if (duration !== undefined) {
                    _duration = duration;
                }
                renderStack = [];
            };
            this.transition = function (selection, args, duration) {
                args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
                if (args.length > 1) {
                    duration = args.pop();
                } else {
                    duration = _duration !== undefined ? _duration : 250;
                }
                selection.__rendered = false;
                if (renderStack.indexOf(selection) < 0) {
                    renderStack.push(selection);
                }
                if (duration === 0) {
                    selection.__rendered = true;
                    selection.delay = function () {
                        return this;
                    };
                    selection.duration = function () {
                        return this;
                    };
                    return selection;
                } else {
                    if (selection.length === 0) {
                        selection.__rendered = true;
                    } else if (selection.every(function (d) {
                            return !d.length;
                        })) {
                        selection.__rendered = true;
                    } else {
                        selection.__rendered = false;
                    }
                    var n = 0;
                    return selection.transition().duration(duration).each(function () {
                        ++n;
                    }).each('end', function (d, i) {
                        if (--n === 0) {
                            selection.__rendered = true;
                            self.renderEnd.apply(this, args);
                        }
                    });
                }
            };
            this.renderEnd = function () {
                if (renderStack.every(function (d) {
                        return d.__rendered;
                    })) {
                    renderStack.forEach(function (d) {
                        d.__rendered = false;
                    });
                    dispatch.renderEnd.apply(this, arguments);
                }
            };
        };
        nv.utils.deepExtend = function (dst) {
            var sources = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
            sources.forEach(function (source) {
                for (var key in source) {
                    var isArray = dst[key] instanceof Array;
                    var isObject = typeof dst[key] === 'object';
                    var srcObj = typeof source[key] === 'object';
                    if (isObject && !isArray && srcObj) {
                        nv.utils.deepExtend(dst[key], source[key]);
                    } else {
                        dst[key] = source[key];
                    }
                }
            });
        };
        nv.utils.state = function () {
            if (!(this instanceof nv.utils.state)) {
                return new nv.utils.state();
            }
            var state = {};
            var _self = this;
            var _setState = function () {
            };
            var _getState = function () {
                return {};
            };
            var init = null;
            var changed = null;
            this.dispatch = d3.dispatch('change', 'set');
            this.dispatch.on('set', function (state) {
                _setState(state, true);
            });
            this.getter = function (fn) {
                _getState = fn;
                return this;
            };
            this.setter = function (fn, callback) {
                if (!callback) {
                    callback = function () {
                    };
                }
                _setState = function (state, update) {
                    fn(state);
                    if (update) {
                        callback();
                    }
                };
                return this;
            };
            this.init = function (state) {
                init = init || {};
                nv.utils.deepExtend(init, state);
            };
            var _set = function () {
                var settings = _getState();
                if (JSON.stringify(settings) === JSON.stringify(state)) {
                    return false;
                }
                for (var key in settings) {
                    if (state[key] === undefined) {
                        state[key] = {};
                    }
                    state[key] = settings[key];
                    changed = true;
                }
                return true;
            };
            this.update = function () {
                if (init) {
                    _setState(init, false);
                    init = null;
                }
                if (_set.call(this)) {
                    this.dispatch.change(state);
                }
            };
        };
        nv.utils.optionsFunc = function (args) {
            if (args) {
                d3.map(args).forEach(function (key, value) {
                    if (typeof this[key] === 'function') {
                        this[key](value);
                    }
                }.bind(this));
            }
            return this;
        };
        nv.utils.calcTicksX = function (numTicks, data) {
            var numValues = 1;
            var i = 0;
            for (i; i < data.length; i += 1) {
                var stream_len = data[i] && data[i].values ? data[i].values.length : 0;
                numValues = stream_len > numValues ? stream_len : numValues;
            }
            nv.log('Requested number of ticks: ', numTicks);
            nv.log('Calculated max values to be: ', numValues);
            numTicks = numTicks > numValues ? numTicks = numValues - 1 : numTicks;
            numTicks = numTicks < 1 ? 1 : numTicks;
            numTicks = Math.floor(numTicks);
            nv.log('Calculating tick count as: ', numTicks);
            return numTicks;
        };
        nv.utils.calcTicksY = function (numTicks, data) {
            return nv.utils.calcTicksX(numTicks, data);
        };
        nv.utils.initOption = function (chart, name) {
            if (chart._calls && chart._calls[name]) {
                chart[name] = chart._calls[name];
            } else {
                chart[name] = function (_) {
                    if (!arguments.length)
                        return chart._options[name];
                    chart._overrides[name] = true;
                    chart._options[name] = _;
                    return chart;
                };
                chart['_' + name] = function (_) {
                    if (!arguments.length)
                        return chart._options[name];
                    if (!chart._overrides[name]) {
                        chart._options[name] = _;
                    }
                    return chart;
                };
            }
        };
        nv.utils.initOptions = function (chart) {
            chart._overrides = chart._overrides || {};
            var ops = Object.getOwnPropertyNames(chart._options || {});
            var calls = Object.getOwnPropertyNames(chart._calls || {});
            ops = ops.concat(calls);
            for (var i in ops) {
                nv.utils.initOption(chart, ops[i]);
            }
        };
        nv.utils.inheritOptionsD3 = function (target, d3_source, oplist) {
            target._d3options = oplist.concat(target._d3options || []);
            oplist.unshift(d3_source);
            oplist.unshift(target);
            d3.rebind.apply(this, oplist);
        };
        nv.utils.arrayUnique = function (a) {
            return a.sort().filter(function (item, pos) {
                return !pos || item != a[pos - 1];
            });
        };
        nv.utils.symbolMap = d3.map();
        nv.utils.symbol = function () {
            var type, size = 64;
            function symbol(d, i) {
                var t = type.call(this, d, i);
                var s = size.call(this, d, i);
                if (d3.svg.symbolTypes.indexOf(t) !== -1) {
                    return d3.svg.symbol().type(t).size(s)();
                } else {
                    return nv.utils.symbolMap.get(t)(s);
                }
            }
            symbol.type = function (_) {
                if (!arguments.length)
                    return type;
                type = d3.functor(_);
                return symbol;
            };
            symbol.size = function (_) {
                if (!arguments.length)
                    return size;
                size = d3.functor(_);
                return symbol;
            };
            return symbol;
        };
        nv.utils.inheritOptions = function (target, source) {
            var ops = Object.getOwnPropertyNames(source._options || {});
            var calls = Object.getOwnPropertyNames(source._calls || {});
            var inherited = source._inherited || [];
            var d3ops = source._d3options || [];
            var args = ops.concat(calls).concat(inherited).concat(d3ops);
            args.unshift(source);
            args.unshift(target);
            d3.rebind.apply(this, args);
            target._inherited = nv.utils.arrayUnique(ops.concat(calls).concat(inherited).concat(ops).concat(target._inherited || []));
            target._d3options = nv.utils.arrayUnique(d3ops.concat(target._d3options || []));
        };
        nv.utils.initSVG = function (svg) {
            svg.classed({ 'nvd3-svg': true });
        };
        nv.utils.sanitizeHeight = function (height, container) {
            return height || parseInt(container.style('height'), 10) || 400;
        };
        nv.utils.sanitizeWidth = function (width, container) {
            return width || parseInt(container.style('width'), 10) || 960;
        };
        nv.utils.availableHeight = function (height, container, margin) {
            return nv.utils.sanitizeHeight(height, container) - margin.top - margin.bottom;
        };
        nv.utils.availableWidth = function (width, container, margin) {
            return nv.utils.sanitizeWidth(width, container) - margin.left - margin.right;
        };
        nv.utils.noData = function (chart, container) {
            var opt = chart.options(), margin = opt.margin(), noData = opt.noData(), data = noData == null ? ['No Data Available.'] : [noData], height = nv.utils.availableHeight(null, container, margin), width = nv.utils.availableWidth(null, container, margin), x = margin.left + width / 2, y = margin.top + height / 2;
            container.selectAll('g').remove();
            var noDataText = container.selectAll('.nv-noData').data(data);
            noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');
            noDataText.attr('x', x).attr('y', y).text(function (t) {
                return t;
            });
        };
        nv.utils.wrapTicks = function (text, width) {
            text.each(function () {
                var text = d3.select(this), words = text.text().split(/\s+/).reverse(), word, line = [], lineNumber = 0, lineHeight = 1.1, y = text.attr('y'), dy = parseFloat(text.attr('dy')), tspan = text.text(null).append('tspan').attr('x', 0).attr('y', y).attr('dy', dy + 'em');
                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(' '));
                    if (tspan.node().getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(' '));
                        line = [word];
                        tspan = text.append('tspan').attr('x', 0).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);
                    }
                }
            });
        };
        nv.models.axis = function () {
            'use strict';
            var axis = d3.svg.axis();
            var scale = d3.scale.linear();
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 75, height = 60, axisLabelText = null, showMaxMin = true, rotateLabels = 0, rotateYLabel = true, staggerLabels = false, isOrdinal = false, ticks = null, axisLabelDistance = 0, duration = 250, dispatch = d3.dispatch('renderEnd');
            axis.scale(scale).orient('bottom').tickFormat(function (d) {
                return d;
            });
            var scale0;
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    var container = d3.select(this);
                    nv.utils.initSVG(container);
                    var wrap = container.selectAll('g.nv-wrap.nv-axis').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-axis');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    if (ticks !== null)
                        axis.ticks(ticks);
                    else if (axis.orient() == 'top' || axis.orient() == 'bottom')
                        axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);
                    g.watchTransition(renderWatch, 'axis').call(axis);
                    scale0 = scale0 || axis.scale();
                    var fmt = axis.tickFormat();
                    if (fmt == null) {
                        fmt = scale0.tickFormat();
                    }
                    var axisLabel = g.selectAll('text.nv-axislabel').data([axisLabelText || null]);
                    axisLabel.exit().remove();
                    var xLabelMargin;
                    var axisMaxMin;
                    var w;
                    switch (axis.orient()) {
                    case 'top':
                        axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                        w = 0;
                        if (scale.range().length === 1) {
                            w = isOrdinal ? scale.range()[0] * 2 + scale.rangeBand() : 0;
                        } else if (scale.range().length === 2) {
                            w = isOrdinal ? scale.range()[0] + scale.range()[1] + scale.rangeBand() : scale.range()[1];
                        } else if (scale.range().length > 2) {
                            w = scale.range()[scale.range().length - 1] + (scale.range()[1] - scale.range()[0]);
                        }
                        ;
                        axisLabel.attr('text-anchor', 'middle').attr('y', 0).attr('x', w / 2);
                        if (showMaxMin) {
                            axisMaxMin = wrap.selectAll('g.nv-axisMaxMin').data(scale.domain());
                            axisMaxMin.enter().append('g').attr('class', function (d, i) {
                                return [
                                    'nv-axisMaxMin',
                                    'nv-axisMaxMin-x',
                                    i == 0 ? 'nv-axisMin-x' : 'nv-axisMax-x'
                                ].join(' ');
                            }).append('text');
                            axisMaxMin.exit().remove();
                            axisMaxMin.attr('transform', function (d, i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale(d)) + ',0)';
                            }).select('text').attr('dy', '-0.5em').attr('y', -axis.tickPadding()).attr('text-anchor', 'middle').text(function (d, i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                            axisMaxMin.watchTransition(renderWatch, 'min-max top').attr('transform', function (d, i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale.range()[i]) + ',0)';
                            });
                        }
                        break;
                    case 'bottom':
                        xLabelMargin = axisLabelDistance + 36;
                        var maxTextWidth = 30;
                        var textHeight = 0;
                        var xTicks = g.selectAll('g').select('text');
                        var rotateLabelsRule = '';
                        if (rotateLabels % 360) {
                            xTicks.each(function (d, i) {
                                var box = this.getBoundingClientRect();
                                var width = box.width;
                                textHeight = box.height;
                                if (width > maxTextWidth)
                                    maxTextWidth = width;
                            });
                            rotateLabelsRule = 'rotate(' + rotateLabels + ' 0,' + (textHeight / 2 + axis.tickPadding()) + ')';
                            var sin = Math.abs(Math.sin(rotateLabels * Math.PI / 180));
                            xLabelMargin = (sin ? sin * maxTextWidth : maxTextWidth) + 30;
                            xTicks.attr('transform', rotateLabelsRule).style('text-anchor', rotateLabels % 360 > 0 ? 'start' : 'end');
                        }
                        axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                        w = 0;
                        if (scale.range().length === 1) {
                            w = isOrdinal ? scale.range()[0] * 2 + scale.rangeBand() : 0;
                        } else if (scale.range().length === 2) {
                            w = isOrdinal ? scale.range()[0] + scale.range()[1] + scale.rangeBand() : scale.range()[1];
                        } else if (scale.range().length > 2) {
                            w = scale.range()[scale.range().length - 1] + (scale.range()[1] - scale.range()[0]);
                        }
                        ;
                        axisLabel.attr('text-anchor', 'middle').attr('y', xLabelMargin).attr('x', w / 2);
                        if (showMaxMin) {
                            axisMaxMin = wrap.selectAll('g.nv-axisMaxMin').data([
                                scale.domain()[0],
                                scale.domain()[scale.domain().length - 1]
                            ]);
                            axisMaxMin.enter().append('g').attr('class', function (d, i) {
                                return [
                                    'nv-axisMaxMin',
                                    'nv-axisMaxMin-x',
                                    i == 0 ? 'nv-axisMin-x' : 'nv-axisMax-x'
                                ].join(' ');
                            }).append('text');
                            axisMaxMin.exit().remove();
                            axisMaxMin.attr('transform', function (d, i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ',0)';
                            }).select('text').attr('dy', '.71em').attr('y', axis.tickPadding()).attr('transform', rotateLabelsRule).style('text-anchor', rotateLabels ? rotateLabels % 360 > 0 ? 'start' : 'end' : 'middle').text(function (d, i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                            axisMaxMin.watchTransition(renderWatch, 'min-max bottom').attr('transform', function (d, i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ',0)';
                            });
                        }
                        if (staggerLabels)
                            xTicks.attr('transform', function (d, i) {
                                return 'translate(0,' + (i % 2 == 0 ? '0' : '12') + ')';
                            });
                        break;
                    case 'right':
                        axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                        axisLabel.style('text-anchor', rotateYLabel ? 'middle' : 'begin').attr('transform', rotateYLabel ? 'rotate(90)' : '').attr('y', rotateYLabel ? -Math.max(margin.right, width) + 12 : -10).attr('x', rotateYLabel ? d3.max(scale.range()) / 2 : axis.tickPadding());
                        if (showMaxMin) {
                            axisMaxMin = wrap.selectAll('g.nv-axisMaxMin').data(scale.domain());
                            axisMaxMin.enter().append('g').attr('class', function (d, i) {
                                return [
                                    'nv-axisMaxMin',
                                    'nv-axisMaxMin-y',
                                    i == 0 ? 'nv-axisMin-y' : 'nv-axisMax-y'
                                ].join(' ');
                            }).append('text').style('opacity', 0);
                            axisMaxMin.exit().remove();
                            axisMaxMin.attr('transform', function (d, i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale(d)) + ')';
                            }).select('text').attr('dy', '.32em').attr('y', 0).attr('x', axis.tickPadding()).style('text-anchor', 'start').text(function (d, i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                            axisMaxMin.watchTransition(renderWatch, 'min-max right').attr('transform', function (d, i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')';
                            }).select('text').style('opacity', 1);
                        }
                        break;
                    case 'left':
                        axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                        axisLabel.style('text-anchor', rotateYLabel ? 'middle' : 'end').attr('transform', rotateYLabel ? 'rotate(-90)' : '').attr('y', rotateYLabel ? -Math.max(margin.left, width) + 25 - (axisLabelDistance || 0) : -10).attr('x', rotateYLabel ? -d3.max(scale.range()) / 2 : -axis.tickPadding());
                        if (showMaxMin) {
                            axisMaxMin = wrap.selectAll('g.nv-axisMaxMin').data(scale.domain());
                            axisMaxMin.enter().append('g').attr('class', function (d, i) {
                                return [
                                    'nv-axisMaxMin',
                                    'nv-axisMaxMin-y',
                                    i == 0 ? 'nv-axisMin-y' : 'nv-axisMax-y'
                                ].join(' ');
                            }).append('text').style('opacity', 0);
                            axisMaxMin.exit().remove();
                            axisMaxMin.attr('transform', function (d, i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale0(d)) + ')';
                            }).select('text').attr('dy', '.32em').attr('y', 0).attr('x', -axis.tickPadding()).attr('text-anchor', 'end').text(function (d, i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                            axisMaxMin.watchTransition(renderWatch, 'min-max right').attr('transform', function (d, i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')';
                            }).select('text').style('opacity', 1);
                        }
                        break;
                    }
                    axisLabel.text(function (d) {
                        return d;
                    });
                    if (showMaxMin && (axis.orient() === 'left' || axis.orient() === 'right')) {
                        g.selectAll('g').each(function (d, i) {
                            d3.select(this).select('text').attr('opacity', 1);
                            if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) {
                                if (d > 1e-10 || d < -1e-10)
                                    d3.select(this).attr('opacity', 0);
                                d3.select(this).select('text').attr('opacity', 0);
                            }
                        });
                        if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0) {
                            wrap.selectAll('g.nv-axisMaxMin').style('opacity', function (d, i) {
                                return !i ? 1 : 0;
                            });
                        }
                    }
                    if (showMaxMin && (axis.orient() === 'top' || axis.orient() === 'bottom')) {
                        var maxMinRange = [];
                        wrap.selectAll('g.nv-axisMaxMin').each(function (d, i) {
                            try {
                                if (i)
                                    maxMinRange.push(scale(d) - this.getBoundingClientRect().width - 4);
                                else
                                    maxMinRange.push(scale(d) + this.getBoundingClientRect().width + 4);
                            } catch (err) {
                                if (i)
                                    maxMinRange.push(scale(d) - 4);
                                else
                                    maxMinRange.push(scale(d) + 4);
                            }
                        });
                        g.selectAll('g').each(function (d, i) {
                            if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {
                                if (d > 1e-10 || d < -1e-10)
                                    d3.select(this).remove();
                                else
                                    d3.select(this).select('text').remove();
                            }
                        });
                    }
                    g.selectAll('.tick').filter(function (d) {
                        return !parseFloat(Math.round(d * 100000) / 1000000) && d !== undefined;
                    }).classed('zero', true);
                    scale0 = scale.copy();
                });
                renderWatch.renderEnd('axis immediate');
                return chart;
            }
            chart.axis = axis;
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                axisLabelDistance: {
                    get: function () {
                        return axisLabelDistance;
                    },
                    set: function (_) {
                        axisLabelDistance = _;
                    }
                },
                staggerLabels: {
                    get: function () {
                        return staggerLabels;
                    },
                    set: function (_) {
                        staggerLabels = _;
                    }
                },
                rotateLabels: {
                    get: function () {
                        return rotateLabels;
                    },
                    set: function (_) {
                        rotateLabels = _;
                    }
                },
                rotateYLabel: {
                    get: function () {
                        return rotateYLabel;
                    },
                    set: function (_) {
                        rotateYLabel = _;
                    }
                },
                showMaxMin: {
                    get: function () {
                        return showMaxMin;
                    },
                    set: function (_) {
                        showMaxMin = _;
                    }
                },
                axisLabel: {
                    get: function () {
                        return axisLabelText;
                    },
                    set: function (_) {
                        axisLabelText = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                ticks: {
                    get: function () {
                        return ticks;
                    },
                    set: function (_) {
                        ticks = _;
                    }
                },
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                    }
                },
                scale: {
                    get: function () {
                        return scale;
                    },
                    set: function (_) {
                        scale = _;
                        axis.scale(scale);
                        isOrdinal = typeof scale.rangeBands === 'function';
                        nv.utils.inheritOptionsD3(chart, scale, [
                            'domain',
                            'range',
                            'rangeBand',
                            'rangeBands'
                        ]);
                    }
                }
            });
            nv.utils.initOptions(chart);
            nv.utils.inheritOptionsD3(chart, axis, [
                'orient',
                'tickValues',
                'tickSubdivide',
                'tickSize',
                'tickPadding',
                'tickFormat'
            ]);
            nv.utils.inheritOptionsD3(chart, scale, [
                'domain',
                'range',
                'rangeBand',
                'rangeBands'
            ]);
            return chart;
        };
        nv.models.boxPlot = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 960, height = 500, id = Math.floor(Math.random() * 10000), x = d3.scale.ordinal(), y = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, color = nv.utils.defaultColor(), container = null, xDomain, yDomain, xRange, yRange, dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd'), duration = 250, maxBoxWidth = null;
            var x0, y0;
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    x.domain(xDomain || data.map(function (d, i) {
                        return getX(d, i);
                    })).rangeBands(xRange || [
                        0,
                        availableWidth
                    ], 0.1);
                    var yData = [];
                    if (!yDomain) {
                        var yMin = d3.min(data.map(function (d) {
                            var min_arr = [];
                            min_arr.push(d.values.Q1);
                            if (d.values.hasOwnProperty('whisker_low') && d.values.whisker_low !== null) {
                                min_arr.push(d.values.whisker_low);
                            }
                            if (d.values.hasOwnProperty('outliers') && d.values.outliers !== null) {
                                min_arr = min_arr.concat(d.values.outliers);
                            }
                            return d3.min(min_arr);
                        }));
                        var yMax = d3.max(data.map(function (d) {
                            var max_arr = [];
                            max_arr.push(d.values.Q3);
                            if (d.values.hasOwnProperty('whisker_high') && d.values.whisker_high !== null) {
                                max_arr.push(d.values.whisker_high);
                            }
                            if (d.values.hasOwnProperty('outliers') && d.values.outliers !== null) {
                                max_arr = max_arr.concat(d.values.outliers);
                            }
                            return d3.max(max_arr);
                        }));
                        yData = [
                            yMin,
                            yMax
                        ];
                    }
                    y.domain(yDomain || yData);
                    y.range(yRange || [
                        availableHeight,
                        0
                    ]);
                    x0 = x0 || x;
                    y0 = y0 || y.copy().range([
                        y(0),
                        y(0)
                    ]);
                    var wrap = container.selectAll('g.nv-wrap').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var boxplots = wrap.selectAll('.nv-boxplot').data(function (d) {
                        return d;
                    });
                    var boxEnter = boxplots.enter().append('g').style('stroke-opacity', 0.000001).style('fill-opacity', 0.000001);
                    boxplots.attr('class', 'nv-boxplot').attr('transform', function (d, i, j) {
                        return 'translate(' + (x(getX(d, i)) + x.rangeBand() * 0.05) + ', 0)';
                    }).classed('hover', function (d) {
                        return d.hover;
                    });
                    boxplots.watchTransition(renderWatch, 'nv-boxplot: boxplots').style('stroke-opacity', 1).style('fill-opacity', 0.75).delay(function (d, i) {
                        return i * duration / data.length;
                    }).attr('transform', function (d, i) {
                        return 'translate(' + (x(getX(d, i)) + x.rangeBand() * 0.05) + ', 0)';
                    });
                    boxplots.exit().remove();
                    boxEnter.each(function (d, i) {
                        var box = d3.select(this);
                        [
                            'low',
                            'high'
                        ].forEach(function (key) {
                            if (d.values.hasOwnProperty('whisker_' + key) && d.values['whisker_' + key] !== null) {
                                box.append('line').style('stroke', d.color ? d.color : color(d, i)).attr('class', 'nv-boxplot-whisker nv-boxplot-' + key);
                                box.append('line').style('stroke', d.color ? d.color : color(d, i)).attr('class', 'nv-boxplot-tick nv-boxplot-' + key);
                            }
                        });
                    });
                    var outliers = boxplots.selectAll('.nv-boxplot-outlier').data(function (d) {
                        if (d.values.hasOwnProperty('outliers') && d.values.outliers !== null) {
                            return d.values.outliers;
                        } else {
                            return [];
                        }
                    });
                    outliers.enter().append('circle').style('fill', function (d, i, j) {
                        return color(d, j);
                    }).style('stroke', function (d, i, j) {
                        return color(d, j);
                    }).on('mouseover', function (d, i, j) {
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            series: {
                                key: d,
                                color: color(d, j)
                            },
                            e: d3.event
                        });
                    }).on('mouseout', function (d, i, j) {
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            series: {
                                key: d,
                                color: color(d, j)
                            },
                            e: d3.event
                        });
                    }).on('mousemove', function (d, i) {
                        dispatch.elementMousemove({ e: d3.event });
                    });
                    outliers.attr('class', 'nv-boxplot-outlier');
                    outliers.watchTransition(renderWatch, 'nv-boxplot: nv-boxplot-outlier').attr('cx', x.rangeBand() * 0.45).attr('cy', function (d, i, j) {
                        return y(d);
                    }).attr('r', '3');
                    outliers.exit().remove();
                    var box_width = function () {
                        return maxBoxWidth === null ? x.rangeBand() * 0.9 : Math.min(75, x.rangeBand() * 0.9);
                    };
                    var box_left = function () {
                        return x.rangeBand() * 0.45 - box_width() / 2;
                    };
                    var box_right = function () {
                        return x.rangeBand() * 0.45 + box_width() / 2;
                    };
                    [
                        'low',
                        'high'
                    ].forEach(function (key) {
                        var endpoint = key === 'low' ? 'Q1' : 'Q3';
                        boxplots.select('line.nv-boxplot-whisker.nv-boxplot-' + key).watchTransition(renderWatch, 'nv-boxplot: boxplots').attr('x1', x.rangeBand() * 0.45).attr('y1', function (d, i) {
                            return y(d.values['whisker_' + key]);
                        }).attr('x2', x.rangeBand() * 0.45).attr('y2', function (d, i) {
                            return y(d.values[endpoint]);
                        });
                        boxplots.select('line.nv-boxplot-tick.nv-boxplot-' + key).watchTransition(renderWatch, 'nv-boxplot: boxplots').attr('x1', box_left).attr('y1', function (d, i) {
                            return y(d.values['whisker_' + key]);
                        }).attr('x2', box_right).attr('y2', function (d, i) {
                            return y(d.values['whisker_' + key]);
                        });
                    });
                    [
                        'low',
                        'high'
                    ].forEach(function (key) {
                        boxEnter.selectAll('.nv-boxplot-' + key).on('mouseover', function (d, i, j) {
                            d3.select(this).classed('hover', true);
                            dispatch.elementMouseover({
                                series: {
                                    key: d.values['whisker_' + key],
                                    color: color(d, j)
                                },
                                e: d3.event
                            });
                        }).on('mouseout', function (d, i, j) {
                            d3.select(this).classed('hover', false);
                            dispatch.elementMouseout({
                                series: {
                                    key: d.values['whisker_' + key],
                                    color: color(d, j)
                                },
                                e: d3.event
                            });
                        }).on('mousemove', function (d, i) {
                            dispatch.elementMousemove({ e: d3.event });
                        });
                    });
                    boxEnter.append('rect').attr('class', 'nv-boxplot-box').on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            key: d.label,
                            value: d.label,
                            series: [
                                {
                                    key: 'Q3',
                                    value: d.values.Q3,
                                    color: d.color || color(d, i)
                                },
                                {
                                    key: 'Q2',
                                    value: d.values.Q2,
                                    color: d.color || color(d, i)
                                },
                                {
                                    key: 'Q1',
                                    value: d.values.Q1,
                                    color: d.color || color(d, i)
                                }
                            ],
                            data: d,
                            index: i,
                            e: d3.event
                        });
                    }).on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            key: d.label,
                            value: d.label,
                            series: [
                                {
                                    key: 'Q3',
                                    value: d.values.Q3,
                                    color: d.color || color(d, i)
                                },
                                {
                                    key: 'Q2',
                                    value: d.values.Q2,
                                    color: d.color || color(d, i)
                                },
                                {
                                    key: 'Q1',
                                    value: d.values.Q1,
                                    color: d.color || color(d, i)
                                }
                            ],
                            data: d,
                            index: i,
                            e: d3.event
                        });
                    }).on('mousemove', function (d, i) {
                        dispatch.elementMousemove({ e: d3.event });
                    });
                    boxplots.select('rect.nv-boxplot-box').watchTransition(renderWatch, 'nv-boxplot: boxes').attr('y', function (d, i) {
                        return y(d.values.Q3);
                    }).attr('width', box_width).attr('x', box_left).attr('height', function (d, i) {
                        return Math.abs(y(d.values.Q3) - y(d.values.Q1)) || 1;
                    }).style('fill', function (d, i) {
                        return d.color || color(d, i);
                    }).style('stroke', function (d, i) {
                        return d.color || color(d, i);
                    });
                    boxEnter.append('line').attr('class', 'nv-boxplot-median');
                    boxplots.select('line.nv-boxplot-median').watchTransition(renderWatch, 'nv-boxplot: boxplots line').attr('x1', box_left).attr('y1', function (d, i) {
                        return y(d.values.Q2);
                    }).attr('x2', box_right).attr('y2', function (d, i) {
                        return y(d.values.Q2);
                    });
                    x0 = x.copy();
                    y0 = y.copy();
                });
                renderWatch.renderEnd('nv-boxplot immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                maxBoxWidth: {
                    get: function () {
                        return maxBoxWidth;
                    },
                    set: function (_) {
                        maxBoxWidth = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.boxPlotChart = function () {
            'use strict';
            var boxplot = nv.models.boxPlot(), xAxis = nv.models.axis(), yAxis = nv.models.axis();
            var margin = {
                    top: 15,
                    right: 10,
                    bottom: 50,
                    left: 60
                }, width = null, height = null, color = nv.utils.getColor(), showXAxis = true, showYAxis = true, rightAlignYAxis = false, staggerLabels = false, tooltip = nv.models.tooltip(), x, y, noData = 'No Data Available.', dispatch = d3.dispatch('beforeUpdate', 'renderEnd'), duration = 250;
            xAxis.orient('bottom').showMaxMin(false).tickFormat(function (d) {
                return d;
            });
            yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickFormat(d3.format(',.1f'));
            tooltip.duration(0);
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(boxplot);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;
                    chart.update = function () {
                        dispatch.beforeUpdate();
                        container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.hasOwnProperty('Q1') && d.values.hasOwnProperty('Q2') && d.values.hasOwnProperty('Q3');
                        }).length) {
                        var noDataText = container.selectAll('.nv-noData').data([noData]);
                        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');
                        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {
                            return d;
                        });
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = boxplot.xScale();
                    y = boxplot.yScale().clamp(true);
                    var wrap = container.selectAll('g.nv-wrap.nv-boxPlotWithAxes').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-boxPlotWithAxes').append('g');
                    var defsEnter = gEnter.append('defs');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis').append('g').attr('class', 'nv-zeroLine').append('line');
                    gEnter.append('g').attr('class', 'nv-barsWrap');
                    g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    boxplot.width(availableWidth).height(availableHeight);
                    var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    }));
                    barsWrap.transition().call(boxplot);
                    defsEnter.append('clipPath').attr('id', 'nv-x-label-clip-' + boxplot.id()).append('rect');
                    g.select('#nv-x-label-clip-' + boxplot.id() + ' rect').attr('width', x.rangeBand() * (staggerLabels ? 2 : 1)).attr('height', 16).attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2));
                    if (showXAxis) {
                        xAxis.scale(x).ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');
                        g.select('.nv-x.nv-axis').call(xAxis);
                        var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                        if (staggerLabels) {
                            xTicks.selectAll('text').attr('transform', function (d, i, j) {
                                return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')';
                            });
                        }
                    }
                    if (showYAxis) {
                        yAxis.scale(y).ticks(Math.floor(availableHeight / 36)).tickSize(-availableWidth, 0);
                        g.select('.nv-y.nv-axis').call(yAxis);
                    }
                    g.select('.nv-zeroLine line').attr('x1', 0).attr('x2', availableWidth).attr('y1', y(0)).attr('y2', y(0));
                });
                renderWatch.renderEnd('nv-boxplot chart immediate');
                return chart;
            }
            boxplot.dispatch.on('elementMouseover.tooltip', function (evt) {
                tooltip.data(evt).hidden(false);
            });
            boxplot.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.data(evt).hidden(true);
            });
            boxplot.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.dispatch = dispatch;
            chart.boxplot = boxplot;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                staggerLabels: {
                    get: function () {
                        return staggerLabels;
                    },
                    set: function (_) {
                        staggerLabels = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                tooltipContent: {
                    get: function () {
                        return tooltip;
                    },
                    set: function (_) {
                        tooltip = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        boxplot.duration(duration);
                        xAxis.duration(duration);
                        yAxis.duration(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        boxplot.color(color);
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(_ ? 'right' : 'left');
                    }
                }
            });
            nv.utils.inheritOptions(chart, boxplot);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.bullet = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, orient = 'left', reverse = false, ranges = function (d) {
                    return d.ranges;
                }, markers = function (d) {
                    return d.markers ? d.markers : [0];
                }, measures = function (d) {
                    return d.measures;
                }, rangeLabels = function (d) {
                    return d.rangeLabels ? d.rangeLabels : [];
                }, markerLabels = function (d) {
                    return d.markerLabels ? d.markerLabels : [];
                }, measureLabels = function (d) {
                    return d.measureLabels ? d.measureLabels : [];
                }, forceX = [0], width = 380, height = 30, container = null, tickFormat = null, color = nv.utils.getColor(['#1f77b4']), dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove');
            function chart(selection) {
                selection.each(function (d, i) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    var rangez = ranges.call(this, d, i).slice().sort(d3.descending), markerz = markers.call(this, d, i).slice().sort(d3.descending), measurez = measures.call(this, d, i).slice().sort(d3.descending), rangeLabelz = rangeLabels.call(this, d, i).slice(), markerLabelz = markerLabels.call(this, d, i).slice(), measureLabelz = measureLabels.call(this, d, i).slice();
                    var x1 = d3.scale.linear().domain(d3.extent(d3.merge([
                        forceX,
                        rangez
                    ]))).range(reverse ? [
                        availableWidth,
                        0
                    ] : [
                        0,
                        availableWidth
                    ]);
                    var x0 = this.__chart__ || d3.scale.linear().domain([
                        0,
                        Infinity
                    ]).range(x1.range());
                    this.__chart__ = x1;
                    var rangeMin = d3.min(rangez), rangeMax = d3.max(rangez), rangeAvg = rangez[1];
                    var wrap = container.selectAll('g.nv-wrap.nv-bullet').data([d]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bullet');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('rect').attr('class', 'nv-range nv-rangeMax');
                    gEnter.append('rect').attr('class', 'nv-range nv-rangeAvg');
                    gEnter.append('rect').attr('class', 'nv-range nv-rangeMin');
                    gEnter.append('rect').attr('class', 'nv-measure');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var w0 = function (d) {
                            return Math.abs(x0(d) - x0(0));
                        }, w1 = function (d) {
                            return Math.abs(x1(d) - x1(0));
                        };
                    var xp0 = function (d) {
                            return d < 0 ? x0(d) : x0(0);
                        }, xp1 = function (d) {
                            return d < 0 ? x1(d) : x1(0);
                        };
                    g.select('rect.nv-rangeMax').attr('height', availableHeight).attr('width', w1(rangeMax > 0 ? rangeMax : rangeMin)).attr('x', xp1(rangeMax > 0 ? rangeMax : rangeMin)).datum(rangeMax > 0 ? rangeMax : rangeMin);
                    g.select('rect.nv-rangeAvg').attr('height', availableHeight).attr('width', w1(rangeAvg)).attr('x', xp1(rangeAvg)).datum(rangeAvg);
                    g.select('rect.nv-rangeMin').attr('height', availableHeight).attr('width', w1(rangeMax)).attr('x', xp1(rangeMax)).attr('width', w1(rangeMax > 0 ? rangeMin : rangeMax)).attr('x', xp1(rangeMax > 0 ? rangeMin : rangeMax)).datum(rangeMax > 0 ? rangeMin : rangeMax);
                    g.select('rect.nv-measure').style('fill', color).attr('height', availableHeight / 3).attr('y', availableHeight / 3).attr('width', measurez < 0 ? x1(0) - x1(measurez[0]) : x1(measurez[0]) - x1(0)).attr('x', xp1(measurez)).on('mouseover', function () {
                        dispatch.elementMouseover({
                            value: measurez[0],
                            label: measureLabelz[0] || 'Current',
                            color: d3.select(this).style('fill')
                        });
                    }).on('mousemove', function () {
                        dispatch.elementMousemove({
                            value: measurez[0],
                            label: measureLabelz[0] || 'Current',
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function () {
                        dispatch.elementMouseout({
                            value: measurez[0],
                            label: measureLabelz[0] || 'Current',
                            color: d3.select(this).style('fill')
                        });
                    });
                    var h3 = availableHeight / 6;
                    var markerData = markerz.map(function (marker, index) {
                        return {
                            value: marker,
                            label: markerLabelz[index]
                        };
                    });
                    gEnter.selectAll('path.nv-markerTriangle').data(markerData).enter().append('path').attr('class', 'nv-markerTriangle').attr('transform', function (d) {
                        return 'translate(' + x1(d.value) + ',' + availableHeight / 2 + ')';
                    }).attr('d', 'M0,' + h3 + 'L' + h3 + ',' + -h3 + ' ' + -h3 + ',' + -h3 + 'Z').on('mouseover', function (d) {
                        dispatch.elementMouseover({
                            value: d.value,
                            label: d.label || 'Previous',
                            color: d3.select(this).style('fill'),
                            pos: [
                                x1(d.value),
                                availableHeight / 2
                            ]
                        });
                    }).on('mousemove', function (d) {
                        dispatch.elementMousemove({
                            value: d.value,
                            label: d.label || 'Previous',
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        dispatch.elementMouseout({
                            value: d.value,
                            label: d.label || 'Previous',
                            color: d3.select(this).style('fill')
                        });
                    });
                    wrap.selectAll('.nv-range').on('mouseover', function (d, i) {
                        var label = rangeLabelz[i] || (!i ? 'Maximum' : i == 1 ? 'Mean' : 'Minimum');
                        dispatch.elementMouseover({
                            value: d,
                            label: label,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mousemove', function () {
                        dispatch.elementMousemove({
                            value: measurez[0],
                            label: measureLabelz[0] || 'Previous',
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        var label = rangeLabelz[i] || (!i ? 'Maximum' : i == 1 ? 'Mean' : 'Minimum');
                        dispatch.elementMouseout({
                            value: d,
                            label: label,
                            color: d3.select(this).style('fill')
                        });
                    });
                });
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                ranges: {
                    get: function () {
                        return ranges;
                    },
                    set: function (_) {
                        ranges = _;
                    }
                },
                markers: {
                    get: function () {
                        return markers;
                    },
                    set: function (_) {
                        markers = _;
                    }
                },
                measures: {
                    get: function () {
                        return measures;
                    },
                    set: function (_) {
                        measures = _;
                    }
                },
                forceX: {
                    get: function () {
                        return forceX;
                    },
                    set: function (_) {
                        forceX = _;
                    }
                },
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                tickFormat: {
                    get: function () {
                        return tickFormat;
                    },
                    set: function (_) {
                        tickFormat = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                orient: {
                    get: function () {
                        return orient;
                    },
                    set: function (_) {
                        orient = _;
                        reverse = orient == 'right' || orient == 'bottom';
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.bulletChart = function () {
            'use strict';
            var bullet = nv.models.bullet();
            var tooltip = nv.models.tooltip();
            var orient = 'left', reverse = false, margin = {
                    top: 5,
                    right: 40,
                    bottom: 20,
                    left: 120
                }, ranges = function (d) {
                    return d.ranges;
                }, markers = function (d) {
                    return d.markers ? d.markers : [0];
                }, measures = function (d) {
                    return d.measures;
                }, width = null, height = 55, tickFormat = null, ticks = null, noData = null, dispatch = d3.dispatch();
            tooltip.duration(0).headerEnabled(false);
            function chart(selection) {
                selection.each(function (d, i) {
                    var container = d3.select(this);
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = height - margin.top - margin.bottom, that = this;
                    chart.update = function () {
                        chart(selection);
                    };
                    chart.container = this;
                    if (!d || !ranges.call(this, d, i)) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    var rangez = ranges.call(this, d, i).slice().sort(d3.descending), markerz = markers.call(this, d, i).slice().sort(d3.descending), measurez = measures.call(this, d, i).slice().sort(d3.descending);
                    var wrap = container.selectAll('g.nv-wrap.nv-bulletChart').data([d]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bulletChart');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-bulletWrap');
                    gEnter.append('g').attr('class', 'nv-titles');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var x1 = d3.scale.linear().domain([
                        0,
                        Math.max(rangez[0], markerz[0], measurez[0])
                    ]).range(reverse ? [
                        availableWidth,
                        0
                    ] : [
                        0,
                        availableWidth
                    ]);
                    var x0 = this.__chart__ || d3.scale.linear().domain([
                        0,
                        Infinity
                    ]).range(x1.range());
                    this.__chart__ = x1;
                    var w0 = function (d) {
                            return Math.abs(x0(d) - x0(0));
                        }, w1 = function (d) {
                            return Math.abs(x1(d) - x1(0));
                        };
                    var title = gEnter.select('.nv-titles').append('g').attr('text-anchor', 'end').attr('transform', 'translate(-6,' + (height - margin.top - margin.bottom) / 2 + ')');
                    title.append('text').attr('class', 'nv-title').text(function (d) {
                        return d.title;
                    });
                    title.append('text').attr('class', 'nv-subtitle').attr('dy', '1em').text(function (d) {
                        return d.subtitle;
                    });
                    bullet.width(availableWidth).height(availableHeight);
                    var bulletWrap = g.select('.nv-bulletWrap');
                    d3.transition(bulletWrap).call(bullet);
                    var format = tickFormat || x1.tickFormat(availableWidth / 100);
                    var tick = g.selectAll('g.nv-tick').data(x1.ticks(ticks ? ticks : availableWidth / 50), function (d) {
                        return this.textContent || format(d);
                    });
                    var tickEnter = tick.enter().append('g').attr('class', 'nv-tick').attr('transform', function (d) {
                        return 'translate(' + x0(d) + ',0)';
                    }).style('opacity', 0.000001);
                    tickEnter.append('line').attr('y1', availableHeight).attr('y2', availableHeight * 7 / 6);
                    tickEnter.append('text').attr('text-anchor', 'middle').attr('dy', '1em').attr('y', availableHeight * 7 / 6).text(format);
                    var tickUpdate = d3.transition(tick).attr('transform', function (d) {
                        return 'translate(' + x1(d) + ',0)';
                    }).style('opacity', 1);
                    tickUpdate.select('line').attr('y1', availableHeight).attr('y2', availableHeight * 7 / 6);
                    tickUpdate.select('text').attr('y', availableHeight * 7 / 6);
                    d3.transition(tick.exit()).attr('transform', function (d) {
                        return 'translate(' + x1(d) + ',0)';
                    }).style('opacity', 0.000001).remove();
                });
                d3.timer.flush();
                return chart;
            }
            bullet.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt['series'] = {
                    key: evt.label,
                    value: evt.value,
                    color: evt.color
                };
                tooltip.data(evt).hidden(false);
            });
            bullet.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            bullet.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.bullet = bullet;
            chart.dispatch = dispatch;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                ranges: {
                    get: function () {
                        return ranges;
                    },
                    set: function (_) {
                        ranges = _;
                    }
                },
                markers: {
                    get: function () {
                        return markers;
                    },
                    set: function (_) {
                        markers = _;
                    }
                },
                measures: {
                    get: function () {
                        return measures;
                    },
                    set: function (_) {
                        measures = _;
                    }
                },
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                tickFormat: {
                    get: function () {
                        return tickFormat;
                    },
                    set: function (_) {
                        tickFormat = _;
                    }
                },
                ticks: {
                    get: function () {
                        return ticks;
                    },
                    set: function (_) {
                        ticks = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                orient: {
                    get: function () {
                        return orient;
                    },
                    set: function (_) {
                        orient = _;
                        reverse = orient == 'right' || orient == 'bottom';
                    }
                }
            });
            nv.utils.inheritOptions(chart, bullet);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.candlestickBar = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = null, height = null, id = Math.floor(Math.random() * 10000), container, x = d3.scale.linear(), y = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, getOpen = function (d) {
                    return d.open;
                }, getClose = function (d) {
                    return d.close;
                }, getHigh = function (d) {
                    return d.high;
                }, getLow = function (d) {
                    return d.low;
                }, forceX = [], forceY = [], padData = false, clipEdge = true, color = nv.utils.defaultColor(), interactive = false, xDomain, yDomain, xRange, yRange, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove');
            function chart(selection) {
                selection.each(function (data) {
                    container = d3.select(this);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    nv.utils.initSVG(container);
                    var barWidth = availableWidth / data[0].values.length * 0.45;
                    x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX)));
                    if (padData)
                        x.range(xRange || [
                            availableWidth * 0.5 / data[0].values.length,
                            availableWidth * (data[0].values.length - 0.5) / data[0].values.length
                        ]);
                    else
                        x.range(xRange || [
                            5 + barWidth / 2,
                            availableWidth - barWidth / 2 - 5
                        ]);
                    y.domain(yDomain || [
                        d3.min(data[0].values.map(getLow).concat(forceY)),
                        d3.max(data[0].values.map(getHigh).concat(forceY))
                    ]).range(yRange || [
                        availableHeight,
                        0
                    ]);
                    if (x.domain()[0] === x.domain()[1])
                        x.domain()[0] ? x.domain([
                            x.domain()[0] - x.domain()[0] * 0.01,
                            x.domain()[1] + x.domain()[1] * 0.01
                        ]) : x.domain([
                            -1,
                            1
                        ]);
                    if (y.domain()[0] === y.domain()[1])
                        y.domain()[0] ? y.domain([
                            y.domain()[0] + y.domain()[0] * 0.01,
                            y.domain()[1] - y.domain()[1] * 0.01
                        ]) : y.domain([
                            -1,
                            1
                        ]);
                    var wrap = d3.select(this).selectAll('g.nv-wrap.nv-candlestickBar').data([data[0].values]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-candlestickBar');
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-ticks');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    container.on('click', function (d, i) {
                        dispatch.chartClick({
                            data: d,
                            index: i,
                            pos: d3.event,
                            id: id
                        });
                    });
                    defsEnter.append('clipPath').attr('id', 'nv-chart-clip-path-' + id).append('rect');
                    wrap.select('#nv-chart-clip-path-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);
                    g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');
                    var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick').data(function (d) {
                        return d;
                    });
                    ticks.exit().remove();
                    var tickGroups = ticks.enter().append('g');
                    ticks.attr('class', function (d, i, j) {
                        return (getOpen(d, i) > getClose(d, i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;
                    });
                    var lines = tickGroups.append('line').attr('class', 'nv-candlestick-lines').attr('transform', function (d, i) {
                        return 'translate(' + x(getX(d, i)) + ',0)';
                    }).attr('x1', 0).attr('y1', function (d, i) {
                        return y(getHigh(d, i));
                    }).attr('x2', 0).attr('y2', function (d, i) {
                        return y(getLow(d, i));
                    });
                    var rects = tickGroups.append('rect').attr('class', 'nv-candlestick-rects nv-bars').attr('transform', function (d, i) {
                        return 'translate(' + (x(getX(d, i)) - barWidth / 2) + ',' + (y(getY(d, i)) - (getOpen(d, i) > getClose(d, i) ? y(getClose(d, i)) - y(getOpen(d, i)) : 0)) + ')';
                    }).attr('x', 0).attr('y', 0).attr('width', barWidth).attr('height', function (d, i) {
                        var open = getOpen(d, i);
                        var close = getClose(d, i);
                        return open > close ? y(close) - y(open) : y(open) - y(close);
                    });
                    ticks.select('.nv-candlestick-lines').transition().attr('transform', function (d, i) {
                        return 'translate(' + x(getX(d, i)) + ',0)';
                    }).attr('x1', 0).attr('y1', function (d, i) {
                        return y(getHigh(d, i));
                    }).attr('x2', 0).attr('y2', function (d, i) {
                        return y(getLow(d, i));
                    });
                    ticks.select('.nv-candlestick-rects').transition().attr('transform', function (d, i) {
                        return 'translate(' + (x(getX(d, i)) - barWidth / 2) + ',' + (y(getY(d, i)) - (getOpen(d, i) > getClose(d, i) ? y(getClose(d, i)) - y(getOpen(d, i)) : 0)) + ')';
                    }).attr('x', 0).attr('y', 0).attr('width', barWidth).attr('height', function (d, i) {
                        var open = getOpen(d, i);
                        var close = getClose(d, i);
                        return open > close ? y(close) - y(open) : y(open) - y(close);
                    });
                });
                return chart;
            }
            chart.highlightPoint = function (pointIndex, isHoverOver) {
                chart.clearHighlights();
                container.select('.nv-candlestickBar .nv-tick-0-' + pointIndex).classed('hover', isHoverOver);
            };
            chart.clearHighlights = function () {
                container.select('.nv-candlestickBar .nv-tick.hover').classed('hover', false);
            };
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                forceX: {
                    get: function () {
                        return forceX;
                    },
                    set: function (_) {
                        forceX = _;
                    }
                },
                forceY: {
                    get: function () {
                        return forceY;
                    },
                    set: function (_) {
                        forceY = _;
                    }
                },
                padData: {
                    get: function () {
                        return padData;
                    },
                    set: function (_) {
                        padData = _;
                    }
                },
                clipEdge: {
                    get: function () {
                        return clipEdge;
                    },
                    set: function (_) {
                        clipEdge = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                interactive: {
                    get: function () {
                        return interactive;
                    },
                    set: function (_) {
                        interactive = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                    }
                },
                open: {
                    get: function () {
                        return getOpen();
                    },
                    set: function (_) {
                        getOpen = _;
                    }
                },
                close: {
                    get: function () {
                        return getClose();
                    },
                    set: function (_) {
                        getClose = _;
                    }
                },
                high: {
                    get: function () {
                        return getHigh;
                    },
                    set: function (_) {
                        getHigh = _;
                    }
                },
                low: {
                    get: function () {
                        return getLow;
                    },
                    set: function (_) {
                        getLow = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top != undefined ? _.top : margin.top;
                        margin.right = _.right != undefined ? _.right : margin.right;
                        margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
                        margin.left = _.left != undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.cumulativeLineChart = function () {
            'use strict';
            var lines = nv.models.line(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend(), interactiveLayer = nv.interactiveGuideline(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 30,
                    bottom: 50,
                    left: 60
                }, color = nv.utils.defaultColor(), width = null, height = null, showLegend = true, showXAxis = true, showYAxis = true, rightAlignYAxis = false, showControls = true, useInteractiveGuideline = false, rescaleY = true, x, y, id = lines.id(), state = nv.utils.state(), defaultState = null, noData = null, average = function (d) {
                    return d.average;
                }, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd'), transitionDuration = 250, duration = 250, noErrorCheck = false;
            state.index = 0;
            state.rescaleY = rescaleY;
            xAxis.orient('bottom').tickPadding(7);
            yAxis.orient(rightAlignYAxis ? 'right' : 'left');
            tooltip.valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            }).headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            controls.updateState(false);
            var dx = d3.scale.linear(), index = {
                    i: 0,
                    x: 0
                }, renderWatch = nv.utils.renderWatch(dispatch, duration);
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        }),
                        index: index.i,
                        rescaleY: rescaleY
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.index !== undefined)
                        index.i = state.index;
                    if (state.rescaleY !== undefined)
                        rescaleY = state.rescaleY;
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(lines);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                selection.each(function (data) {
                    var container = d3.select(this);
                    nv.utils.initSVG(container);
                    container.classed('nv-chart-' + id, true);
                    var that = this;
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        if (duration === 0)
                            container.call(chart);
                        else
                            container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    var indexDrag = d3.behavior.drag().on('dragstart', dragStart).on('drag', dragMove).on('dragend', dragEnd);
                    function dragStart(d, i) {
                        d3.select(chart.container).style('cursor', 'ew-resize');
                    }
                    function dragMove(d, i) {
                        index.x = d3.event.x;
                        index.i = Math.round(dx.invert(index.x));
                        updateZero();
                    }
                    function dragEnd(d, i) {
                        d3.select(chart.container).style('cursor', 'auto');
                        state.index = index.i;
                        dispatch.stateChange(state);
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = lines.xScale();
                    y = lines.yScale();
                    if (!rescaleY) {
                        var seriesDomains = data.filter(function (series) {
                            return !series.disabled;
                        }).map(function (series, i) {
                            var initialDomain = d3.extent(series.values, lines.y());
                            if (initialDomain[0] < -0.95)
                                initialDomain[0] = -0.95;
                            return [
                                (initialDomain[0] - initialDomain[1]) / (1 + initialDomain[1]),
                                (initialDomain[1] - initialDomain[0]) / (1 + initialDomain[0])
                            ];
                        });
                        var completeDomain = [
                            d3.min(seriesDomains, function (d) {
                                return d[0];
                            }),
                            d3.max(seriesDomains, function (d) {
                                return d[1];
                            })
                        ];
                        lines.yDomain(completeDomain);
                    } else {
                        lines.yDomain(null);
                    }
                    dx.domain([
                        0,
                        data[0].values.length - 1
                    ]).range([
                        0,
                        availableWidth
                    ]).clamp(true);
                    var data = indexify(index.i, data);
                    var interactivePointerEvents = useInteractiveGuideline ? 'none' : 'all';
                    var wrap = container.selectAll('g.nv-wrap.nv-cumulativeLine').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-cumulativeLine').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-interactive');
                    gEnter.append('g').attr('class', 'nv-x nv-axis').style('pointer-events', 'none');
                    gEnter.append('g').attr('class', 'nv-y nv-axis');
                    gEnter.append('g').attr('class', 'nv-background');
                    gEnter.append('g').attr('class', 'nv-linesWrap').style('pointer-events', interactivePointerEvents);
                    gEnter.append('g').attr('class', 'nv-avgLinesWrap').style('pointer-events', 'none');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    gEnter.append('g').attr('class', 'nv-controlsWrap');
                    if (showLegend) {
                        legend.width(availableWidth);
                        g.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        g.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');
                    }
                    if (showControls) {
                        var controlsData = [{
                                key: 'Re-scale y-axis',
                                disabled: !rescaleY
                            }];
                        controls.width(140).color([
                            '#444',
                            '#444',
                            '#444'
                        ]).rightAlign(false).margin({
                            top: 5,
                            right: 0,
                            bottom: 5,
                            left: 20
                        });
                        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    var tempDisabled = data.filter(function (d) {
                        return d.tempDisabled;
                    });
                    wrap.select('.tempDisabled').remove();
                    if (tempDisabled.length) {
                        wrap.append('text').attr('class', 'tempDisabled').attr('x', availableWidth / 2).attr('y', '-.71em').style('text-anchor', 'end').text(tempDisabled.map(function (d) {
                            return d.key;
                        }).join(', ') + ' values cannot be calculated for this time period.');
                    }
                    if (useInteractiveGuideline) {
                        interactiveLayer.width(availableWidth).height(availableHeight).margin({
                            left: margin.left,
                            top: margin.top
                        }).svgContainer(container).xScale(x);
                        wrap.select('.nv-interactive').call(interactiveLayer);
                    }
                    gEnter.select('.nv-background').append('rect');
                    g.select('.nv-background rect').attr('width', availableWidth).attr('height', availableHeight);
                    lines.y(function (d) {
                        return d.display.y;
                    }).width(availableWidth).height(availableHeight).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled && !data[i].tempDisabled;
                    }));
                    var linesWrap = g.select('.nv-linesWrap').datum(data.filter(function (d) {
                        return !d.disabled && !d.tempDisabled;
                    }));
                    linesWrap.call(lines);
                    data.forEach(function (d, i) {
                        d.seriesIndex = i;
                    });
                    var avgLineData = data.filter(function (d) {
                        return !d.disabled && !!average(d);
                    });
                    var avgLines = g.select('.nv-avgLinesWrap').selectAll('line').data(avgLineData, function (d) {
                        return d.key;
                    });
                    var getAvgLineY = function (d) {
                        var yVal = y(average(d));
                        if (yVal < 0)
                            return 0;
                        if (yVal > availableHeight)
                            return availableHeight;
                        return yVal;
                    };
                    avgLines.enter().append('line').style('stroke-width', 2).style('stroke-dasharray', '10,10').style('stroke', function (d, i) {
                        return lines.color()(d, d.seriesIndex);
                    }).attr('x1', 0).attr('x2', availableWidth).attr('y1', getAvgLineY).attr('y2', getAvgLineY);
                    avgLines.style('stroke-opacity', function (d) {
                        var yVal = y(average(d));
                        if (yVal < 0 || yVal > availableHeight)
                            return 0;
                        return 1;
                    }).attr('x1', 0).attr('x2', availableWidth).attr('y1', getAvgLineY).attr('y2', getAvgLineY);
                    avgLines.exit().remove();
                    var indexLine = linesWrap.selectAll('.nv-indexLine').data([index]);
                    indexLine.enter().append('rect').attr('class', 'nv-indexLine').attr('width', 3).attr('x', -2).attr('fill', 'red').attr('fill-opacity', 0.5).style('pointer-events', 'all').call(indexDrag);
                    indexLine.attr('transform', function (d) {
                        return 'translate(' + dx(d.i) + ',0)';
                    }).attr('height', availableHeight);
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 70, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');
                        g.select('.nv-x.nv-axis').call(xAxis);
                    }
                    if (showYAxis) {
                        yAxis.scale(y)._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                        g.select('.nv-y.nv-axis').call(yAxis);
                    }
                    function updateZero() {
                        indexLine.data([index]);
                        var oldDuration = chart.duration();
                        chart.duration(0);
                        chart.update();
                        chart.duration(oldDuration);
                    }
                    g.select('.nv-background rect').on('click', function () {
                        index.x = d3.mouse(this)[0];
                        index.i = Math.round(dx.invert(index.x));
                        state.index = index.i;
                        dispatch.stateChange(state);
                        updateZero();
                    });
                    lines.dispatch.on('elementClick', function (e) {
                        index.i = e.pointIndex;
                        index.x = dx(index.i);
                        state.index = index.i;
                        dispatch.stateChange(state);
                        updateZero();
                    });
                    controls.dispatch.on('legendClick', function (d, i) {
                        d.disabled = !d.disabled;
                        rescaleY = !d.disabled;
                        state.rescaleY = rescaleY;
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    interactiveLayer.dispatch.on('elementMousemove', function (e) {
                        lines.clearHighlights();
                        var singlePoint, pointIndex, pointXLocation, allData = [];
                        data.filter(function (series, i) {
                            series.seriesIndex = i;
                            return !series.disabled;
                        }).forEach(function (series, i) {
                            pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                            lines.highlightPoint(i, pointIndex, true);
                            var point = series.values[pointIndex];
                            if (typeof point === 'undefined')
                                return;
                            if (typeof singlePoint === 'undefined')
                                singlePoint = point;
                            if (typeof pointXLocation === 'undefined')
                                pointXLocation = chart.xScale()(chart.x()(point, pointIndex));
                            allData.push({
                                key: series.key,
                                value: chart.y()(point, pointIndex),
                                color: color(series, series.seriesIndex)
                            });
                        });
                        if (allData.length > 2) {
                            var yValue = chart.yScale().invert(e.mouseY);
                            var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                            var threshold = 0.03 * domainExtent;
                            var indexToHighlight = nv.nearestValueIndex(allData.map(function (d) {
                                return d.value;
                            }), yValue, threshold);
                            if (indexToHighlight !== null)
                                allData[indexToHighlight].highlight = true;
                        }
                        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex), pointIndex);
                        interactiveLayer.tooltip.chartContainer(that.parentNode).valueFormatter(function (d, i) {
                            return yAxis.tickFormat()(d);
                        }).data({
                            value: xValue,
                            series: allData
                        })();
                        interactiveLayer.renderGuideLine(pointXLocation);
                    });
                    interactiveLayer.dispatch.on('elementMouseout', function (e) {
                        lines.clearHighlights();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        if (typeof e.index !== 'undefined') {
                            index.i = e.index;
                            index.x = dx(index.i);
                            state.index = e.index;
                            indexLine.data([index]);
                        }
                        if (typeof e.rescaleY !== 'undefined') {
                            rescaleY = e.rescaleY;
                        }
                        chart.update();
                    });
                });
                renderWatch.renderEnd('cumulativeLineChart immediate');
                return chart;
            }
            lines.dispatch.on('elementMouseover.tooltip', function (evt) {
                var point = {
                    x: chart.x()(evt.point),
                    y: chart.y()(evt.point),
                    color: evt.point.color
                };
                evt.point = point;
                tooltip.data(evt).hidden(false);
            });
            lines.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            var indexifyYGetter = null;
            function indexify(idx, data) {
                if (!indexifyYGetter)
                    indexifyYGetter = lines.y();
                return data.map(function (line, i) {
                    if (!line.values) {
                        return line;
                    }
                    var indexValue = line.values[idx];
                    if (indexValue == null) {
                        return line;
                    }
                    var v = indexifyYGetter(indexValue, idx);
                    if (v < -0.95 && !noErrorCheck) {
                        line.tempDisabled = true;
                        return line;
                    }
                    line.tempDisabled = false;
                    line.values = line.values.map(function (point, pointIndex) {
                        point.display = { 'y': (indexifyYGetter(point, pointIndex) - v) / (1 + v) };
                        return point;
                    });
                    return line;
                });
            }
            chart.dispatch = dispatch;
            chart.lines = lines;
            chart.legend = legend;
            chart.controls = controls;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.interactiveLayer = interactiveLayer;
            chart.state = state;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                rescaleY: {
                    get: function () {
                        return rescaleY;
                    },
                    set: function (_) {
                        rescaleY = _;
                    }
                },
                showControls: {
                    get: function () {
                        return showControls;
                    },
                    set: function (_) {
                        showControls = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                average: {
                    get: function () {
                        return average;
                    },
                    set: function (_) {
                        average = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                noErrorCheck: {
                    get: function () {
                        return noErrorCheck;
                    },
                    set: function (_) {
                        noErrorCheck = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                    }
                },
                useInteractiveGuideline: {
                    get: function () {
                        return useInteractiveGuideline;
                    },
                    set: function (_) {
                        useInteractiveGuideline = _;
                        if (_ === true) {
                            chart.interactive(false);
                            chart.useVoronoi(false);
                        }
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(_ ? 'right' : 'left');
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        lines.duration(duration);
                        xAxis.duration(duration);
                        yAxis.duration(duration);
                        renderWatch.reset(duration);
                    }
                }
            });
            nv.utils.inheritOptions(chart, lines);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.discreteBar = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 960, height = 500, id = Math.floor(Math.random() * 10000), container, x = d3.scale.ordinal(), y = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, forceY = [0], color = nv.utils.defaultColor(), showValues = false, valueFormat = d3.format(',.2f'), xDomain, yDomain, xRange, yRange, dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd'), rectClass = 'discreteBar', duration = 250;
            var x0, y0;
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    data.forEach(function (series, i) {
                        series.values.forEach(function (point) {
                            point.series = i;
                        });
                    });
                    var seriesData = xDomain && yDomain ? [] : data.map(function (d) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d, i),
                                y: getY(d, i),
                                y0: d.y0
                            };
                        });
                    });
                    x.domain(xDomain || d3.merge(seriesData).map(function (d) {
                        return d.x;
                    })).rangeBands(xRange || [
                        0,
                        availableWidth
                    ], 0.1);
                    y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function (d) {
                        return d.y;
                    }).concat(forceY)));
                    if (showValues)
                        y.range(yRange || [
                            availableHeight - (y.domain()[0] < 0 ? 12 : 0),
                            y.domain()[1] > 0 ? 12 : 0
                        ]);
                    else
                        y.range(yRange || [
                            availableHeight,
                            0
                        ]);
                    x0 = x0 || x;
                    y0 = y0 || y.copy().range([
                        y(0),
                        y(0)
                    ]);
                    var wrap = container.selectAll('g.nv-wrap.nv-discretebar').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discretebar');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-groups');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {
                        return d;
                    }, function (d) {
                        return d.key;
                    });
                    groups.enter().append('g').style('stroke-opacity', 0.000001).style('fill-opacity', 0.000001);
                    groups.exit().watchTransition(renderWatch, 'discreteBar: exit groups').style('stroke-opacity', 0.000001).style('fill-opacity', 0.000001).remove();
                    groups.attr('class', function (d, i) {
                        return 'nv-group nv-series-' + i;
                    }).classed('hover', function (d) {
                        return d.hover;
                    });
                    groups.watchTransition(renderWatch, 'discreteBar: groups').style('stroke-opacity', 1).style('fill-opacity', 0.75);
                    var bars = groups.selectAll('g.nv-bar').data(function (d) {
                        return d.values;
                    });
                    bars.exit().remove();
                    var barsEnter = bars.enter().append('g').attr('transform', function (d, i, j) {
                        return 'translate(' + (x(getX(d, i)) + x.rangeBand() * 0.05) + ', ' + y(0) + ')';
                    }).on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mousemove', function (d, i) {
                        dispatch.elementMousemove({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('click', function (d, i) {
                        dispatch.elementClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    }).on('dblclick', function (d, i) {
                        dispatch.elementDblClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    });
                    barsEnter.append('rect').attr('height', 0).attr('width', x.rangeBand() * 0.9 / data.length);
                    if (showValues) {
                        barsEnter.append('text').attr('text-anchor', 'middle');
                        bars.select('text').text(function (d, i) {
                            return valueFormat(getY(d, i));
                        }).watchTransition(renderWatch, 'discreteBar: bars text').attr('x', x.rangeBand() * 0.9 / 2).attr('y', function (d, i) {
                            return getY(d, i) < 0 ? y(getY(d, i)) - y(0) + 12 : -4;
                        });
                    } else {
                        bars.selectAll('text').remove();
                    }
                    bars.attr('class', function (d, i) {
                        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';
                    }).style('fill', function (d, i) {
                        return d.color || color(d, i);
                    }).style('stroke', function (d, i) {
                        return d.color || color(d, i);
                    }).select('rect').attr('class', rectClass).watchTransition(renderWatch, 'discreteBar: bars rect').attr('width', x.rangeBand() * 0.9 / data.length);
                    bars.watchTransition(renderWatch, 'discreteBar: bars').attr('transform', function (d, i) {
                        var left = x(getX(d, i)) + x.rangeBand() * 0.05, top = getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i));
                        return 'translate(' + left + ', ' + top + ')';
                    }).select('rect').attr('height', function (d, i) {
                        return Math.max(Math.abs(y(getY(d, i)) - y(yDomain && yDomain[0] || 0)) || 1);
                    });
                    x0 = x.copy();
                    y0 = y.copy();
                });
                renderWatch.renderEnd('discreteBar immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                forceY: {
                    get: function () {
                        return forceY;
                    },
                    set: function (_) {
                        forceY = _;
                    }
                },
                showValues: {
                    get: function () {
                        return showValues;
                    },
                    set: function (_) {
                        showValues = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                valueFormat: {
                    get: function () {
                        return valueFormat;
                    },
                    set: function (_) {
                        valueFormat = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                rectClass: {
                    get: function () {
                        return rectClass;
                    },
                    set: function (_) {
                        rectClass = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.discreteBarChart = function () {
            'use strict';
            var discretebar = nv.models.discreteBar(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 15,
                    right: 10,
                    bottom: 50,
                    left: 60
                }, width = null, height = null, color = nv.utils.getColor(), showXAxis = true, showYAxis = true, rightAlignYAxis = false, staggerLabels = false, wrapLabels = false, rotateLabels = 0, x, y, noData = null, dispatch = d3.dispatch('beforeUpdate', 'renderEnd'), duration = 250;
            xAxis.orient('bottom').showMaxMin(false).tickFormat(function (d) {
                return d;
            });
            yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickFormat(d3.format(',.1f'));
            tooltip.duration(0).headerEnabled(false).valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            }).keyFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(discretebar);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        dispatch.beforeUpdate();
                        container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = discretebar.xScale();
                    y = discretebar.yScale().clamp(true);
                    var wrap = container.selectAll('g.nv-wrap.nv-discreteBarWithAxes').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discreteBarWithAxes').append('g');
                    var defsEnter = gEnter.append('defs');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis').append('g').attr('class', 'nv-zeroLine').append('line');
                    gEnter.append('g').attr('class', 'nv-barsWrap');
                    g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    discretebar.width(availableWidth).height(availableHeight);
                    var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    }));
                    barsWrap.transition().call(discretebar);
                    defsEnter.append('clipPath').attr('id', 'nv-x-label-clip-' + discretebar.id()).append('rect');
                    g.select('#nv-x-label-clip-' + discretebar.id() + ' rect').attr('width', x.rangeBand() * (staggerLabels ? 2 : 1)).attr('height', 16).attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2));
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + (y.range()[0] + (discretebar.showValues() && y.domain()[0] < 0 ? 16 : 0)) + ')');
                        g.select('.nv-x.nv-axis').call(xAxis);
                        var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                        if (staggerLabels) {
                            xTicks.selectAll('text').attr('transform', function (d, i, j) {
                                return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')';
                            });
                        }
                        if (rotateLabels) {
                            xTicks.selectAll('.tick text').attr('transform', 'rotate(' + rotateLabels + ' 0,0)').style('text-anchor', rotateLabels > 0 ? 'start' : 'end');
                        }
                        if (wrapLabels) {
                            g.selectAll('.tick text').call(nv.utils.wrapTicks, chart.xAxis.rangeBand());
                        }
                    }
                    if (showYAxis) {
                        yAxis.scale(y)._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                        g.select('.nv-y.nv-axis').call(yAxis);
                    }
                    g.select('.nv-zeroLine line').attr('x1', 0).attr('x2', availableWidth).attr('y1', y(0)).attr('y2', y(0));
                });
                renderWatch.renderEnd('discreteBar chart immediate');
                return chart;
            }
            discretebar.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt['series'] = {
                    key: chart.x()(evt.data),
                    value: chart.y()(evt.data),
                    color: evt.color
                };
                tooltip.data(evt).hidden(false);
            });
            discretebar.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            discretebar.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.dispatch = dispatch;
            chart.discretebar = discretebar;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                staggerLabels: {
                    get: function () {
                        return staggerLabels;
                    },
                    set: function (_) {
                        staggerLabels = _;
                    }
                },
                rotateLabels: {
                    get: function () {
                        return rotateLabels;
                    },
                    set: function (_) {
                        rotateLabels = _;
                    }
                },
                wrapLabels: {
                    get: function () {
                        return wrapLabels;
                    },
                    set: function (_) {
                        wrapLabels = !!_;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        discretebar.duration(duration);
                        xAxis.duration(duration);
                        yAxis.duration(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        discretebar.color(color);
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(_ ? 'right' : 'left');
                    }
                }
            });
            nv.utils.inheritOptions(chart, discretebar);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.distribution = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 400, size = 8, axis = 'x', getData = function (d) {
                    return d[axis];
                }, color = nv.utils.defaultColor(), scale = d3.scale.linear(), domain, duration = 250, dispatch = d3.dispatch('renderEnd');
            var scale0;
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    var availableLength = width - (axis === 'x' ? margin.left + margin.right : margin.top + margin.bottom), naxis = axis == 'x' ? 'y' : 'x', container = d3.select(this);
                    nv.utils.initSVG(container);
                    scale0 = scale0 || scale;
                    var wrap = container.selectAll('g.nv-distribution').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-distribution');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var distWrap = g.selectAll('g.nv-dist').data(function (d) {
                        return d;
                    }, function (d) {
                        return d.key;
                    });
                    distWrap.enter().append('g');
                    distWrap.attr('class', function (d, i) {
                        return 'nv-dist nv-series-' + i;
                    }).style('stroke', function (d, i) {
                        return color(d, i);
                    });
                    var dist = distWrap.selectAll('line.nv-dist' + axis).data(function (d) {
                        return d.values;
                    });
                    dist.enter().append('line').attr(axis + '1', function (d, i) {
                        return scale0(getData(d, i));
                    }).attr(axis + '2', function (d, i) {
                        return scale0(getData(d, i));
                    });
                    renderWatch.transition(distWrap.exit().selectAll('line.nv-dist' + axis), 'dist exit').attr(axis + '1', function (d, i) {
                        return scale(getData(d, i));
                    }).attr(axis + '2', function (d, i) {
                        return scale(getData(d, i));
                    }).style('stroke-opacity', 0).remove();
                    dist.attr('class', function (d, i) {
                        return 'nv-dist' + axis + ' nv-dist' + axis + '-' + i;
                    }).attr(naxis + '1', 0).attr(naxis + '2', size);
                    renderWatch.transition(dist, 'dist').attr(axis + '1', function (d, i) {
                        return scale(getData(d, i));
                    }).attr(axis + '2', function (d, i) {
                        return scale(getData(d, i));
                    });
                    scale0 = scale.copy();
                });
                renderWatch.renderEnd('distribution immediate');
                return chart;
            }
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart.dispatch = dispatch;
            chart.margin = function (_) {
                if (!arguments.length)
                    return margin;
                margin.top = typeof _.top != 'undefined' ? _.top : margin.top;
                margin.right = typeof _.right != 'undefined' ? _.right : margin.right;
                margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
                margin.left = typeof _.left != 'undefined' ? _.left : margin.left;
                return chart;
            };
            chart.width = function (_) {
                if (!arguments.length)
                    return width;
                width = _;
                return chart;
            };
            chart.axis = function (_) {
                if (!arguments.length)
                    return axis;
                axis = _;
                return chart;
            };
            chart.size = function (_) {
                if (!arguments.length)
                    return size;
                size = _;
                return chart;
            };
            chart.getData = function (_) {
                if (!arguments.length)
                    return getData;
                getData = d3.functor(_);
                return chart;
            };
            chart.scale = function (_) {
                if (!arguments.length)
                    return scale;
                scale = _;
                return chart;
            };
            chart.color = function (_) {
                if (!arguments.length)
                    return color;
                color = nv.utils.getColor(_);
                return chart;
            };
            chart.duration = function (_) {
                if (!arguments.length)
                    return duration;
                duration = _;
                renderWatch.reset(duration);
                return chart;
            };
            return chart;
        };
        nv.models.furiousLegend = function () {
            'use strict';
            var margin = {
                    top: 5,
                    right: 0,
                    bottom: 5,
                    left: 0
                }, width = 400, height = 20, getKey = function (d) {
                    return d.key;
                }, color = nv.utils.getColor(), maxKeyLength = 20, align = true, padding = 28, rightAlign = true, updateState = true, radioButtonMode = false, expanded = false, dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange'), vers = 'classic';
            function chart(selection) {
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, container = d3.select(this);
                    nv.utils.initSVG(container);
                    var wrap = container.selectAll('g.nv-legend').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');
                    var g = wrap.select('g');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var series = g.selectAll('.nv-series').data(function (d) {
                        if (vers != 'furious')
                            return d;
                        return d.filter(function (n) {
                            return expanded ? true : !n.disengaged;
                        });
                    });
                    var seriesEnter = series.enter().append('g').attr('class', 'nv-series');
                    var seriesShape;
                    if (vers == 'classic') {
                        seriesEnter.append('circle').style('stroke-width', 2).attr('class', 'nv-legend-symbol').attr('r', 5);
                        seriesShape = series.select('circle');
                    } else if (vers == 'furious') {
                        seriesEnter.append('rect').style('stroke-width', 2).attr('class', 'nv-legend-symbol').attr('rx', 3).attr('ry', 3);
                        seriesShape = series.select('rect');
                        seriesEnter.append('g').attr('class', 'nv-check-box').property('innerHTML', '<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>').attr('transform', 'translate(-10,-8)scale(0.5)');
                        var seriesCheckbox = series.select('.nv-check-box');
                        seriesCheckbox.each(function (d, i) {
                            d3.select(this).selectAll('path').attr('stroke', setTextColor(d, i));
                        });
                    }
                    seriesEnter.append('text').attr('text-anchor', 'start').attr('class', 'nv-legend-text').attr('dy', '.32em').attr('dx', '8');
                    var seriesText = series.select('text.nv-legend-text');
                    series.on('mouseover', function (d, i) {
                        dispatch.legendMouseover(d, i);
                    }).on('mouseout', function (d, i) {
                        dispatch.legendMouseout(d, i);
                    }).on('click', function (d, i) {
                        dispatch.legendClick(d, i);
                        var data = series.data();
                        if (updateState) {
                            if (vers == 'classic') {
                                if (radioButtonMode) {
                                    data.forEach(function (series) {
                                        series.disabled = true;
                                    });
                                    d.disabled = false;
                                } else {
                                    d.disabled = !d.disabled;
                                    if (data.every(function (series) {
                                            return series.disabled;
                                        })) {
                                        data.forEach(function (series) {
                                            series.disabled = false;
                                        });
                                    }
                                }
                            } else if (vers == 'furious') {
                                if (expanded) {
                                    d.disengaged = !d.disengaged;
                                    d.userDisabled = d.userDisabled == undefined ? !!d.disabled : d.userDisabled;
                                    d.disabled = d.disengaged || d.userDisabled;
                                } else if (!expanded) {
                                    d.disabled = !d.disabled;
                                    d.userDisabled = d.disabled;
                                    var engaged = data.filter(function (d) {
                                        return !d.disengaged;
                                    });
                                    if (engaged.every(function (series) {
                                            return series.userDisabled;
                                        })) {
                                        data.forEach(function (series) {
                                            series.disabled = series.userDisabled = false;
                                        });
                                    }
                                }
                            }
                            dispatch.stateChange({
                                disabled: data.map(function (d) {
                                    return !!d.disabled;
                                }),
                                disengaged: data.map(function (d) {
                                    return !!d.disengaged;
                                })
                            });
                        }
                    }).on('dblclick', function (d, i) {
                        if (vers == 'furious' && expanded)
                            return;
                        dispatch.legendDblclick(d, i);
                        if (updateState) {
                            var data = series.data();
                            data.forEach(function (series) {
                                series.disabled = true;
                                if (vers == 'furious')
                                    series.userDisabled = series.disabled;
                            });
                            d.disabled = false;
                            if (vers == 'furious')
                                d.userDisabled = d.disabled;
                            dispatch.stateChange({
                                disabled: data.map(function (d) {
                                    return !!d.disabled;
                                })
                            });
                        }
                    });
                    series.classed('nv-disabled', function (d) {
                        return d.userDisabled;
                    });
                    series.exit().remove();
                    seriesText.attr('fill', setTextColor).text(getKey);
                    var versPadding;
                    switch (vers) {
                    case 'furious':
                        versPadding = 23;
                        break;
                    case 'classic':
                        versPadding = 20;
                    }
                    if (align) {
                        var seriesWidths = [];
                        series.each(function (d, i) {
                            var legendText;
                            if (getKey(d).length > maxKeyLength) {
                                var trimmedKey = getKey(d).substring(0, maxKeyLength);
                                legendText = d3.select(this).select('text').text(trimmedKey + '...');
                                d3.select(this).append('svg:title').text(getKey(d));
                            } else {
                                legendText = d3.select(this).select('text');
                            }
                            var nodeTextLength;
                            try {
                                nodeTextLength = legendText.node().getComputedTextLength();
                                if (nodeTextLength <= 0)
                                    throw Error();
                            } catch (e) {
                                nodeTextLength = nv.utils.calcApproxTextWidth(legendText);
                            }
                            seriesWidths.push(nodeTextLength + padding);
                        });
                        var seriesPerRow = 0;
                        var legendWidth = 0;
                        var columnWidths = [];
                        while (legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
                            columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
                            legendWidth += seriesWidths[seriesPerRow++];
                        }
                        if (seriesPerRow === 0)
                            seriesPerRow = 1;
                        while (legendWidth > availableWidth && seriesPerRow > 1) {
                            columnWidths = [];
                            seriesPerRow--;
                            for (var k = 0; k < seriesWidths.length; k++) {
                                if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0))
                                    columnWidths[k % seriesPerRow] = seriesWidths[k];
                            }
                            legendWidth = columnWidths.reduce(function (prev, cur, index, array) {
                                return prev + cur;
                            });
                        }
                        var xPositions = [];
                        for (var i = 0, curX = 0; i < seriesPerRow; i++) {
                            xPositions[i] = curX;
                            curX += columnWidths[i];
                        }
                        series.attr('transform', function (d, i) {
                            return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * versPadding) + ')';
                        });
                        if (rightAlign) {
                            g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');
                        } else {
                            g.attr('transform', 'translate(0' + ',' + margin.top + ')');
                        }
                        height = margin.top + margin.bottom + Math.ceil(seriesWidths.length / seriesPerRow) * versPadding;
                    } else {
                        var ypos = 5, newxpos = 5, maxwidth = 0, xpos;
                        series.attr('transform', function (d, i) {
                            var length = d3.select(this).select('text').node().getComputedTextLength() + padding;
                            xpos = newxpos;
                            if (width < margin.left + margin.right + xpos + length) {
                                newxpos = xpos = 5;
                                ypos += versPadding;
                            }
                            newxpos += length;
                            if (newxpos > maxwidth)
                                maxwidth = newxpos;
                            return 'translate(' + xpos + ',' + ypos + ')';
                        });
                        g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');
                        height = margin.top + margin.bottom + ypos + 15;
                    }
                    if (vers == 'furious') {
                        seriesShape.attr('width', function (d, i) {
                            return seriesText[0][i].getComputedTextLength() + 27;
                        }).attr('height', 18).attr('y', -9).attr('x', -15);
                    }
                    seriesShape.style('fill', setBGColor).style('stroke', function (d, i) {
                        return d.color || color(d, i);
                    });
                });
                function setTextColor(d, i) {
                    if (vers != 'furious')
                        return '#000';
                    if (expanded) {
                        return d.disengaged ? color(d, i) : '#fff';
                    } else if (!expanded) {
                        return !!d.disabled ? color(d, i) : '#fff';
                    }
                }
                function setBGColor(d, i) {
                    if (expanded && vers == 'furious') {
                        return d.disengaged ? '#fff' : color(d, i);
                    } else {
                        return !!d.disabled ? '#fff' : color(d, i);
                    }
                }
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                key: {
                    get: function () {
                        return getKey;
                    },
                    set: function (_) {
                        getKey = _;
                    }
                },
                align: {
                    get: function () {
                        return align;
                    },
                    set: function (_) {
                        align = _;
                    }
                },
                rightAlign: {
                    get: function () {
                        return rightAlign;
                    },
                    set: function (_) {
                        rightAlign = _;
                    }
                },
                maxKeyLength: {
                    get: function () {
                        return maxKeyLength;
                    },
                    set: function (_) {
                        maxKeyLength = _;
                    }
                },
                padding: {
                    get: function () {
                        return padding;
                    },
                    set: function (_) {
                        padding = _;
                    }
                },
                updateState: {
                    get: function () {
                        return updateState;
                    },
                    set: function (_) {
                        updateState = _;
                    }
                },
                radioButtonMode: {
                    get: function () {
                        return radioButtonMode;
                    },
                    set: function (_) {
                        radioButtonMode = _;
                    }
                },
                expanded: {
                    get: function () {
                        return expanded;
                    },
                    set: function (_) {
                        expanded = _;
                    }
                },
                vers: {
                    get: function () {
                        return vers;
                    },
                    set: function (_) {
                        vers = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.historicalBar = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = null, height = null, id = Math.floor(Math.random() * 10000), container = null, x = d3.scale.linear(), y = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, forceX = [], forceY = [0], padData = false, clipEdge = true, color = nv.utils.defaultColor(), xDomain, yDomain, xRange, yRange, dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd'), interactive = true;
            var renderWatch = nv.utils.renderWatch(dispatch, 0);
            function chart(selection) {
                selection.each(function (data) {
                    renderWatch.reset();
                    container = d3.select(this);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    nv.utils.initSVG(container);
                    x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX)));
                    if (padData)
                        x.range(xRange || [
                            availableWidth * 0.5 / data[0].values.length,
                            availableWidth * (data[0].values.length - 0.5) / data[0].values.length
                        ]);
                    else
                        x.range(xRange || [
                            0,
                            availableWidth
                        ]);
                    y.domain(yDomain || d3.extent(data[0].values.map(getY).concat(forceY))).range(yRange || [
                        availableHeight,
                        0
                    ]);
                    if (x.domain()[0] === x.domain()[1])
                        x.domain()[0] ? x.domain([
                            x.domain()[0] - x.domain()[0] * 0.01,
                            x.domain()[1] + x.domain()[1] * 0.01
                        ]) : x.domain([
                            -1,
                            1
                        ]);
                    if (y.domain()[0] === y.domain()[1])
                        y.domain()[0] ? y.domain([
                            y.domain()[0] + y.domain()[0] * 0.01,
                            y.domain()[1] - y.domain()[1] * 0.01
                        ]) : y.domain([
                            -1,
                            1
                        ]);
                    var wrap = container.selectAll('g.nv-wrap.nv-historicalBar-' + id).data([data[0].values]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBar-' + id);
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-bars');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    container.on('click', function (d, i) {
                        dispatch.chartClick({
                            data: d,
                            index: i,
                            pos: d3.event,
                            id: id
                        });
                    });
                    defsEnter.append('clipPath').attr('id', 'nv-chart-clip-path-' + id).append('rect');
                    wrap.select('#nv-chart-clip-path-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);
                    g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');
                    var bars = wrap.select('.nv-bars').selectAll('.nv-bar').data(function (d) {
                        return d;
                    }, function (d, i) {
                        return getX(d, i);
                    });
                    bars.exit().remove();
                    bars.enter().append('rect').attr('x', 0).attr('y', function (d, i) {
                        return nv.utils.NaNtoZero(y(Math.max(0, getY(d, i))));
                    }).attr('height', function (d, i) {
                        return nv.utils.NaNtoZero(Math.abs(y(getY(d, i)) - y(0)));
                    }).attr('transform', function (d, i) {
                        return 'translate(' + (x(getX(d, i)) - availableWidth / data[0].values.length * 0.45) + ',0)';
                    }).on('mouseover', function (d, i) {
                        if (!interactive)
                            return;
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        if (!interactive)
                            return;
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mousemove', function (d, i) {
                        if (!interactive)
                            return;
                        dispatch.elementMousemove({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('click', function (d, i) {
                        if (!interactive)
                            return;
                        dispatch.elementClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    }).on('dblclick', function (d, i) {
                        if (!interactive)
                            return;
                        dispatch.elementDblClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    });
                    bars.attr('fill', function (d, i) {
                        return color(d, i);
                    }).attr('class', function (d, i, j) {
                        return (getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i;
                    }).watchTransition(renderWatch, 'bars').attr('transform', function (d, i) {
                        return 'translate(' + (x(getX(d, i)) - availableWidth / data[0].values.length * 0.45) + ',0)';
                    }).attr('width', availableWidth / data[0].values.length * 0.9);
                    bars.watchTransition(renderWatch, 'bars').attr('y', function (d, i) {
                        var rval = getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i));
                        return nv.utils.NaNtoZero(rval);
                    }).attr('height', function (d, i) {
                        return nv.utils.NaNtoZero(Math.max(Math.abs(y(getY(d, i)) - y(0)), 1));
                    });
                });
                renderWatch.renderEnd('historicalBar immediate');
                return chart;
            }
            chart.highlightPoint = function (pointIndex, isHoverOver) {
                container.select('.nv-bars .nv-bar-0-' + pointIndex).classed('hover', isHoverOver);
            };
            chart.clearHighlights = function () {
                container.select('.nv-bars .nv-bar.hover').classed('hover', false);
            };
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                forceX: {
                    get: function () {
                        return forceX;
                    },
                    set: function (_) {
                        forceX = _;
                    }
                },
                forceY: {
                    get: function () {
                        return forceY;
                    },
                    set: function (_) {
                        forceY = _;
                    }
                },
                padData: {
                    get: function () {
                        return padData;
                    },
                    set: function (_) {
                        padData = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                clipEdge: {
                    get: function () {
                        return clipEdge;
                    },
                    set: function (_) {
                        clipEdge = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                interactive: {
                    get: function () {
                        return interactive;
                    },
                    set: function (_) {
                        interactive = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.historicalBarChart = function (bar_model) {
            'use strict';
            var bars = bar_model || nv.models.historicalBar(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), interactiveLayer = nv.interactiveGuideline(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 90,
                    bottom: 50,
                    left: 90
                }, color = nv.utils.defaultColor(), width = null, height = null, showLegend = false, showXAxis = true, showYAxis = true, rightAlignYAxis = false, useInteractiveGuideline = false, x, y, state = {}, defaultState = null, noData = null, dispatch = d3.dispatch('tooltipHide', 'stateChange', 'changeState', 'renderEnd'), transitionDuration = 250;
            xAxis.orient('bottom').tickPadding(7);
            yAxis.orient(rightAlignYAxis ? 'right' : 'left');
            tooltip.duration(0).headerEnabled(false).valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            }).headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            var renderWatch = nv.utils.renderWatch(dispatch, 0);
            function chart(selection) {
                selection.each(function (data) {
                    renderWatch.reset();
                    renderWatch.models(bars);
                    if (showXAxis)
                        renderWatch.models(xAxis);
                    if (showYAxis)
                        renderWatch.models(yAxis);
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        container.transition().duration(transitionDuration).call(chart);
                    };
                    chart.container = this;
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = bars.xScale();
                    y = bars.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-historicalBarChart').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBarChart').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis');
                    gEnter.append('g').attr('class', 'nv-barsWrap');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    gEnter.append('g').attr('class', 'nv-interactive');
                    if (showLegend) {
                        legend.width(availableWidth);
                        g.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        wrap.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    if (useInteractiveGuideline) {
                        interactiveLayer.width(availableWidth).height(availableHeight).margin({
                            left: margin.left,
                            top: margin.top
                        }).svgContainer(container).xScale(x);
                        wrap.select('.nv-interactive').call(interactiveLayer);
                    }
                    bars.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled;
                    }));
                    var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    }));
                    barsWrap.transition().call(bars);
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');
                        g.select('.nv-x.nv-axis').transition().call(xAxis);
                    }
                    if (showYAxis) {
                        yAxis.scale(y)._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                        g.select('.nv-y.nv-axis').transition().call(yAxis);
                    }
                    interactiveLayer.dispatch.on('elementMousemove', function (e) {
                        bars.clearHighlights();
                        var singlePoint, pointIndex, pointXLocation, allData = [];
                        data.filter(function (series, i) {
                            series.seriesIndex = i;
                            return !series.disabled;
                        }).forEach(function (series, i) {
                            pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                            bars.highlightPoint(pointIndex, true);
                            var point = series.values[pointIndex];
                            if (point === undefined)
                                return;
                            if (singlePoint === undefined)
                                singlePoint = point;
                            if (pointXLocation === undefined)
                                pointXLocation = chart.xScale()(chart.x()(point, pointIndex));
                            allData.push({
                                key: series.key,
                                value: chart.y()(point, pointIndex),
                                color: color(series, series.seriesIndex),
                                data: series.values[pointIndex]
                            });
                        });
                        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex));
                        interactiveLayer.tooltip.chartContainer(that.parentNode).valueFormatter(function (d, i) {
                            return yAxis.tickFormat()(d);
                        }).data({
                            value: xValue,
                            index: pointIndex,
                            series: allData
                        })();
                        interactiveLayer.renderGuideLine(pointXLocation);
                    });
                    interactiveLayer.dispatch.on('elementMouseout', function (e) {
                        dispatch.tooltipHide();
                        bars.clearHighlights();
                    });
                    legend.dispatch.on('legendClick', function (d, i) {
                        d.disabled = !d.disabled;
                        if (!data.filter(function (d) {
                                return !d.disabled;
                            }).length) {
                            data.map(function (d) {
                                d.disabled = false;
                                wrap.selectAll('.nv-series').classed('disabled', false);
                                return d;
                            });
                        }
                        state.disabled = data.map(function (d) {
                            return !!d.disabled;
                        });
                        dispatch.stateChange(state);
                        selection.transition().call(chart);
                    });
                    legend.dispatch.on('legendDblclick', function (d) {
                        data.forEach(function (d) {
                            d.disabled = true;
                        });
                        d.disabled = false;
                        state.disabled = data.map(function (d) {
                            return !!d.disabled;
                        });
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        chart.update();
                    });
                });
                renderWatch.renderEnd('historicalBarChart immediate');
                return chart;
            }
            bars.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt['series'] = {
                    key: chart.x()(evt.data),
                    value: chart.y()(evt.data),
                    color: evt.color
                };
                tooltip.data(evt).hidden(false);
            });
            bars.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            bars.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.dispatch = dispatch;
            chart.bars = bars;
            chart.legend = legend;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.interactiveLayer = interactiveLayer;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                        bars.color(color);
                    }
                },
                duration: {
                    get: function () {
                        return transitionDuration;
                    },
                    set: function (_) {
                        transitionDuration = _;
                        renderWatch.reset(transitionDuration);
                        yAxis.duration(transitionDuration);
                        xAxis.duration(transitionDuration);
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(_ ? 'right' : 'left');
                    }
                },
                useInteractiveGuideline: {
                    get: function () {
                        return useInteractiveGuideline;
                    },
                    set: function (_) {
                        useInteractiveGuideline = _;
                        if (_ === true) {
                            chart.interactive(false);
                        }
                    }
                }
            });
            nv.utils.inheritOptions(chart, bars);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.ohlcBarChart = function () {
            var chart = nv.models.historicalBarChart(nv.models.ohlcBar());
            chart.useInteractiveGuideline(true);
            chart.interactiveLayer.tooltip.contentGenerator(function (data) {
                var d = data.series[0].data;
                var color = d.open < d.close ? '2ca02c' : 'd62728';
                return '' + '<h3 style="color: #' + color + '">' + data.value + '</h3>' + '<table>' + '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' + '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' + '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' + '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' + '</table>';
            });
            return chart;
        };
        nv.models.candlestickBarChart = function () {
            var chart = nv.models.historicalBarChart(nv.models.candlestickBar());
            chart.useInteractiveGuideline(true);
            chart.interactiveLayer.tooltip.contentGenerator(function (data) {
                var d = data.series[0].data;
                var color = d.open < d.close ? '2ca02c' : 'd62728';
                return '' + '<h3 style="color: #' + color + '">' + data.value + '</h3>' + '<table>' + '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' + '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' + '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' + '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' + '</table>';
            });
            return chart;
        };
        nv.models.legend = function () {
            'use strict';
            var margin = {
                    top: 5,
                    right: 0,
                    bottom: 5,
                    left: 0
                }, width = 400, height = 20, getKey = function (d) {
                    return d.key;
                }, color = nv.utils.getColor(), maxKeyLength = 20, align = true, padding = 32, rightAlign = true, updateState = true, radioButtonMode = false, expanded = false, dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange'), vers = 'classic';
            function chart(selection) {
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, container = d3.select(this);
                    nv.utils.initSVG(container);
                    var wrap = container.selectAll('g.nv-legend').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');
                    var g = wrap.select('g');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var series = g.selectAll('.nv-series').data(function (d) {
                        if (vers != 'furious')
                            return d;
                        return d.filter(function (n) {
                            return expanded ? true : !n.disengaged;
                        });
                    });
                    var seriesEnter = series.enter().append('g').attr('class', 'nv-series');
                    var seriesShape;
                    var versPadding;
                    switch (vers) {
                    case 'furious':
                        versPadding = 23;
                        break;
                    case 'classic':
                        versPadding = 20;
                    }
                    if (vers == 'classic') {
                        seriesEnter.append('circle').style('stroke-width', 2).attr('class', 'nv-legend-symbol').attr('r', 5);
                        seriesShape = series.select('circle');
                    } else if (vers == 'furious') {
                        seriesEnter.append('rect').style('stroke-width', 2).attr('class', 'nv-legend-symbol').attr('rx', 3).attr('ry', 3);
                        seriesShape = series.select('.nv-legend-symbol');
                        seriesEnter.append('g').attr('class', 'nv-check-box').property('innerHTML', '<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>').attr('transform', 'translate(-10,-8)scale(0.5)');
                        var seriesCheckbox = series.select('.nv-check-box');
                        seriesCheckbox.each(function (d, i) {
                            d3.select(this).selectAll('path').attr('stroke', setTextColor(d, i));
                        });
                    }
                    seriesEnter.append('text').attr('text-anchor', 'start').attr('class', 'nv-legend-text').attr('dy', '.32em').attr('dx', '8');
                    var seriesText = series.select('text.nv-legend-text');
                    series.on('mouseover', function (d, i) {
                        dispatch.legendMouseover(d, i);
                    }).on('mouseout', function (d, i) {
                        dispatch.legendMouseout(d, i);
                    }).on('click', function (d, i) {
                        dispatch.legendClick(d, i);
                        var data = series.data();
                        if (updateState) {
                            if (vers == 'classic') {
                                if (radioButtonMode) {
                                    data.forEach(function (series) {
                                        series.disabled = true;
                                    });
                                    d.disabled = false;
                                } else {
                                    d.disabled = !d.disabled;
                                    if (data.every(function (series) {
                                            return series.disabled;
                                        })) {
                                        data.forEach(function (series) {
                                            series.disabled = false;
                                        });
                                    }
                                }
                            } else if (vers == 'furious') {
                                if (expanded) {
                                    d.disengaged = !d.disengaged;
                                    d.userDisabled = d.userDisabled == undefined ? !!d.disabled : d.userDisabled;
                                    d.disabled = d.disengaged || d.userDisabled;
                                } else if (!expanded) {
                                    d.disabled = !d.disabled;
                                    d.userDisabled = d.disabled;
                                    var engaged = data.filter(function (d) {
                                        return !d.disengaged;
                                    });
                                    if (engaged.every(function (series) {
                                            return series.userDisabled;
                                        })) {
                                        data.forEach(function (series) {
                                            series.disabled = series.userDisabled = false;
                                        });
                                    }
                                }
                            }
                            dispatch.stateChange({
                                disabled: data.map(function (d) {
                                    return !!d.disabled;
                                }),
                                disengaged: data.map(function (d) {
                                    return !!d.disengaged;
                                })
                            });
                        }
                    }).on('dblclick', function (d, i) {
                        if (vers == 'furious' && expanded)
                            return;
                        dispatch.legendDblclick(d, i);
                        if (updateState) {
                            var data = series.data();
                            data.forEach(function (series) {
                                series.disabled = true;
                                if (vers == 'furious')
                                    series.userDisabled = series.disabled;
                            });
                            d.disabled = false;
                            if (vers == 'furious')
                                d.userDisabled = d.disabled;
                            dispatch.stateChange({
                                disabled: data.map(function (d) {
                                    return !!d.disabled;
                                })
                            });
                        }
                    });
                    series.classed('nv-disabled', function (d) {
                        return d.userDisabled;
                    });
                    series.exit().remove();
                    seriesText.attr('fill', setTextColor).text(getKey);
                    var legendWidth = 0;
                    if (align) {
                        var seriesWidths = [];
                        series.each(function (d, i) {
                            var legendText;
                            if (getKey(d).length > maxKeyLength) {
                                var trimmedKey = getKey(d).substring(0, maxKeyLength);
                                legendText = d3.select(this).select('text').text(trimmedKey + '...');
                                d3.select(this).append('svg:title').text(getKey(d));
                            } else {
                                legendText = d3.select(this).select('text');
                            }
                            var nodeTextLength;
                            try {
                                nodeTextLength = legendText.node().getComputedTextLength();
                                if (nodeTextLength <= 0)
                                    throw Error();
                            } catch (e) {
                                nodeTextLength = nv.utils.calcApproxTextWidth(legendText);
                            }
                            seriesWidths.push(nodeTextLength + padding);
                        });
                        var seriesPerRow = 0;
                        var columnWidths = [];
                        legendWidth = 0;
                        while (legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
                            columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
                            legendWidth += seriesWidths[seriesPerRow++];
                        }
                        if (seriesPerRow === 0)
                            seriesPerRow = 1;
                        while (legendWidth > availableWidth && seriesPerRow > 1) {
                            columnWidths = [];
                            seriesPerRow--;
                            for (var k = 0; k < seriesWidths.length; k++) {
                                if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0))
                                    columnWidths[k % seriesPerRow] = seriesWidths[k];
                            }
                            legendWidth = columnWidths.reduce(function (prev, cur, index, array) {
                                return prev + cur;
                            });
                        }
                        var xPositions = [];
                        for (var i = 0, curX = 0; i < seriesPerRow; i++) {
                            xPositions[i] = curX;
                            curX += columnWidths[i];
                        }
                        series.attr('transform', function (d, i) {
                            return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * versPadding) + ')';
                        });
                        if (rightAlign) {
                            g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');
                        } else {
                            g.attr('transform', 'translate(0' + ',' + margin.top + ')');
                        }
                        height = margin.top + margin.bottom + Math.ceil(seriesWidths.length / seriesPerRow) * versPadding;
                    } else {
                        var ypos = 5, newxpos = 5, maxwidth = 0, xpos;
                        series.attr('transform', function (d, i) {
                            var length = d3.select(this).select('text').node().getComputedTextLength() + padding;
                            xpos = newxpos;
                            if (width < margin.left + margin.right + xpos + length) {
                                newxpos = xpos = 5;
                                ypos += versPadding;
                            }
                            newxpos += length;
                            if (newxpos > maxwidth)
                                maxwidth = newxpos;
                            if (legendWidth < xpos + maxwidth) {
                                legendWidth = xpos + maxwidth;
                            }
                            return 'translate(' + xpos + ',' + ypos + ')';
                        });
                        g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');
                        height = margin.top + margin.bottom + ypos + 15;
                    }
                    if (vers == 'furious') {
                        seriesShape.attr('width', function (d, i) {
                            return seriesText[0][i].getComputedTextLength() + 27;
                        }).attr('height', 18).attr('y', -9).attr('x', -15);
                        gEnter.insert('rect', ':first-child').attr('class', 'nv-legend-bg').attr('fill', '#eee').attr('opacity', 0);
                        var seriesBG = g.select('.nv-legend-bg');
                        seriesBG.transition().duration(300).attr('x', -versPadding).attr('width', legendWidth + versPadding - 12).attr('height', height + 10).attr('y', -margin.top - 10).attr('opacity', expanded ? 1 : 0);
                    }
                    seriesShape.style('fill', setBGColor).style('fill-opacity', setBGOpacity).style('stroke', setBGColor);
                });
                function setTextColor(d, i) {
                    if (vers != 'furious')
                        return '#000';
                    if (expanded) {
                        return d.disengaged ? '#000' : '#fff';
                    } else if (!expanded) {
                        if (!d.color)
                            d.color = color(d, i);
                        return !!d.disabled ? d.color : '#fff';
                    }
                }
                function setBGColor(d, i) {
                    if (expanded && vers == 'furious') {
                        return d.disengaged ? '#eee' : d.color || color(d, i);
                    } else {
                        return d.color || color(d, i);
                    }
                }
                function setBGOpacity(d, i) {
                    if (expanded && vers == 'furious') {
                        return 1;
                    } else {
                        return !!d.disabled ? 0 : 1;
                    }
                }
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                key: {
                    get: function () {
                        return getKey;
                    },
                    set: function (_) {
                        getKey = _;
                    }
                },
                align: {
                    get: function () {
                        return align;
                    },
                    set: function (_) {
                        align = _;
                    }
                },
                maxKeyLength: {
                    get: function () {
                        return maxKeyLength;
                    },
                    set: function (_) {
                        maxKeyLength = _;
                    }
                },
                rightAlign: {
                    get: function () {
                        return rightAlign;
                    },
                    set: function (_) {
                        rightAlign = _;
                    }
                },
                padding: {
                    get: function () {
                        return padding;
                    },
                    set: function (_) {
                        padding = _;
                    }
                },
                updateState: {
                    get: function () {
                        return updateState;
                    },
                    set: function (_) {
                        updateState = _;
                    }
                },
                radioButtonMode: {
                    get: function () {
                        return radioButtonMode;
                    },
                    set: function (_) {
                        radioButtonMode = _;
                    }
                },
                expanded: {
                    get: function () {
                        return expanded;
                    },
                    set: function (_) {
                        expanded = _;
                    }
                },
                vers: {
                    get: function () {
                        return vers;
                    },
                    set: function (_) {
                        vers = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.line = function () {
            'use strict';
            var scatter = nv.models.scatter();
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 960, height = 500, container = null, strokeWidth = 1.5, color = nv.utils.defaultColor(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, defined = function (d, i) {
                    return !isNaN(getY(d, i)) && getY(d, i) !== null;
                }, isArea = function (d) {
                    return d.area;
                }, clipEdge = false, x, y, interpolate = 'linear', duration = 250, dispatch = d3.dispatch('elementClick', 'elementMouseover', 'elementMouseout', 'renderEnd');
            scatter.pointSize(16).pointDomain([
                16,
                256
            ]);
            var x0, y0, renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(scatter);
                selection.each(function (data) {
                    container = d3.select(this);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    nv.utils.initSVG(container);
                    x = scatter.xScale();
                    y = scatter.yScale();
                    x0 = x0 || x;
                    y0 = y0 || y;
                    var wrap = container.selectAll('g.nv-wrap.nv-line').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-line');
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-groups');
                    gEnter.append('g').attr('class', 'nv-scatterWrap');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    scatter.width(availableWidth).height(availableHeight);
                    var scatterWrap = wrap.select('.nv-scatterWrap');
                    scatterWrap.call(scatter);
                    defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + scatter.id()).append('rect');
                    wrap.select('#nv-edge-clip-' + scatter.id() + ' rect').attr('width', availableWidth).attr('height', availableHeight > 0 ? availableHeight : 0);
                    g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');
                    scatterWrap.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');
                    var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {
                        return d;
                    }, function (d) {
                        return d.key;
                    });
                    groups.enter().append('g').style('stroke-opacity', 0.000001).style('stroke-width', function (d) {
                        return d.strokeWidth || strokeWidth;
                    }).style('fill-opacity', 0.000001);
                    groups.exit().remove();
                    groups.attr('class', function (d, i) {
                        return (d.classed || '') + ' nv-group nv-series-' + i;
                    }).classed('hover', function (d) {
                        return d.hover;
                    }).style('fill', function (d, i) {
                        return color(d, i);
                    }).style('stroke', function (d, i) {
                        return color(d, i);
                    });
                    groups.watchTransition(renderWatch, 'line: groups').style('stroke-opacity', 1).style('fill-opacity', function (d) {
                        return d.fillOpacity || 0.5;
                    });
                    var areaPaths = groups.selectAll('path.nv-area').data(function (d) {
                        return isArea(d) ? [d] : [];
                    });
                    areaPaths.enter().append('path').attr('class', 'nv-area').attr('d', function (d) {
                        return d3.svg.area().interpolate(interpolate).defined(defined).x(function (d, i) {
                            return nv.utils.NaNtoZero(x0(getX(d, i)));
                        }).y0(function (d, i) {
                            return nv.utils.NaNtoZero(y0(getY(d, i)));
                        }).y1(function (d, i) {
                            return y0(y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0]);
                        }).apply(this, [d.values]);
                    });
                    groups.exit().selectAll('path.nv-area').remove();
                    areaPaths.watchTransition(renderWatch, 'line: areaPaths').attr('d', function (d) {
                        return d3.svg.area().interpolate(interpolate).defined(defined).x(function (d, i) {
                            return nv.utils.NaNtoZero(x(getX(d, i)));
                        }).y0(function (d, i) {
                            return nv.utils.NaNtoZero(y(getY(d, i)));
                        }).y1(function (d, i) {
                            return y(y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0]);
                        }).apply(this, [d.values]);
                    });
                    var linePaths = groups.selectAll('path.nv-line').data(function (d) {
                        return [d.values];
                    });
                    linePaths.enter().append('path').attr('class', 'nv-line').attr('d', d3.svg.line().interpolate(interpolate).defined(defined).x(function (d, i) {
                        return nv.utils.NaNtoZero(x0(getX(d, i)));
                    }).y(function (d, i) {
                        return nv.utils.NaNtoZero(y0(getY(d, i)));
                    }));
                    linePaths.watchTransition(renderWatch, 'line: linePaths').attr('d', d3.svg.line().interpolate(interpolate).defined(defined).x(function (d, i) {
                        return nv.utils.NaNtoZero(x(getX(d, i)));
                    }).y(function (d, i) {
                        return nv.utils.NaNtoZero(y(getY(d, i)));
                    }));
                    x0 = x.copy();
                    y0 = y.copy();
                });
                renderWatch.renderEnd('line immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.scatter = scatter;
            scatter.dispatch.on('elementClick', function () {
                dispatch.elementClick.apply(this, arguments);
            });
            scatter.dispatch.on('elementMouseover', function () {
                dispatch.elementMouseover.apply(this, arguments);
            });
            scatter.dispatch.on('elementMouseout', function () {
                dispatch.elementMouseout.apply(this, arguments);
            });
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                defined: {
                    get: function () {
                        return defined;
                    },
                    set: function (_) {
                        defined = _;
                    }
                },
                interpolate: {
                    get: function () {
                        return interpolate;
                    },
                    set: function (_) {
                        interpolate = _;
                    }
                },
                clipEdge: {
                    get: function () {
                        return clipEdge;
                    },
                    set: function (_) {
                        clipEdge = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        scatter.duration(duration);
                    }
                },
                isArea: {
                    get: function () {
                        return isArea;
                    },
                    set: function (_) {
                        isArea = d3.functor(_);
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                        scatter.x(_);
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                        scatter.y(_);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        scatter.color(color);
                    }
                }
            });
            nv.utils.inheritOptions(chart, scatter);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.lineChart = function () {
            'use strict';
            var lines = nv.models.line(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), interactiveLayer = nv.interactiveGuideline(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 20,
                    bottom: 50,
                    left: 60
                }, color = nv.utils.defaultColor(), width = null, height = null, showLegend = true, showXAxis = true, showYAxis = true, rightAlignYAxis = false, useInteractiveGuideline = false, x, y, state = nv.utils.state(), defaultState = null, noData = null, dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd'), duration = 250;
            xAxis.orient('bottom').tickPadding(7);
            yAxis.orient(rightAlignYAxis ? 'right' : 'left');
            tooltip.valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            }).headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        })
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(lines);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        if (duration === 0)
                            container.call(chart);
                        else
                            container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = lines.xScale();
                    y = lines.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-lineChart').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineChart').append('g');
                    var g = wrap.select('g');
                    gEnter.append('rect').style('opacity', 0);
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis');
                    gEnter.append('g').attr('class', 'nv-linesWrap');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    gEnter.append('g').attr('class', 'nv-interactive');
                    g.select('rect').attr('width', availableWidth).attr('height', availableHeight > 0 ? availableHeight : 0);
                    if (showLegend) {
                        legend.width(availableWidth);
                        g.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        wrap.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    if (useInteractiveGuideline) {
                        interactiveLayer.width(availableWidth).height(availableHeight).margin({
                            left: margin.left,
                            top: margin.top
                        }).svgContainer(container).xScale(x);
                        wrap.select('.nv-interactive').call(interactiveLayer);
                    }
                    lines.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled;
                    }));
                    var linesWrap = g.select('.nv-linesWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    }));
                    linesWrap.call(lines);
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');
                        g.select('.nv-x.nv-axis').call(xAxis);
                    }
                    if (showYAxis) {
                        yAxis.scale(y)._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                        g.select('.nv-y.nv-axis').call(yAxis);
                    }
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    interactiveLayer.dispatch.on('elementMousemove', function (e) {
                        lines.clearHighlights();
                        var singlePoint, pointIndex, pointXLocation, allData = [];
                        data.filter(function (series, i) {
                            series.seriesIndex = i;
                            return !series.disabled;
                        }).forEach(function (series, i) {
                            pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                            var point = series.values[pointIndex];
                            var pointYValue = chart.y()(point, pointIndex);
                            if (pointYValue != null) {
                                lines.highlightPoint(i, pointIndex, true);
                            }
                            if (point === undefined)
                                return;
                            if (singlePoint === undefined)
                                singlePoint = point;
                            if (pointXLocation === undefined)
                                pointXLocation = chart.xScale()(chart.x()(point, pointIndex));
                            allData.push({
                                key: series.key,
                                value: pointYValue,
                                color: color(series, series.seriesIndex)
                            });
                        });
                        if (allData.length > 2) {
                            var yValue = chart.yScale().invert(e.mouseY);
                            var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                            var threshold = 0.03 * domainExtent;
                            var indexToHighlight = nv.nearestValueIndex(allData.map(function (d) {
                                return d.value;
                            }), yValue, threshold);
                            if (indexToHighlight !== null)
                                allData[indexToHighlight].highlight = true;
                        }
                        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex));
                        interactiveLayer.tooltip.chartContainer(that.parentNode).valueFormatter(function (d, i) {
                            return d == null ? 'N/A' : yAxis.tickFormat()(d);
                        }).data({
                            value: xValue,
                            index: pointIndex,
                            series: allData
                        })();
                        interactiveLayer.renderGuideLine(pointXLocation);
                    });
                    interactiveLayer.dispatch.on('elementClick', function (e) {
                        var pointXLocation, allData = [];
                        data.filter(function (series, i) {
                            series.seriesIndex = i;
                            return !series.disabled;
                        }).forEach(function (series) {
                            var pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                            var point = series.values[pointIndex];
                            if (typeof point === 'undefined')
                                return;
                            if (typeof pointXLocation === 'undefined')
                                pointXLocation = chart.xScale()(chart.x()(point, pointIndex));
                            var yPos = chart.yScale()(chart.y()(point, pointIndex));
                            allData.push({
                                point: point,
                                pointIndex: pointIndex,
                                pos: [
                                    pointXLocation,
                                    yPos
                                ],
                                seriesIndex: series.seriesIndex,
                                series: series
                            });
                        });
                        lines.dispatch.elementClick(allData);
                    });
                    interactiveLayer.dispatch.on('elementMouseout', function (e) {
                        lines.clearHighlights();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        chart.update();
                    });
                });
                renderWatch.renderEnd('lineChart immediate');
                return chart;
            }
            lines.dispatch.on('elementMouseover.tooltip', function (evt) {
                tooltip.data(evt).hidden(false);
            });
            lines.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            chart.dispatch = dispatch;
            chart.lines = lines;
            chart.legend = legend;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.interactiveLayer = interactiveLayer;
            chart.tooltip = tooltip;
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        lines.duration(duration);
                        xAxis.duration(duration);
                        yAxis.duration(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                        lines.color(color);
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(rightAlignYAxis ? 'right' : 'left');
                    }
                },
                useInteractiveGuideline: {
                    get: function () {
                        return useInteractiveGuideline;
                    },
                    set: function (_) {
                        useInteractiveGuideline = _;
                        if (useInteractiveGuideline) {
                            lines.interactive(false);
                            lines.useVoronoi(false);
                        }
                    }
                }
            });
            nv.utils.inheritOptions(chart, lines);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.linePlusBarChart = function () {
            'use strict';
            var lines = nv.models.line(), lines2 = nv.models.line(), bars = nv.models.historicalBar(), bars2 = nv.models.historicalBar(), xAxis = nv.models.axis(), x2Axis = nv.models.axis(), y1Axis = nv.models.axis(), y2Axis = nv.models.axis(), y3Axis = nv.models.axis(), y4Axis = nv.models.axis(), legend = nv.models.legend(), brush = d3.svg.brush(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 30,
                    bottom: 30,
                    left: 60
                }, margin2 = {
                    top: 0,
                    right: 30,
                    bottom: 20,
                    left: 60
                }, width = null, height = null, getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, color = nv.utils.defaultColor(), showLegend = true, focusEnable = true, focusShowAxisY = false, focusShowAxisX = true, focusHeight = 50, extent, brushExtent = null, x, x2, y1, y2, y3, y4, noData = null, dispatch = d3.dispatch('brush', 'stateChange', 'changeState'), transitionDuration = 0, state = nv.utils.state(), defaultState = null, legendLeftAxisHint = ' (left axis)', legendRightAxisHint = ' (right axis)';
            lines.clipEdge(true);
            lines2.interactive(false);
            lines2.pointActive(function (d) {
                return false;
            });
            xAxis.orient('bottom').tickPadding(5);
            y1Axis.orient('left');
            y2Axis.orient('right');
            x2Axis.orient('bottom').tickPadding(5);
            y3Axis.orient('left');
            y4Axis.orient('right');
            tooltip.headerEnabled(true).headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        })
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            var allDisabled = function (data) {
                return data.every(function (series) {
                    return series.disabled;
                });
            };
            function chart(selection) {
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight1 = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focusHeight : 0), availableHeight2 = focusHeight - margin2.top - margin2.bottom;
                    chart.update = function () {
                        container.transition().duration(transitionDuration).call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    var dataBars = data.filter(function (d) {
                        return !d.disabled && d.bar;
                    });
                    var dataLines = data.filter(function (d) {
                        return !d.bar;
                    });
                    x = bars.xScale();
                    x2 = x2Axis.scale();
                    y1 = bars.yScale();
                    y2 = lines.yScale();
                    y3 = bars2.yScale();
                    y4 = lines2.yScale();
                    var series1 = data.filter(function (d) {
                        return !d.disabled && d.bar;
                    }).map(function (d) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d, i),
                                y: getY(d, i)
                            };
                        });
                    });
                    var series2 = data.filter(function (d) {
                        return !d.disabled && !d.bar;
                    }).map(function (d) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d, i),
                                y: getY(d, i)
                            };
                        });
                    });
                    x.range([
                        0,
                        availableWidth
                    ]);
                    x2.domain(d3.extent(d3.merge(series1.concat(series2)), function (d) {
                        return d.x;
                    })).range([
                        0,
                        availableWidth
                    ]);
                    var wrap = container.selectAll('g.nv-wrap.nv-linePlusBar').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
                    focusEnter.append('g').attr('class', 'nv-x nv-axis');
                    focusEnter.append('g').attr('class', 'nv-y1 nv-axis');
                    focusEnter.append('g').attr('class', 'nv-y2 nv-axis');
                    focusEnter.append('g').attr('class', 'nv-barsWrap');
                    focusEnter.append('g').attr('class', 'nv-linesWrap');
                    var contextEnter = gEnter.append('g').attr('class', 'nv-context');
                    contextEnter.append('g').attr('class', 'nv-x nv-axis');
                    contextEnter.append('g').attr('class', 'nv-y1 nv-axis');
                    contextEnter.append('g').attr('class', 'nv-y2 nv-axis');
                    contextEnter.append('g').attr('class', 'nv-barsWrap');
                    contextEnter.append('g').attr('class', 'nv-linesWrap');
                    contextEnter.append('g').attr('class', 'nv-brushBackground');
                    contextEnter.append('g').attr('class', 'nv-x nv-brush');
                    if (showLegend) {
                        var legendWidth = legend.align() ? availableWidth / 2 : availableWidth;
                        var legendXPosition = legend.align() ? legendWidth : 0;
                        legend.width(legendWidth);
                        g.select('.nv-legendWrap').datum(data.map(function (series) {
                            series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                            series.key = series.originalKey + (series.bar ? legendLeftAxisHint : legendRightAxisHint);
                            return series;
                        })).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight1 = nv.utils.availableHeight(height, container, margin) - focusHeight;
                        }
                        g.select('.nv-legendWrap').attr('transform', 'translate(' + legendXPosition + ',' + -margin.top + ')');
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    g.select('.nv-context').style('display', focusEnable ? 'initial' : 'none');
                    bars2.width(availableWidth).height(availableHeight2).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled && data[i].bar;
                    }));
                    lines2.width(availableWidth).height(availableHeight2).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled && !data[i].bar;
                    }));
                    var bars2Wrap = g.select('.nv-context .nv-barsWrap').datum(dataBars.length ? dataBars : [{ values: [] }]);
                    var lines2Wrap = g.select('.nv-context .nv-linesWrap').datum(allDisabled(dataLines) ? [{ values: [] }] : dataLines.filter(function (dataLine) {
                        return !dataLine.disabled;
                    }));
                    g.select('.nv-context').attr('transform', 'translate(0,' + (availableHeight1 + margin.bottom + margin2.top) + ')');
                    bars2Wrap.transition().call(bars2);
                    lines2Wrap.transition().call(lines2);
                    if (focusShowAxisX) {
                        x2Axis._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight2, 0);
                        g.select('.nv-context .nv-x.nv-axis').attr('transform', 'translate(0,' + y3.range()[0] + ')');
                        g.select('.nv-context .nv-x.nv-axis').transition().call(x2Axis);
                    }
                    if (focusShowAxisY) {
                        y3Axis.scale(y3)._ticks(availableHeight2 / 36).tickSize(-availableWidth, 0);
                        y4Axis.scale(y4)._ticks(availableHeight2 / 36).tickSize(dataBars.length ? 0 : -availableWidth, 0);
                        g.select('.nv-context .nv-y3.nv-axis').style('opacity', dataBars.length ? 1 : 0).attr('transform', 'translate(0,' + x2.range()[0] + ')');
                        g.select('.nv-context .nv-y2.nv-axis').style('opacity', dataLines.length ? 1 : 0).attr('transform', 'translate(' + x2.range()[1] + ',0)');
                        g.select('.nv-context .nv-y1.nv-axis').transition().call(y3Axis);
                        g.select('.nv-context .nv-y2.nv-axis').transition().call(y4Axis);
                    }
                    brush.x(x2).on('brush', onBrush);
                    if (brushExtent)
                        brush.extent(brushExtent);
                    var brushBG = g.select('.nv-brushBackground').selectAll('g').data([brushExtent || brush.extent()]);
                    var brushBGenter = brushBG.enter().append('g');
                    brushBGenter.append('rect').attr('class', 'left').attr('x', 0).attr('y', 0).attr('height', availableHeight2);
                    brushBGenter.append('rect').attr('class', 'right').attr('x', 0).attr('y', 0).attr('height', availableHeight2);
                    var gBrush = g.select('.nv-x.nv-brush').call(brush);
                    gBrush.selectAll('rect').attr('height', availableHeight2);
                    gBrush.selectAll('.resize').append('path').attr('d', resizePath);
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        chart.update();
                    });
                    function resizePath(d) {
                        var e = +(d == 'e'), x = e ? 1 : -1, y = availableHeight2 / 3;
                        return 'M' + 0.5 * x + ',' + y + 'A6,6 0 0 ' + e + ' ' + 6.5 * x + ',' + (y + 6) + 'V' + (2 * y - 6) + 'A6,6 0 0 ' + e + ' ' + 0.5 * x + ',' + 2 * y + 'Z' + 'M' + 2.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8) + 'M' + 4.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8);
                    }
                    function updateBrushBG() {
                        if (!brush.empty())
                            brush.extent(brushExtent);
                        brushBG.data([brush.empty() ? x2.domain() : brushExtent]).each(function (d, i) {
                            var leftWidth = x2(d[0]) - x2.range()[0], rightWidth = x2.range()[1] - x2(d[1]);
                            d3.select(this).select('.left').attr('width', leftWidth < 0 ? 0 : leftWidth);
                            d3.select(this).select('.right').attr('x', x2(d[1])).attr('width', rightWidth < 0 ? 0 : rightWidth);
                        });
                    }
                    function onBrush() {
                        brushExtent = brush.empty() ? null : brush.extent();
                        extent = brush.empty() ? x2.domain() : brush.extent();
                        dispatch.brush({
                            extent: extent,
                            brush: brush
                        });
                        updateBrushBG();
                        bars.width(availableWidth).height(availableHeight1).color(data.map(function (d, i) {
                            return d.color || color(d, i);
                        }).filter(function (d, i) {
                            return !data[i].disabled && data[i].bar;
                        }));
                        lines.width(availableWidth).height(availableHeight1).color(data.map(function (d, i) {
                            return d.color || color(d, i);
                        }).filter(function (d, i) {
                            return !data[i].disabled && !data[i].bar;
                        }));
                        var focusBarsWrap = g.select('.nv-focus .nv-barsWrap').datum(!dataBars.length ? [{ values: [] }] : dataBars.map(function (d, i) {
                            return {
                                key: d.key,
                                values: d.values.filter(function (d, i) {
                                    return bars.x()(d, i) >= extent[0] && bars.x()(d, i) <= extent[1];
                                })
                            };
                        }));
                        var focusLinesWrap = g.select('.nv-focus .nv-linesWrap').datum(allDisabled(dataLines) ? [{ values: [] }] : dataLines.filter(function (dataLine) {
                            return !dataLine.disabled;
                        }).map(function (d, i) {
                            return {
                                area: d.area,
                                fillOpacity: d.fillOpacity,
                                key: d.key,
                                values: d.values.filter(function (d, i) {
                                    return lines.x()(d, i) >= extent[0] && lines.x()(d, i) <= extent[1];
                                })
                            };
                        }));
                        if (dataBars.length) {
                            x = bars.xScale();
                        } else {
                            x = lines.xScale();
                        }
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight1, 0);
                        xAxis.domain([
                            Math.ceil(extent[0]),
                            Math.floor(extent[1])
                        ]);
                        g.select('.nv-x.nv-axis').transition().duration(transitionDuration).call(xAxis);
                        focusBarsWrap.transition().duration(transitionDuration).call(bars);
                        focusLinesWrap.transition().duration(transitionDuration).call(lines);
                        g.select('.nv-focus .nv-x.nv-axis').attr('transform', 'translate(0,' + y1.range()[0] + ')');
                        y1Axis.scale(y1)._ticks(nv.utils.calcTicksY(availableHeight1 / 36, data)).tickSize(-availableWidth, 0);
                        y2Axis.scale(y2)._ticks(nv.utils.calcTicksY(availableHeight1 / 36, data)).tickSize(dataBars.length ? 0 : -availableWidth, 0);
                        g.select('.nv-focus .nv-y1.nv-axis').style('opacity', dataBars.length ? 1 : 0);
                        g.select('.nv-focus .nv-y2.nv-axis').style('opacity', dataLines.length && !allDisabled(dataLines) ? 1 : 0).attr('transform', 'translate(' + x.range()[1] + ',0)');
                        g.select('.nv-focus .nv-y1.nv-axis').transition().duration(transitionDuration).call(y1Axis);
                        g.select('.nv-focus .nv-y2.nv-axis').transition().duration(transitionDuration).call(y2Axis);
                    }
                    onBrush();
                });
                return chart;
            }
            lines.dispatch.on('elementMouseover.tooltip', function (evt) {
                tooltip.duration(100).valueFormatter(function (d, i) {
                    return y2Axis.tickFormat()(d, i);
                }).data(evt).hidden(false);
            });
            lines.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            bars.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt.value = chart.x()(evt.data);
                evt['series'] = {
                    value: chart.y()(evt.data),
                    color: evt.color
                };
                tooltip.duration(0).valueFormatter(function (d, i) {
                    return y1Axis.tickFormat()(d, i);
                }).data(evt).hidden(false);
            });
            bars.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            bars.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.dispatch = dispatch;
            chart.legend = legend;
            chart.lines = lines;
            chart.lines2 = lines2;
            chart.bars = bars;
            chart.bars2 = bars2;
            chart.xAxis = xAxis;
            chart.x2Axis = x2Axis;
            chart.y1Axis = y1Axis;
            chart.y2Axis = y2Axis;
            chart.y3Axis = y3Axis;
            chart.y4Axis = y4Axis;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                brushExtent: {
                    get: function () {
                        return brushExtent;
                    },
                    set: function (_) {
                        brushExtent = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                focusEnable: {
                    get: function () {
                        return focusEnable;
                    },
                    set: function (_) {
                        focusEnable = _;
                    }
                },
                focusHeight: {
                    get: function () {
                        return focusHeight;
                    },
                    set: function (_) {
                        focusHeight = _;
                    }
                },
                focusShowAxisX: {
                    get: function () {
                        return focusShowAxisX;
                    },
                    set: function (_) {
                        focusShowAxisX = _;
                    }
                },
                focusShowAxisY: {
                    get: function () {
                        return focusShowAxisY;
                    },
                    set: function (_) {
                        focusShowAxisY = _;
                    }
                },
                legendLeftAxisHint: {
                    get: function () {
                        return legendLeftAxisHint;
                    },
                    set: function (_) {
                        legendLeftAxisHint = _;
                    }
                },
                legendRightAxisHint: {
                    get: function () {
                        return legendRightAxisHint;
                    },
                    set: function (_) {
                        legendRightAxisHint = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                focusMargin: {
                    get: function () {
                        return margin2;
                    },
                    set: function (_) {
                        margin2.top = _.top !== undefined ? _.top : margin2.top;
                        margin2.right = _.right !== undefined ? _.right : margin2.right;
                        margin2.bottom = _.bottom !== undefined ? _.bottom : margin2.bottom;
                        margin2.left = _.left !== undefined ? _.left : margin2.left;
                    }
                },
                duration: {
                    get: function () {
                        return transitionDuration;
                    },
                    set: function (_) {
                        transitionDuration = _;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                        lines.x(_);
                        lines2.x(_);
                        bars.x(_);
                        bars2.x(_);
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                        lines.y(_);
                        lines2.y(_);
                        bars.y(_);
                        bars2.y(_);
                    }
                }
            });
            nv.utils.inheritOptions(chart, lines);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.lineWithFocusChart = function () {
            'use strict';
            var lines = nv.models.line(), lines2 = nv.models.line(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), x2Axis = nv.models.axis(), y2Axis = nv.models.axis(), legend = nv.models.legend(), brush = d3.svg.brush(), tooltip = nv.models.tooltip(), interactiveLayer = nv.interactiveGuideline();
            var margin = {
                    top: 30,
                    right: 30,
                    bottom: 30,
                    left: 60
                }, margin2 = {
                    top: 0,
                    right: 30,
                    bottom: 20,
                    left: 60
                }, color = nv.utils.defaultColor(), width = null, height = null, height2 = 50, useInteractiveGuideline = false, x, y, x2, y2, showLegend = true, brushExtent = null, noData = null, dispatch = d3.dispatch('brush', 'stateChange', 'changeState'), transitionDuration = 250, state = nv.utils.state(), defaultState = null;
            lines.clipEdge(true).duration(0);
            lines2.interactive(false);
            lines2.pointActive(function (d) {
                return false;
            });
            xAxis.orient('bottom').tickPadding(5);
            yAxis.orient('left');
            x2Axis.orient('bottom').tickPadding(5);
            y2Axis.orient('left');
            tooltip.valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            }).headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        })
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            function chart(selection) {
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight1 = nv.utils.availableHeight(height, container, margin) - height2, availableHeight2 = height2 - margin2.top - margin2.bottom;
                    chart.update = function () {
                        container.transition().duration(transitionDuration).call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = lines.xScale();
                    y = lines.yScale();
                    x2 = lines2.xScale();
                    y2 = lines2.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-lineWithFocusChart').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineWithFocusChart').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
                    focusEnter.append('g').attr('class', 'nv-x nv-axis');
                    focusEnter.append('g').attr('class', 'nv-y nv-axis');
                    focusEnter.append('g').attr('class', 'nv-linesWrap');
                    focusEnter.append('g').attr('class', 'nv-interactive');
                    var contextEnter = gEnter.append('g').attr('class', 'nv-context');
                    contextEnter.append('g').attr('class', 'nv-x nv-axis');
                    contextEnter.append('g').attr('class', 'nv-y nv-axis');
                    contextEnter.append('g').attr('class', 'nv-linesWrap');
                    contextEnter.append('g').attr('class', 'nv-brushBackground');
                    contextEnter.append('g').attr('class', 'nv-x nv-brush');
                    if (showLegend) {
                        legend.width(availableWidth);
                        g.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight1 = nv.utils.availableHeight(height, container, margin) - height2;
                        }
                        g.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (useInteractiveGuideline) {
                        interactiveLayer.width(availableWidth).height(availableHeight1).margin({
                            left: margin.left,
                            top: margin.top
                        }).svgContainer(container).xScale(x);
                        wrap.select('.nv-interactive').call(interactiveLayer);
                    }
                    lines.width(availableWidth).height(availableHeight1).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled;
                    }));
                    lines2.defined(lines.defined()).width(availableWidth).height(availableHeight2).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled;
                    }));
                    g.select('.nv-context').attr('transform', 'translate(0,' + (availableHeight1 + margin.bottom + margin2.top) + ')');
                    var contextLinesWrap = g.select('.nv-context .nv-linesWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    }));
                    d3.transition(contextLinesWrap).call(lines2);
                    xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight1, 0);
                    yAxis.scale(y)._ticks(nv.utils.calcTicksY(availableHeight1 / 36, data)).tickSize(-availableWidth, 0);
                    g.select('.nv-focus .nv-x.nv-axis').attr('transform', 'translate(0,' + availableHeight1 + ')');
                    brush.x(x2).on('brush', function () {
                        onBrush();
                    });
                    if (brushExtent)
                        brush.extent(brushExtent);
                    var brushBG = g.select('.nv-brushBackground').selectAll('g').data([brushExtent || brush.extent()]);
                    var brushBGenter = brushBG.enter().append('g');
                    brushBGenter.append('rect').attr('class', 'left').attr('x', 0).attr('y', 0).attr('height', availableHeight2);
                    brushBGenter.append('rect').attr('class', 'right').attr('x', 0).attr('y', 0).attr('height', availableHeight2);
                    var gBrush = g.select('.nv-x.nv-brush').call(brush);
                    gBrush.selectAll('rect').attr('height', availableHeight2);
                    gBrush.selectAll('.resize').append('path').attr('d', resizePath);
                    onBrush();
                    x2Axis.scale(x2)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight2, 0);
                    g.select('.nv-context .nv-x.nv-axis').attr('transform', 'translate(0,' + y2.range()[0] + ')');
                    d3.transition(g.select('.nv-context .nv-x.nv-axis')).call(x2Axis);
                    y2Axis.scale(y2)._ticks(nv.utils.calcTicksY(availableHeight2 / 36, data)).tickSize(-availableWidth, 0);
                    d3.transition(g.select('.nv-context .nv-y.nv-axis')).call(y2Axis);
                    g.select('.nv-context .nv-x.nv-axis').attr('transform', 'translate(0,' + y2.range()[0] + ')');
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    interactiveLayer.dispatch.on('elementMousemove', function (e) {
                        lines.clearHighlights();
                        var singlePoint, pointIndex, pointXLocation, allData = [];
                        data.filter(function (series, i) {
                            series.seriesIndex = i;
                            return !series.disabled;
                        }).forEach(function (series, i) {
                            var extent = brush.empty() ? x2.domain() : brush.extent();
                            var currentValues = series.values.filter(function (d, i) {
                                return lines.x()(d, i) >= extent[0] && lines.x()(d, i) <= extent[1];
                            });
                            pointIndex = nv.interactiveBisect(currentValues, e.pointXValue, lines.x());
                            var point = currentValues[pointIndex];
                            var pointYValue = chart.y()(point, pointIndex);
                            if (pointYValue != null) {
                                lines.highlightPoint(i, pointIndex, true);
                            }
                            if (point === undefined)
                                return;
                            if (singlePoint === undefined)
                                singlePoint = point;
                            if (pointXLocation === undefined)
                                pointXLocation = chart.xScale()(chart.x()(point, pointIndex));
                            allData.push({
                                key: series.key,
                                value: chart.y()(point, pointIndex),
                                color: color(series, series.seriesIndex)
                            });
                        });
                        if (allData.length > 2) {
                            var yValue = chart.yScale().invert(e.mouseY);
                            var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                            var threshold = 0.03 * domainExtent;
                            var indexToHighlight = nv.nearestValueIndex(allData.map(function (d) {
                                return d.value;
                            }), yValue, threshold);
                            if (indexToHighlight !== null)
                                allData[indexToHighlight].highlight = true;
                        }
                        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex));
                        interactiveLayer.tooltip.chartContainer(that.parentNode).valueFormatter(function (d, i) {
                            return d == null ? 'N/A' : yAxis.tickFormat()(d);
                        }).data({
                            value: xValue,
                            index: pointIndex,
                            series: allData
                        })();
                        interactiveLayer.renderGuideLine(pointXLocation);
                    });
                    interactiveLayer.dispatch.on('elementMouseout', function (e) {
                        lines.clearHighlights();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                        }
                        chart.update();
                    });
                    function resizePath(d) {
                        var e = +(d == 'e'), x = e ? 1 : -1, y = availableHeight2 / 3;
                        return 'M' + 0.5 * x + ',' + y + 'A6,6 0 0 ' + e + ' ' + 6.5 * x + ',' + (y + 6) + 'V' + (2 * y - 6) + 'A6,6 0 0 ' + e + ' ' + 0.5 * x + ',' + 2 * y + 'Z' + 'M' + 2.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8) + 'M' + 4.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8);
                    }
                    function updateBrushBG() {
                        if (!brush.empty())
                            brush.extent(brushExtent);
                        brushBG.data([brush.empty() ? x2.domain() : brushExtent]).each(function (d, i) {
                            var leftWidth = x2(d[0]) - x.range()[0], rightWidth = availableWidth - x2(d[1]);
                            d3.select(this).select('.left').attr('width', leftWidth < 0 ? 0 : leftWidth);
                            d3.select(this).select('.right').attr('x', x2(d[1])).attr('width', rightWidth < 0 ? 0 : rightWidth);
                        });
                    }
                    function onBrush() {
                        brushExtent = brush.empty() ? null : brush.extent();
                        var extent = brush.empty() ? x2.domain() : brush.extent();
                        if (Math.abs(extent[0] - extent[1]) <= 1) {
                            return;
                        }
                        dispatch.brush({
                            extent: extent,
                            brush: brush
                        });
                        updateBrushBG();
                        var focusLinesWrap = g.select('.nv-focus .nv-linesWrap').datum(data.filter(function (d) {
                            return !d.disabled;
                        }).map(function (d, i) {
                            return {
                                key: d.key,
                                area: d.area,
                                classed: d.classed,
                                values: d.values.filter(function (d, i) {
                                    return lines.x()(d, i) >= extent[0] && lines.x()(d, i) <= extent[1];
                                })
                            };
                        }));
                        focusLinesWrap.transition().duration(transitionDuration).call(lines);
                        g.select('.nv-focus .nv-x.nv-axis').transition().duration(transitionDuration).call(xAxis);
                        g.select('.nv-focus .nv-y.nv-axis').transition().duration(transitionDuration).call(yAxis);
                    }
                });
                return chart;
            }
            lines.dispatch.on('elementMouseover.tooltip', function (evt) {
                tooltip.data(evt).hidden(false);
            });
            lines.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            chart.dispatch = dispatch;
            chart.legend = legend;
            chart.lines = lines;
            chart.lines2 = lines2;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.x2Axis = x2Axis;
            chart.y2Axis = y2Axis;
            chart.interactiveLayer = interactiveLayer;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                focusHeight: {
                    get: function () {
                        return height2;
                    },
                    set: function (_) {
                        height2 = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                brushExtent: {
                    get: function () {
                        return brushExtent;
                    },
                    set: function (_) {
                        brushExtent = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                focusMargin: {
                    get: function () {
                        return margin2;
                    },
                    set: function (_) {
                        margin2.top = _.top !== undefined ? _.top : margin2.top;
                        margin2.right = _.right !== undefined ? _.right : margin2.right;
                        margin2.bottom = _.bottom !== undefined ? _.bottom : margin2.bottom;
                        margin2.left = _.left !== undefined ? _.left : margin2.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                    }
                },
                interpolate: {
                    get: function () {
                        return lines.interpolate();
                    },
                    set: function (_) {
                        lines.interpolate(_);
                        lines2.interpolate(_);
                    }
                },
                xTickFormat: {
                    get: function () {
                        return xAxis.tickFormat();
                    },
                    set: function (_) {
                        xAxis.tickFormat(_);
                        x2Axis.tickFormat(_);
                    }
                },
                yTickFormat: {
                    get: function () {
                        return yAxis.tickFormat();
                    },
                    set: function (_) {
                        yAxis.tickFormat(_);
                        y2Axis.tickFormat(_);
                    }
                },
                duration: {
                    get: function () {
                        return transitionDuration;
                    },
                    set: function (_) {
                        transitionDuration = _;
                        yAxis.duration(transitionDuration);
                        y2Axis.duration(transitionDuration);
                        xAxis.duration(transitionDuration);
                        x2Axis.duration(transitionDuration);
                    }
                },
                x: {
                    get: function () {
                        return lines.x();
                    },
                    set: function (_) {
                        lines.x(_);
                        lines2.x(_);
                    }
                },
                y: {
                    get: function () {
                        return lines.y();
                    },
                    set: function (_) {
                        lines.y(_);
                        lines2.y(_);
                    }
                },
                useInteractiveGuideline: {
                    get: function () {
                        return useInteractiveGuideline;
                    },
                    set: function (_) {
                        useInteractiveGuideline = _;
                        if (useInteractiveGuideline) {
                            lines.interactive(false);
                            lines.useVoronoi(false);
                        }
                    }
                }
            });
            nv.utils.inheritOptions(chart, lines);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.multiBar = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 960, height = 500, x = d3.scale.ordinal(), y = d3.scale.linear(), id = Math.floor(Math.random() * 10000), container = null, getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, forceY = [0], clipEdge = true, stacked = false, stackOffset = 'zero', color = nv.utils.defaultColor(), hideable = false, barColor = null, disabled, duration = 500, xDomain, yDomain, xRange, yRange, groupSpacing = 0.1, dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd');
            var x0, y0, renderWatch = nv.utils.renderWatch(dispatch, duration);
            var last_datalength = 0;
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    var nonStackableCount = 0;
                    var endFn = function (d, i) {
                        if (d.series === data.length - 1 && i === data[0].values.length - 1)
                            return true;
                        return false;
                    };
                    if (hideable && data.length)
                        hideable = [{
                                values: data[0].values.map(function (d) {
                                    return {
                                        x: d.x,
                                        y: 0,
                                        series: d.series,
                                        size: 0.01
                                    };
                                })
                            }];
                    if (stacked) {
                        var parsed = d3.layout.stack().offset(stackOffset).values(function (d) {
                            return d.values;
                        }).y(getY)(!data.length && hideable ? hideable : data);
                        parsed.forEach(function (series, i) {
                            if (series.nonStackable) {
                                data[i].nonStackableSeries = nonStackableCount++;
                                parsed[i] = data[i];
                            } else {
                                if (i > 0 && parsed[i - 1].nonStackable) {
                                    parsed[i].values.map(function (d, j) {
                                        d.y0 -= parsed[i - 1].values[j].y;
                                        d.y1 = d.y0 + d.y;
                                    });
                                }
                            }
                        });
                        data = parsed;
                    }
                    data.forEach(function (series, i) {
                        series.values.forEach(function (point) {
                            point.series = i;
                            point.key = series.key;
                        });
                    });
                    if (stacked) {
                        data[0].values.map(function (d, i) {
                            var posBase = 0, negBase = 0;
                            data.map(function (d, idx) {
                                if (!data[idx].nonStackable) {
                                    var f = d.values[i];
                                    f.size = Math.abs(f.y);
                                    if (f.y < 0) {
                                        f.y1 = negBase;
                                        negBase = negBase - f.size;
                                    } else {
                                        f.y1 = f.size + posBase;
                                        posBase = posBase + f.size;
                                    }
                                }
                            });
                        });
                    }
                    var seriesData = xDomain && yDomain ? [] : data.map(function (d, idx) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d, i),
                                y: getY(d, i),
                                y0: d.y0,
                                y1: d.y1,
                                idx: idx
                            };
                        });
                    });
                    x.domain(xDomain || d3.merge(seriesData).map(function (d) {
                        return d.x;
                    })).rangeBands(xRange || [
                        0,
                        availableWidth
                    ], groupSpacing);
                    y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function (d) {
                        var domain = d.y;
                        if (stacked && !data[d.idx].nonStackable) {
                            if (d.y > 0) {
                                domain = d.y1;
                            } else {
                                domain = d.y1 + d.y;
                            }
                        }
                        return domain;
                    }).concat(forceY))).range(yRange || [
                        availableHeight,
                        0
                    ]);
                    if (x.domain()[0] === x.domain()[1])
                        x.domain()[0] ? x.domain([
                            x.domain()[0] - x.domain()[0] * 0.01,
                            x.domain()[1] + x.domain()[1] * 0.01
                        ]) : x.domain([
                            -1,
                            1
                        ]);
                    if (y.domain()[0] === y.domain()[1])
                        y.domain()[0] ? y.domain([
                            y.domain()[0] + y.domain()[0] * 0.01,
                            y.domain()[1] - y.domain()[1] * 0.01
                        ]) : y.domain([
                            -1,
                            1
                        ]);
                    x0 = x0 || x;
                    y0 = y0 || y;
                    var wrap = container.selectAll('g.nv-wrap.nv-multibar').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibar');
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-groups');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + id).append('rect');
                    wrap.select('#nv-edge-clip-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);
                    g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');
                    var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {
                        return d;
                    }, function (d, i) {
                        return i;
                    });
                    groups.enter().append('g').style('stroke-opacity', 0.000001).style('fill-opacity', 0.000001);
                    var exitTransition = renderWatch.transition(groups.exit().selectAll('rect.nv-bar'), 'multibarExit', Math.min(100, duration)).attr('y', function (d, i, j) {
                        var yVal = y0(0) || 0;
                        if (stacked) {
                            if (data[d.series] && !data[d.series].nonStackable) {
                                yVal = y0(d.y0);
                            }
                        }
                        return yVal;
                    }).attr('height', 0).remove();
                    if (exitTransition.delay)
                        exitTransition.delay(function (d, i) {
                            var delay = i * (duration / (last_datalength + 1)) - i;
                            return delay;
                        });
                    groups.attr('class', function (d, i) {
                        return 'nv-group nv-series-' + i;
                    }).classed('hover', function (d) {
                        return d.hover;
                    }).style('fill', function (d, i) {
                        return color(d, i);
                    }).style('stroke', function (d, i) {
                        return color(d, i);
                    });
                    groups.style('stroke-opacity', 1).style('fill-opacity', 0.75);
                    var bars = groups.selectAll('rect.nv-bar').data(function (d) {
                        return hideable && !data.length ? hideable.values : d.values;
                    });
                    bars.exit().remove();
                    var barsEnter = bars.enter().append('rect').attr('class', function (d, i) {
                        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';
                    }).attr('x', function (d, i, j) {
                        return stacked && !data[j].nonStackable ? 0 : j * x.rangeBand() / data.length;
                    }).attr('y', function (d, i, j) {
                        return y0(stacked && !data[j].nonStackable ? d.y0 : 0) || 0;
                    }).attr('height', 0).attr('width', function (d, i, j) {
                        return x.rangeBand() / (stacked && !data[j].nonStackable ? 1 : data.length);
                    }).attr('transform', function (d, i) {
                        return 'translate(' + x(getX(d, i)) + ',0)';
                    });
                    bars.style('fill', function (d, i, j) {
                        return color(d, j, i);
                    }).style('stroke', function (d, i, j) {
                        return color(d, j, i);
                    }).on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mousemove', function (d, i) {
                        dispatch.elementMousemove({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('click', function (d, i) {
                        dispatch.elementClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    }).on('dblclick', function (d, i) {
                        dispatch.elementDblClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    });
                    bars.attr('class', function (d, i) {
                        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';
                    }).attr('transform', function (d, i) {
                        return 'translate(' + x(getX(d, i)) + ',0)';
                    });
                    if (barColor) {
                        if (!disabled)
                            disabled = data.map(function () {
                                return true;
                            });
                        bars.style('fill', function (d, i, j) {
                            return d3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {
                                return i;
                            }).filter(function (d, i) {
                                return !disabled[i];
                            })[j]).toString();
                        }).style('stroke', function (d, i, j) {
                            return d3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {
                                return i;
                            }).filter(function (d, i) {
                                return !disabled[i];
                            })[j]).toString();
                        });
                    }
                    var barSelection = bars.watchTransition(renderWatch, 'multibar', Math.min(250, duration)).delay(function (d, i) {
                        return i * duration / data[0].values.length;
                    });
                    if (stacked) {
                        barSelection.attr('y', function (d, i, j) {
                            var yVal = 0;
                            if (!data[j].nonStackable) {
                                yVal = y(d.y1);
                            } else {
                                if (getY(d, i) < 0) {
                                    yVal = y(0);
                                } else {
                                    if (y(0) - y(getY(d, i)) < -1) {
                                        yVal = y(0) - 1;
                                    } else {
                                        yVal = y(getY(d, i)) || 0;
                                    }
                                }
                            }
                            return yVal;
                        }).attr('height', function (d, i, j) {
                            if (!data[j].nonStackable) {
                                return Math.max(Math.abs(y(d.y + d.y0) - y(d.y0)), 0);
                            } else {
                                return Math.max(Math.abs(y(getY(d, i)) - y(0)), 0) || 0;
                            }
                        }).attr('x', function (d, i, j) {
                            var width = 0;
                            if (data[j].nonStackable) {
                                width = d.series * x.rangeBand() / data.length;
                                if (data.length !== nonStackableCount) {
                                    width = data[j].nonStackableSeries * x.rangeBand() / (nonStackableCount * 2);
                                }
                            }
                            return width;
                        }).attr('width', function (d, i, j) {
                            if (!data[j].nonStackable) {
                                return x.rangeBand();
                            } else {
                                var width = x.rangeBand() / nonStackableCount;
                                if (data.length !== nonStackableCount) {
                                    width = x.rangeBand() / (nonStackableCount * 2);
                                }
                                return width;
                            }
                        });
                    } else {
                        barSelection.attr('x', function (d, i) {
                            return d.series * x.rangeBand() / data.length;
                        }).attr('width', x.rangeBand() / data.length).attr('y', function (d, i) {
                            return getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i)) || 0;
                        }).attr('height', function (d, i) {
                            return Math.max(Math.abs(y(getY(d, i)) - y(0)), 1) || 0;
                        });
                    }
                    x0 = x.copy();
                    y0 = y.copy();
                    if (data[0] && data[0].values) {
                        last_datalength = data[0].values.length;
                    }
                });
                renderWatch.renderEnd('multibar immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                forceY: {
                    get: function () {
                        return forceY;
                    },
                    set: function (_) {
                        forceY = _;
                    }
                },
                stacked: {
                    get: function () {
                        return stacked;
                    },
                    set: function (_) {
                        stacked = _;
                    }
                },
                stackOffset: {
                    get: function () {
                        return stackOffset;
                    },
                    set: function (_) {
                        stackOffset = _;
                    }
                },
                clipEdge: {
                    get: function () {
                        return clipEdge;
                    },
                    set: function (_) {
                        clipEdge = _;
                    }
                },
                disabled: {
                    get: function () {
                        return disabled;
                    },
                    set: function (_) {
                        disabled = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                hideable: {
                    get: function () {
                        return hideable;
                    },
                    set: function (_) {
                        hideable = _;
                    }
                },
                groupSpacing: {
                    get: function () {
                        return groupSpacing;
                    },
                    set: function (_) {
                        groupSpacing = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                barColor: {
                    get: function () {
                        return barColor;
                    },
                    set: function (_) {
                        barColor = _ ? nv.utils.getColor(_) : null;
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.multiBarChart = function () {
            'use strict';
            var multibar = nv.models.multiBar(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 20,
                    bottom: 50,
                    left: 60
                }, width = null, height = null, color = nv.utils.defaultColor(), showControls = true, controlLabels = {}, showLegend = true, showXAxis = true, showYAxis = true, rightAlignYAxis = false, reduceXTicks = true, staggerLabels = false, wrapLabels = false, rotateLabels = 0, x, y, state = nv.utils.state(), defaultState = null, noData = null, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd'), controlWidth = function () {
                    return showControls ? 180 : 0;
                }, duration = 250;
            state.stacked = false;
            multibar.stacked(false);
            xAxis.orient('bottom').tickPadding(7).showMaxMin(false).tickFormat(function (d) {
                return d;
            });
            yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickFormat(d3.format(',.1f'));
            tooltip.duration(0).valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            }).headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            controls.updateState(false);
            var renderWatch = nv.utils.renderWatch(dispatch);
            var stacked = false;
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        }),
                        stacked: stacked
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.stacked !== undefined)
                        stacked = state.stacked;
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(multibar);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        if (duration === 0)
                            container.call(chart);
                        else
                            container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = multibar.xScale();
                    y = multibar.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis');
                    gEnter.append('g').attr('class', 'nv-barsWrap');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    gEnter.append('g').attr('class', 'nv-controlsWrap');
                    if (showLegend) {
                        legend.width(availableWidth - controlWidth());
                        g.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        g.select('.nv-legendWrap').attr('transform', 'translate(' + controlWidth() + ',' + -margin.top + ')');
                    }
                    if (showControls) {
                        var controlsData = [
                            {
                                key: controlLabels.grouped || 'Grouped',
                                disabled: multibar.stacked()
                            },
                            {
                                key: controlLabels.stacked || 'Stacked',
                                disabled: !multibar.stacked()
                            }
                        ];
                        controls.width(controlWidth()).color([
                            '#444',
                            '#444',
                            '#444'
                        ]);
                        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    multibar.disabled(data.map(function (series) {
                        return series.disabled;
                    })).width(availableWidth).height(availableHeight).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled;
                    }));
                    var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    }));
                    barsWrap.call(multibar);
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');
                        g.select('.nv-x.nv-axis').call(xAxis);
                        var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');
                        xTicks.selectAll('line, text').style('opacity', 1);
                        if (staggerLabels) {
                            var getTranslate = function (x, y) {
                                return 'translate(' + x + ',' + y + ')';
                            };
                            var staggerUp = 5, staggerDown = 17;
                            xTicks.selectAll('text').attr('transform', function (d, i, j) {
                                return getTranslate(0, j % 2 == 0 ? staggerUp : staggerDown);
                            });
                            var totalInBetweenTicks = d3.selectAll('.nv-x.nv-axis .nv-wrap g g text')[0].length;
                            g.selectAll('.nv-x.nv-axis .nv-axisMaxMin text').attr('transform', function (d, i) {
                                return getTranslate(0, i === 0 || totalInBetweenTicks % 2 !== 0 ? staggerDown : staggerUp);
                            });
                        }
                        if (wrapLabels) {
                            g.selectAll('.tick text').call(nv.utils.wrapTicks, chart.xAxis.rangeBand());
                        }
                        if (reduceXTicks)
                            xTicks.filter(function (d, i) {
                                return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
                            }).selectAll('text, line').style('opacity', 0);
                        if (rotateLabels)
                            xTicks.selectAll('.tick text').attr('transform', 'rotate(' + rotateLabels + ' 0,0)').style('text-anchor', rotateLabels > 0 ? 'start' : 'end');
                        g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text').style('opacity', 1);
                    }
                    if (showYAxis) {
                        yAxis.scale(y)._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                        g.select('.nv-y.nv-axis').call(yAxis);
                    }
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    controls.dispatch.on('legendClick', function (d, i) {
                        if (!d.disabled)
                            return;
                        controlsData = controlsData.map(function (s) {
                            s.disabled = true;
                            return s;
                        });
                        d.disabled = false;
                        switch (d.key) {
                        case 'Grouped':
                        case controlLabels.grouped:
                            multibar.stacked(false);
                            break;
                        case 'Stacked':
                        case controlLabels.stacked:
                            multibar.stacked(true);
                            break;
                        }
                        state.stacked = multibar.stacked();
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        if (typeof e.stacked !== 'undefined') {
                            multibar.stacked(e.stacked);
                            state.stacked = e.stacked;
                            stacked = e.stacked;
                        }
                        chart.update();
                    });
                });
                renderWatch.renderEnd('multibarchart immediate');
                return chart;
            }
            multibar.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt.value = chart.x()(evt.data);
                evt['series'] = {
                    key: evt.data.key,
                    value: chart.y()(evt.data),
                    color: evt.color
                };
                tooltip.data(evt).hidden(false);
            });
            multibar.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            multibar.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.dispatch = dispatch;
            chart.multibar = multibar;
            chart.legend = legend;
            chart.controls = controls;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.state = state;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                showControls: {
                    get: function () {
                        return showControls;
                    },
                    set: function (_) {
                        showControls = _;
                    }
                },
                controlLabels: {
                    get: function () {
                        return controlLabels;
                    },
                    set: function (_) {
                        controlLabels = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                reduceXTicks: {
                    get: function () {
                        return reduceXTicks;
                    },
                    set: function (_) {
                        reduceXTicks = _;
                    }
                },
                rotateLabels: {
                    get: function () {
                        return rotateLabels;
                    },
                    set: function (_) {
                        rotateLabels = _;
                    }
                },
                staggerLabels: {
                    get: function () {
                        return staggerLabels;
                    },
                    set: function (_) {
                        staggerLabels = _;
                    }
                },
                wrapLabels: {
                    get: function () {
                        return wrapLabels;
                    },
                    set: function (_) {
                        wrapLabels = !!_;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        multibar.duration(duration);
                        xAxis.duration(duration);
                        yAxis.duration(duration);
                        renderWatch.reset(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(rightAlignYAxis ? 'right' : 'left');
                    }
                },
                barColor: {
                    get: function () {
                        return multibar.barColor;
                    },
                    set: function (_) {
                        multibar.barColor(_);
                        legend.color(function (d, i) {
                            return d3.rgb('#ccc').darker(i * 1.5).toString();
                        });
                    }
                }
            });
            nv.utils.inheritOptions(chart, multibar);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.multiBarHorizontal = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 960, height = 500, id = Math.floor(Math.random() * 10000), container = null, x = d3.scale.ordinal(), y = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, getYerr = function (d) {
                    return d.yErr;
                }, forceY = [0], color = nv.utils.defaultColor(), barColor = null, disabled, stacked = false, showValues = false, showBarLabels = false, valuePadding = 60, groupSpacing = 0.1, valueFormat = d3.format(',.2f'), delay = 1200, xDomain, yDomain, xRange, yRange, duration = 250, dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd');
            var x0, y0;
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    if (stacked)
                        data = d3.layout.stack().offset('zero').values(function (d) {
                            return d.values;
                        }).y(getY)(data);
                    data.forEach(function (series, i) {
                        series.values.forEach(function (point) {
                            point.series = i;
                            point.key = series.key;
                        });
                    });
                    if (stacked)
                        data[0].values.map(function (d, i) {
                            var posBase = 0, negBase = 0;
                            data.map(function (d) {
                                var f = d.values[i];
                                f.size = Math.abs(f.y);
                                if (f.y < 0) {
                                    f.y1 = negBase - f.size;
                                    negBase = negBase - f.size;
                                } else {
                                    f.y1 = posBase;
                                    posBase = posBase + f.size;
                                }
                            });
                        });
                    var seriesData = xDomain && yDomain ? [] : data.map(function (d) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d, i),
                                y: getY(d, i),
                                y0: d.y0,
                                y1: d.y1
                            };
                        });
                    });
                    x.domain(xDomain || d3.merge(seriesData).map(function (d) {
                        return d.x;
                    })).rangeBands(xRange || [
                        0,
                        availableHeight
                    ], groupSpacing);
                    y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function (d) {
                        return stacked ? d.y > 0 ? d.y1 + d.y : d.y1 : d.y;
                    }).concat(forceY)));
                    if (showValues && !stacked)
                        y.range(yRange || [
                            y.domain()[0] < 0 ? valuePadding : 0,
                            availableWidth - (y.domain()[1] > 0 ? valuePadding : 0)
                        ]);
                    else
                        y.range(yRange || [
                            0,
                            availableWidth
                        ]);
                    x0 = x0 || x;
                    y0 = y0 || d3.scale.linear().domain(y.domain()).range([
                        y(0),
                        y(0)
                    ]);
                    var wrap = d3.select(this).selectAll('g.nv-wrap.nv-multibarHorizontal').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibarHorizontal');
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-groups');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {
                        return d;
                    }, function (d, i) {
                        return i;
                    });
                    groups.enter().append('g').style('stroke-opacity', 0.000001).style('fill-opacity', 0.000001);
                    groups.exit().watchTransition(renderWatch, 'multibarhorizontal: exit groups').style('stroke-opacity', 0.000001).style('fill-opacity', 0.000001).remove();
                    groups.attr('class', function (d, i) {
                        return 'nv-group nv-series-' + i;
                    }).classed('hover', function (d) {
                        return d.hover;
                    }).style('fill', function (d, i) {
                        return color(d, i);
                    }).style('stroke', function (d, i) {
                        return color(d, i);
                    });
                    groups.watchTransition(renderWatch, 'multibarhorizontal: groups').style('stroke-opacity', 1).style('fill-opacity', 0.75);
                    var bars = groups.selectAll('g.nv-bar').data(function (d) {
                        return d.values;
                    });
                    bars.exit().remove();
                    var barsEnter = bars.enter().append('g').attr('transform', function (d, i, j) {
                        return 'translate(' + y0(stacked ? d.y0 : 0) + ',' + (stacked ? 0 : j * x.rangeBand() / data.length + x(getX(d, i))) + ')';
                    });
                    barsEnter.append('rect').attr('width', 0).attr('height', x.rangeBand() / (stacked ? 1 : data.length));
                    bars.on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        dispatch.elementMouseout({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mousemove', function (d, i) {
                        dispatch.elementMousemove({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    }).on('click', function (d, i) {
                        dispatch.elementClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    }).on('dblclick', function (d, i) {
                        dispatch.elementDblClick({
                            data: d,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                        d3.event.stopPropagation();
                    });
                    if (getYerr(data[0], 0)) {
                        barsEnter.append('polyline');
                        bars.select('polyline').attr('fill', 'none').attr('points', function (d, i) {
                            var xerr = getYerr(d, i), mid = 0.8 * x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                            xerr = xerr.length ? xerr : [
                                -Math.abs(xerr),
                                Math.abs(xerr)
                            ];
                            xerr = xerr.map(function (e) {
                                return y(e) - y(0);
                            });
                            var a = [
                                [
                                    xerr[0],
                                    -mid
                                ],
                                [
                                    xerr[0],
                                    mid
                                ],
                                [
                                    xerr[0],
                                    0
                                ],
                                [
                                    xerr[1],
                                    0
                                ],
                                [
                                    xerr[1],
                                    -mid
                                ],
                                [
                                    xerr[1],
                                    mid
                                ]
                            ];
                            return a.map(function (path) {
                                return path.join(',');
                            }).join(' ');
                        }).attr('transform', function (d, i) {
                            var mid = x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                            return 'translate(' + (getY(d, i) < 0 ? 0 : y(getY(d, i)) - y(0)) + ', ' + mid + ')';
                        });
                    }
                    barsEnter.append('text');
                    if (showValues && !stacked) {
                        bars.select('text').attr('text-anchor', function (d, i) {
                            return getY(d, i) < 0 ? 'end' : 'start';
                        }).attr('y', x.rangeBand() / (data.length * 2)).attr('dy', '.32em').text(function (d, i) {
                            var t = valueFormat(getY(d, i)), yerr = getYerr(d, i);
                            if (yerr === undefined)
                                return t;
                            if (!yerr.length)
                                return t + '\xB1' + valueFormat(Math.abs(yerr));
                            return t + '+' + valueFormat(Math.abs(yerr[1])) + '-' + valueFormat(Math.abs(yerr[0]));
                        });
                        bars.watchTransition(renderWatch, 'multibarhorizontal: bars').select('text').attr('x', function (d, i) {
                            return getY(d, i) < 0 ? -4 : y(getY(d, i)) - y(0) + 4;
                        });
                    } else {
                        bars.selectAll('text').text('');
                    }
                    if (showBarLabels && !stacked) {
                        barsEnter.append('text').classed('nv-bar-label', true);
                        bars.select('text.nv-bar-label').attr('text-anchor', function (d, i) {
                            return getY(d, i) < 0 ? 'start' : 'end';
                        }).attr('y', x.rangeBand() / (data.length * 2)).attr('dy', '.32em').text(function (d, i) {
                            return getX(d, i);
                        });
                        bars.watchTransition(renderWatch, 'multibarhorizontal: bars').select('text.nv-bar-label').attr('x', function (d, i) {
                            return getY(d, i) < 0 ? y(0) - y(getY(d, i)) + 4 : -4;
                        });
                    } else {
                        bars.selectAll('text.nv-bar-label').text('');
                    }
                    bars.attr('class', function (d, i) {
                        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';
                    });
                    if (barColor) {
                        if (!disabled)
                            disabled = data.map(function () {
                                return true;
                            });
                        bars.style('fill', function (d, i, j) {
                            return d3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {
                                return i;
                            }).filter(function (d, i) {
                                return !disabled[i];
                            })[j]).toString();
                        }).style('stroke', function (d, i, j) {
                            return d3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {
                                return i;
                            }).filter(function (d, i) {
                                return !disabled[i];
                            })[j]).toString();
                        });
                    }
                    if (stacked)
                        bars.watchTransition(renderWatch, 'multibarhorizontal: bars').attr('transform', function (d, i) {
                            return 'translate(' + y(d.y1) + ',' + x(getX(d, i)) + ')';
                        }).select('rect').attr('width', function (d, i) {
                            return Math.abs(y(getY(d, i) + d.y0) - y(d.y0)) || 0;
                        }).attr('height', x.rangeBand());
                    else
                        bars.watchTransition(renderWatch, 'multibarhorizontal: bars').attr('transform', function (d, i) {
                            return 'translate(' + (getY(d, i) < 0 ? y(getY(d, i)) : y(0)) + ',' + (d.series * x.rangeBand() / data.length + x(getX(d, i))) + ')';
                        }).select('rect').attr('height', x.rangeBand() / data.length).attr('width', function (d, i) {
                            return Math.max(Math.abs(y(getY(d, i)) - y(0)), 1) || 0;
                        });
                    x0 = x.copy();
                    y0 = y.copy();
                });
                renderWatch.renderEnd('multibarHorizontal immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                    }
                },
                yErr: {
                    get: function () {
                        return getYerr;
                    },
                    set: function (_) {
                        getYerr = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                forceY: {
                    get: function () {
                        return forceY;
                    },
                    set: function (_) {
                        forceY = _;
                    }
                },
                stacked: {
                    get: function () {
                        return stacked;
                    },
                    set: function (_) {
                        stacked = _;
                    }
                },
                showValues: {
                    get: function () {
                        return showValues;
                    },
                    set: function (_) {
                        showValues = _;
                    }
                },
                disabled: {
                    get: function () {
                        return disabled;
                    },
                    set: function (_) {
                        disabled = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                valueFormat: {
                    get: function () {
                        return valueFormat;
                    },
                    set: function (_) {
                        valueFormat = _;
                    }
                },
                valuePadding: {
                    get: function () {
                        return valuePadding;
                    },
                    set: function (_) {
                        valuePadding = _;
                    }
                },
                groupSpacing: {
                    get: function () {
                        return groupSpacing;
                    },
                    set: function (_) {
                        groupSpacing = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                barColor: {
                    get: function () {
                        return barColor;
                    },
                    set: function (_) {
                        barColor = _ ? nv.utils.getColor(_) : null;
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.multiBarHorizontalChart = function () {
            'use strict';
            var multibar = nv.models.multiBarHorizontal(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend().height(30), controls = nv.models.legend().height(30), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 20,
                    bottom: 50,
                    left: 60
                }, width = null, height = null, color = nv.utils.defaultColor(), showControls = true, controlLabels = {}, showLegend = true, showXAxis = true, showYAxis = true, stacked = false, x, y, state = nv.utils.state(), defaultState = null, noData = null, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd'), controlWidth = function () {
                    return showControls ? 180 : 0;
                }, duration = 250;
            state.stacked = false;
            multibar.stacked(stacked);
            xAxis.orient('left').tickPadding(5).showMaxMin(false).tickFormat(function (d) {
                return d;
            });
            yAxis.orient('bottom').tickFormat(d3.format(',.1f'));
            tooltip.duration(0).valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            }).headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            });
            controls.updateState(false);
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        }),
                        stacked: stacked
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.stacked !== undefined)
                        stacked = state.stacked;
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(multibar);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    stacked = multibar.stacked();
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = multibar.xScale();
                    y = multibar.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-multiBarHorizontalChart').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarHorizontalChart').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis').append('g').attr('class', 'nv-zeroLine').append('line');
                    gEnter.append('g').attr('class', 'nv-barsWrap');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    gEnter.append('g').attr('class', 'nv-controlsWrap');
                    if (showLegend) {
                        legend.width(availableWidth - controlWidth());
                        g.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        g.select('.nv-legendWrap').attr('transform', 'translate(' + controlWidth() + ',' + -margin.top + ')');
                    }
                    if (showControls) {
                        var controlsData = [
                            {
                                key: controlLabels.grouped || 'Grouped',
                                disabled: multibar.stacked()
                            },
                            {
                                key: controlLabels.stacked || 'Stacked',
                                disabled: !multibar.stacked()
                            }
                        ];
                        controls.width(controlWidth()).color([
                            '#444',
                            '#444',
                            '#444'
                        ]);
                        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    multibar.disabled(data.map(function (series) {
                        return series.disabled;
                    })).width(availableWidth).height(availableHeight).color(data.map(function (d, i) {
                        return d.color || color(d, i);
                    }).filter(function (d, i) {
                        return !data[i].disabled;
                    }));
                    var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    }));
                    barsWrap.transition().call(multibar);
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksY(availableHeight / 24, data)).tickSize(-availableWidth, 0);
                        g.select('.nv-x.nv-axis').call(xAxis);
                        var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                        xTicks.selectAll('line, text');
                    }
                    if (showYAxis) {
                        yAxis.scale(y)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(0,' + availableHeight + ')');
                        g.select('.nv-y.nv-axis').call(yAxis);
                    }
                    g.select('.nv-zeroLine line').attr('x1', y(0)).attr('x2', y(0)).attr('y1', 0).attr('y2', -availableHeight);
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    controls.dispatch.on('legendClick', function (d, i) {
                        if (!d.disabled)
                            return;
                        controlsData = controlsData.map(function (s) {
                            s.disabled = true;
                            return s;
                        });
                        d.disabled = false;
                        switch (d.key) {
                        case 'Grouped':
                            multibar.stacked(false);
                            break;
                        case 'Stacked':
                            multibar.stacked(true);
                            break;
                        }
                        state.stacked = multibar.stacked();
                        dispatch.stateChange(state);
                        stacked = multibar.stacked();
                        chart.update();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        if (typeof e.stacked !== 'undefined') {
                            multibar.stacked(e.stacked);
                            state.stacked = e.stacked;
                            stacked = e.stacked;
                        }
                        chart.update();
                    });
                });
                renderWatch.renderEnd('multibar horizontal chart immediate');
                return chart;
            }
            multibar.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt.value = chart.x()(evt.data);
                evt['series'] = {
                    key: evt.data.key,
                    value: chart.y()(evt.data),
                    color: evt.color
                };
                tooltip.data(evt).hidden(false);
            });
            multibar.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            multibar.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.dispatch = dispatch;
            chart.multibar = multibar;
            chart.legend = legend;
            chart.controls = controls;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.state = state;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                showControls: {
                    get: function () {
                        return showControls;
                    },
                    set: function (_) {
                        showControls = _;
                    }
                },
                controlLabels: {
                    get: function () {
                        return controlLabels;
                    },
                    set: function (_) {
                        controlLabels = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        multibar.duration(duration);
                        xAxis.duration(duration);
                        yAxis.duration(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                    }
                },
                barColor: {
                    get: function () {
                        return multibar.barColor;
                    },
                    set: function (_) {
                        multibar.barColor(_);
                        legend.color(function (d, i) {
                            return d3.rgb('#ccc').darker(i * 1.5).toString();
                        });
                    }
                }
            });
            nv.utils.inheritOptions(chart, multibar);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.multiChart = function () {
            'use strict';
            var margin = {
                    top: 30,
                    right: 20,
                    bottom: 50,
                    left: 60
                }, color = nv.utils.defaultColor(), width = null, height = null, showLegend = true, noData = null, yDomain1, yDomain2, getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, interpolate = 'monotone', useVoronoi = true;
            var x = d3.scale.linear(), yScale1 = d3.scale.linear(), yScale2 = d3.scale.linear(), lines1 = nv.models.line().yScale(yScale1), lines2 = nv.models.line().yScale(yScale2), scatters1 = nv.models.scatter().yScale(yScale1), scatters2 = nv.models.scatter().yScale(yScale2), bars1 = nv.models.multiBar().stacked(false).yScale(yScale1), bars2 = nv.models.multiBar().stacked(false).yScale(yScale2), stack1 = nv.models.stackedArea().yScale(yScale1), stack2 = nv.models.stackedArea().yScale(yScale2), xAxis = nv.models.axis().scale(x).orient('bottom').tickPadding(5), yAxis1 = nv.models.axis().scale(yScale1).orient('left'), yAxis2 = nv.models.axis().scale(yScale2).orient('right'), legend = nv.models.legend().height(30), tooltip = nv.models.tooltip(), dispatch = d3.dispatch();
            function chart(selection) {
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    chart.update = function () {
                        container.transition().call(chart);
                    };
                    chart.container = this;
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    var dataLines1 = data.filter(function (d) {
                        return d.type == 'line' && d.yAxis == 1;
                    });
                    var dataLines2 = data.filter(function (d) {
                        return d.type == 'line' && d.yAxis == 2;
                    });
                    var dataScatters1 = data.filter(function (d) {
                        return d.type == 'scatter' && d.yAxis == 1;
                    });
                    var dataScatters2 = data.filter(function (d) {
                        return d.type == 'scatter' && d.yAxis == 2;
                    });
                    var dataBars1 = data.filter(function (d) {
                        return d.type == 'bar' && d.yAxis == 1;
                    });
                    var dataBars2 = data.filter(function (d) {
                        return d.type == 'bar' && d.yAxis == 2;
                    });
                    var dataStack1 = data.filter(function (d) {
                        return d.type == 'area' && d.yAxis == 1;
                    });
                    var dataStack2 = data.filter(function (d) {
                        return d.type == 'area' && d.yAxis == 2;
                    });
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    var series1 = data.filter(function (d) {
                        return !d.disabled && d.yAxis == 1;
                    }).map(function (d) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d),
                                y: getY(d)
                            };
                        });
                    });
                    var series2 = data.filter(function (d) {
                        return !d.disabled && d.yAxis == 2;
                    }).map(function (d) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d),
                                y: getY(d)
                            };
                        });
                    });
                    x.domain(d3.extent(d3.merge(series1.concat(series2)), function (d) {
                        return getX(d);
                    })).range([
                        0,
                        availableWidth
                    ]);
                    var wrap = container.selectAll('g.wrap.multiChart').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'wrap nvd3 multiChart').append('g');
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y1 nv-axis');
                    gEnter.append('g').attr('class', 'nv-y2 nv-axis');
                    gEnter.append('g').attr('class', 'lines1Wrap');
                    gEnter.append('g').attr('class', 'lines2Wrap');
                    gEnter.append('g').attr('class', 'scatters1Wrap');
                    gEnter.append('g').attr('class', 'scatters2Wrap');
                    gEnter.append('g').attr('class', 'bars1Wrap');
                    gEnter.append('g').attr('class', 'bars2Wrap');
                    gEnter.append('g').attr('class', 'stack1Wrap');
                    gEnter.append('g').attr('class', 'stack2Wrap');
                    gEnter.append('g').attr('class', 'legendWrap');
                    var g = wrap.select('g');
                    var color_array = data.map(function (d, i) {
                        return data[i].color || color(d, i);
                    });
                    if (showLegend) {
                        var legendWidth = legend.align() ? availableWidth / 2 : availableWidth;
                        var legendXPosition = legend.align() ? legendWidth : 0;
                        legend.width(legendWidth);
                        legend.color(color_array);
                        g.select('.legendWrap').datum(data.map(function (series) {
                            series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                            series.key = series.originalKey + (series.yAxis == 1 ? '' : ' (right axis)');
                            return series;
                        })).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        g.select('.legendWrap').attr('transform', 'translate(' + legendXPosition + ',' + -margin.top + ')');
                    }
                    lines1.width(availableWidth).height(availableHeight).interpolate(interpolate).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'line';
                    }));
                    lines2.width(availableWidth).height(availableHeight).interpolate(interpolate).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'line';
                    }));
                    scatters1.width(availableWidth).height(availableHeight).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'scatter';
                    }));
                    scatters2.width(availableWidth).height(availableHeight).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'scatter';
                    }));
                    bars1.width(availableWidth).height(availableHeight).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'bar';
                    }));
                    bars2.width(availableWidth).height(availableHeight).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'bar';
                    }));
                    stack1.width(availableWidth).height(availableHeight).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'area';
                    }));
                    stack2.width(availableWidth).height(availableHeight).color(color_array.filter(function (d, i) {
                        return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'area';
                    }));
                    g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var lines1Wrap = g.select('.lines1Wrap').datum(dataLines1.filter(function (d) {
                        return !d.disabled;
                    }));
                    var scatters1Wrap = g.select('.scatters1Wrap').datum(dataScatters1.filter(function (d) {
                        return !d.disabled;
                    }));
                    var bars1Wrap = g.select('.bars1Wrap').datum(dataBars1.filter(function (d) {
                        return !d.disabled;
                    }));
                    var stack1Wrap = g.select('.stack1Wrap').datum(dataStack1.filter(function (d) {
                        return !d.disabled;
                    }));
                    var lines2Wrap = g.select('.lines2Wrap').datum(dataLines2.filter(function (d) {
                        return !d.disabled;
                    }));
                    var scatters2Wrap = g.select('.scatters2Wrap').datum(dataScatters2.filter(function (d) {
                        return !d.disabled;
                    }));
                    var bars2Wrap = g.select('.bars2Wrap').datum(dataBars2.filter(function (d) {
                        return !d.disabled;
                    }));
                    var stack2Wrap = g.select('.stack2Wrap').datum(dataStack2.filter(function (d) {
                        return !d.disabled;
                    }));
                    var extraValue1 = dataStack1.length ? dataStack1.map(function (a) {
                        return a.values;
                    }).reduce(function (a, b) {
                        return a.map(function (aVal, i) {
                            return {
                                x: aVal.x,
                                y: aVal.y + b[i].y
                            };
                        });
                    }).concat([{
                            x: 0,
                            y: 0
                        }]) : [];
                    var extraValue2 = dataStack2.length ? dataStack2.map(function (a) {
                        return a.values;
                    }).reduce(function (a, b) {
                        return a.map(function (aVal, i) {
                            return {
                                x: aVal.x,
                                y: aVal.y + b[i].y
                            };
                        });
                    }).concat([{
                            x: 0,
                            y: 0
                        }]) : [];
                    yScale1.domain(yDomain1 || d3.extent(d3.merge(series1).concat(extraValue1), function (d) {
                        return d.y;
                    })).range([
                        0,
                        availableHeight
                    ]);
                    yScale2.domain(yDomain2 || d3.extent(d3.merge(series2).concat(extraValue2), function (d) {
                        return d.y;
                    })).range([
                        0,
                        availableHeight
                    ]);
                    lines1.yDomain(yScale1.domain());
                    scatters1.yDomain(yScale1.domain());
                    bars1.yDomain(yScale1.domain());
                    stack1.yDomain(yScale1.domain());
                    lines2.yDomain(yScale2.domain());
                    scatters2.yDomain(yScale2.domain());
                    bars2.yDomain(yScale2.domain());
                    stack2.yDomain(yScale2.domain());
                    if (dataStack1.length) {
                        d3.transition(stack1Wrap).call(stack1);
                    }
                    if (dataStack2.length) {
                        d3.transition(stack2Wrap).call(stack2);
                    }
                    if (dataBars1.length) {
                        d3.transition(bars1Wrap).call(bars1);
                    }
                    if (dataBars2.length) {
                        d3.transition(bars2Wrap).call(bars2);
                    }
                    if (dataLines1.length) {
                        d3.transition(lines1Wrap).call(lines1);
                    }
                    if (dataLines2.length) {
                        d3.transition(lines2Wrap).call(lines2);
                    }
                    if (dataScatters1.length) {
                        d3.transition(scatters1Wrap).call(scatters1);
                    }
                    if (dataScatters2.length) {
                        d3.transition(scatters2Wrap).call(scatters2);
                    }
                    xAxis._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                    g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + availableHeight + ')');
                    d3.transition(g.select('.nv-x.nv-axis')).call(xAxis);
                    yAxis1._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                    d3.transition(g.select('.nv-y1.nv-axis')).call(yAxis1);
                    yAxis2._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                    d3.transition(g.select('.nv-y2.nv-axis')).call(yAxis2);
                    g.select('.nv-y1.nv-axis').classed('nv-disabled', series1.length ? false : true).attr('transform', 'translate(' + x.range()[0] + ',0)');
                    g.select('.nv-y2.nv-axis').classed('nv-disabled', series2.length ? false : true).attr('transform', 'translate(' + x.range()[1] + ',0)');
                    legend.dispatch.on('stateChange', function (newState) {
                        chart.update();
                    });
                    function mouseover_line(evt) {
                        var yaxis = data[evt.seriesIndex].yAxis === 2 ? yAxis2 : yAxis1;
                        evt.value = evt.point.x;
                        evt.series = {
                            value: evt.point.y,
                            color: evt.point.color,
                            key: evt.series.key
                        };
                        tooltip.duration(0).valueFormatter(function (d, i) {
                            return yaxis.tickFormat()(d, i);
                        }).data(evt).hidden(false);
                    }
                    function mouseover_scatter(evt) {
                        var yaxis = data[evt.seriesIndex].yAxis === 2 ? yAxis2 : yAxis1;
                        evt.value = evt.point.x;
                        evt.series = {
                            value: evt.point.y,
                            color: evt.point.color,
                            key: evt.series.key
                        };
                        tooltip.duration(100).valueFormatter(function (d, i) {
                            return yaxis.tickFormat()(d, i);
                        }).data(evt).hidden(false);
                    }
                    function mouseover_stack(evt) {
                        var yaxis = data[evt.seriesIndex].yAxis === 2 ? yAxis2 : yAxis1;
                        evt.point['x'] = stack1.x()(evt.point);
                        evt.point['y'] = stack1.y()(evt.point);
                        tooltip.duration(0).valueFormatter(function (d, i) {
                            return yaxis.tickFormat()(d, i);
                        }).data(evt).hidden(false);
                    }
                    function mouseover_bar(evt) {
                        var yaxis = data[evt.data.series].yAxis === 2 ? yAxis2 : yAxis1;
                        evt.value = bars1.x()(evt.data);
                        evt['series'] = {
                            value: bars1.y()(evt.data),
                            color: evt.color,
                            key: evt.data.key
                        };
                        tooltip.duration(0).valueFormatter(function (d, i) {
                            return yaxis.tickFormat()(d, i);
                        }).data(evt).hidden(false);
                    }
                    lines1.dispatch.on('elementMouseover.tooltip', mouseover_line);
                    lines2.dispatch.on('elementMouseover.tooltip', mouseover_line);
                    lines1.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    lines2.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    scatters1.dispatch.on('elementMouseover.tooltip', mouseover_scatter);
                    scatters2.dispatch.on('elementMouseover.tooltip', mouseover_scatter);
                    scatters1.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    scatters2.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    stack1.dispatch.on('elementMouseover.tooltip', mouseover_stack);
                    stack2.dispatch.on('elementMouseover.tooltip', mouseover_stack);
                    stack1.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    stack2.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    bars1.dispatch.on('elementMouseover.tooltip', mouseover_bar);
                    bars2.dispatch.on('elementMouseover.tooltip', mouseover_bar);
                    bars1.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    bars2.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                    });
                    bars1.dispatch.on('elementMousemove.tooltip', function (evt) {
                        tooltip();
                    });
                    bars2.dispatch.on('elementMousemove.tooltip', function (evt) {
                        tooltip();
                    });
                });
                return chart;
            }
            chart.dispatch = dispatch;
            chart.legend = legend;
            chart.lines1 = lines1;
            chart.lines2 = lines2;
            chart.scatters1 = scatters1;
            chart.scatters2 = scatters2;
            chart.bars1 = bars1;
            chart.bars2 = bars2;
            chart.stack1 = stack1;
            chart.stack2 = stack2;
            chart.xAxis = xAxis;
            chart.yAxis1 = yAxis1;
            chart.yAxis2 = yAxis2;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                yDomain1: {
                    get: function () {
                        return yDomain1;
                    },
                    set: function (_) {
                        yDomain1 = _;
                    }
                },
                yDomain2: {
                    get: function () {
                        return yDomain2;
                    },
                    set: function (_) {
                        yDomain2 = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                interpolate: {
                    get: function () {
                        return interpolate;
                    },
                    set: function (_) {
                        interpolate = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                        lines1.x(_);
                        lines2.x(_);
                        scatters1.x(_);
                        scatters2.x(_);
                        bars1.x(_);
                        bars2.x(_);
                        stack1.x(_);
                        stack2.x(_);
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                        lines1.y(_);
                        lines2.y(_);
                        scatters1.y(_);
                        scatters2.y(_);
                        stack1.y(_);
                        stack2.y(_);
                        bars1.y(_);
                        bars2.y(_);
                    }
                },
                useVoronoi: {
                    get: function () {
                        return useVoronoi;
                    },
                    set: function (_) {
                        useVoronoi = _;
                        lines1.useVoronoi(_);
                        lines2.useVoronoi(_);
                        stack1.useVoronoi(_);
                        stack2.useVoronoi(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.ohlcBar = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = null, height = null, id = Math.floor(Math.random() * 10000), container = null, x = d3.scale.linear(), y = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, getOpen = function (d) {
                    return d.open;
                }, getClose = function (d) {
                    return d.close;
                }, getHigh = function (d) {
                    return d.high;
                }, getLow = function (d) {
                    return d.low;
                }, forceX = [], forceY = [], padData = false, clipEdge = true, color = nv.utils.defaultColor(), interactive = false, xDomain, yDomain, xRange, yRange, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove');
            function chart(selection) {
                selection.each(function (data) {
                    container = d3.select(this);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    nv.utils.initSVG(container);
                    var w = availableWidth / data[0].values.length * 0.9;
                    x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX)));
                    if (padData)
                        x.range(xRange || [
                            availableWidth * 0.5 / data[0].values.length,
                            availableWidth * (data[0].values.length - 0.5) / data[0].values.length
                        ]);
                    else
                        x.range(xRange || [
                            5 + w / 2,
                            availableWidth - w / 2 - 5
                        ]);
                    y.domain(yDomain || [
                        d3.min(data[0].values.map(getLow).concat(forceY)),
                        d3.max(data[0].values.map(getHigh).concat(forceY))
                    ]).range(yRange || [
                        availableHeight,
                        0
                    ]);
                    if (x.domain()[0] === x.domain()[1])
                        x.domain()[0] ? x.domain([
                            x.domain()[0] - x.domain()[0] * 0.01,
                            x.domain()[1] + x.domain()[1] * 0.01
                        ]) : x.domain([
                            -1,
                            1
                        ]);
                    if (y.domain()[0] === y.domain()[1])
                        y.domain()[0] ? y.domain([
                            y.domain()[0] + y.domain()[0] * 0.01,
                            y.domain()[1] - y.domain()[1] * 0.01
                        ]) : y.domain([
                            -1,
                            1
                        ]);
                    var wrap = d3.select(this).selectAll('g.nv-wrap.nv-ohlcBar').data([data[0].values]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-ohlcBar');
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-ticks');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    container.on('click', function (d, i) {
                        dispatch.chartClick({
                            data: d,
                            index: i,
                            pos: d3.event,
                            id: id
                        });
                    });
                    defsEnter.append('clipPath').attr('id', 'nv-chart-clip-path-' + id).append('rect');
                    wrap.select('#nv-chart-clip-path-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);
                    g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');
                    var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick').data(function (d) {
                        return d;
                    });
                    ticks.exit().remove();
                    ticks.enter().append('path').attr('class', function (d, i, j) {
                        return (getOpen(d, i) > getClose(d, i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;
                    }).attr('d', function (d, i) {
                        return 'm0,0l0,' + (y(getOpen(d, i)) - y(getHigh(d, i))) + 'l' + -w / 2 + ',0l' + w / 2 + ',0l0,' + (y(getLow(d, i)) - y(getOpen(d, i))) + 'l0,' + (y(getClose(d, i)) - y(getLow(d, i))) + 'l' + w / 2 + ',0l' + -w / 2 + ',0z';
                    }).attr('transform', function (d, i) {
                        return 'translate(' + x(getX(d, i)) + ',' + y(getHigh(d, i)) + ')';
                    }).attr('fill', function (d, i) {
                        return color[0];
                    }).attr('stroke', function (d, i) {
                        return color[0];
                    }).attr('x', 0).attr('y', function (d, i) {
                        return y(Math.max(0, getY(d, i)));
                    }).attr('height', function (d, i) {
                        return Math.abs(y(getY(d, i)) - y(0));
                    });
                    ticks.attr('class', function (d, i, j) {
                        return (getOpen(d, i) > getClose(d, i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;
                    });
                    d3.transition(ticks).attr('transform', function (d, i) {
                        return 'translate(' + x(getX(d, i)) + ',' + y(getHigh(d, i)) + ')';
                    }).attr('d', function (d, i) {
                        var w = availableWidth / data[0].values.length * 0.9;
                        return 'm0,0l0,' + (y(getOpen(d, i)) - y(getHigh(d, i))) + 'l' + -w / 2 + ',0l' + w / 2 + ',0l0,' + (y(getLow(d, i)) - y(getOpen(d, i))) + 'l0,' + (y(getClose(d, i)) - y(getLow(d, i))) + 'l' + w / 2 + ',0l' + -w / 2 + ',0z';
                    });
                });
                return chart;
            }
            chart.highlightPoint = function (pointIndex, isHoverOver) {
                chart.clearHighlights();
                container.select('.nv-ohlcBar .nv-tick-0-' + pointIndex).classed('hover', isHoverOver);
            };
            chart.clearHighlights = function () {
                container.select('.nv-ohlcBar .nv-tick.hover').classed('hover', false);
            };
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                forceX: {
                    get: function () {
                        return forceX;
                    },
                    set: function (_) {
                        forceX = _;
                    }
                },
                forceY: {
                    get: function () {
                        return forceY;
                    },
                    set: function (_) {
                        forceY = _;
                    }
                },
                padData: {
                    get: function () {
                        return padData;
                    },
                    set: function (_) {
                        padData = _;
                    }
                },
                clipEdge: {
                    get: function () {
                        return clipEdge;
                    },
                    set: function (_) {
                        clipEdge = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                interactive: {
                    get: function () {
                        return interactive;
                    },
                    set: function (_) {
                        interactive = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = _;
                    }
                },
                open: {
                    get: function () {
                        return getOpen();
                    },
                    set: function (_) {
                        getOpen = _;
                    }
                },
                close: {
                    get: function () {
                        return getClose();
                    },
                    set: function (_) {
                        getClose = _;
                    }
                },
                high: {
                    get: function () {
                        return getHigh;
                    },
                    set: function (_) {
                        getHigh = _;
                    }
                },
                low: {
                    get: function () {
                        return getLow;
                    },
                    set: function (_) {
                        getLow = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top != undefined ? _.top : margin.top;
                        margin.right = _.right != undefined ? _.right : margin.right;
                        margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
                        margin.left = _.left != undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.parallelCoordinates = function () {
            'use strict';
            var margin = {
                    top: 30,
                    right: 0,
                    bottom: 10,
                    left: 0
                }, width = null, height = null, x = d3.scale.ordinal(), y = {}, dimensionNames = [], dimensionFormats = [], color = nv.utils.defaultColor(), filters = [], active = [], dragging = [], lineTension = 1, dispatch = d3.dispatch('brush', 'elementMouseover', 'elementMouseout');
            function chart(selection) {
                selection.each(function (data) {
                    var container = d3.select(this);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    nv.utils.initSVG(container);
                    active = data;
                    x.rangePoints([
                        0,
                        availableWidth
                    ], 1).domain(dimensionNames);
                    var onlyNanValues = {};
                    dimensionNames.forEach(function (d) {
                        var extent = d3.extent(data, function (p) {
                            return +p[d];
                        });
                        onlyNanValues[d] = false;
                        if (extent[0] === undefined) {
                            onlyNanValues[d] = true;
                            extent[0] = 0;
                            extent[1] = 0;
                        }
                        if (extent[0] === extent[1]) {
                            extent[0] = extent[0] - 1;
                            extent[1] = extent[1] + 1;
                        }
                        y[d] = d3.scale.linear().domain(extent).range([
                            (availableHeight - 12) * 0.9,
                            0
                        ]);
                        y[d].brush = d3.svg.brush().y(y[d]).on('brush', brush);
                        return d != 'name';
                    });
                    var wrap = container.selectAll('g.nv-wrap.nv-parallelCoordinates').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-parallelCoordinates');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-parallelCoordinates background');
                    gEnter.append('g').attr('class', 'nv-parallelCoordinates foreground');
                    gEnter.append('g').attr('class', 'nv-parallelCoordinates missingValuesline');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var line = d3.svg.line().interpolate('cardinal').tension(lineTension), axis = d3.svg.axis().orient('left'), axisDrag = d3.behavior.drag().on('dragstart', dragStart).on('drag', dragMove).on('dragend', dragEnd);
                    var missingValuesline, missingValueslineText;
                    var step = x.range()[1] - x.range()[0];
                    var axisWithMissingValues = [];
                    var lineData = [
                        0 + step / 2,
                        availableHeight - 12,
                        availableWidth - step / 2,
                        availableHeight - 12
                    ];
                    missingValuesline = wrap.select('.missingValuesline').selectAll('line').data([lineData]);
                    missingValuesline.enter().append('line');
                    missingValuesline.exit().remove();
                    missingValuesline.attr('x1', function (d) {
                        return d[0];
                    }).attr('y1', function (d) {
                        return d[1];
                    }).attr('x2', function (d) {
                        return d[2];
                    }).attr('y2', function (d) {
                        return d[3];
                    });
                    missingValueslineText = wrap.select('.missingValuesline').selectAll('text').data(['undefined values']);
                    missingValueslineText.append('text').data(['undefined values']);
                    missingValueslineText.enter().append('text');
                    missingValueslineText.exit().remove();
                    missingValueslineText.attr('y', availableHeight).attr('x', availableWidth - 92 - step / 2).text(function (d) {
                        return d;
                    });
                    var background = wrap.select('.background').selectAll('path').data(data);
                    background.enter().append('path');
                    background.exit().remove();
                    background.attr('d', path);
                    var foreground = wrap.select('.foreground').selectAll('path').data(data);
                    foreground.enter().append('path');
                    foreground.exit().remove();
                    foreground.attr('d', path).attr('stroke', color);
                    foreground.on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            label: d.name,
                            data: d.data,
                            index: i,
                            pos: [
                                d3.mouse(this.parentNode)[0],
                                d3.mouse(this.parentNode)[1]
                            ]
                        });
                    });
                    foreground.on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            label: d.name,
                            data: d.data,
                            index: i
                        });
                    });
                    var dimensions = g.selectAll('.dimension').data(dimensionNames);
                    var dimensionsEnter = dimensions.enter().append('g').attr('class', 'nv-parallelCoordinates dimension');
                    dimensionsEnter.append('g').attr('class', 'nv-parallelCoordinates nv-axis');
                    dimensionsEnter.append('g').attr('class', 'nv-parallelCoordinates-brush');
                    dimensionsEnter.append('text').attr('class', 'nv-parallelCoordinates nv-label');
                    dimensions.attr('transform', function (d) {
                        return 'translate(' + x(d) + ',0)';
                    });
                    dimensions.exit().remove();
                    dimensions.select('.nv-label').style('cursor', 'move').attr('dy', '-1em').attr('text-anchor', 'middle').text(String).on('mouseover', function (d, i) {
                        dispatch.elementMouseover({
                            dim: d,
                            pos: [
                                d3.mouse(this.parentNode.parentNode)[0],
                                d3.mouse(this.parentNode.parentNode)[1]
                            ]
                        });
                    }).on('mouseout', function (d, i) {
                        dispatch.elementMouseout({ dim: d });
                    }).call(axisDrag);
                    dimensions.select('.nv-axis').each(function (d, i) {
                        d3.select(this).call(axis.scale(y[d]).tickFormat(d3.format(dimensionFormats[i])));
                    });
                    dimensions.select('.nv-parallelCoordinates-brush').each(function (d) {
                        d3.select(this).call(y[d].brush);
                    }).selectAll('rect').attr('x', -8).attr('width', 16);
                    function path(d) {
                        return line(dimensionNames.map(function (p) {
                            if (isNaN(d[p]) || isNaN(parseFloat(d[p]))) {
                                var domain = y[p].domain();
                                var range = y[p].range();
                                var min = domain[0] - (domain[1] - domain[0]) / 9;
                                if (axisWithMissingValues.indexOf(p) < 0) {
                                    var newscale = d3.scale.linear().domain([
                                        min,
                                        domain[1]
                                    ]).range([
                                        availableHeight - 12,
                                        range[1]
                                    ]);
                                    y[p].brush.y(newscale);
                                    axisWithMissingValues.push(p);
                                }
                                return [
                                    x(p),
                                    y[p](min)
                                ];
                            }
                            if (axisWithMissingValues.length > 0) {
                                missingValuesline.style('display', 'inline');
                                missingValueslineText.style('display', 'inline');
                            } else {
                                missingValuesline.style('display', 'none');
                                missingValueslineText.style('display', 'none');
                            }
                            return [
                                x(p),
                                y[p](d[p])
                            ];
                        }));
                    }
                    function brush() {
                        var actives = dimensionNames.filter(function (p) {
                                return !y[p].brush.empty();
                            }), extents = actives.map(function (p) {
                                return y[p].brush.extent();
                            });
                        filters = [];
                        actives.forEach(function (d, i) {
                            filters[i] = {
                                dimension: d,
                                extent: extents[i]
                            };
                        });
                        active = [];
                        foreground.style('display', function (d) {
                            var isActive = actives.every(function (p, i) {
                                if (isNaN(d[p]) && extents[i][0] == y[p].brush.y().domain()[0])
                                    return true;
                                return extents[i][0] <= d[p] && d[p] <= extents[i][1];
                            });
                            if (isActive)
                                active.push(d);
                            return isActive ? null : 'none';
                        });
                        dispatch.brush({
                            filters: filters,
                            active: active
                        });
                    }
                    function dragStart(d, i) {
                        dragging[d] = this.parentNode.__origin__ = x(d);
                        background.attr('visibility', 'hidden');
                    }
                    function dragMove(d, i) {
                        dragging[d] = Math.min(availableWidth, Math.max(0, this.parentNode.__origin__ += d3.event.x));
                        foreground.attr('d', path);
                        dimensionNames.sort(function (a, b) {
                            return position(a) - position(b);
                        });
                        x.domain(dimensionNames);
                        dimensions.attr('transform', function (d) {
                            return 'translate(' + position(d) + ')';
                        });
                    }
                    function dragEnd(d, i) {
                        delete this.parentNode.__origin__;
                        delete dragging[d];
                        d3.select(this.parentNode).attr('transform', 'translate(' + x(d) + ')');
                        foreground.attr('d', path);
                        background.attr('d', path).attr('visibility', null);
                    }
                    function position(d) {
                        var v = dragging[d];
                        return v == null ? x(d) : v;
                    }
                });
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                dimensionNames: {
                    get: function () {
                        return dimensionNames;
                    },
                    set: function (_) {
                        dimensionNames = _;
                    }
                },
                dimensionFormats: {
                    get: function () {
                        return dimensionFormats;
                    },
                    set: function (_) {
                        dimensionFormats = _;
                    }
                },
                lineTension: {
                    get: function () {
                        return lineTension;
                    },
                    set: function (_) {
                        lineTension = _;
                    }
                },
                dimensions: {
                    get: function () {
                        return dimensionNames;
                    },
                    set: function (_) {
                        nv.deprecated('dimensions', 'use dimensionNames instead');
                        dimensionNames = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.pie = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 500, height = 500, getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, id = Math.floor(Math.random() * 10000), container = null, color = nv.utils.defaultColor(), valueFormat = d3.format(',.2f'), showLabels = true, labelsOutside = false, labelType = 'key', labelThreshold = 0.02, donut = false, title = false, growOnHover = true, titleOffset = 0, labelSunbeamLayout = false, startAngle = false, padAngle = false, endAngle = false, cornerRadius = 0, donutRatio = 0.5, arcsRadius = [], dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd');
            var arcs = [];
            var arcsOver = [];
            var renderWatch = nv.utils.renderWatch(dispatch);
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, radius = Math.min(availableWidth, availableHeight) / 2, arcsRadiusOuter = [], arcsRadiusInner = [];
                    container = d3.select(this);
                    if (arcsRadius.length === 0) {
                        var outer = radius - radius / 5;
                        var inner = donutRatio * radius;
                        for (var i = 0; i < data[0].length; i++) {
                            arcsRadiusOuter.push(outer);
                            arcsRadiusInner.push(inner);
                        }
                    } else {
                        arcsRadiusOuter = arcsRadius.map(function (d) {
                            return (d.outer - d.outer / 5) * radius;
                        });
                        arcsRadiusInner = arcsRadius.map(function (d) {
                            return (d.inner - d.inner / 5) * radius;
                        });
                        donutRatio = d3.min(arcsRadius.map(function (d) {
                            return d.inner - d.inner / 5;
                        }));
                    }
                    nv.utils.initSVG(container);
                    var wrap = container.selectAll('.nv-wrap.nv-pie').data(data);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pie nv-chart-' + id);
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    var g_pie = gEnter.append('g').attr('class', 'nv-pie');
                    gEnter.append('g').attr('class', 'nv-pieLabels');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    g.select('.nv-pie').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
                    g.select('.nv-pieLabels').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
                    container.on('click', function (d, i) {
                        dispatch.chartClick({
                            data: d,
                            index: i,
                            pos: d3.event,
                            id: id
                        });
                    });
                    arcs = [];
                    arcsOver = [];
                    for (var i = 0; i < data[0].length; i++) {
                        var arc = d3.svg.arc().outerRadius(arcsRadiusOuter[i]);
                        var arcOver = d3.svg.arc().outerRadius(arcsRadiusOuter[i] + 5);
                        if (startAngle !== false) {
                            arc.startAngle(startAngle);
                            arcOver.startAngle(startAngle);
                        }
                        if (endAngle !== false) {
                            arc.endAngle(endAngle);
                            arcOver.endAngle(endAngle);
                        }
                        if (donut) {
                            arc.innerRadius(arcsRadiusInner[i]);
                            arcOver.innerRadius(arcsRadiusInner[i]);
                        }
                        if (arc.cornerRadius && cornerRadius) {
                            arc.cornerRadius(cornerRadius);
                            arcOver.cornerRadius(cornerRadius);
                        }
                        arcs.push(arc);
                        arcsOver.push(arcOver);
                    }
                    var pie = d3.layout.pie().sort(null).value(function (d) {
                        return d.disabled ? 0 : getY(d);
                    });
                    if (pie.padAngle && padAngle) {
                        pie.padAngle(padAngle);
                    }
                    if (donut && title) {
                        g_pie.append('text').attr('class', 'nv-pie-title');
                        wrap.select('.nv-pie-title').style('text-anchor', 'middle').text(function (d) {
                            return title;
                        }).style('font-size', Math.min(availableWidth, availableHeight) * donutRatio * 2 / (title.length + 2) + 'px').attr('dy', '0.35em').attr('transform', function (d, i) {
                            return 'translate(0, ' + titleOffset + ')';
                        });
                    }
                    var slices = wrap.select('.nv-pie').selectAll('.nv-slice').data(pie);
                    var pieLabels = wrap.select('.nv-pieLabels').selectAll('.nv-label').data(pie);
                    slices.exit().remove();
                    pieLabels.exit().remove();
                    var ae = slices.enter().append('g');
                    ae.attr('class', 'nv-slice');
                    ae.on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true);
                        if (growOnHover) {
                            d3.select(this).select('path').transition().duration(70).attr('d', arcsOver[i]);
                        }
                        dispatch.elementMouseover({
                            data: d.data,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    });
                    ae.on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false);
                        if (growOnHover) {
                            d3.select(this).select('path').transition().duration(50).attr('d', arcs[i]);
                        }
                        dispatch.elementMouseout({
                            data: d.data,
                            index: i
                        });
                    });
                    ae.on('mousemove', function (d, i) {
                        dispatch.elementMousemove({
                            data: d.data,
                            index: i
                        });
                    });
                    ae.on('click', function (d, i) {
                        dispatch.elementClick({
                            data: d.data,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    });
                    ae.on('dblclick', function (d, i) {
                        dispatch.elementDblClick({
                            data: d.data,
                            index: i,
                            color: d3.select(this).style('fill')
                        });
                    });
                    slices.attr('fill', function (d, i) {
                        return color(d.data, i);
                    });
                    slices.attr('stroke', function (d, i) {
                        return color(d.data, i);
                    });
                    var paths = ae.append('path').each(function (d) {
                        this._current = d;
                    });
                    slices.select('path').transition().attr('d', function (d, i) {
                        return arcs[i](d);
                    }).attrTween('d', arcTween);
                    if (showLabels) {
                        var labelsArc = [];
                        for (var i = 0; i < data[0].length; i++) {
                            labelsArc.push(arcs[i]);
                            if (labelsOutside) {
                                if (donut) {
                                    labelsArc[i] = d3.svg.arc().outerRadius(arcs[i].outerRadius());
                                    if (startAngle !== false)
                                        labelsArc[i].startAngle(startAngle);
                                    if (endAngle !== false)
                                        labelsArc[i].endAngle(endAngle);
                                }
                            } else if (!donut) {
                                labelsArc[i].innerRadius(0);
                            }
                        }
                        pieLabels.enter().append('g').classed('nv-label', true).each(function (d, i) {
                            var group = d3.select(this);
                            group.attr('transform', function (d, i) {
                                if (labelSunbeamLayout) {
                                    d.outerRadius = arcsRadiusOuter[i] + 10;
                                    d.innerRadius = arcsRadiusOuter[i] + 15;
                                    var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                                    if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                                        rotateAngle -= 90;
                                    } else {
                                        rotateAngle += 90;
                                    }
                                    return 'translate(' + labelsArc[i].centroid(d) + ') rotate(' + rotateAngle + ')';
                                } else {
                                    d.outerRadius = radius + 10;
                                    d.innerRadius = radius + 15;
                                    return 'translate(' + labelsArc[i].centroid(d) + ')';
                                }
                            });
                            group.append('rect').style('stroke', '#fff').style('fill', '#fff').attr('rx', 3).attr('ry', 3);
                            group.append('text').style('text-anchor', labelSunbeamLayout ? (d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end' : 'middle').style('fill', '#000');
                        });
                        var labelLocationHash = {};
                        var avgHeight = 14;
                        var avgWidth = 140;
                        var createHashKey = function (coordinates) {
                            return Math.floor(coordinates[0] / avgWidth) * avgWidth + ',' + Math.floor(coordinates[1] / avgHeight) * avgHeight;
                        };
                        pieLabels.watchTransition(renderWatch, 'pie labels').attr('transform', function (d, i) {
                            if (labelSunbeamLayout) {
                                d.outerRadius = arcsRadiusOuter[i] + 10;
                                d.innerRadius = arcsRadiusOuter[i] + 15;
                                var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                                if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                                    rotateAngle -= 90;
                                } else {
                                    rotateAngle += 90;
                                }
                                return 'translate(' + labelsArc[i].centroid(d) + ') rotate(' + rotateAngle + ')';
                            } else {
                                d.outerRadius = radius + 10;
                                d.innerRadius = radius + 15;
                                var center = labelsArc[i].centroid(d);
                                if (d.value) {
                                    var hashKey = createHashKey(center);
                                    if (labelLocationHash[hashKey]) {
                                        center[1] -= avgHeight;
                                    }
                                    labelLocationHash[createHashKey(center)] = true;
                                }
                                return 'translate(' + center + ')';
                            }
                        });
                        pieLabels.select('.nv-label text').style('text-anchor', function (d, i) {
                            return labelSunbeamLayout ? (d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end' : 'middle';
                        }).text(function (d, i) {
                            var percent = (d.endAngle - d.startAngle) / (2 * Math.PI);
                            var label = '';
                            if (!d.value || percent < labelThreshold)
                                return '';
                            if (typeof labelType === 'function') {
                                label = labelType(d, i, {
                                    'key': getX(d.data),
                                    'value': getY(d.data),
                                    'percent': valueFormat(percent)
                                });
                            } else {
                                switch (labelType) {
                                case 'key':
                                    label = getX(d.data);
                                    break;
                                case 'value':
                                    label = valueFormat(getY(d.data));
                                    break;
                                case 'percent':
                                    label = d3.format('%')(percent);
                                    break;
                                }
                            }
                            return label;
                        });
                    }
                    function angle(d) {
                        var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
                        return a > 90 ? a - 180 : a;
                    }
                    function arcTween(a, idx) {
                        a.endAngle = isNaN(a.endAngle) ? 0 : a.endAngle;
                        a.startAngle = isNaN(a.startAngle) ? 0 : a.startAngle;
                        if (!donut)
                            a.innerRadius = 0;
                        var i = d3.interpolate(this._current, a);
                        this._current = i(0);
                        return function (t) {
                            return arcs[idx](i(t));
                        };
                    }
                });
                renderWatch.renderEnd('pie immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                arcsRadius: {
                    get: function () {
                        return arcsRadius;
                    },
                    set: function (_) {
                        arcsRadius = _;
                    }
                },
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLabels: {
                    get: function () {
                        return showLabels;
                    },
                    set: function (_) {
                        showLabels = _;
                    }
                },
                title: {
                    get: function () {
                        return title;
                    },
                    set: function (_) {
                        title = _;
                    }
                },
                titleOffset: {
                    get: function () {
                        return titleOffset;
                    },
                    set: function (_) {
                        titleOffset = _;
                    }
                },
                labelThreshold: {
                    get: function () {
                        return labelThreshold;
                    },
                    set: function (_) {
                        labelThreshold = _;
                    }
                },
                valueFormat: {
                    get: function () {
                        return valueFormat;
                    },
                    set: function (_) {
                        valueFormat = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                endAngle: {
                    get: function () {
                        return endAngle;
                    },
                    set: function (_) {
                        endAngle = _;
                    }
                },
                startAngle: {
                    get: function () {
                        return startAngle;
                    },
                    set: function (_) {
                        startAngle = _;
                    }
                },
                padAngle: {
                    get: function () {
                        return padAngle;
                    },
                    set: function (_) {
                        padAngle = _;
                    }
                },
                cornerRadius: {
                    get: function () {
                        return cornerRadius;
                    },
                    set: function (_) {
                        cornerRadius = _;
                    }
                },
                donutRatio: {
                    get: function () {
                        return donutRatio;
                    },
                    set: function (_) {
                        donutRatio = _;
                    }
                },
                labelsOutside: {
                    get: function () {
                        return labelsOutside;
                    },
                    set: function (_) {
                        labelsOutside = _;
                    }
                },
                labelSunbeamLayout: {
                    get: function () {
                        return labelSunbeamLayout;
                    },
                    set: function (_) {
                        labelSunbeamLayout = _;
                    }
                },
                donut: {
                    get: function () {
                        return donut;
                    },
                    set: function (_) {
                        donut = _;
                    }
                },
                growOnHover: {
                    get: function () {
                        return growOnHover;
                    },
                    set: function (_) {
                        growOnHover = _;
                    }
                },
                pieLabelsOutside: {
                    get: function () {
                        return labelsOutside;
                    },
                    set: function (_) {
                        labelsOutside = _;
                        nv.deprecated('pieLabelsOutside', 'use labelsOutside instead');
                    }
                },
                donutLabelsOutside: {
                    get: function () {
                        return labelsOutside;
                    },
                    set: function (_) {
                        labelsOutside = _;
                        nv.deprecated('donutLabelsOutside', 'use labelsOutside instead');
                    }
                },
                labelFormat: {
                    get: function () {
                        return valueFormat;
                    },
                    set: function (_) {
                        valueFormat = _;
                        nv.deprecated('labelFormat', 'use valueFormat instead');
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = typeof _.top != 'undefined' ? _.top : margin.top;
                        margin.right = typeof _.right != 'undefined' ? _.right : margin.right;
                        margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
                        margin.left = typeof _.left != 'undefined' ? _.left : margin.left;
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = d3.functor(_);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                labelType: {
                    get: function () {
                        return labelType;
                    },
                    set: function (_) {
                        labelType = _ || 'key';
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.pieChart = function () {
            'use strict';
            var pie = nv.models.pie();
            var legend = nv.models.legend();
            var tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 20,
                    bottom: 20,
                    left: 20
                }, width = null, height = null, showLegend = true, legendPosition = 'top', color = nv.utils.defaultColor(), state = nv.utils.state(), defaultState = null, noData = null, duration = 250, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd');
            tooltip.duration(0).headerEnabled(false).valueFormatter(function (d, i) {
                return pie.valueFormat()(d, i);
            });
            var renderWatch = nv.utils.renderWatch(dispatch);
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        })
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.active !== undefined) {
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                    }
                };
            };
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(pie);
                selection.each(function (data) {
                    var container = d3.select(this);
                    nv.utils.initSVG(container);
                    var that = this;
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        container.transition().call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-pieWrap');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    if (showLegend) {
                        if (legendPosition === 'top') {
                            legend.width(availableWidth).key(pie.x());
                            wrap.select('.nv-legendWrap').datum(data).call(legend);
                            if (margin.top != legend.height()) {
                                margin.top = legend.height();
                                availableHeight = nv.utils.availableHeight(height, container, margin);
                            }
                            wrap.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');
                        } else if (legendPosition === 'right') {
                            var legendWidth = nv.models.legend().width();
                            if (availableWidth / 2 < legendWidth) {
                                legendWidth = availableWidth / 2;
                            }
                            legend.height(availableHeight).key(pie.x());
                            legend.width(legendWidth);
                            availableWidth -= legend.width();
                            wrap.select('.nv-legendWrap').datum(data).call(legend).attr('transform', 'translate(' + availableWidth + ',0)');
                        }
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    pie.width(availableWidth).height(availableHeight);
                    var pieWrap = g.select('.nv-pieWrap').datum([data]);
                    d3.transition(pieWrap).call(pie);
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState) {
                            state[key] = newState[key];
                        }
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        chart.update();
                    });
                });
                renderWatch.renderEnd('pieChart immediate');
                return chart;
            }
            pie.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt['series'] = {
                    key: chart.x()(evt.data),
                    value: chart.y()(evt.data),
                    color: evt.color
                };
                tooltip.data(evt).hidden(false);
            });
            pie.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            pie.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.legend = legend;
            chart.dispatch = dispatch;
            chart.pie = pie;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                legendPosition: {
                    get: function () {
                        return legendPosition;
                    },
                    set: function (_) {
                        legendPosition = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = _;
                        legend.color(color);
                        pie.color(color);
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                }
            });
            nv.utils.inheritOptions(chart, pie);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.scatter = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = null, height = null, color = nv.utils.defaultColor(), id = Math.floor(Math.random() * 100000), container = null, x = d3.scale.linear(), y = d3.scale.linear(), z = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, getSize = function (d) {
                    return d.size || 1;
                }, getShape = function (d) {
                    return d.shape || 'circle';
                }, forceX = [], forceY = [], forceSize = [], interactive = true, pointActive = function (d) {
                    return !d.notActive;
                }, padData = false, padDataOuter = 0.1, clipEdge = false, clipVoronoi = true, showVoronoi = false, clipRadius = function () {
                    return 25;
                }, xDomain = null, yDomain = null, xRange = null, yRange = null, sizeDomain = null, sizeRange = null, singlePoint = false, dispatch = d3.dispatch('elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd'), useVoronoi = true, duration = 250;
            var x0, y0, z0, timeoutID, needsUpdate = false, renderWatch = nv.utils.renderWatch(dispatch, duration), _sizeRange_def = [
                    16,
                    256
                ];
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    container = d3.select(this);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    nv.utils.initSVG(container);
                    data.forEach(function (series, i) {
                        series.values.forEach(function (point) {
                            point.series = i;
                        });
                    });
                    var seriesData = xDomain && yDomain && sizeDomain ? [] : d3.merge(data.map(function (d) {
                        return d.values.map(function (d, i) {
                            return {
                                x: getX(d, i),
                                y: getY(d, i),
                                size: getSize(d, i)
                            };
                        });
                    }));
                    x.domain(xDomain || d3.extent(seriesData.map(function (d) {
                        return d.x;
                    }).concat(forceX)));
                    if (padData && data[0])
                        x.range(xRange || [
                            (availableWidth * padDataOuter + availableWidth) / (2 * data[0].values.length),
                            availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length)
                        ]);
                    else
                        x.range(xRange || [
                            0,
                            availableWidth
                        ]);
                    y.domain(yDomain || d3.extent(seriesData.map(function (d) {
                        return d.y;
                    }).concat(forceY))).range(yRange || [
                        availableHeight,
                        0
                    ]);
                    z.domain(sizeDomain || d3.extent(seriesData.map(function (d) {
                        return d.size;
                    }).concat(forceSize))).range(sizeRange || _sizeRange_def);
                    singlePoint = x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1];
                    if (x.domain()[0] === x.domain()[1])
                        x.domain()[0] ? x.domain([
                            x.domain()[0] - x.domain()[0] * 0.01,
                            x.domain()[1] + x.domain()[1] * 0.01
                        ]) : x.domain([
                            -1,
                            1
                        ]);
                    if (y.domain()[0] === y.domain()[1])
                        y.domain()[0] ? y.domain([
                            y.domain()[0] - y.domain()[0] * 0.01,
                            y.domain()[1] + y.domain()[1] * 0.01
                        ]) : y.domain([
                            -1,
                            1
                        ]);
                    if (isNaN(x.domain()[0])) {
                        x.domain([
                            -1,
                            1
                        ]);
                    }
                    if (isNaN(y.domain()[0])) {
                        y.domain([
                            -1,
                            1
                        ]);
                    }
                    x0 = x0 || x;
                    y0 = y0 || y;
                    z0 = z0 || z;
                    var wrap = container.selectAll('g.nv-wrap.nv-scatter').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatter nv-chart-' + id);
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    wrap.classed('nv-single-point', singlePoint);
                    gEnter.append('g').attr('class', 'nv-groups');
                    gEnter.append('g').attr('class', 'nv-point-paths');
                    wrapEnter.append('g').attr('class', 'nv-point-clips');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + id).append('rect');
                    wrap.select('#nv-edge-clip-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight > 0 ? availableHeight : 0);
                    g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');
                    function updateInteractiveLayer() {
                        needsUpdate = false;
                        if (!interactive)
                            return false;
                        if (useVoronoi === true) {
                            var vertices = d3.merge(data.map(function (group, groupIndex) {
                                return group.values.map(function (point, pointIndex) {
                                    var pX = getX(point, pointIndex);
                                    var pY = getY(point, pointIndex);
                                    return [
                                        x(pX) + Math.random() * 0.0001,
                                        y(pY) + Math.random() * 0.0001,
                                        groupIndex,
                                        pointIndex,
                                        point
                                    ];
                                }).filter(function (pointArray, pointIndex) {
                                    return pointActive(pointArray[4], pointIndex);
                                });
                            }));
                            if (vertices.length == 0)
                                return false;
                            if (vertices.length < 3) {
                                vertices.push([
                                    x.range()[0] - 20,
                                    y.range()[0] - 20,
                                    null,
                                    null
                                ]);
                                vertices.push([
                                    x.range()[1] + 20,
                                    y.range()[1] + 20,
                                    null,
                                    null
                                ]);
                                vertices.push([
                                    x.range()[0] - 20,
                                    y.range()[0] + 20,
                                    null,
                                    null
                                ]);
                                vertices.push([
                                    x.range()[1] + 20,
                                    y.range()[1] - 20,
                                    null,
                                    null
                                ]);
                            }
                            var bounds = d3.geom.polygon([
                                [
                                    -10,
                                    -10
                                ],
                                [
                                    -10,
                                    height + 10
                                ],
                                [
                                    width + 10,
                                    height + 10
                                ],
                                [
                                    width + 10,
                                    -10
                                ]
                            ]);
                            var voronoi = d3.geom.voronoi(vertices).map(function (d, i) {
                                return {
                                    'data': bounds.clip(d),
                                    'series': vertices[i][2],
                                    'point': vertices[i][3]
                                };
                            });
                            wrap.select('.nv-point-paths').selectAll('path').remove();
                            var pointPaths = wrap.select('.nv-point-paths').selectAll('path').data(voronoi);
                            var vPointPaths = pointPaths.enter().append('svg:path').attr('d', function (d) {
                                if (!d || !d.data || d.data.length === 0)
                                    return 'M 0 0';
                                else
                                    return 'M' + d.data.join(',') + 'Z';
                            }).attr('id', function (d, i) {
                                return 'nv-path-' + i;
                            }).attr('clip-path', function (d, i) {
                                return 'url(#nv-clip-' + id + '-' + i + ')';
                            });
                            if (showVoronoi) {
                                vPointPaths.style('fill', d3.rgb(230, 230, 230)).style('fill-opacity', 0.4).style('stroke-opacity', 1).style('stroke', d3.rgb(200, 200, 200));
                            }
                            if (clipVoronoi) {
                                wrap.select('.nv-point-clips').selectAll('*').remove();
                                var pointClips = wrap.select('.nv-point-clips').selectAll('clipPath').data(vertices);
                                var vPointClips = pointClips.enter().append('svg:clipPath').attr('id', function (d, i) {
                                    return 'nv-clip-' + id + '-' + i;
                                }).append('svg:circle').attr('cx', function (d) {
                                    return d[0];
                                }).attr('cy', function (d) {
                                    return d[1];
                                }).attr('r', clipRadius);
                            }
                            var mouseEventCallback = function (d, mDispatch) {
                                if (needsUpdate)
                                    return 0;
                                var series = data[d.series];
                                if (series === undefined)
                                    return;
                                var point = series.values[d.point];
                                point['color'] = color(series, d.series);
                                point['x'] = getX(point);
                                point['y'] = getY(point);
                                var box = container.node().getBoundingClientRect();
                                var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                                var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                                var pos = {
                                    left: x(getX(point, d.point)) + box.left + scrollLeft + margin.left + 10,
                                    top: y(getY(point, d.point)) + box.top + scrollTop + margin.top + 10
                                };
                                mDispatch({
                                    point: point,
                                    series: series,
                                    pos: pos,
                                    relativePos: [
                                        x(getX(point, d.point)) + margin.left,
                                        y(getY(point, d.point)) + margin.top
                                    ],
                                    seriesIndex: d.series,
                                    pointIndex: d.point
                                });
                            };
                            pointPaths.on('click', function (d) {
                                mouseEventCallback(d, dispatch.elementClick);
                            }).on('dblclick', function (d) {
                                mouseEventCallback(d, dispatch.elementDblClick);
                            }).on('mouseover', function (d) {
                                mouseEventCallback(d, dispatch.elementMouseover);
                            }).on('mouseout', function (d, i) {
                                mouseEventCallback(d, dispatch.elementMouseout);
                            });
                        } else {
                            wrap.select('.nv-groups').selectAll('.nv-group').selectAll('.nv-point').on('click', function (d, i) {
                                if (needsUpdate || !data[d.series])
                                    return 0;
                                var series = data[d.series], point = series.values[i];
                                dispatch.elementClick({
                                    point: point,
                                    series: series,
                                    pos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    relativePos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    seriesIndex: d.series,
                                    pointIndex: i
                                });
                            }).on('dblclick', function (d, i) {
                                if (needsUpdate || !data[d.series])
                                    return 0;
                                var series = data[d.series], point = series.values[i];
                                dispatch.elementDblClick({
                                    point: point,
                                    series: series,
                                    pos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    relativePos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    seriesIndex: d.series,
                                    pointIndex: i
                                });
                            }).on('mouseover', function (d, i) {
                                if (needsUpdate || !data[d.series])
                                    return 0;
                                var series = data[d.series], point = series.values[i];
                                dispatch.elementMouseover({
                                    point: point,
                                    series: series,
                                    pos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    relativePos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    seriesIndex: d.series,
                                    pointIndex: i,
                                    color: color(d, i)
                                });
                            }).on('mouseout', function (d, i) {
                                if (needsUpdate || !data[d.series])
                                    return 0;
                                var series = data[d.series], point = series.values[i];
                                dispatch.elementMouseout({
                                    point: point,
                                    series: series,
                                    pos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    relativePos: [
                                        x(getX(point, i)) + margin.left,
                                        y(getY(point, i)) + margin.top
                                    ],
                                    seriesIndex: d.series,
                                    pointIndex: i,
                                    color: color(d, i)
                                });
                            });
                        }
                    }
                    needsUpdate = true;
                    var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {
                        return d;
                    }, function (d) {
                        return d.key;
                    });
                    groups.enter().append('g').style('stroke-opacity', 0.000001).style('fill-opacity', 0.000001);
                    groups.exit().remove();
                    groups.attr('class', function (d, i) {
                        return 'nv-group nv-series-' + i;
                    }).classed('hover', function (d) {
                        return d.hover;
                    });
                    groups.watchTransition(renderWatch, 'scatter: groups').style('fill', function (d, i) {
                        return color(d, i);
                    }).style('stroke', function (d, i) {
                        return color(d, i);
                    }).style('stroke-opacity', 1).style('fill-opacity', 0.5);
                    var points = groups.selectAll('path.nv-point').data(function (d) {
                        return d.values.map(function (point, pointIndex) {
                            return [
                                point,
                                pointIndex
                            ];
                        }).filter(function (pointArray, pointIndex) {
                            return pointActive(pointArray[0], pointIndex);
                        });
                    });
                    points.enter().append('path').style('fill', function (d) {
                        return d.color;
                    }).style('stroke', function (d) {
                        return d.color;
                    }).attr('transform', function (d) {
                        return 'translate(' + nv.utils.NaNtoZero(x0(getX(d[0], d[1]))) + ',' + nv.utils.NaNtoZero(y0(getY(d[0], d[1]))) + ')';
                    }).attr('d', nv.utils.symbol().type(function (d) {
                        return getShape(d[0]);
                    }).size(function (d) {
                        return z(getSize(d[0], d[1]));
                    }));
                    points.exit().remove();
                    groups.exit().selectAll('path.nv-point').watchTransition(renderWatch, 'scatter exit').attr('transform', function (d) {
                        return 'translate(' + x(getX(d[0], d[1])) + ',' + y(getY(d[0], d[1])) + ')';
                    }).remove();
                    points.each(function (d) {
                        d3.select(this).classed('nv-point', true).classed('nv-point-' + d[1], true).classed('nv-noninteractive', !interactive).classed('hover', false);
                    });
                    points.watchTransition(renderWatch, 'scatter points').attr('transform', function (d) {
                        return 'translate(' + x(getX(d[0], d[1])) + ',' + y(getY(d[0], d[1])) + ')';
                    }).attr('d', nv.utils.symbol().type(function (d) {
                        return getShape(d[0]);
                    }).size(function (d) {
                        return z(getSize(d[0], d[1]));
                    }));
                    clearTimeout(timeoutID);
                    timeoutID = setTimeout(updateInteractiveLayer, 300);
                    x0 = x.copy();
                    y0 = y.copy();
                    z0 = z.copy();
                });
                renderWatch.renderEnd('scatter immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._calls = new function () {
                this.clearHighlights = function () {
                    nv.dom.write(function () {
                        container.selectAll('.nv-point.hover').classed('hover', false);
                    });
                    return null;
                };
                this.highlightPoint = function (seriesIndex, pointIndex, isHoverOver) {
                    nv.dom.write(function () {
                        container.select('.nv-groups').selectAll('.nv-series-' + seriesIndex).selectAll('.nv-point-' + pointIndex).classed('hover', isHoverOver);
                    });
                };
            }();
            dispatch.on('elementMouseover.point', function (d) {
                if (interactive)
                    chart._calls.highlightPoint(d.seriesIndex, d.pointIndex, true);
            });
            dispatch.on('elementMouseout.point', function (d) {
                if (interactive)
                    chart._calls.highlightPoint(d.seriesIndex, d.pointIndex, false);
            });
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                pointScale: {
                    get: function () {
                        return z;
                    },
                    set: function (_) {
                        z = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                pointDomain: {
                    get: function () {
                        return sizeDomain;
                    },
                    set: function (_) {
                        sizeDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                pointRange: {
                    get: function () {
                        return sizeRange;
                    },
                    set: function (_) {
                        sizeRange = _;
                    }
                },
                forceX: {
                    get: function () {
                        return forceX;
                    },
                    set: function (_) {
                        forceX = _;
                    }
                },
                forceY: {
                    get: function () {
                        return forceY;
                    },
                    set: function (_) {
                        forceY = _;
                    }
                },
                forcePoint: {
                    get: function () {
                        return forceSize;
                    },
                    set: function (_) {
                        forceSize = _;
                    }
                },
                interactive: {
                    get: function () {
                        return interactive;
                    },
                    set: function (_) {
                        interactive = _;
                    }
                },
                pointActive: {
                    get: function () {
                        return pointActive;
                    },
                    set: function (_) {
                        pointActive = _;
                    }
                },
                padDataOuter: {
                    get: function () {
                        return padDataOuter;
                    },
                    set: function (_) {
                        padDataOuter = _;
                    }
                },
                padData: {
                    get: function () {
                        return padData;
                    },
                    set: function (_) {
                        padData = _;
                    }
                },
                clipEdge: {
                    get: function () {
                        return clipEdge;
                    },
                    set: function (_) {
                        clipEdge = _;
                    }
                },
                clipVoronoi: {
                    get: function () {
                        return clipVoronoi;
                    },
                    set: function (_) {
                        clipVoronoi = _;
                    }
                },
                clipRadius: {
                    get: function () {
                        return clipRadius;
                    },
                    set: function (_) {
                        clipRadius = _;
                    }
                },
                showVoronoi: {
                    get: function () {
                        return showVoronoi;
                    },
                    set: function (_) {
                        showVoronoi = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = d3.functor(_);
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = d3.functor(_);
                    }
                },
                pointSize: {
                    get: function () {
                        return getSize;
                    },
                    set: function (_) {
                        getSize = d3.functor(_);
                    }
                },
                pointShape: {
                    get: function () {
                        return getShape;
                    },
                    set: function (_) {
                        getShape = d3.functor(_);
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                useVoronoi: {
                    get: function () {
                        return useVoronoi;
                    },
                    set: function (_) {
                        useVoronoi = _;
                        if (useVoronoi === false) {
                            clipVoronoi = false;
                        }
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.scatterChart = function () {
            'use strict';
            var scatter = nv.models.scatter(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), distX = nv.models.distribution(), distY = nv.models.distribution(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 20,
                    bottom: 50,
                    left: 75
                }, width = null, height = null, container = null, color = nv.utils.defaultColor(), x = scatter.xScale(), y = scatter.yScale(), showDistX = false, showDistY = false, showLegend = true, showXAxis = true, showYAxis = true, rightAlignYAxis = false, state = nv.utils.state(), defaultState = null, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd'), noData = null, duration = 250;
            scatter.xScale(x).yScale(y);
            xAxis.orient('bottom').tickPadding(10);
            yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickPadding(10);
            distX.axis('x');
            distY.axis('y');
            tooltip.headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            }).valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            });
            var x0, y0, renderWatch = nv.utils.renderWatch(dispatch, duration);
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        })
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(scatter);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                if (showDistX)
                    renderWatch.models(distX);
                if (showDistY)
                    renderWatch.models(distY);
                selection.each(function (data) {
                    var that = this;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        if (duration === 0)
                            container.call(chart);
                        else
                            container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        renderWatch.renderEnd('scatter immediate');
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = scatter.xScale();
                    y = scatter.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('rect').attr('class', 'nvd3 nv-background').style('pointer-events', 'none');
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis');
                    gEnter.append('g').attr('class', 'nv-scatterWrap');
                    gEnter.append('g').attr('class', 'nv-regressionLinesWrap');
                    gEnter.append('g').attr('class', 'nv-distWrap');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    if (showLegend) {
                        var legendWidth = availableWidth;
                        legend.width(legendWidth);
                        wrap.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        wrap.select('.nv-legendWrap').attr('transform', 'translate(0' + ',' + -margin.top + ')');
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    scatter.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {
                        d.color = d.color || color(d, i);
                        return d.color;
                    }).filter(function (d, i) {
                        return !data[i].disabled;
                    }));
                    wrap.select('.nv-scatterWrap').datum(data.filter(function (d) {
                        return !d.disabled;
                    })).call(scatter);
                    wrap.select('.nv-regressionLinesWrap').attr('clip-path', 'url(#nv-edge-clip-' + scatter.id() + ')');
                    var regWrap = wrap.select('.nv-regressionLinesWrap').selectAll('.nv-regLines').data(function (d) {
                        return d;
                    });
                    regWrap.enter().append('g').attr('class', 'nv-regLines');
                    var regLine = regWrap.selectAll('.nv-regLine').data(function (d) {
                        return [d];
                    });
                    regLine.enter().append('line').attr('class', 'nv-regLine').style('stroke-opacity', 0);
                    regLine.filter(function (d) {
                        return d.intercept && d.slope;
                    }).watchTransition(renderWatch, 'scatterPlusLineChart: regline').attr('x1', x.range()[0]).attr('x2', x.range()[1]).attr('y1', function (d, i) {
                        return y(x.domain()[0] * d.slope + d.intercept);
                    }).attr('y2', function (d, i) {
                        return y(x.domain()[1] * d.slope + d.intercept);
                    }).style('stroke', function (d, i, j) {
                        return color(d, j);
                    }).style('stroke-opacity', function (d, i) {
                        return d.disabled || typeof d.slope === 'undefined' || typeof d.intercept === 'undefined' ? 0 : 1;
                    });
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')').call(xAxis);
                    }
                    if (showYAxis) {
                        yAxis.scale(y)._ticks(nv.utils.calcTicksY(availableHeight / 36, data)).tickSize(-availableWidth, 0);
                        g.select('.nv-y.nv-axis').call(yAxis);
                    }
                    if (showDistX) {
                        distX.getData(scatter.x()).scale(x).width(availableWidth).color(data.map(function (d, i) {
                            return d.color || color(d, i);
                        }).filter(function (d, i) {
                            return !data[i].disabled;
                        }));
                        gEnter.select('.nv-distWrap').append('g').attr('class', 'nv-distributionX');
                        g.select('.nv-distributionX').attr('transform', 'translate(0,' + y.range()[0] + ')').datum(data.filter(function (d) {
                            return !d.disabled;
                        })).call(distX);
                    }
                    if (showDistY) {
                        distY.getData(scatter.y()).scale(y).width(availableHeight).color(data.map(function (d, i) {
                            return d.color || color(d, i);
                        }).filter(function (d, i) {
                            return !data[i].disabled;
                        }));
                        gEnter.select('.nv-distWrap').append('g').attr('class', 'nv-distributionY');
                        g.select('.nv-distributionY').attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size()) + ',0)').datum(data.filter(function (d) {
                            return !d.disabled;
                        })).call(distY);
                    }
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined') {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        chart.update();
                    });
                    scatter.dispatch.on('elementMouseout.tooltip', function (evt) {
                        tooltip.hidden(true);
                        container.select('.nv-chart-' + scatter.id() + ' .nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex).attr('y1', 0);
                        container.select('.nv-chart-' + scatter.id() + ' .nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex).attr('x2', distY.size());
                    });
                    scatter.dispatch.on('elementMouseover.tooltip', function (evt) {
                        container.select('.nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex).attr('y1', evt.relativePos[1] - availableHeight);
                        container.select('.nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex).attr('x2', evt.relativePos[0] + distX.size());
                        tooltip.data(evt).hidden(false);
                    });
                    x0 = x.copy();
                    y0 = y.copy();
                });
                renderWatch.renderEnd('scatter with line immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.scatter = scatter;
            chart.legend = legend;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.distX = distX;
            chart.distY = distY;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                container: {
                    get: function () {
                        return container;
                    },
                    set: function (_) {
                        container = _;
                    }
                },
                showDistX: {
                    get: function () {
                        return showDistX;
                    },
                    set: function (_) {
                        showDistX = _;
                    }
                },
                showDistY: {
                    get: function () {
                        return showDistY;
                    },
                    set: function (_) {
                        showDistY = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(_ ? 'right' : 'left');
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                        distX.color(color);
                        distY.color(color);
                    }
                }
            });
            nv.utils.inheritOptions(chart, scatter);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.sparkline = function () {
            'use strict';
            var margin = {
                    top: 2,
                    right: 0,
                    bottom: 2,
                    left: 0
                }, width = 400, height = 32, container = null, animate = true, x = d3.scale.linear(), y = d3.scale.linear(), getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, color = nv.utils.getColor(['#000']), xDomain, yDomain, xRange, yRange;
            function chart(selection) {
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    x.domain(xDomain || d3.extent(data, getX)).range(xRange || [
                        0,
                        availableWidth
                    ]);
                    y.domain(yDomain || d3.extent(data, getY)).range(yRange || [
                        availableHeight,
                        0
                    ]);
                    var wrap = container.selectAll('g.nv-wrap.nv-sparkline').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparkline');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var paths = wrap.selectAll('path').data(function (d) {
                        return [d];
                    });
                    paths.enter().append('path');
                    paths.exit().remove();
                    paths.style('stroke', function (d, i) {
                        return d.color || color(d, i);
                    }).attr('d', d3.svg.line().x(function (d, i) {
                        return x(getX(d, i));
                    }).y(function (d, i) {
                        return y(getY(d, i));
                    }));
                    var points = wrap.selectAll('circle.nv-point').data(function (data) {
                        var yValues = data.map(function (d, i) {
                            return getY(d, i);
                        });
                        function pointIndex(index) {
                            if (index != -1) {
                                var result = data[index];
                                result.pointIndex = index;
                                return result;
                            } else {
                                return null;
                            }
                        }
                        var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])), minPoint = pointIndex(yValues.indexOf(y.domain()[0])), currentPoint = pointIndex(yValues.length - 1);
                        return [
                            minPoint,
                            maxPoint,
                            currentPoint
                        ].filter(function (d) {
                            return d != null;
                        });
                    });
                    points.enter().append('circle');
                    points.exit().remove();
                    points.attr('cx', function (d, i) {
                        return x(getX(d, d.pointIndex));
                    }).attr('cy', function (d, i) {
                        return y(getY(d, d.pointIndex));
                    }).attr('r', 2).attr('class', function (d, i) {
                        return getX(d, d.pointIndex) == x.domain()[1] ? 'nv-point nv-currentValue' : getY(d, d.pointIndex) == y.domain()[0] ? 'nv-point nv-minValue' : 'nv-point nv-maxValue';
                    });
                });
                return chart;
            }
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                xDomain: {
                    get: function () {
                        return xDomain;
                    },
                    set: function (_) {
                        xDomain = _;
                    }
                },
                yDomain: {
                    get: function () {
                        return yDomain;
                    },
                    set: function (_) {
                        yDomain = _;
                    }
                },
                xRange: {
                    get: function () {
                        return xRange;
                    },
                    set: function (_) {
                        xRange = _;
                    }
                },
                yRange: {
                    get: function () {
                        return yRange;
                    },
                    set: function (_) {
                        yRange = _;
                    }
                },
                xScale: {
                    get: function () {
                        return x;
                    },
                    set: function (_) {
                        x = _;
                    }
                },
                yScale: {
                    get: function () {
                        return y;
                    },
                    set: function (_) {
                        y = _;
                    }
                },
                animate: {
                    get: function () {
                        return animate;
                    },
                    set: function (_) {
                        animate = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = d3.functor(_);
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = d3.functor(_);
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.sparklinePlus = function () {
            'use strict';
            var sparkline = nv.models.sparkline();
            var margin = {
                    top: 15,
                    right: 100,
                    bottom: 10,
                    left: 50
                }, width = null, height = null, x, y, index = [], paused = false, xTickFormat = d3.format(',r'), yTickFormat = d3.format(',.2f'), showLastValue = true, alignValue = true, rightAlignValue = false, noData = null;
            function chart(selection) {
                selection.each(function (data) {
                    var container = d3.select(this);
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        container.call(chart);
                    };
                    chart.container = this;
                    if (!data || !data.length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    var currentValue = sparkline.y()(data[data.length - 1], data.length - 1);
                    x = sparkline.xScale();
                    y = sparkline.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-sparklineplus').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparklineplus');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-sparklineWrap');
                    gEnter.append('g').attr('class', 'nv-valueWrap');
                    gEnter.append('g').attr('class', 'nv-hoverArea');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    var sparklineWrap = g.select('.nv-sparklineWrap');
                    sparkline.width(availableWidth).height(availableHeight);
                    sparklineWrap.call(sparkline);
                    if (showLastValue) {
                        var valueWrap = g.select('.nv-valueWrap');
                        var value = valueWrap.selectAll('.nv-currentValue').data([currentValue]);
                        value.enter().append('text').attr('class', 'nv-currentValue').attr('dx', rightAlignValue ? -8 : 8).attr('dy', '.9em').style('text-anchor', rightAlignValue ? 'end' : 'start');
                        value.attr('x', availableWidth + (rightAlignValue ? margin.right : 0)).attr('y', alignValue ? function (d) {
                            return y(d);
                        } : 0).style('fill', sparkline.color()(data[data.length - 1], data.length - 1)).text(yTickFormat(currentValue));
                    }
                    gEnter.select('.nv-hoverArea').append('rect').on('mousemove', sparklineHover).on('click', function () {
                        paused = !paused;
                    }).on('mouseout', function () {
                        index = [];
                        updateValueLine();
                    });
                    g.select('.nv-hoverArea rect').attr('transform', function (d) {
                        return 'translate(' + -margin.left + ',' + -margin.top + ')';
                    }).attr('width', availableWidth + margin.left + margin.right).attr('height', availableHeight + margin.top);
                    function updateValueLine() {
                        if (paused)
                            return;
                        var hoverValue = g.selectAll('.nv-hoverValue').data(index);
                        var hoverEnter = hoverValue.enter().append('g').attr('class', 'nv-hoverValue').style('stroke-opacity', 0).style('fill-opacity', 0);
                        hoverValue.exit().transition().duration(250).style('stroke-opacity', 0).style('fill-opacity', 0).remove();
                        hoverValue.attr('transform', function (d) {
                            return 'translate(' + x(sparkline.x()(data[d], d)) + ',0)';
                        }).transition().duration(250).style('stroke-opacity', 1).style('fill-opacity', 1);
                        if (!index.length)
                            return;
                        hoverEnter.append('line').attr('x1', 0).attr('y1', -margin.top).attr('x2', 0).attr('y2', availableHeight);
                        hoverEnter.append('text').attr('class', 'nv-xValue').attr('x', -6).attr('y', -margin.top).attr('text-anchor', 'end').attr('dy', '.9em');
                        g.select('.nv-hoverValue .nv-xValue').text(xTickFormat(sparkline.x()(data[index[0]], index[0])));
                        hoverEnter.append('text').attr('class', 'nv-yValue').attr('x', 6).attr('y', -margin.top).attr('text-anchor', 'start').attr('dy', '.9em');
                        g.select('.nv-hoverValue .nv-yValue').text(yTickFormat(sparkline.y()(data[index[0]], index[0])));
                    }
                    function sparklineHover() {
                        if (paused)
                            return;
                        var pos = d3.mouse(this)[0] - margin.left;
                        function getClosestIndex(data, x) {
                            var distance = Math.abs(sparkline.x()(data[0], 0) - x);
                            var closestIndex = 0;
                            for (var i = 0; i < data.length; i++) {
                                if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {
                                    distance = Math.abs(sparkline.x()(data[i], i) - x);
                                    closestIndex = i;
                                }
                            }
                            return closestIndex;
                        }
                        index = [getClosestIndex(data, Math.round(x.invert(pos)))];
                        updateValueLine();
                    }
                });
                return chart;
            }
            chart.sparkline = sparkline;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                xTickFormat: {
                    get: function () {
                        return xTickFormat;
                    },
                    set: function (_) {
                        xTickFormat = _;
                    }
                },
                yTickFormat: {
                    get: function () {
                        return yTickFormat;
                    },
                    set: function (_) {
                        yTickFormat = _;
                    }
                },
                showLastValue: {
                    get: function () {
                        return showLastValue;
                    },
                    set: function (_) {
                        showLastValue = _;
                    }
                },
                alignValue: {
                    get: function () {
                        return alignValue;
                    },
                    set: function (_) {
                        alignValue = _;
                    }
                },
                rightAlignValue: {
                    get: function () {
                        return rightAlignValue;
                    },
                    set: function (_) {
                        rightAlignValue = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                }
            });
            nv.utils.inheritOptions(chart, sparkline);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.stackedArea = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = 960, height = 500, color = nv.utils.defaultColor(), id = Math.floor(Math.random() * 100000), container = null, getX = function (d) {
                    return d.x;
                }, getY = function (d) {
                    return d.y;
                }, style = 'stack', offset = 'zero', order = 'default', interpolate = 'linear', clipEdge = false, x, y, scatter = nv.models.scatter(), duration = 250, dispatch = d3.dispatch('areaClick', 'areaMouseover', 'areaMouseout', 'renderEnd', 'elementClick', 'elementMouseover', 'elementMouseout');
            scatter.pointSize(2.2).pointDomain([
                2.2,
                2.2
            ]);
            var renderWatch = nv.utils.renderWatch(dispatch, duration);
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(scatter);
                selection.each(function (data) {
                    var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom;
                    container = d3.select(this);
                    nv.utils.initSVG(container);
                    x = scatter.xScale();
                    y = scatter.yScale();
                    var dataRaw = data;
                    data.forEach(function (aseries, i) {
                        aseries.seriesIndex = i;
                        aseries.values = aseries.values.map(function (d, j) {
                            d.index = j;
                            d.seriesIndex = i;
                            return d;
                        });
                    });
                    var dataFiltered = data.filter(function (series) {
                        return !series.disabled;
                    });
                    data = d3.layout.stack().order(order).offset(offset).values(function (d) {
                        return d.values;
                    }).x(getX).y(getY).out(function (d, y0, y) {
                        d.display = {
                            y: y,
                            y0: y0
                        };
                    })(dataFiltered);
                    var wrap = container.selectAll('g.nv-wrap.nv-stackedarea').data([data]);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedarea');
                    var defsEnter = wrapEnter.append('defs');
                    var gEnter = wrapEnter.append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-areaWrap');
                    gEnter.append('g').attr('class', 'nv-scatterWrap');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (scatter.forceY().length == 0) {
                        scatter.forceY().push(0);
                    }
                    scatter.width(availableWidth).height(availableHeight).x(getX).y(function (d) {
                        if (d.display !== undefined) {
                            return d.display.y + d.display.y0;
                        }
                    }).forceY([0]).color(data.map(function (d, i) {
                        return d.color || color(d, d.seriesIndex);
                    }));
                    var scatterWrap = g.select('.nv-scatterWrap').datum(data);
                    scatterWrap.call(scatter);
                    defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + id).append('rect');
                    wrap.select('#nv-edge-clip-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);
                    g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');
                    var area = d3.svg.area().x(function (d, i) {
                        return x(getX(d, i));
                    }).y0(function (d) {
                        return y(d.display.y0);
                    }).y1(function (d) {
                        return y(d.display.y + d.display.y0);
                    }).interpolate(interpolate);
                    var zeroArea = d3.svg.area().x(function (d, i) {
                        return x(getX(d, i));
                    }).y0(function (d) {
                        return y(d.display.y0);
                    }).y1(function (d) {
                        return y(d.display.y0);
                    });
                    var path = g.select('.nv-areaWrap').selectAll('path.nv-area').data(function (d) {
                        return d;
                    });
                    path.enter().append('path').attr('class', function (d, i) {
                        return 'nv-area nv-area-' + i;
                    }).attr('d', function (d, i) {
                        return zeroArea(d.values, d.seriesIndex);
                    }).on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true);
                        dispatch.areaMouseover({
                            point: d,
                            series: d.key,
                            pos: [
                                d3.event.pageX,
                                d3.event.pageY
                            ],
                            seriesIndex: d.seriesIndex
                        });
                    }).on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false);
                        dispatch.areaMouseout({
                            point: d,
                            series: d.key,
                            pos: [
                                d3.event.pageX,
                                d3.event.pageY
                            ],
                            seriesIndex: d.seriesIndex
                        });
                    }).on('click', function (d, i) {
                        d3.select(this).classed('hover', false);
                        dispatch.areaClick({
                            point: d,
                            series: d.key,
                            pos: [
                                d3.event.pageX,
                                d3.event.pageY
                            ],
                            seriesIndex: d.seriesIndex
                        });
                    });
                    path.exit().remove();
                    path.style('fill', function (d, i) {
                        return d.color || color(d, d.seriesIndex);
                    }).style('stroke', function (d, i) {
                        return d.color || color(d, d.seriesIndex);
                    });
                    path.watchTransition(renderWatch, 'stackedArea path').attr('d', function (d, i) {
                        return area(d.values, i);
                    });
                    scatter.dispatch.on('elementMouseover.area', function (e) {
                        g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', true);
                    });
                    scatter.dispatch.on('elementMouseout.area', function (e) {
                        g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', false);
                    });
                    chart.d3_stackedOffset_stackPercent = function (stackData) {
                        var n = stackData.length, m = stackData[0].length, i, j, o, y0 = [];
                        for (j = 0; j < m; ++j) {
                            for (i = 0, o = 0; i < dataRaw.length; i++) {
                                o += getY(dataRaw[i].values[j]);
                            }
                            if (o)
                                for (i = 0; i < n; i++) {
                                    stackData[i][j][1] /= o;
                                }
                            else {
                                for (i = 0; i < n; i++) {
                                    stackData[i][j][1] = 0;
                                }
                            }
                        }
                        for (j = 0; j < m; ++j)
                            y0[j] = 0;
                        return y0;
                    };
                });
                renderWatch.renderEnd('stackedArea immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.scatter = scatter;
            scatter.dispatch.on('elementClick', function () {
                dispatch.elementClick.apply(this, arguments);
            });
            scatter.dispatch.on('elementMouseover', function () {
                dispatch.elementMouseover.apply(this, arguments);
            });
            scatter.dispatch.on('elementMouseout', function () {
                dispatch.elementMouseout.apply(this, arguments);
            });
            chart.interpolate = function (_) {
                if (!arguments.length)
                    return interpolate;
                interpolate = _;
                return chart;
            };
            chart.duration = function (_) {
                if (!arguments.length)
                    return duration;
                duration = _;
                renderWatch.reset(duration);
                scatter.duration(duration);
                return chart;
            };
            chart.dispatch = dispatch;
            chart.scatter = scatter;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                clipEdge: {
                    get: function () {
                        return clipEdge;
                    },
                    set: function (_) {
                        clipEdge = _;
                    }
                },
                offset: {
                    get: function () {
                        return offset;
                    },
                    set: function (_) {
                        offset = _;
                    }
                },
                order: {
                    get: function () {
                        return order;
                    },
                    set: function (_) {
                        order = _;
                    }
                },
                interpolate: {
                    get: function () {
                        return interpolate;
                    },
                    set: function (_) {
                        interpolate = _;
                    }
                },
                x: {
                    get: function () {
                        return getX;
                    },
                    set: function (_) {
                        getX = d3.functor(_);
                    }
                },
                y: {
                    get: function () {
                        return getY;
                    },
                    set: function (_) {
                        getY = d3.functor(_);
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                },
                style: {
                    get: function () {
                        return style;
                    },
                    set: function (_) {
                        style = _;
                        switch (style) {
                        case 'stack':
                            chart.offset('zero');
                            chart.order('default');
                            break;
                        case 'stream':
                            chart.offset('wiggle');
                            chart.order('inside-out');
                            break;
                        case 'stream-center':
                            chart.offset('silhouette');
                            chart.order('inside-out');
                            break;
                        case 'expand':
                            chart.offset('expand');
                            chart.order('default');
                            break;
                        case 'stack_percent':
                            chart.offset(chart.d3_stackedOffset_stackPercent);
                            chart.order('default');
                            break;
                        }
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        scatter.duration(duration);
                    }
                }
            });
            nv.utils.inheritOptions(chart, scatter);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.stackedAreaChart = function () {
            'use strict';
            var stacked = nv.models.stackedArea(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend(), interactiveLayer = nv.interactiveGuideline(), tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 25,
                    bottom: 50,
                    left: 60
                }, width = null, height = null, color = nv.utils.defaultColor(), showControls = true, showLegend = true, showXAxis = true, showYAxis = true, rightAlignYAxis = false, useInteractiveGuideline = false, showTotalInTooltip = true, totalLabel = 'TOTAL', x, y, state = nv.utils.state(), defaultState = null, noData = null, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd'), controlWidth = 250, controlOptions = [
                    'Stacked',
                    'Stream',
                    'Expanded'
                ], controlLabels = {}, duration = 250;
            state.style = stacked.style();
            xAxis.orient('bottom').tickPadding(7);
            yAxis.orient(rightAlignYAxis ? 'right' : 'left');
            tooltip.headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            }).valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            });
            interactiveLayer.tooltip.headerFormatter(function (d, i) {
                return xAxis.tickFormat()(d, i);
            }).valueFormatter(function (d, i) {
                return yAxis.tickFormat()(d, i);
            });
            var oldYTickFormat = null, oldValueFormatter = null;
            controls.updateState(false);
            var renderWatch = nv.utils.renderWatch(dispatch);
            var style = stacked.style();
            var stateGetter = function (data) {
                return function () {
                    return {
                        active: data.map(function (d) {
                            return !d.disabled;
                        }),
                        style: stacked.style()
                    };
                };
            };
            var stateSetter = function (data) {
                return function (state) {
                    if (state.style !== undefined)
                        style = state.style;
                    if (state.active !== undefined)
                        data.forEach(function (series, i) {
                            series.disabled = !state.active[i];
                        });
                };
            };
            var percentFormatter = d3.format('%');
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(stacked);
                if (showXAxis)
                    renderWatch.models(xAxis);
                if (showYAxis)
                    renderWatch.models(yAxis);
                selection.each(function (data) {
                    var container = d3.select(this), that = this;
                    nv.utils.initSVG(container);
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    state.setter(stateSetter(data), chart.update).getter(stateGetter(data)).update();
                    state.disabled = data.map(function (d) {
                        return !!d.disabled;
                    });
                    if (!defaultState) {
                        var key;
                        defaultState = {};
                        for (key in state) {
                            if (state[key] instanceof Array)
                                defaultState[key] = state[key].slice(0);
                            else
                                defaultState[key] = state[key];
                        }
                    }
                    if (!data || !data.length || !data.filter(function (d) {
                            return d.values.length;
                        }).length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    x = stacked.xScale();
                    y = stacked.yScale();
                    var wrap = container.selectAll('g.nv-wrap.nv-stackedAreaChart').data([data]);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedAreaChart').append('g');
                    var g = wrap.select('g');
                    gEnter.append('rect').style('opacity', 0);
                    gEnter.append('g').attr('class', 'nv-x nv-axis');
                    gEnter.append('g').attr('class', 'nv-y nv-axis');
                    gEnter.append('g').attr('class', 'nv-stackedWrap');
                    gEnter.append('g').attr('class', 'nv-legendWrap');
                    gEnter.append('g').attr('class', 'nv-controlsWrap');
                    gEnter.append('g').attr('class', 'nv-interactive');
                    g.select('rect').attr('width', availableWidth).attr('height', availableHeight);
                    if (showLegend) {
                        var legendWidth = showControls ? availableWidth - controlWidth : availableWidth;
                        legend.width(legendWidth);
                        g.select('.nv-legendWrap').datum(data).call(legend);
                        if (margin.top != legend.height()) {
                            margin.top = legend.height();
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        g.select('.nv-legendWrap').attr('transform', 'translate(' + (availableWidth - legendWidth) + ',' + -margin.top + ')');
                    }
                    if (showControls) {
                        var controlsData = [
                            {
                                key: controlLabels.stacked || 'Stacked',
                                metaKey: 'Stacked',
                                disabled: stacked.style() != 'stack',
                                style: 'stack'
                            },
                            {
                                key: controlLabels.stream || 'Stream',
                                metaKey: 'Stream',
                                disabled: stacked.style() != 'stream',
                                style: 'stream'
                            },
                            {
                                key: controlLabels.expanded || 'Expanded',
                                metaKey: 'Expanded',
                                disabled: stacked.style() != 'expand',
                                style: 'expand'
                            },
                            {
                                key: controlLabels.stack_percent || 'Stack %',
                                metaKey: 'Stack_Percent',
                                disabled: stacked.style() != 'stack_percent',
                                style: 'stack_percent'
                            }
                        ];
                        controlWidth = controlOptions.length / 3 * 260;
                        controlsData = controlsData.filter(function (d) {
                            return controlOptions.indexOf(d.metaKey) !== -1;
                        });
                        controls.width(controlWidth).color([
                            '#444',
                            '#444',
                            '#444'
                        ]);
                        g.select('.nv-controlsWrap').datum(controlsData).call(controls);
                        if (margin.top != Math.max(controls.height(), legend.height())) {
                            margin.top = Math.max(controls.height(), legend.height());
                            availableHeight = nv.utils.availableHeight(height, container, margin);
                        }
                        g.select('.nv-controlsWrap').attr('transform', 'translate(0,' + -margin.top + ')');
                    }
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    if (rightAlignYAxis) {
                        g.select('.nv-y.nv-axis').attr('transform', 'translate(' + availableWidth + ',0)');
                    }
                    if (useInteractiveGuideline) {
                        interactiveLayer.width(availableWidth).height(availableHeight).margin({
                            left: margin.left,
                            top: margin.top
                        }).svgContainer(container).xScale(x);
                        wrap.select('.nv-interactive').call(interactiveLayer);
                    }
                    stacked.width(availableWidth).height(availableHeight);
                    var stackedWrap = g.select('.nv-stackedWrap').datum(data);
                    stackedWrap.transition().call(stacked);
                    if (showXAxis) {
                        xAxis.scale(x)._ticks(nv.utils.calcTicksX(availableWidth / 100, data)).tickSize(-availableHeight, 0);
                        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + availableHeight + ')');
                        g.select('.nv-x.nv-axis').transition().duration(0).call(xAxis);
                    }
                    if (showYAxis) {
                        var ticks;
                        if (stacked.offset() === 'wiggle') {
                            ticks = 0;
                        } else {
                            ticks = nv.utils.calcTicksY(availableHeight / 36, data);
                        }
                        yAxis.scale(y)._ticks(ticks).tickSize(-availableWidth, 0);
                        if (stacked.style() === 'expand' || stacked.style() === 'stack_percent') {
                            var currentFormat = yAxis.tickFormat();
                            if (!oldYTickFormat || currentFormat !== percentFormatter)
                                oldYTickFormat = currentFormat;
                            yAxis.tickFormat(percentFormatter);
                        } else {
                            if (oldYTickFormat) {
                                yAxis.tickFormat(oldYTickFormat);
                                oldYTickFormat = null;
                            }
                        }
                        g.select('.nv-y.nv-axis').transition().duration(0).call(yAxis);
                    }
                    stacked.dispatch.on('areaClick.toggle', function (e) {
                        if (data.filter(function (d) {
                                return !d.disabled;
                            }).length === 1)
                            data.forEach(function (d) {
                                d.disabled = false;
                            });
                        else
                            data.forEach(function (d, i) {
                                d.disabled = i != e.seriesIndex;
                            });
                        state.disabled = data.map(function (d) {
                            return !!d.disabled;
                        });
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    legend.dispatch.on('stateChange', function (newState) {
                        for (var key in newState)
                            state[key] = newState[key];
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    controls.dispatch.on('legendClick', function (d, i) {
                        if (!d.disabled)
                            return;
                        controlsData = controlsData.map(function (s) {
                            s.disabled = true;
                            return s;
                        });
                        d.disabled = false;
                        stacked.style(d.style);
                        state.style = stacked.style();
                        dispatch.stateChange(state);
                        chart.update();
                    });
                    interactiveLayer.dispatch.on('elementMousemove', function (e) {
                        stacked.clearHighlights();
                        var singlePoint, pointIndex, pointXLocation, allData = [], valueSum = 0;
                        data.filter(function (series, i) {
                            series.seriesIndex = i;
                            return !series.disabled;
                        }).forEach(function (series, i) {
                            pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                            var point = series.values[pointIndex];
                            var pointYValue = chart.y()(point, pointIndex);
                            if (pointYValue != null) {
                                stacked.highlightPoint(i, pointIndex, true);
                            }
                            if (typeof point === 'undefined')
                                return;
                            if (typeof singlePoint === 'undefined')
                                singlePoint = point;
                            if (typeof pointXLocation === 'undefined')
                                pointXLocation = chart.xScale()(chart.x()(point, pointIndex));
                            var tooltipValue = stacked.style() == 'expand' ? point.display.y : chart.y()(point, pointIndex);
                            allData.push({
                                key: series.key,
                                value: tooltipValue,
                                color: color(series, series.seriesIndex),
                                stackedValue: point.display
                            });
                            if (showTotalInTooltip && stacked.style() != 'expand') {
                                valueSum += tooltipValue;
                            }
                            ;
                        });
                        allData.reverse();
                        if (allData.length > 2) {
                            var yValue = chart.yScale().invert(e.mouseY);
                            var yDistMax = Infinity, indexToHighlight = null;
                            allData.forEach(function (series, i) {
                                yValue = Math.abs(yValue);
                                var stackedY0 = Math.abs(series.stackedValue.y0);
                                var stackedY = Math.abs(series.stackedValue.y);
                                if (yValue >= stackedY0 && yValue <= stackedY + stackedY0) {
                                    indexToHighlight = i;
                                    return;
                                }
                            });
                            if (indexToHighlight != null)
                                allData[indexToHighlight].highlight = true;
                        }
                        if (showTotalInTooltip && stacked.style() != 'expand' && allData.length >= 2) {
                            allData.push({
                                key: totalLabel,
                                value: valueSum,
                                total: true
                            });
                        }
                        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex));
                        var valueFormatter = interactiveLayer.tooltip.valueFormatter();
                        if (stacked.style() === 'expand' || stacked.style() === 'stack_percent') {
                            if (!oldValueFormatter) {
                                oldValueFormatter = valueFormatter;
                            }
                            valueFormatter = d3.format('.1%');
                        } else {
                            if (oldValueFormatter) {
                                valueFormatter = oldValueFormatter;
                                oldValueFormatter = null;
                            }
                        }
                        interactiveLayer.tooltip.chartContainer(that.parentNode).valueFormatter(valueFormatter).data({
                            value: xValue,
                            series: allData
                        })();
                        interactiveLayer.renderGuideLine(pointXLocation);
                    });
                    interactiveLayer.dispatch.on('elementMouseout', function (e) {
                        stacked.clearHighlights();
                    });
                    dispatch.on('changeState', function (e) {
                        if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                            data.forEach(function (series, i) {
                                series.disabled = e.disabled[i];
                            });
                            state.disabled = e.disabled;
                        }
                        if (typeof e.style !== 'undefined') {
                            stacked.style(e.style);
                            style = e.style;
                        }
                        chart.update();
                    });
                });
                renderWatch.renderEnd('stacked Area chart immediate');
                return chart;
            }
            stacked.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt.point['x'] = stacked.x()(evt.point);
                evt.point['y'] = stacked.y()(evt.point);
                tooltip.data(evt).hidden(false);
            });
            stacked.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            chart.dispatch = dispatch;
            chart.stacked = stacked;
            chart.legend = legend;
            chart.controls = controls;
            chart.xAxis = xAxis;
            chart.yAxis = yAxis;
            chart.interactiveLayer = interactiveLayer;
            chart.tooltip = tooltip;
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                showLegend: {
                    get: function () {
                        return showLegend;
                    },
                    set: function (_) {
                        showLegend = _;
                    }
                },
                showXAxis: {
                    get: function () {
                        return showXAxis;
                    },
                    set: function (_) {
                        showXAxis = _;
                    }
                },
                showYAxis: {
                    get: function () {
                        return showYAxis;
                    },
                    set: function (_) {
                        showYAxis = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                showControls: {
                    get: function () {
                        return showControls;
                    },
                    set: function (_) {
                        showControls = _;
                    }
                },
                controlLabels: {
                    get: function () {
                        return controlLabels;
                    },
                    set: function (_) {
                        controlLabels = _;
                    }
                },
                controlOptions: {
                    get: function () {
                        return controlOptions;
                    },
                    set: function (_) {
                        controlOptions = _;
                    }
                },
                showTotalInTooltip: {
                    get: function () {
                        return showTotalInTooltip;
                    },
                    set: function (_) {
                        showTotalInTooltip = _;
                    }
                },
                totalLabel: {
                    get: function () {
                        return totalLabel;
                    },
                    set: function (_) {
                        totalLabel = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        stacked.duration(duration);
                        xAxis.duration(duration);
                        yAxis.duration(duration);
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                        legend.color(color);
                        stacked.color(color);
                    }
                },
                rightAlignYAxis: {
                    get: function () {
                        return rightAlignYAxis;
                    },
                    set: function (_) {
                        rightAlignYAxis = _;
                        yAxis.orient(rightAlignYAxis ? 'right' : 'left');
                    }
                },
                useInteractiveGuideline: {
                    get: function () {
                        return useInteractiveGuideline;
                    },
                    set: function (_) {
                        useInteractiveGuideline = !!_;
                        chart.interactive(!_);
                        chart.useVoronoi(!_);
                        stacked.scatter.interactive(!_);
                    }
                }
            });
            nv.utils.inheritOptions(chart, stacked);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.sunburst = function () {
            'use strict';
            var margin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }, width = null, height = null, mode = 'count', modes = {
                    count: function (d) {
                        return 1;
                    },
                    size: function (d) {
                        return d.size;
                    }
                }, id = Math.floor(Math.random() * 10000), container = null, color = nv.utils.defaultColor(), duration = 500, dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMousemove', 'elementMouseover', 'elementMouseout', 'renderEnd');
            var x = d3.scale.linear().range([
                0,
                2 * Math.PI
            ]);
            var y = d3.scale.sqrt();
            var partition = d3.layout.partition().sort(null).value(function (d) {
                return 1;
            });
            var arc = d3.svg.arc().startAngle(function (d) {
                return Math.max(0, Math.min(2 * Math.PI, x(d.x)));
            }).endAngle(function (d) {
                return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
            }).innerRadius(function (d) {
                return Math.max(0, y(d.y));
            }).outerRadius(function (d) {
                return Math.max(0, y(d.y + d.dy));
            });
            var node, prevNode;
            var rootNode;
            var renderWatch = nv.utils.renderWatch(dispatch);
            function chart(selection) {
                renderWatch.reset();
                selection.each(function (data) {
                    container = d3.select(this);
                    var availableWidth = nv.utils.availableWidth(width, container, margin);
                    var availableHeight = nv.utils.availableHeight(height, container, margin);
                    var radius = Math.min(availableWidth, availableHeight) / 2;
                    var path;
                    nv.utils.initSVG(container);
                    var wrap = container.selectAll('.nv-wrap.nv-sunburst').data(data);
                    var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sunburst nv-chart-' + id);
                    var g = wrapEnter.selectAll('nv-sunburst');
                    wrap.attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
                    container.on('click', function (d, i) {
                        dispatch.chartClick({
                            data: d,
                            index: i,
                            pos: d3.event,
                            id: id
                        });
                    });
                    y.range([
                        0,
                        radius
                    ]);
                    node = node || data;
                    rootNode = data[0];
                    partition.value(modes[mode] || modes['count']);
                    path = g.data(partition.nodes).enter().append('path').attr('d', arc).style('fill', function (d) {
                        return color((d.children ? d : d.parent).name);
                    }).style('stroke', '#FFF').on('click', function (d) {
                        if (prevNode !== node && node !== d)
                            prevNode = node;
                        node = d;
                        path.transition().duration(duration).attrTween('d', arcTweenZoom(d));
                    }).each(stash).on('dblclick', function (d) {
                        if (prevNode.parent == d) {
                            path.transition().duration(duration).attrTween('d', arcTweenZoom(rootNode));
                        }
                    }).each(stash).on('mouseover', function (d, i) {
                        d3.select(this).classed('hover', true).style('opacity', 0.8);
                        dispatch.elementMouseover({
                            data: d,
                            color: d3.select(this).style('fill')
                        });
                    }).on('mouseout', function (d, i) {
                        d3.select(this).classed('hover', false).style('opacity', 1);
                        dispatch.elementMouseout({ data: d });
                    }).on('mousemove', function (d, i) {
                        dispatch.elementMousemove({ data: d });
                    });
                    function stash(d) {
                        d.x0 = d.x;
                        d.dx0 = d.dx;
                    }
                    function arcTweenData(a, i) {
                        var oi = d3.interpolate({
                            x: a.x0,
                            dx: a.dx0
                        }, a);
                        function tween(t) {
                            var b = oi(t);
                            a.x0 = b.x;
                            a.dx0 = b.dx;
                            return arc(b);
                        }
                        if (i == 0) {
                            var xd = d3.interpolate(x.domain(), [
                                node.x,
                                node.x + node.dx
                            ]);
                            return function (t) {
                                x.domain(xd(t));
                                return tween(t);
                            };
                        } else {
                            return tween;
                        }
                    }
                    function arcTweenZoom(d) {
                        var xd = d3.interpolate(x.domain(), [
                                d.x,
                                d.x + d.dx
                            ]), yd = d3.interpolate(y.domain(), [
                                d.y,
                                1
                            ]), yr = d3.interpolate(y.range(), [
                                d.y ? 20 : 0,
                                radius
                            ]);
                        return function (d, i) {
                            return i ? function (t) {
                                return arc(d);
                            } : function (t) {
                                x.domain(xd(t));
                                y.domain(yd(t)).range(yr(t));
                                return arc(d);
                            };
                        };
                    }
                });
                renderWatch.renderEnd('sunburst immediate');
                return chart;
            }
            chart.dispatch = dispatch;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                width: {
                    get: function () {
                        return width;
                    },
                    set: function (_) {
                        width = _;
                    }
                },
                height: {
                    get: function () {
                        return height;
                    },
                    set: function (_) {
                        height = _;
                    }
                },
                mode: {
                    get: function () {
                        return mode;
                    },
                    set: function (_) {
                        mode = _;
                    }
                },
                id: {
                    get: function () {
                        return id;
                    },
                    set: function (_) {
                        id = _;
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top != undefined ? _.top : margin.top;
                        margin.right = _.right != undefined ? _.right : margin.right;
                        margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
                        margin.left = _.left != undefined ? _.left : margin.left;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = nv.utils.getColor(_);
                    }
                }
            });
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.models.sunburstChart = function () {
            'use strict';
            var sunburst = nv.models.sunburst();
            var tooltip = nv.models.tooltip();
            var margin = {
                    top: 30,
                    right: 20,
                    bottom: 20,
                    left: 20
                }, width = null, height = null, color = nv.utils.defaultColor(), id = Math.round(Math.random() * 100000), defaultState = null, noData = null, duration = 250, dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd');
            tooltip.duration(0);
            var renderWatch = nv.utils.renderWatch(dispatch);
            tooltip.headerEnabled(false).valueFormatter(function (d, i) {
                return d;
            });
            function chart(selection) {
                renderWatch.reset();
                renderWatch.models(sunburst);
                selection.each(function (data) {
                    var container = d3.select(this);
                    nv.utils.initSVG(container);
                    var that = this;
                    var availableWidth = nv.utils.availableWidth(width, container, margin), availableHeight = nv.utils.availableHeight(height, container, margin);
                    chart.update = function () {
                        if (duration === 0)
                            container.call(chart);
                        else
                            container.transition().duration(duration).call(chart);
                    };
                    chart.container = this;
                    if (!data || !data.length) {
                        nv.utils.noData(chart, container);
                        return chart;
                    } else {
                        container.selectAll('.nv-noData').remove();
                    }
                    var wrap = container.selectAll('g.nv-wrap.nv-sunburstChart').data(data);
                    var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sunburstChart').append('g');
                    var g = wrap.select('g');
                    gEnter.append('g').attr('class', 'nv-sunburstWrap');
                    wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                    sunburst.width(availableWidth).height(availableHeight);
                    var sunWrap = g.select('.nv-sunburstWrap').datum(data);
                    d3.transition(sunWrap).call(sunburst);
                });
                renderWatch.renderEnd('sunburstChart immediate');
                return chart;
            }
            sunburst.dispatch.on('elementMouseover.tooltip', function (evt) {
                evt['series'] = {
                    key: evt.data.name,
                    value: evt.data.size,
                    color: evt.color
                };
                tooltip.data(evt).hidden(false);
            });
            sunburst.dispatch.on('elementMouseout.tooltip', function (evt) {
                tooltip.hidden(true);
            });
            sunburst.dispatch.on('elementMousemove.tooltip', function (evt) {
                tooltip();
            });
            chart.dispatch = dispatch;
            chart.sunburst = sunburst;
            chart.tooltip = tooltip;
            chart.options = nv.utils.optionsFunc.bind(chart);
            chart._options = Object.create({}, {
                noData: {
                    get: function () {
                        return noData;
                    },
                    set: function (_) {
                        noData = _;
                    }
                },
                defaultState: {
                    get: function () {
                        return defaultState;
                    },
                    set: function (_) {
                        defaultState = _;
                    }
                },
                color: {
                    get: function () {
                        return color;
                    },
                    set: function (_) {
                        color = _;
                        sunburst.color(color);
                    }
                },
                duration: {
                    get: function () {
                        return duration;
                    },
                    set: function (_) {
                        duration = _;
                        renderWatch.reset(duration);
                        sunburst.duration(duration);
                    }
                },
                margin: {
                    get: function () {
                        return margin;
                    },
                    set: function (_) {
                        margin.top = _.top !== undefined ? _.top : margin.top;
                        margin.right = _.right !== undefined ? _.right : margin.right;
                        margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                        margin.left = _.left !== undefined ? _.left : margin.left;
                    }
                }
            });
            nv.utils.inheritOptions(chart, sunburst);
            nv.utils.initOptions(chart);
            return chart;
        };
        nv.version = '1.8.1-dev';
    }());
});
/*angular-nvd3@1.0.5#dist/angular-nvd3*/
define('angular-nvd3@1.0.5#dist/angular-nvd3', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/**************************************************************************\n* AngularJS-nvD3, v1.0.5; MIT License; 03/12/2015 08:27\n* http://krispo.github.io/angular-nvd3\n**************************************************************************/\n(function(){\n\n    \'use strict\';\n\n    angular.module(\'nvd3\', [])\n\n        .directive(\'nvd3\', [\'nvd3Utils\', function(nvd3Utils){\n            return {\n                restrict: \'AE\',\n                scope: {\n                    data: \'=\',      //chart data, [required]\n                    options: \'=\',   //chart options, according to nvd3 core api, [required]\n                    api: \'=?\',      //directive global api, [optional]\n                    events: \'=?\',   //global events that directive would subscribe to, [optional]\n                    config: \'=?\',    //global directive configuration, [optional]\n                    onReady: \'&?\' //callback function that is called with internal scope when directive is created [optional]\n                },\n                link: function(scope, element, attrs){\n                    var defaultConfig = {\n                        extended: false,\n                        visible: true,\n                        disabled: false,\n                        refreshDataOnly: true,\n                        deepWatchOptions: true,\n                        deepWatchData: true,\n                        deepWatchDataDepth: 2, // 0 - by reference (cheap), 1 - by collection item (the middle), 2 - by value (expensive)\n                        debounce: 10 // default 10ms, time silence to prevent refresh while multiple options changes at a time\n                    };\n\n                    //flag indicates if directive and chart is ready\n                    scope.isReady = false;\n\n                    //basic directive configuration\n                    scope._config = angular.extend(defaultConfig, scope.config);\n\n                    //directive global api\n                    scope.api = {\n                        // Fully refresh directive\n                        refresh: function(){\n                            scope.api.updateWithOptions(scope.options);\n                            scope.isReady = true;\n                        },\n\n                        // Fully refresh directive with specified timeout\n                        refreshWithTimeout: function(t){\n                            setTimeout(function(){\n                                scope.api.refresh();\n                            }, t);\n                        },\n\n                        // Update chart layout (for example if container is resized)\n                        update: function() {\n                            if (scope.chart && scope.svg) {\n                                scope.svg.datum(scope.data).call(scope.chart);\n                                // scope.chart.update();\n                            } else {\n                                scope.api.refresh();\n                            }\n                        },\n\n                        // Update chart layout with specified timeout\n                        updateWithTimeout: function(t){\n                            setTimeout(function(){\n                                scope.api.update();\n                            }, t);\n                        },\n\n                        // Update chart with new options\n                        updateWithOptions: function(options){\n                            // Clearing\n                            scope.api.clearElement();\n\n                            // Exit if options are not yet bound\n                            if (angular.isDefined(options) === false) return;\n\n                            // Exit if chart is hidden\n                            if (!scope._config.visible) return;\n\n                            // Initialize chart with specific type\n                            scope.chart = nv.models[options.chart.type]();\n\n                            // Generate random chart ID\n                            scope.chart.id = Math.random().toString(36).substr(2, 15);\n\n                            angular.forEach(scope.chart, function(value, key){\n                                if (key[0] === \'_\');\n                                else if ([\n                                        \'clearHighlights\',\n                                        \'highlightPoint\',\n                                        \'id\',\n                                        \'options\',\n                                        \'resizeHandler\',\n                                        \'state\',\n                                        \'open\',\n                                        \'close\',\n                                        \'tooltipContent\'\n                                    ].indexOf(key) >= 0);\n\n                                else if (key === \'dispatch\') {\n                                    if (options.chart[key] === undefined || options.chart[key] === null) {\n                                        if (scope._config.extended) options.chart[key] = {};\n                                    }\n                                    configureEvents(scope.chart[key], options.chart[key]);\n                                }\n\n                                else if ([\n                                        \'bars\',\n                                        \'bars1\',\n                                        \'bars2\',\n                                        \'boxplot\',\n                                        \'bullet\',\n                                        \'controls\',\n                                        \'discretebar\',\n                                        \'distX\',\n                                        \'distY\',\n                                        \'interactiveLayer\',\n                                        \'legend\',\n                                        \'lines\',\n                                        \'lines1\',\n                                        \'lines2\',\n                                        \'multibar\',\n                                        \'pie\',\n                                        \'scatter\',\n                                        \'sparkline\',\n                                        \'stack1\',\n                                        \'stack2\',\n                                        \'sunburst\',\n                                        \'tooltip\',\n                                        \'x2Axis\',\n                                        \'xAxis\',\n                                        \'y1Axis\',\n                                        \'y2Axis\',\n                                        \'y3Axis\',\n                                        \'y4Axis\',\n                                        \'yAxis\',\n                                        \'yAxis1\',\n                                        \'yAxis2\'\n                                    ].indexOf(key) >= 0 ||\n                                        // stacked is a component for stackedAreaChart, but a boolean for multiBarChart and multiBarHorizontalChart\n                                    (key === \'stacked\' && options.chart.type === \'stackedAreaChart\')) {\n                                    if (options.chart[key] === undefined || options.chart[key] === null) {\n                                        if (scope._config.extended) options.chart[key] = {};\n                                    }\n                                    configure(scope.chart[key], options.chart[key], options.chart.type);\n                                }\n\n                                //TODO: need to fix bug in nvd3\n                                else if ((key === \'xTickFormat\' || key === \'yTickFormat\') && options.chart.type === \'lineWithFocusChart\');\n                                else if ((key === \'tooltips\') && options.chart.type === \'boxPlotChart\');\n                                else if ((key === \'tooltipXContent\' || key === \'tooltipYContent\') && options.chart.type === \'scatterChart\');\n\n                                else if (options.chart[key] === undefined || options.chart[key] === null){\n                                    if (scope._config.extended) {\n                                        if (key===\'barColor\')\n                                            options.chart[key] = value()();\n                                        else\n                                            options.chart[key] = value();\n                                    }\n                                }\n\n                                else scope.chart[key](options.chart[key]);\n                            });\n\n                            // Update with data\n                            if (options.chart.type === \'sunburstChart\') {\n                                scope.api.updateWithData(angular.copy(scope.data));\n                            } else {\n                                scope.api.updateWithData(scope.data);\n                            }\n\n                            // Configure wrappers\n                            if (options[\'title\'] || scope._config.extended) configureWrapper(\'title\');\n                            if (options[\'subtitle\'] || scope._config.extended) configureWrapper(\'subtitle\');\n                            if (options[\'caption\'] || scope._config.extended) configureWrapper(\'caption\');\n\n\n                            // Configure styles\n                            if (options[\'styles\'] || scope._config.extended) configureStyles();\n\n                            nv.addGraph(function() {\n                                if (!scope.chart) return;\n\n                                // Remove resize handler. Due to async execution should be placed here, not in the clearElement\n                                if (scope.chart.resizeHandler) scope.chart.resizeHandler.clear();\n\n                                // Update the chart when window resizes\n                                scope.chart.resizeHandler = nv.utils.windowResize(function() {\n                                    scope.chart && scope.chart.update && scope.chart.update();\n                                });\n\n                                /// Zoom feature\n                                if (options.chart.zoom !== undefined && [\n                                        \'scatterChart\',\n                                        \'lineChart\',\n                                        \'candlestickBarChart\',\n                                        \'cumulativeLineChart\',\n                                        \'historicalBarChart\',\n                                        \'ohlcBarChart\',\n                                        \'stackedAreaChart\'\n                                    ].indexOf(options.chart.type) > -1) {\n                                    nvd3Utils.zoom(scope, options);\n                                }\n\n                                return scope.chart;\n                            }, options.chart[\'callback\']);\n                        },\n\n                        // Update chart with new data\n                        updateWithData: function (data){\n                            if (data) {\n                                // remove whole svg element with old data\n                                d3.select(element[0]).select(\'svg\').remove();\n\n                                var h, w;\n\n                                // Select the current element to add <svg> element and to render the chart in\n                                scope.svg = d3.select(element[0]).append(\'svg\');\n                                if (h = scope.options.chart.height) {\n                                    if (!isNaN(+h)) h += \'px\'; //check if height is number\n                                    scope.svg.attr(\'height\', h).style({height: h});\n                                }\n                                if (w = scope.options.chart.width) {\n                                    if (!isNaN(+w)) w += \'px\'; //check if width is number\n                                    scope.svg.attr(\'width\', w).style({width: w});\n                                } else {\n                                    scope.svg.attr(\'width\', \'100%\').style({width: \'100%\'});\n                                }\n\n                                scope.svg.datum(data).call(scope.chart);\n                            }\n                        },\n\n                        // Fully clear directive element\n                        clearElement: function (){\n                            element.find(\'.title\').remove();\n                            element.find(\'.subtitle\').remove();\n                            element.find(\'.caption\').remove();\n                            element.empty();\n\n                            // remove tooltip if exists\n                            if (scope.chart && scope.chart.tooltip && scope.chart.tooltip.id) {\n                                d3.select(\'#\' + scope.chart.tooltip.id()).remove();\n                            }\n\n                            // To be compatible with old nvd3 (v1.7.1)\n                            if (nv.graphs && scope.chart) {\n                                for (var i = nv.graphs.length - 1; i >= 0; i--) {\n                                    if (nv.graphs[i] && (nv.graphs[i].id === scope.chart.id)) {\n                                        nv.graphs.splice(i, 1);\n                                    }\n                                }\n                            }\n                            if (nv.tooltip && nv.tooltip.cleanup) {\n                                nv.tooltip.cleanup();\n                            }\n                            if (scope.chart && scope.chart.resizeHandler) scope.chart.resizeHandler.clear();\n                            scope.chart = null;\n                        },\n\n                        // Get full directive scope\n                        getScope: function(){ return scope; },\n\n                        // Get directive element\n                        getElement: function(){ return element; }\n                    };\n\n                    // Configure the chart model with the passed options\n                    function configure(chart, options, chartType){\n                        if (chart && options){\n                            angular.forEach(chart, function(value, key){\n                                if (key[0] === \'_\');\n                                else if (key === \'dispatch\') {\n                                    if (options[key] === undefined || options[key] === null) {\n                                        if (scope._config.extended) options[key] = {};\n                                    }\n                                    configureEvents(value, options[key]);\n                                }\n                                else if (key === \'tooltip\') {\n                                    if (options[key] === undefined || options[key] === null) {\n                                        if (scope._config.extended) options[key] = {};\n                                    }\n                                    configure(chart[key], options[key], chartType);\n                                }\n                                else if (key === \'contentGenerator\') {\n                                    if (options[key]) chart[key](options[key]);\n                                }\n                                else if ([\n                                        \'axis\',\n                                        \'clearHighlights\',\n                                        \'defined\',\n                                        \'highlightPoint\',\n                                        \'nvPointerEventsClass\',\n                                        \'options\',\n                                        \'rangeBand\',\n                                        \'rangeBands\',\n                                        \'scatter\',\n                                        \'open\',\n                                        \'close\'\n                                    ].indexOf(key) === -1) {\n                                    if (options[key] === undefined || options[key] === null){\n                                        if (scope._config.extended) options[key] = value();\n                                    }\n                                    else chart[key](options[key]);\n                                }\n                            });\n                        }\n                    }\n\n                    // Subscribe to the chart events (contained in \'dispatch\')\n                    // and pass eventHandler functions in the \'options\' parameter\n                    function configureEvents(dispatch, options){\n                        if (dispatch && options){\n                            angular.forEach(dispatch, function(value, key){\n                                if (options[key] === undefined || options[key] === null){\n                                    if (scope._config.extended) options[key] = value.on;\n                                }\n                                else dispatch.on(key + \'._\', options[key]);\n                            });\n                        }\n                    }\n\n                    // Configure \'title\', \'subtitle\', \'caption\'.\n                    // nvd3 has no sufficient models for it yet.\n                    function configureWrapper(name){\n                        var _ = nvd3Utils.deepExtend(defaultWrapper(name), scope.options[name] || {});\n\n                        if (scope._config.extended) scope.options[name] = _;\n\n                        var wrapElement = angular.element(\'<div></div>\').html(_[\'html\'] || \'\')\n                            .addClass(name).addClass(_.className)\n                            .removeAttr(\'style\')\n                            .css(_.css);\n\n                        if (!_[\'html\']) wrapElement.text(_.text);\n\n                        if (_.enable) {\n                            if (name === \'title\') element.prepend(wrapElement);\n                            else if (name === \'subtitle\') angular.element(element[0].querySelector(\'.title\')).after(wrapElement);\n                            else if (name === \'caption\') element.append(wrapElement);\n                        }\n                    }\n\n                    // Add some styles to the whole directive element\n                    function configureStyles(){\n                        var _ = nvd3Utils.deepExtend(defaultStyles(), scope.options[\'styles\'] || {});\n\n                        if (scope._config.extended) scope.options[\'styles\'] = _;\n\n                        angular.forEach(_.classes, function(value, key){\n                            value ? element.addClass(key) : element.removeClass(key);\n                        });\n\n                        element.removeAttr(\'style\').css(_.css);\n                    }\n\n                    // Default values for \'title\', \'subtitle\', \'caption\'\n                    function defaultWrapper(_){\n                        switch (_){\n                            case \'title\': return {\n                                enable: false,\n                                text: \'Write Your Title\',\n                                className: \'h4\',\n                                css: {\n                                    width: scope.options.chart.width + \'px\',\n                                    textAlign: \'center\'\n                                }\n                            };\n                            case \'subtitle\': return {\n                                enable: false,\n                                text: \'Write Your Subtitle\',\n                                css: {\n                                    width: scope.options.chart.width + \'px\',\n                                    textAlign: \'center\'\n                                }\n                            };\n                            case \'caption\': return {\n                                enable: false,\n                                text: \'Figure 1. Write Your Caption text.\',\n                                css: {\n                                    width: scope.options.chart.width + \'px\',\n                                    textAlign: \'center\'\n                                }\n                            };\n                        }\n                    }\n\n                    // Default values for styles\n                    function defaultStyles(){\n                        return {\n                            classes: {\n                                \'with-3d-shadow\': true,\n                                \'with-transitions\': true,\n                                \'gallery\': false\n                            },\n                            css: {}\n                        };\n                    }\n\n                    /* Event Handling */\n                    // Watching on options changing\n                    if (scope._config.deepWatchOptions) {\n                        scope.$watch(\'options\', nvd3Utils.debounce(function(newOptions){\n                            if (!scope._config.disabled) scope.api.refresh();\n                        }, scope._config.debounce, true), true);\n                    }\n\n                    // Watching on data changing\n                    function dataWatchFn(newData, oldData) {\n                        if (newData !== oldData){\n                            if (!scope._config.disabled) {\n                                scope._config.refreshDataOnly ? scope.api.update() : scope.api.refresh(); // if wanted to refresh data only, use update method, otherwise use full refresh.\n                            }\n                        }\n                    }\n                    if (scope._config.deepWatchData) {\n                        if (scope._config.deepWatchDataDepth === 1) {\n                            scope.$watchCollection(\'data\', dataWatchFn);\n                        } else {\n                            scope.$watch(\'data\', dataWatchFn, scope._config.deepWatchDataDepth === 2);\n                        }\n                    }\n\n                    // Watching on config changing\n                    scope.$watch(\'config\', function(newConfig, oldConfig){\n                        if (newConfig !== oldConfig){\n                            scope._config = angular.extend(defaultConfig, newConfig);\n                            scope.api.refresh();\n                        }\n                    }, true);\n\n                    // Refresh chart first time if deepWatchOptions and deepWatchData are false\n                    if (!scope._config.deepWatchOptions && !scope._config.deepWatchData) {\n                        scope.api.refresh();\n                    }\n\n                    //subscribe on global events\n                    angular.forEach(scope.events, function(eventHandler, event){\n                        scope.$on(event, function(e, args){\n                            return eventHandler(e, scope, args);\n                        });\n                    });\n\n                    // remove completely when directive is destroyed\n                    element.on(\'$destroy\', function () {\n                        scope.api.clearElement();\n                    });\n\n                    // trigger onReady callback if directive is ready\n                    scope.$watch(\'isReady\', function(isReady){\n                        if (isReady) {\n                            if (scope.onReady && typeof scope.onReady() === \'function\') scope.onReady()(scope, element);\n                        }\n                    });\n                }\n            };\n        }])\n\n        .factory(\'nvd3Utils\', function(){\n            return {\n                debounce: function(func, wait, immediate) {\n                    var timeout;\n                    return function() {\n                        var context = this, args = arguments;\n                        var later = function() {\n                            timeout = null;\n                            if (!immediate) func.apply(context, args);\n                        };\n                        var callNow = immediate && !timeout;\n                        clearTimeout(timeout);\n                        timeout = setTimeout(later, wait);\n                        if (callNow) func.apply(context, args);\n                    };\n                },\n                deepExtend: function(dst){\n                    var me = this;\n                    angular.forEach(arguments, function(obj) {\n                        if (obj !== dst) {\n                            angular.forEach(obj, function(value, key) {\n                                if (dst[key] && dst[key].constructor && dst[key].constructor === Object) {\n                                    me.deepExtend(dst[key], value);\n                                } else {\n                                    dst[key] = value;\n                                }\n                            });\n                        }\n                    });\n                    return dst;\n                },\n                zoom: function(scope, options) {\n                    var zoom = options.chart.zoom;\n\n                    // check if zoom enabled\n                    var enabled = (typeof zoom.enabled === \'undefined\' || zoom.enabled === null) ? true : zoom.enabled;\n                    if (!enabled) return;\n\n                    var xScale = scope.chart.xAxis.scale()\n                        , yScale = scope.chart.yAxis.scale()\n                        , xDomain = scope.chart.xDomain || xScale.domain\n                        , yDomain = scope.chart.yDomain || yScale.domain\n                        , x_boundary = xScale.domain().slice()\n                        , y_boundary = yScale.domain().slice()\n\n                    // initialize zoom options\n                        , scale = zoom.scale || 1\n                        , translate = zoom.translate || [0, 0]\n                        , scaleExtent = zoom.scaleExtent || [1, 10]\n                        , useFixedDomain = zoom.useFixedDomain || false\n                        , useNiceScale = zoom.useNiceScale || false\n                        , horizontalOff = zoom.horizontalOff || false\n                        , verticalOff = zoom.verticalOff || false\n                        , unzoomEventType = zoom.unzoomEventType || \'dblclick.zoom\'\n\n                    // auxiliary functions\n                        , fixDomain\n                        , d3zoom\n                        , zoomed\n                        , unzoomed\n                        ;\n\n                    // ensure nice axis\n                    if (useNiceScale) {\n                        xScale.nice();\n                        yScale.nice();\n                    }\n\n                    // fix domain\n                    fixDomain = function (domain, boundary) {\n                        domain[0] = Math.min(Math.max(domain[0], boundary[0]), boundary[1] - boundary[1] / scaleExtent[1]);\n                        domain[1] = Math.max(boundary[0] + boundary[1] / scaleExtent[1], Math.min(domain[1], boundary[1]));\n                        return domain;\n                    };\n\n                    // zoom event handler\n                    zoomed = function () {\n                        if (zoom.zoomed !== undefined) {\n                            var domains = zoom.zoomed(xScale.domain(), yScale.domain());\n                            if (!horizontalOff) xDomain([domains.x1, domains.x2]);\n                            if (!verticalOff) yDomain([domains.y1, domains.y2]);\n                        } else {\n                            if (!horizontalOff) xDomain(useFixedDomain ? fixDomain(xScale.domain(), x_boundary) : xScale.domain());\n                            if (!verticalOff) yDomain(useFixedDomain ? fixDomain(yScale.domain(), y_boundary) : yScale.domain());\n                        }\n                        scope.chart.update();\n                    };\n\n                    // unzoomed event handler\n                    unzoomed = function () {\n                        if (zoom.unzoomed !== undefined) {\n                            var domains = zoom.unzoomed(xScale.domain(), yScale.domain());\n                            if (!horizontalOff) xDomain([domains.x1, domains.x2]);\n                            if (!verticalOff) yDomain([domains.y1, domains.y2]);\n                        } else {\n                            if (!horizontalOff) xDomain(x_boundary);\n                            if (!verticalOff) yDomain(y_boundary);\n                        }\n                        d3zoom.scale(scale).translate(translate);\n                        scope.chart.update();\n                    };\n\n                    // create d3 zoom handler\n                    d3zoom = d3.behavior.zoom()\n                        .x(xScale)\n                        .y(yScale)\n                        .scaleExtent(scaleExtent)\n                        .on(\'zoom\', zoomed);\n\n                    scope.svg.call(d3zoom);\n\n                    d3zoom.scale(scale).translate(translate).event(scope.svg);\n\n                    if (unzoomEventType !== \'none\') scope.svg.on(unzoomEventType, unzoomed);\n                }\n            };\n        });\n})();\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*angular-nvd3@1.0.5#index*/
define('angular-nvd3@1.0.5#index', function (require, exports, module) {
    require('./dist/angular-nvd3');
    module.exports = 'nvd3';
});
/*mev-scatter-plot@0.0.0#src/_directives/scatterPlotDirective*/
define('mev-scatter-plot@0.0.0#src/_directives/scatterPlotDirective', [
    'angular',
    'd3',
    'lodash'
], function (angular, d3, _) {
    'use strict';
    var ScatterPlotDirective = function ScatterPlotDirective() {
        return {
            restrict: 'EC',
            scope: {
                inputData: '=',
                labelX: '=',
                labelY: '=',
                logScaleX: '=',
                logScaleY: '='
            },
            controller: 'scatterCtrl',
            template: '<nvd3 options=\'options\' data=\'data\' config=\'config\' api=\'api\'></nvd3>',
            link: function (scope, elm, attrs, ctrl) {
                var _self = this;
                scope.api = undefined;
                scope.config = {};
                scope.vm = {
                    refresh: function () {
                        scope.api.updateWithOptions(getOptions());
                    }
                };
                var _svg, _brush, _chart;
                function _addBrush() {
                    if (_svg && _brush)
                        _svg.selectAll('.brush').remove();
                    _svg.insert('g', ':first-child').attr('class', 'brush').call(_brush);
                }
                if (scope.inputData === 'random') {
                    scope.inputData = ctrl.generateData(2, 3);
                }
                scope.data = scope.inputData;
                scope.options = getOptions();
                scope.$watch('inputData', function (newVal) {
                    if (newVal) {
                        scope.data = scope.inputData;
                        console.debug('domain data', scope.inputData);
                        scope.options = getOptions();
                    }
                });
                scope.$watch('logScaleX', function (newVal, oldVal) {
                    if (typeof newVal !== 'undefined' && typeof oldVal !== 'undefined') {
                        scope.options = getOptions();
                    }
                });
                scope.$watch('logScaleY', function (newVal, oldVal) {
                    if (typeof newVal !== 'undefined' && typeof oldVal !== 'undefined') {
                        scope.options = getOptions();
                    }
                });
                function updateOptions() {
                    scope.options = getOptions();
                }
                function getDomain(dim) {
                    var theDomain = [
                        Infinity,
                        -Infinity
                    ];
                    if (scope.inputData) {
                        _.map(scope.inputData, function (group) {
                            var domain = d3.extent(group.values, function (d) {
                                return d[dim];
                            });
                            theDomain[0] = theDomain[0] > domain[0] ? domain[0] : theDomain[0];
                            theDomain[1] = theDomain[1] < domain[1] ? domain[1] : theDomain[1];
                        });
                        console.debug('theDomain ' + dim, theDomain);
                        return theDomain.map(function (v) {
                            if (dim === 'x' && scope.logScaleX)
                                return Math.abs(v) * 1.1;
                            else if (dim === 'y' && scope.logScaleY)
                                return Math.abs(v) * 1.1;
                            else
                                return v * 1.1;
                        });
                    }
                }
                function getScale(isLog) {
                    if (isLog)
                        return d3.scale.log();
                    else
                        return d3.scale.linear();
                }
                function getValue(dim, isLog) {
                    if (isLog)
                        return function (d) {
                            return Math.abs(d[dim]);
                        };
                    else
                        return function (d) {
                            return d[dim];
                        };
                }
                function getOptions() {
                    return {
                        chart: {
                            type: 'scatterChart',
                            showVoronoi: false,
                            interactive: true,
                            pointSize: 64,
                            pointScale: d3.scale.identity(),
                            callback: function (chart) {
                                console.debug('chart', chart);
                                chart.dispatch.on('renderEnd', function () {
                                    _chart = chart;
                                    console.log('render complete', arguments, chart);
                                    var svgDom = angular.element('svg');
                                    console.debug('.nvd3-svg', svgDom.height());
                                    _svg = d3.select('.nvd3.nv-wrap.nv-scatter');
                                    console.debug('_svg', _svg);
                                    _brush = d3.svg.brush().x(chart.scatter.xScale()).y(chart.scatter.yScale());
                                    _addBrush();
                                    var selection = [];
                                    function raiseEventSelectionUpdated(selection) {
                                        scope.$apply(function () {
                                            scope.$emit('mev.scatterPlot.selection', _.clone(selection, true));
                                        });
                                    }
                                    function clearSelection() {
                                        var node = _svg.selectAll('.nv-group > path.nv-point');
                                        console.debug('node', node);
                                        node.classed('selected', false);
                                        selection.length = 0;
                                    }
                                    function getBrushExtent() {
                                        var extent = _brush.extent();
                                        extent.x = [
                                            extent[0][0],
                                            extent[1][0]
                                        ];
                                        extent.y = [
                                            extent[0][1],
                                            extent[1][1]
                                        ];
                                        return extent;
                                    }
                                    function updateSelection() {
                                        var extent = getBrushExtent();
                                        var node = _svg.selectAll('.nv-group > path.nv-point');
                                        console.debug('node', node.size(), node);
                                        var count = 0;
                                        node.classed('selected', function (d) {
                                            console.debug('count', count++, d, d.length);
                                            if (d.length === 2) {
                                                var datum = d[0];
                                                var x = _chart.x()(datum);
                                                var y = _chart.y()(datum);
                                                var select = extent[0][0] <= x && x < extent[1][0] && extent[0][1] <= y && y < extent[1][1];
                                                if (select) {
                                                    console.debug('selected x range', extent[0][0], x, extent[1][0]);
                                                    console.debug('selected y range', extent[0][1], y, extent[1][1]);
                                                    selection.push(datum);
                                                } else {
                                                    console.debug('not x range', extent[0][0], x, extent[1][0]);
                                                    console.debug('not  y range', extent[0][1], y, extent[1][1]);
                                                }
                                                return select;
                                            } else {
                                                console.debug('bad datum', d, d.length);
                                                return false;
                                            }
                                        });
                                        raiseEventSelectionUpdated(selection);
                                        console.debug('brushend selection', selection);
                                    }
                                    function getSelectedData() {
                                    }
                                    _brush.on('brush', function () {
                                    });
                                    _brush.on('brushstart', function () {
                                        console.debug('brushstart', _brush.extent(), arguments);
                                        clearSelection();
                                    });
                                    _brush.on('brushend', function () {
                                        console.debug('brushend', _brush.extent(), arguments);
                                        updateSelection();
                                    });
                                });
                            },
                            height: 450,
                            color: d3.scale.category10().range(),
                            scatter: {
                                x: getValue('x', scope.logScaleX),
                                y: getValue('y', scope.logScaleY),
                                xScale: getScale(scope.logScaleX),
                                yScale: getScale(scope.logScaleY),
                                forceX: getDomain('x'),
                                forceY: getDomain('y'),
                                onlyCircles: true,
                                dispatch: {
                                    elementClick: function () {
                                        console.debug('click', arguments);
                                    },
                                    brushend: function () {
                                        console.debug('brush', arguments);
                                    }
                                }
                            },
                            tooltip: {
                                contentGenerator: function (d) {
                                    var valueFormatter = function (d, i) {
                                        return _chart.xAxis.axisLabel() + ': ' + d;
                                    };
                                    var headerFormatter = function (d) {
                                        return _chart.yAxis.axisLabel() + ': ' + d;
                                    };
                                    var keyFormatter = function (d, i) {
                                        return d;
                                    };
                                    if (d === null) {
                                        return '';
                                    }
                                    var table = d3.select(document.createElement('table'));
                                    var theadEnter = table.selectAll('thead').data([d]).enter().append('thead');
                                    theadEnter.append('tr').append('td').attr('colspan', 3).append('strong').classed('id', true).html(d.point.id);
                                    theadEnter.append('tr').append('td').attr('colspan', 3).classed('x-value', true).html(headerFormatter(d.series[0].value));
                                    var tbodyEnter = table.selectAll('tbody').data([d]).enter().append('tbody');
                                    var trowEnter = tbodyEnter.selectAll('tr').data(function (p) {
                                        return p.series;
                                    }).enter().append('tr').classed('highlight', function (p) {
                                        return p.highlight;
                                    });
                                    trowEnter.append('td').classed('legend-color-guide', true).append('div').style('background-color', function (p) {
                                        return p.color;
                                    });
                                    trowEnter.append('td').classed('key', true).classed('total', function (p) {
                                        return !!p.total;
                                    }).html(function (p, i) {
                                        return keyFormatter(p.key, i);
                                    });
                                    trowEnter.append('td').classed('value', true).html(function (p, i) {
                                        return valueFormatter(d.value, i);
                                    });
                                    trowEnter.selectAll('td').each(function (p) {
                                        if (p.highlight) {
                                            var opacityScale = d3.scale.linear().domain([
                                                0,
                                                1
                                            ]).range([
                                                '#fff',
                                                p.color
                                            ]);
                                            var opacity = 0.6;
                                            d3.select(this).style('border-bottom-color', opacityScale(opacity)).style('border-top-color', opacityScale(opacity));
                                        }
                                    });
                                    var html = table.node().outerHTML;
                                    if (d.footer !== undefined)
                                        html += '<div class=\'footer\'>' + d.footer + '</div>';
                                    return html;
                                }
                            },
                            showDistX: true,
                            showDistY: true,
                            duration: 350,
                            xAxis: {
                                axisLabel: scope.labelX,
                                tickFormat: function (d) {
                                    return d3.format('.02f')(d);
                                }
                            },
                            yAxis: {
                                axisLabel: scope.labelY,
                                tickFormat: function (d) {
                                    return d3.format('.02f')(d);
                                },
                                axisLabelDistance: -5
                            },
                            padData: false,
                            zoom: {
                                enabled: true,
                                scaleExtent: [
                                    1,
                                    10
                                ],
                                useFixedDomain: false,
                                useNiceScale: false,
                                horizontalOff: false,
                                verticalOff: false,
                                unzoomEventType: 'dblclick.zoom'
                            }
                        }
                    };
                }
            }
        };
    };
    ScatterPlotDirective.$inject = [];
    ScatterPlotDirective.$name = 'scatterPlot';
    ScatterPlotDirective.$provider = 'directive';
    return ScatterPlotDirective;
});
/*$css*/
define('$css', function (require, exports, module) {
    var loader = require('@loader');
    if (isProduction()) {
        exports.fetch = function (load) {
            var cssFile = load.address;
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = cssFile;
            document.head.appendChild(link);
            return '';
        };
    } else {
        exports.instantiate = function (load) {
            var loader = this;
            load.metadata.deps = [];
            load.metadata.execute = function () {
                var source = load.source + '/*# sourceURL=' + load.address + ' */';
                source = source.replace(/url\(['"]?([^'"\)]*)['"]?\)/g, function (whole, part) {
                    return 'url(' + steal.joinURIs(load.address, part) + ')';
                });
                if (load.source && typeof document !== 'undefined') {
                    var doc = document.head ? document : document.getElementsByTagName ? document : document.documentElement;
                    var head = doc.head || doc.getElementsByTagName('head')[0], style = document.createElement('style');
                    if (!head) {
                        var docEl = doc.documentElement || doc;
                        head = document.createElement('head');
                        docEl.insertBefore(head, docEl.firstChild);
                    }
                    style.type = 'text/css';
                    if (style.styleSheet) {
                        style.styleSheet.cssText = source;
                    } else {
                        style.appendChild(document.createTextNode(source));
                    }
                    head.appendChild(style);
                    if (loader.has('live-reload')) {
                        var cssReload = loader['import']('live-reload', { name: '$css' });
                        Promise.resolve(cssReload).then(function (reload) {
                            loader['import'](load.name).then(function () {
                                reload.once(load.name, function () {
                                    head.removeChild(style);
                                });
                            });
                        });
                    }
                }
                return System.newModule({ source: source });
            };
            load.metadata.format = 'css';
        };
    }
    function isProduction() {
        return loader.isEnv && loader.isEnv('production') || loader.env === 'production';
    }
    exports.buildType = 'css';
    exports.includeInBuild = true;
});
/*less*/
define('less', [], function(){ return {}; });
/*$less*/
define('$less', [], function(){ return {}; });
/*mev-scatter-plot@0.0.0#src/scatterPlot*/
define('mev-scatter-plot@0.0.0#src/scatterPlot', [
    'mui',
    'jquery',
    'd3',
    'nvd3',
    'angular-nvd3',
    'lodash',
    './_directives/scatterPlotDirective',
    'nvd3/build/nv.d3.css!',
    './style/scatter.less!'
], function (ng, $, d3, nvd3, ngnvd3, _, scatterPlotDirective) {
    'use strict';
    return ng.module('scatterPlot', arguments, arguments).directive(scatterPlotDirective.$name, scatterPlotDirective).controller('scatterCtrl', [
        '$scope',
        function () {
            this.generateData = function (groups, points) {
                var data = [], shapes = ['circle'], random = d3.random.normal();
                for (var i = 0; i < groups; i++) {
                    data.push({
                        key: 'Group ' + i,
                        values: []
                    });
                    for (var j = 0; j < points; j++) {
                        data[i].values.push({
                            x: random() * 1000,
                            y: random() * 1000,
                            size: Math.random(),
                            shape: shapes[j % 6]
                        });
                    }
                }
                return data;
            };
        }
    ]);
});
/*mev-scatter-plot@0.0.0#index*/
define('mev-scatter-plot@0.0.0#index', [
    'angular',
    'mev-scatter-plot/src/scatterPlot'
], function (ng, scatterPlot) {
    return scatterPlot;
});
/*demo/demo*/
define('demo/demo', [
    'angular',
    'mev-scatter-plot'
], function (ng) {
    'use strict';
    return ng.module('demo', arguments, arguments).controller('myCtrl', [
        '$scope',
        function ($scope) {
            var _self = this;
            $scope.data = 'random';
            $scope.vm = {
                logScaleX: false,
                logScaleY: false
            };
        }
    ]);
});
/*demo/index*/
define('demo/index', [
    'angular',
    './demo'
], function (ng, demo) {
    ng.element(document).ready(function () {
        ng.bootstrap(document, [demo.name]);
    });
});
//# sourceMappingURL=index.js.map