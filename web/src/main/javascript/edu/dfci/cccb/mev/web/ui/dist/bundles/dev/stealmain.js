/*[production-config]*/
steal = ((typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self : window).steal || {};
steal.loadBundles = true;
steal.configMain = "package.json!npm";
/*steal*/
!function(e){"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):"undefined"!=typeof window?window.Promise=e():"undefined"!=typeof global?global.Promise=e():"undefined"!=typeof self&&(self.Promise=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/**
 * ES6 global Promise shim
 */
var unhandledRejections = require('../lib/decorators/unhandledRejection');
var PromiseConstructor = unhandledRejections(require('../lib/Promise'));

module.exports = typeof global != 'undefined' ? (global.Promise = PromiseConstructor)
	           : typeof self   != 'undefined' ? (self.Promise   = PromiseConstructor)
	           : PromiseConstructor;

},{"../lib/Promise":2,"../lib/decorators/unhandledRejection":4}],2:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":3,"./env":5,"./makePromise":7}],3:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],4:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":5,"../format":6}],5:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' && process !== null &&
			typeof process.nextTick === 'function';
	}

	function hasMutationObserver () {
		return (typeof MutationObserver === 'function' && MutationObserver) ||
			(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{}],6:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && e.stack ? e.stack : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],7:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
				return (function(noop, self, CustomEvent) {
					var hasCustomEvent = false;
					try {
						var ev = new CustomEvent('unhandledRejection');
						hasCustomEvent = ev instanceof CustomEvent;
					} catch (e) {}

					return !hasCustomEvent ? noop : function(type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(noop, self, CustomEvent));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}]},{},[1])
(1)
});
;
(function(__global) {
  
$__Object$getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};

var $__Object$defineProperty;
(function () {
  try {
    if (!!Object.defineProperty({}, 'a', {})) {
      $__Object$defineProperty = Object.defineProperty;
    }
  } catch (e) {
    $__Object$defineProperty = function (obj, prop, opt) {
      try {
        obj[prop] = opt.value || opt.get.call(obj);
      }
      catch(e) {}
    }
  }
}());

$__Object$create = Object.create || function(o, props) {
  function F() {}
  F.prototype = o;

  if (typeof(props) === "object") {
    for (prop in props) {
      if (props.hasOwnProperty((prop))) {
        F[prop] = props[prop];
      }
    }
  }
  return new F();
};

/*
*********************************************************************************************

  Dynamic Module Loader Polyfill

    - Implemented exactly to the former 2014-08-24 ES6 Specification Draft Rev 27, Section 15
      http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#august_24_2014_draft_rev_27

    - Functions are commented with their spec numbers, with spec differences commented.

    - Spec bugs are commented in this code with links.

    - Abstract functions have been combined where possible, and their associated functions
      commented.

    - Realm implementation is entirely omitted.

*********************************************************************************************
*/

// Some Helpers

// logs a linkset snapshot for debugging
/* function snapshot(loader) {
  console.log('---Snapshot---');
  for (var i = 0; i < loader.loads.length; i++) {
    var load = loader.loads[i];
    var linkSetLog = '  ' + load.name + ' (' + load.status + '): ';

    for (var j = 0; j < load.linkSets.length; j++) {
      linkSetLog += '{' + logloads(load.linkSets[j].loads) + '} ';
    }
    console.log(linkSetLog);
  }
  console.log('');
}
function logloads(loads) {
  var log = '';
  for (var k = 0; k < loads.length; k++)
    log += loads[k].name + (k != loads.length - 1 ? ' ' : '');
  return log;
} */


/* function checkInvariants() {
  // see https://bugs.ecmascript.org/show_bug.cgi?id=2603#c1

  var loads = System._loader.loads;
  var linkSets = [];

  for (var i = 0; i < loads.length; i++) {
    var load = loads[i];
    console.assert(load.status == 'loading' || load.status == 'loaded', 'Each load is loading or loaded');

    for (var j = 0; j < load.linkSets.length; j++) {
      var linkSet = load.linkSets[j];

      for (var k = 0; k < linkSet.loads.length; k++)
        console.assert(loads.indexOf(linkSet.loads[k]) != -1, 'linkSet loads are a subset of loader loads');

      if (linkSets.indexOf(linkSet) == -1)
        linkSets.push(linkSet);
    }
  }

  for (var i = 0; i < loads.length; i++) {
    var load = loads[i];
    for (var j = 0; j < linkSets.length; j++) {
      var linkSet = linkSets[j];

      if (linkSet.loads.indexOf(load) != -1)
        console.assert(load.linkSets.indexOf(linkSet) != -1, 'linkSet contains load -> load contains linkSet');

      if (load.linkSets.indexOf(linkSet) != -1)
        console.assert(linkSet.loads.indexOf(load) != -1, 'load contains linkSet -> linkSet contains load');
    }
  }

  for (var i = 0; i < linkSets.length; i++) {
    var linkSet = linkSets[i];
    for (var j = 0; j < linkSet.loads.length; j++) {
      var load = linkSet.loads[j];

      for (var k = 0; k < load.dependencies.length; k++) {
        var depName = load.dependencies[k].value;
        var depLoad;
        for (var l = 0; l < loads.length; l++) {
          if (loads[l].name != depName)
            continue;
          depLoad = loads[l];
          break;
        }

        // loading records are allowed not to have their dependencies yet
        // if (load.status != 'loading')
        //  console.assert(depLoad, 'depLoad found');

        // console.assert(linkSet.loads.indexOf(depLoad) != -1, 'linkset contains all dependencies');
      }
    }
  }
} */


(function() {
  var Promise = __global.Promise || require('when/es6-shim/Promise');
  if (__global.console)
    console.assert = console.assert || function() {};

  // IE8 support
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, thisLen = this.length; i < thisLen; i++) {
      if (this[i] === item) {
        return i;
      }
    }
    return -1;
  };
  var defineProperty = $__Object$defineProperty;

  // 15.2.3 - Runtime Semantics: Loader State

  // 15.2.3.11
  function createLoaderLoad(object) {
    return {
      // modules is an object for ES5 implementation
      modules: {},
      loads: [],
      loaderObj: object
    };
  }

  // 15.2.3.2 Load Records and LoadRequest Objects

  // 15.2.3.2.1
  function createLoad(name) {
    return {
      status: 'loading',
      name: name,
      linkSets: [],
      dependencies: [],
      metadata: {}
    };
  }

  // 15.2.3.2.2 createLoadRequestObject, absorbed into calling functions

  // 15.2.4

  // 15.2.4.1
  function loadModule(loader, name, options) {
    return new Promise(asyncStartLoadPartwayThrough({
      step: options.address ? 'fetch' : 'locate',
      loader: loader,
      moduleName: name,
      // allow metadata for import https://bugs.ecmascript.org/show_bug.cgi?id=3091
      moduleMetadata: options && options.metadata || {},
      moduleSource: options.source,
      moduleAddress: options.address
    }));
  }

  // 15.2.4.2
  function requestLoad(loader, request, refererName, refererAddress) {
    // 15.2.4.2.1 CallNormalize
    return new Promise(function(resolve, reject) {
      resolve(loader.loaderObj.normalize(request, refererName, refererAddress));
    })
    // 15.2.4.2.2 GetOrCreateLoad
    .then(function(name) {
      var load;
      if (loader.modules[name]) {
        load = createLoad(name);
        load.status = 'linked';
        // https://bugs.ecmascript.org/show_bug.cgi?id=2795
        load.module = loader.modules[name];
        return load;
      }

      for (var i = 0, l = loader.loads.length; i < l; i++) {
        load = loader.loads[i];
        if (load.name != name)
          continue;
        console.assert(load.status == 'loading' || load.status == 'loaded', 'loading or loaded');
        return load;
      }

      load = createLoad(name);
      loader.loads.push(load);

      proceedToLocate(loader, load);

      return load;
    });
  }

  // 15.2.4.3
  function proceedToLocate(loader, load) {
    proceedToFetch(loader, load,
      Promise.resolve()
      // 15.2.4.3.1 CallLocate
      .then(function() {
        return loader.loaderObj.locate({ name: load.name, metadata: load.metadata });
      })
    );
  }

  // 15.2.4.4
  function proceedToFetch(loader, load, p) {
    proceedToTranslate(loader, load,
      p
      // 15.2.4.4.1 CallFetch
      .then(function(address) {
        // adjusted, see https://bugs.ecmascript.org/show_bug.cgi?id=2602
        if (load.status != 'loading')
          return;
        load.address = address;

        return loader.loaderObj.fetch({ name: load.name, metadata: load.metadata, address: address });
      })
    );
  }

  var anonCnt = 0;

  // 15.2.4.5
  function proceedToTranslate(loader, load, p) {
    p
    // 15.2.4.5.1 CallTranslate
    .then(function(source) {
      if (load.status != 'loading')
        return;

      return Promise.resolve(loader.loaderObj.translate({ name: load.name, metadata: load.metadata, address: load.address, source: source }))

      // 15.2.4.5.2 CallInstantiate
      .then(function(source) {
        if(load.status != 'loading') {
          return;
        }
        load.source = source;
        return loader.loaderObj.instantiate({ name: load.name, metadata: load.metadata, address: load.address, source: source });
      })

      // 15.2.4.5.3 InstantiateSucceeded
      .then(function(instantiateResult) {
        if(load.status != 'loading') {
          return;
        }
        if (instantiateResult === undefined) {
          load.address = load.address || '<Anonymous Module ' + ++anonCnt + '>';

          // instead of load.kind, use load.isDeclarative
          load.isDeclarative = true;
          return loader.loaderObj.transpile(load)
          .then(function(transpiled) {
            // Hijack System.register to set declare function
            var curSystem = __global.System;
            var curRegister = curSystem.register;
            curSystem.register = function(name, deps, declare) {
              if (typeof name != 'string') {
                declare = deps;
                deps = name;
              }
              // store the registered declaration as load.declare
              // store the deps as load.deps
              load.declare = declare;
              load.depsList = deps;
            }            
            __eval(transpiled, __global, load);
            curSystem.register = curRegister;
          });
        }
        else if (typeof instantiateResult == 'object') {
          load.depsList = instantiateResult.deps || [];
          load.execute = instantiateResult.execute;
          load.isDeclarative = false;
        }
        else
          throw TypeError('Invalid instantiate return value');
      })
      // 15.2.4.6 ProcessLoadDependencies
      .then(function() {
        if(load.status != 'loading') {
          return;
        }
        load.dependencies = [];
        var depsList = load.depsList;

        var loadPromises = [];
        for (var i = 0, l = depsList.length; i < l; i++) (function(request, index) {
          loadPromises.push(
            requestLoad(loader, request, load.name, load.address)

            // 15.2.4.6.1 AddDependencyLoad (load is parentLoad)
            .then(function(depLoad) {

              // adjusted from spec to maintain dependency order
              // this is due to the System.register internal implementation needs
              load.dependencies[index] = {
                key: request,
                value: depLoad.name
              };

              if (depLoad.status != 'linked') {
                var linkSets = load.linkSets.concat([]);
                for (var i = 0, l = linkSets.length; i < l; i++)
                  addLoadToLinkSet(linkSets[i], depLoad);
              }

              // console.log('AddDependencyLoad ' + depLoad.name + ' for ' + load.name);
              // snapshot(loader);
            })
          );
        })(depsList[i], i);

        return Promise.all(loadPromises);
      })

      // 15.2.4.6.2 LoadSucceeded
      .then(function() {
        // console.log('LoadSucceeded ' + load.name);
        // snapshot(loader);
        if(load.status != 'loading') {
          return;
        }

        console.assert(load.status == 'loading', 'is loading');

        load.status = 'loaded';

        var linkSets = load.linkSets.concat([]);
        for (var i = 0, l = linkSets.length; i < l; i++)
          updateLinkSetOnLoad(linkSets[i], load);
      });
    })
    // 15.2.4.5.4 LoadFailed
    ['catch'](function(exc) {
      load.status = 'failed';
      load.exception = exc;

      var linkSets = load.linkSets.concat([]);
      for (var i = 0, l = linkSets.length; i < l; i++) {
        linkSetFailed(linkSets[i], load, exc);
      }

      console.assert(load.linkSets.length == 0, 'linkSets not removed');
    });
  }

  // 15.2.4.7 PromiseOfStartLoadPartwayThrough absorbed into calling functions

  // 15.2.4.7.1
  function asyncStartLoadPartwayThrough(stepState) {
    return function(resolve, reject) {
      var loader = stepState.loader;
      var name = stepState.moduleName;
      var step = stepState.step;

      if (loader.modules[name])
        throw new TypeError('"' + name + '" already exists in the module table');

      // adjusted to pick up existing loads
      var existingLoad;
      for (var i = 0, l = loader.loads.length; i < l; i++) {
        if (loader.loads[i].name == name) {
          existingLoad = loader.loads[i];

          if(step == 'translate' && !existingLoad.source) {
            existingLoad.address = stepState.moduleAddress;
            proceedToTranslate(loader, existingLoad, Promise.resolve(stepState.moduleSource));
          }

          return existingLoad.linkSets[0].done.then(function() {
            resolve(existingLoad);
          });
        }
      }

      var load = createLoad(name);

      load.metadata = stepState.moduleMetadata;

      var linkSet = createLinkSet(loader, load);

      loader.loads.push(load);

      resolve(linkSet.done);

      if (step == 'locate')
        proceedToLocate(loader, load);

      else if (step == 'fetch')
        proceedToFetch(loader, load, Promise.resolve(stepState.moduleAddress));

      else {
        console.assert(step == 'translate', 'translate step');
        load.address = stepState.moduleAddress;
        proceedToTranslate(loader, load, Promise.resolve(stepState.moduleSource));
      }
    }
  }

  // Declarative linking functions run through alternative implementation:
  // 15.2.5.1.1 CreateModuleLinkageRecord not implemented
  // 15.2.5.1.2 LookupExport not implemented
  // 15.2.5.1.3 LookupModuleDependency not implemented

  // 15.2.5.2.1
  function createLinkSet(loader, startingLoad) {
    var linkSet = {
      loader: loader,
      loads: [],
      startingLoad: startingLoad, // added see spec bug https://bugs.ecmascript.org/show_bug.cgi?id=2995
      loadingCount: 0
    };
    linkSet.done = new Promise(function(resolve, reject) {
      linkSet.resolve = resolve;
      linkSet.reject = reject;
    });
    addLoadToLinkSet(linkSet, startingLoad);
    return linkSet;
  }
  // 15.2.5.2.2
  function addLoadToLinkSet(linkSet, load) {
    console.assert(load.status == 'loading' || load.status == 'loaded', 'loading or loaded on link set');

    for (var i = 0, l = linkSet.loads.length; i < l; i++)
      if (linkSet.loads[i] == load)
        return;

    linkSet.loads.push(load);
    load.linkSets.push(linkSet);

    // adjustment, see https://bugs.ecmascript.org/show_bug.cgi?id=2603
    if (load.status != 'loaded') {
      linkSet.loadingCount++;
    }

    var loader = linkSet.loader;

    for (var i = 0, l = load.dependencies.length; i < l; i++) {
      var name = load.dependencies[i].value;

      if (loader.modules[name])
        continue;

      for (var j = 0, d = loader.loads.length; j < d; j++) {
        if (loader.loads[j].name != name)
          continue;

        addLoadToLinkSet(linkSet, loader.loads[j]);
        break;
      }
    }
    // console.log('add to linkset ' + load.name);
    // snapshot(linkSet.loader);
  }

  // linking errors can be generic or load-specific
  // this is necessary for debugging info
  function doLink(linkSet) {
    var error = false;
    try {
      link(linkSet, function(load, exc) {
        linkSetFailed(linkSet, load, exc);
        error = true;
      });
    }
    catch(e) {
      linkSetFailed(linkSet, null, e);
      error = true;
    }
    return error;
  }

  // 15.2.5.2.3
  function updateLinkSetOnLoad(linkSet, load) {
    // console.log('update linkset on load ' + load.name);
    // snapshot(linkSet.loader);

    console.assert(load.status == 'loaded' || load.status == 'linked', 'loaded or linked');

    linkSet.loadingCount--;

    if (linkSet.loadingCount > 0)
      return;

    // adjusted for spec bug https://bugs.ecmascript.org/show_bug.cgi?id=2995
    var startingLoad = linkSet.startingLoad;

    // non-executing link variation for loader tracing
    // on the server. Not in spec.
    /***/
    if (linkSet.loader.loaderObj.execute === false) {
      var loads = [].concat(linkSet.loads);
      for (var i = 0, l = loads.length; i < l; i++) {
        var load = loads[i];
        load.module = !load.isDeclarative ? {
          module: _newModule({})
        } : {
          name: load.name,
          module: _newModule({}),
          evaluated: true
        };
        load.status = 'linked';
        finishLoad(linkSet.loader, load);
      }
      return linkSet.resolve(startingLoad);
    }
    /***/

    var abrupt = doLink(linkSet);

    if (abrupt)
      return;

    console.assert(linkSet.loads.length == 0, 'loads cleared');

    linkSet.resolve(startingLoad);
  }

  // 15.2.5.2.4
  function linkSetFailed(linkSet, load, exc) {
    var loader = linkSet.loader;

    if (linkSet.loads[0].name != load.name)
      exc = addToError(exc, 'Error loading "' + load.name + '" from "' + linkSet.loads[0].name + '" at ' + (linkSet.loads[0].address || '<unknown>') + '\n');

    exc = addToError(exc, 'Error loading "' + load.name + '" at ' + (load.address || '<unknown>') + '\n');

    var loads = linkSet.loads.concat([]);
    for (var i = 0, l = loads.length; i < l; i++) {
      var load = loads[i];

      // store all failed load records
      loader.loaderObj.failed = loader.loaderObj.failed || [];
      if (indexOf.call(loader.loaderObj.failed, load) == -1)
        loader.loaderObj.failed.push(load);

      var linkIndex = indexOf.call(load.linkSets, linkSet);
      console.assert(linkIndex != -1, 'link not present');
      load.linkSets.splice(linkIndex, 1);
      if (load.linkSets.length == 0) {
        var globalLoadsIndex = indexOf.call(linkSet.loader.loads, load);
        if (globalLoadsIndex != -1)
          linkSet.loader.loads.splice(globalLoadsIndex, 1);
      }
    }
    linkSet.reject(exc);
  }

  // 15.2.5.2.5
  function finishLoad(loader, load) {
    // add to global trace if tracing
    if (loader.loaderObj.trace) {
      if (!loader.loaderObj.loads)
        loader.loaderObj.loads = {};
      var depMap = {};
      load.dependencies.forEach(function(dep) {
        depMap[dep.key] = dep.value;
      });
      loader.loaderObj.loads[load.name] = {
        name: load.name,
        deps: load.dependencies.map(function(dep){ return dep.key }),
        depMap: depMap,
        address: load.address,
        metadata: load.metadata,
        source: load.source,
        kind: load.isDeclarative ? 'declarative' : 'dynamic'
      };
    }
    // if not anonymous, add to the module table
    if (load.name) {
      console.assert(!loader.modules[load.name], 'load not in module table');
      loader.modules[load.name] = load.module;
    }
    var loadIndex = indexOf.call(loader.loads, load);
    if (loadIndex != -1)
      loader.loads.splice(loadIndex, 1);
    for (var i = 0, l = load.linkSets.length; i < l; i++) {
      loadIndex = indexOf.call(load.linkSets[i].loads, load);
      if (loadIndex != -1)
        load.linkSets[i].loads.splice(loadIndex, 1);
    }
    load.linkSets.splice(0, load.linkSets.length);
  }

  // 15.2.5.3 Module Linking Groups

  // 15.2.5.3.2 BuildLinkageGroups alternative implementation
  // Adjustments (also see https://bugs.ecmascript.org/show_bug.cgi?id=2755)
  // 1. groups is an already-interleaved array of group kinds
  // 2. load.groupIndex is set when this function runs
  // 3. load.groupIndex is the interleaved index ie 0 declarative, 1 dynamic, 2 declarative, ... (or starting with dynamic)
  function buildLinkageGroups(load, loads, groups) {
    groups[load.groupIndex] = groups[load.groupIndex] || [];

    // if the load already has a group index and its in its group, its already been done
    // this logic naturally handles cycles
    if (indexOf.call(groups[load.groupIndex], load) != -1)
      return;

    // now add it to the group to indicate its been seen
    groups[load.groupIndex].push(load);

    for (var i = 0, l = loads.length; i < l; i++) {
      var loadDep = loads[i];

      // dependencies not found are already linked
      for (var j = 0; j < load.dependencies.length; j++) {
        if (loadDep.name == load.dependencies[j].value) {
          // by definition all loads in linkset are loaded, not linked
          console.assert(loadDep.status == 'loaded', 'Load in linkSet not loaded!');

          // if it is a group transition, the index of the dependency has gone up
          // otherwise it is the same as the parent
          var loadDepGroupIndex = load.groupIndex + (loadDep.isDeclarative != load.isDeclarative);

          // the group index of an entry is always the maximum
          if (loadDep.groupIndex === undefined || loadDep.groupIndex < loadDepGroupIndex) {

            // if already in a group, remove from the old group
            if (loadDep.groupIndex !== undefined) {
              groups[loadDep.groupIndex].splice(indexOf.call(groups[loadDep.groupIndex], loadDep), 1);

              // if the old group is empty, then we have a mixed depndency cycle
              if (groups[loadDep.groupIndex].length == 0)
                throw new TypeError("Mixed dependency cycle detected");
            }

            loadDep.groupIndex = loadDepGroupIndex;
          }

          buildLinkageGroups(loadDep, loads, groups);
        }
      }
    }
  }

  function doDynamicExecute(linkSet, load, linkError) {
    try {
      var module = load.execute();
    }
    catch(e) {
      linkError(load, e);
      return;
    }
    if (!module || !(module instanceof Module))
      linkError(load, new TypeError('Execution must define a Module instance'));
    else
      return module;
  }

  // 15.2.5.4
  function link(linkSet, linkError) {

    var loader = linkSet.loader;

    if (!linkSet.loads.length)
      return;

    // console.log('linking {' + logloads(linkSet.loads) + '}');
    // snapshot(loader);

    // 15.2.5.3.1 LinkageGroups alternative implementation

    // build all the groups
    // because the first load represents the top of the tree
    // for a given linkset, we can work down from there
    var groups = [];
    var startingLoad = linkSet.loads[0];
    startingLoad.groupIndex = 0;
    buildLinkageGroups(startingLoad, linkSet.loads, groups);

    // determine the kind of the bottom group
    var curGroupDeclarative = startingLoad.isDeclarative == groups.length % 2;

    // run through the groups from bottom to top
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var load = group[j];

        // 15.2.5.5 LinkDeclarativeModules adjusted
        if (curGroupDeclarative) {
          linkDeclarativeModule(load, linkSet.loads, loader);
        }
        // 15.2.5.6 LinkDynamicModules adjusted
        else {
          var module = doDynamicExecute(linkSet, load, linkError);
          if (!module)
            return;
          load.module = {
            name: load.name,
            module: module
          };
          load.status = 'linked';
        }
        finishLoad(loader, load);
      }

      // alternative current kind for next loop
      curGroupDeclarative = !curGroupDeclarative;
    }
  }


  // custom module records for binding graph
  // store linking module records in a separate table
  function getOrCreateModuleRecord(name, loader) {
    var moduleRecords = loader.moduleRecords;
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      module: new Module(), // start from an empty module and extend
      importers: []
    });
  }

  // custom declarative linking function
  function linkDeclarativeModule(load, loads, loader) {
    if (load.module)
      return;

    var module = load.module = getOrCreateModuleRecord(load.name, loader);
    var moduleObj = load.module.module;

    var registryEntry = load.declare.call(__global, function(name, value) {
      // NB This should be an Object.defineProperty, but that is very slow.
      //    By disaling this module write-protection we gain performance.
      //    It could be useful to allow an option to enable or disable this.
      module.locked = true;
      moduleObj[name] = value;

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          importerModule.setters[importerIndex](moduleObj);
        }
      }

      module.locked = false;
      return value;
    });

    // setup our setters and execution function
    module.setters = registryEntry.setters;
    module.execute = registryEntry.execute;

    // now link all the module dependencies
    // amending the depMap as we go
    for (var i = 0, l = load.dependencies.length; i < l; i++) {
      var depName = load.dependencies[i].value;
      var depModule = loader.modules[depName];

      // if dependency not already in the module registry
      // then try and link it now
      if (!depModule) {
        // get the dependency load record
        for (var j = 0; j < loads.length; j++) {
          if (loads[j].name != depName)
            continue;

          // only link if already not already started linking (stops at circular / dynamic)
          if (!loads[j].module) {
            linkDeclarativeModule(loads[j], loads, loader);
            depModule = loads[j].module;
          }
          // if circular, create the module record
          else {
            depModule = getOrCreateModuleRecord(depName, loader);
          }
        }
      }

      // only declarative modules have dynamic bindings
      if (depModule.importers) {
        module.dependencies.push(depModule);
        depModule.importers.push(module);
      }
      else {
        // track dynamic records as null module records as already linked
        module.dependencies.push(null);
      }

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depModule.module);
    }

    load.status = 'linked';
  }



  // 15.2.5.5.1 LinkImports not implemented
  // 15.2.5.7 ResolveExportEntries not implemented
  // 15.2.5.8 ResolveExports not implemented
  // 15.2.5.9 ResolveExport not implemented
  // 15.2.5.10 ResolveImportEntries not implemented

  // 15.2.6.1
  function evaluateLoadedModule(loader, load) {
    console.assert(load.status == 'linked', 'is linked ' + load.name);

    doEnsureEvaluated(load.module, [], loader);
    return load.module.module;
  }

  /*
   * Module Object non-exotic for ES5:
   *
   * module.module        bound module object
   * module.execute       execution function for module
   * module.dependencies  list of module objects for dependencies
   * See getOrCreateModuleRecord for all properties
   *
   */
  function doExecute(module) {
    try {
      module.execute.call(__global);
    }
    catch(e) {
      return e;
    }
  }

  // propogate execution errors
  // see https://bugs.ecmascript.org/show_bug.cgi?id=2993
  function doEnsureEvaluated(module, seen, loader) {
    var err = ensureEvaluated(module, seen, loader);
    if (err)
      throw err;
  }
  // 15.2.6.2 EnsureEvaluated adjusted
  function ensureEvaluated(module, seen, loader) {
    if (module.evaluated || !module.dependencies)
      return;

    seen.push(module);

    var deps = module.dependencies;
    var err;

    for (var i = 0, l = deps.length; i < l; i++) {
      var dep = deps[i];
      // dynamic dependencies are empty in module.dependencies
      // as they are already linked
      if (!dep)
        continue;
      if (indexOf.call(seen, dep) == -1) {
        err = ensureEvaluated(dep, seen, loader);
        // stop on error, see https://bugs.ecmascript.org/show_bug.cgi?id=2996
        if (err) {
          err = addToError(err, 'Error evaluating ' + dep.name + '\n');
          return err;
        }
      }
    }

    if (module.failed)
      return new Error('Module failed execution.');

    if (module.evaluated)
      return;

    module.evaluated = true;
    err = doExecute(module);
    if (err) {
      module.failed = true;
    }
    else if (Object.preventExtensions) {
      // spec variation
      // we don't create a new module here because it was created and ammended
      // we just disable further extensions instead
      Object.preventExtensions(module.module);
    }

    module.execute = undefined;
    return err;
  }

  function addToError(err, msg) {
    if (err instanceof Error)
      err.message = msg + err.message;
    else
      err = msg + err;
    return err;
  }

  // 26.3 Loader

  // 26.3.1.1
  function Loader(options) {
    if (typeof options != 'object')
      throw new TypeError('Options must be an object');

    if (options.normalize)
      this.normalize = options.normalize;
    if (options.locate)
      this.locate = options.locate;
    if (options.fetch)
      this.fetch = options.fetch;
    if (options.translate)
      this.translate = options.translate;
    if (options.instantiate)
      this.instantiate = options.instantiate;

    this._loader = {
      loaderObj: this,
      loads: [],
      modules: {},
      importPromises: {},
      moduleRecords: {}
    };

    // 26.3.3.6
    defineProperty(this, 'global', {
      get: function() {
        return __global;
      }
    });

    // 26.3.3.13 realm not implemented
  }

  function Module() {}

  // importPromises adds ability to import a module twice without error - https://bugs.ecmascript.org/show_bug.cgi?id=2601
  function createImportPromise(loader, name, promise) {
    var importPromises = loader._loader.importPromises;
    return importPromises[name] = promise.then(function(m) {
      importPromises[name] = undefined;
      return m;
    }, function(e) {
      importPromises[name] = undefined;
      throw e;
    });
  }

  Loader.prototype = {
    // 26.3.3.1
    constructor: Loader,
    // 26.3.3.2
    define: function(name, source, options) {
      // check if already defined
      if (this._loader.importPromises[name])
        throw new TypeError('Module is already loading.');
      return createImportPromise(this, name, new Promise(asyncStartLoadPartwayThrough({
        step: 'translate',
        loader: this._loader,
        moduleName: name,
        moduleMetadata: options && options.metadata || {},
        moduleSource: source,
        moduleAddress: options && options.address
      })));
    },
    // 26.3.3.3
    'delete': function(name) {
      var loader = this._loader;
      delete loader.importPromises[name];
      delete loader.moduleRecords[name];
      return loader.modules[name] ? delete loader.modules[name] : false;
    },
    // 26.3.3.4 entries not implemented
    // 26.3.3.5
    get: function(key) {
      if (!this._loader.modules[key])
        return;
      doEnsureEvaluated(this._loader.modules[key], [], this);
      return this._loader.modules[key].module;
    },
    // 26.3.3.7
    has: function(name) {
      return !!this._loader.modules[name];
    },
    // 26.3.3.8
    'import': function(name, options) {
      // run normalize first
      var loaderObj = this;

      // added, see https://bugs.ecmascript.org/show_bug.cgi?id=2659
      return Promise.resolve(loaderObj.normalize(name, options && options.name, options && options.address))
      .then(function(name) {
        var loader = loaderObj._loader;

        if (loader.modules[name]) {
          doEnsureEvaluated(loader.modules[name], [], loader._loader);
          return loader.modules[name].module;
        }

        return loader.importPromises[name] || createImportPromise(loaderObj, name,
          loadModule(loader, name, options || {})
          .then(function(load) {
            delete loader.importPromises[name];
            return evaluateLoadedModule(loader, load);
          }));
      });
    },
    // 26.3.3.9 keys not implemented
    // 26.3.3.10
    load: function(name, options) {
      if (this._loader.modules[name]) {
        doEnsureEvaluated(this._loader.modules[name], [], this._loader);
        return Promise.resolve(this._loader.modules[name].module);
      }
      return this._loader.importPromises[name] || createImportPromise(this, name, loadModule(this._loader, name, {}));
    },
    // 26.3.3.11
    module: function(source, options) {
      var load = createLoad();
      load.address = options && options.address;
      var linkSet = createLinkSet(this._loader, load);
      var sourcePromise = Promise.resolve(source);
      var loader = this._loader;
      var p = linkSet.done.then(function() {
        return evaluateLoadedModule(loader, load);
      });
      proceedToTranslate(loader, load, sourcePromise);
      return p;
    },
    // 26.3.3.12
    newModule: function (obj) {
      if (typeof obj != 'object')
        throw new TypeError('Expected object');

      // we do this to be able to tell if a module is a module privately in ES5
      // by doing m instanceof Module
      var m = new Module();

      var pNames;
      if (Object.getOwnPropertyNames && obj != null) {
        pNames = Object.getOwnPropertyNames(obj);
      }
      else {
        pNames = [];
        for (var key in obj)
          pNames.push(key);
      }

      for (var i = 0; i < pNames.length; i++) (function(key) {
        defineProperty(m, key, {
          configurable: false,
          enumerable: true,
          get: function () {
            return obj[key];
          }
        });
      })(pNames[i]);

      if (Object.preventExtensions)
        Object.preventExtensions(m);

      return m;
    },
    // 26.3.3.14
    set: function(name, module) {
      if (!(module instanceof Module))
        throw new TypeError('Loader.set(' + name + ', module) must be a module');
      this._loader.modules[name] = {
        module: module
      };
    },
    // 26.3.3.15 values not implemented
    // 26.3.3.16 @@iterator not implemented
    // 26.3.3.17 @@toStringTag not implemented

    // 26.3.3.18.1
    normalize: function(name, referrerName, referrerAddress) {
      return name;
    },
    // 26.3.3.18.2
    locate: function(load) {
      return load.name;
    },
    // 26.3.3.18.3
    fetch: function(load) {
      throw new TypeError('Fetch not implemented');
    },
    // 26.3.3.18.4
    translate: function(load) {
      return load.source;
    },
    // 26.3.3.18.5
    instantiate: function(load) {
    }
  };

  var _newModule = Loader.prototype.newModule;

  if (typeof exports === 'object')
    module.exports = Loader;

  __global.Reflect = __global.Reflect || {};
  __global.Reflect.Loader = __global.Reflect.Loader || Loader;
  __global.Reflect.global = __global.Reflect.global || __global;
  __global.LoaderPolyfill = Loader;

})();

/*
 * Traceur and Babel transpile hook for Loader
 */
(function(Loader) {
  var g = __global;

  function getTranspilerModule(loader, globalName) {
    return loader.newModule({ 'default': g[globalName], __useDefault: true });
  }

  // use Traceur by default
  Loader.prototype.transpiler = 'traceur';

  Loader.prototype.transpile = function(load) {
    var self = this;

    // pick up Transpiler modules from existing globals on first run if set
    if (!self.transpilerHasRun) {
      if (g.traceur && !self.has('traceur'))
        self.set('traceur', getTranspilerModule(self, 'traceur'));
      if (g.babel && !self.has('babel'))
        self.set('babel', getTranspilerModule(self, 'babel'));
      self.transpilerHasRun = true;
    }
    
    return self['import'](self.transpiler).then(function(transpiler) {
      if (transpiler.__useDefault)
        transpiler = transpiler['default'];
      return 'var __moduleAddress = "' + load.address + '";' + (transpiler.Compiler ? traceurTranspile : babelTranspile).call(self, load, transpiler);
    });
  };

  Loader.prototype.instantiate = function(load) {
    var self = this;
    return Promise.resolve(self.normalize(self.transpiler))
    .then(function(transpilerNormalized) {
      // load transpiler as a global (avoiding System clobbering)
      if (load.name === transpilerNormalized) {
        return {
          deps: [],
          execute: function() {
            var curSystem = g.System;
            var curLoader = g.Reflect.Loader;
            // ensure not detected as CommonJS
            __eval('(function(require,exports,module){' + load.source + '})();', g, load);
            g.System = curSystem;
            g.Reflect.Loader = curLoader;
            return getTranspilerModule(self, load.name);
          }
        };
      }
    });
  };

  function traceurTranspile(load, traceur) {
    var options = this.traceurOptions || {};
    options.modules = 'instantiate';
    options.script = false;
    options.sourceMaps = 'inline';
    options.filename = load.address;
    options.inputSourceMap = load.metadata.sourceMap;
    options.moduleName = false;

    var compiler = new traceur.Compiler(options);
    var source = doTraceurCompile(load.source, compiler, options.filename);

    // add "!eval" to end of Traceur sourceURL
    // I believe this does something?
    source += '!eval';

    return source;
  }
  function doTraceurCompile(source, compiler, filename) {
    try {
      return compiler.compile(source, filename);
    }
    catch(e) {
      // traceur throws an error array
      throw e[0];
    }
  }

  function babelTranspile(load, babel) {
    var options = this.babelOptions || {};
    options.modules = 'system';
    options.sourceMap = 'inline';
    options.filename = load.address;
    options.code = true;
    options.ast = false;
    
    if (!options.blacklist)
      options.blacklist = ['react'];

    var source = babel.transform(load.source, options).code;

    // add "!eval" to end of Babel sourceURL
    // I believe this does something?
    return source + '\n//# sourceURL=' + load.address + '!eval';
  }


})(__global.LoaderPolyfill);
/*
*********************************************************************************************

  System Loader Implementation

    - Implemented to https://github.com/jorendorff/js-loaders/blob/master/browser-loader.js

    - <script type="module"> supported

*********************************************************************************************
*/



(function() {
  var isWorker = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
  var isBrowser = typeof window != 'undefined' && !isWorker;
  var isWindows = typeof process != 'undefined' && !!process.platform.match(/^win/);
  var Promise = __global.Promise || require('when/es6-shim/Promise');

  // Helpers
  // Absolute URL parsing, from https://gist.github.com/Yaffle/1088850
  function parseURI(url) {
    var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/?#]*(?::[^:@\/?#]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
    // authority = '//' + user + ':' + pass '@' + hostname + ':' port
    return (m ? {
      href     : m[0] || '',
      protocol : m[1] || '',
      authority: m[2] || '',
      host     : m[3] || '',
      hostname : m[4] || '',
      port     : m[5] || '',
      pathname : m[6] || '',
      search   : m[7] || '',
      hash     : m[8] || ''
    } : null);
  }

  function removeDotSegments(input) {
    var output = [];
    input.replace(/^(\.\.?(\/|$))+/, '')
      .replace(/\/(\.(\/|$))+/g, '/')
      .replace(/\/\.\.$/, '/../')
      .replace(/\/?[^\/]*/g, function (p) {
        if (p === '/..')
          output.pop();
        else
          output.push(p);
    });
    return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
  }

  function toAbsoluteURL(base, href) {

    if (isWindows)
      href = href.replace(/\\/g, '/');

    href = parseURI(href || '');
    base = parseURI(base || '');

    return !href || !base ? null : (href.protocol || base.protocol) +
      (href.protocol || href.authority ? href.authority : base.authority) +
      removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
      (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
      href.hash;
  }

  var fetchTextFromURL;

  if (typeof XMLHttpRequest != 'undefined') {
    fetchTextFromURL = function(url, fulfill, reject) {
      var xhr = new XMLHttpRequest();
      var sameDomain = true;
      var doTimeout = false;
      if (!('withCredentials' in xhr)) {
        // check if same domain
        var domainCheck = /^(\w+:)?\/\/([^\/]+)/.exec(url);
        if (domainCheck) {
          sameDomain = domainCheck[2] === window.location.host;
          if (domainCheck[1])
            sameDomain &= domainCheck[1] === window.location.protocol;
        }
      }
      if (!sameDomain && typeof XDomainRequest != 'undefined') {
        xhr = new XDomainRequest();
        xhr.onload = load;
        xhr.onerror = error;
        xhr.ontimeout = error;
        xhr.onprogress = function() {};
        xhr.timeout = 0;
        doTimeout = true;
      }
      function load() {
        fulfill(xhr.responseText);
      }
      function error() {
        reject(xhr.statusText + ': ' + url || 'XHR error');
      }

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status === 200 || (xhr.status == 0 && xhr.responseText)) {
            load();
          } else {
            error();
          }
        }
      };
      xhr.open("GET", url, true);

      if (doTimeout)
        setTimeout(function() {
          xhr.send();
        }, 0);

      xhr.send(null);
    }
  }
  else if (typeof require != 'undefined') {
    var fs;
    fetchTextFromURL = function(url, fulfill, reject) {
      if (url.substr(0, 5) != 'file:')
        throw 'Only file URLs of the form file: allowed running in Node.';
      fs = fs || require('fs');
      url = url.substr(5);
      if (isWindows)
        url = url.replace(/\//g, '\\');
      return fs.readFile(url, function(err, data) {
        if (err)
          return reject(err);
        else
          fulfill(data + '');
      });
    }
  }
  else {
    throw new TypeError('No environment fetch API available.');
  }

  var SystemLoader = function($__super) {
    function SystemLoader(options) {
      $__super.call(this, options || {});

      // Set default baseURL and paths
      if (typeof location != 'undefined' && location.href) {
        var href = __global.location.href.split('#')[0].split('?')[0];
        this.baseURL = href.substring(0, href.lastIndexOf('/') + 1);
      }
      else if (typeof process != 'undefined' && process.cwd) {
        this.baseURL = 'file:' + process.cwd() + '/';
        if (isWindows)
          this.baseURL = this.baseURL.replace(/\\/g, '/');
      }
      else {
        throw new TypeError('No environment baseURL');
      }
      this.paths = { '*': '*.js' };
    }

    SystemLoader.__proto__ = ($__super !== null ? $__super : Function.prototype);
    SystemLoader.prototype = $__Object$create(($__super !== null ? $__super.prototype : null));

    $__Object$defineProperty(SystemLoader.prototype, "constructor", {
      value: SystemLoader
    });

    $__Object$defineProperty(SystemLoader.prototype, "global", {
      get: function() {
        return isBrowser ? window : (isWorker ? self : __global);
      },

      enumerable: false
    });

    $__Object$defineProperty(SystemLoader.prototype, "strict", {
      get: function() { return true; },
      enumerable: false
    });

    $__Object$defineProperty(SystemLoader.prototype, "normalize", {
      value: function(name, parentName, parentAddress) {
        if (typeof name != 'string')
          throw new TypeError('Module name must be a string');

        var segments = name.split('/');

        if (segments.length == 0)
          throw new TypeError('No module name provided');

        // current segment
        var i = 0;
        // is the module name relative
        var rel = false;
        // number of backtracking segments
        var dotdots = 0;
        if (segments[0] == '.') {
          i++;
          if (i == segments.length)
            throw new TypeError('Illegal module name "' + name + '"');
          rel = true;
        }
        else {
          while (segments[i] == '..') {
            i++;
            if (i == segments.length)
              throw new TypeError('Illegal module name "' + name + '"');
          }
          if (i)
            rel = true;
          dotdots = i;
        }

        for (var j = i; j < segments.length; j++) {
          var segment = segments[j];
          if (segment == '' || segment == '.' || segment == '..')
            throw new TypeError('Illegal module name "' + name + '"');
        }

        if (!rel)
          return name;

        // build the full module name
        var normalizedParts = [];
        var parentParts = (parentName || '').split('/');
        var normalizedLen = parentParts.length - 1 - dotdots;

        normalizedParts = normalizedParts.concat(parentParts.splice(0, parentParts.length - 1 - dotdots));
        normalizedParts = normalizedParts.concat(segments.splice(i, segments.length - i));

        return normalizedParts.join('/');
      },

      enumerable: false,
      writable: true
    });

    $__Object$defineProperty(SystemLoader.prototype, "locate", {
      value: function(load) {
        var name = load.name;

        // NB no specification provided for System.paths, used ideas discussed in https://github.com/jorendorff/js-loaders/issues/25

        // most specific (longest) match wins
        var pathMatch = '', wildcard;

        // check to see if we have a paths entry
        for (var p in this.paths) {
          var pathParts = p.split('*');
          if (pathParts.length > 2)
            throw new TypeError('Only one wildcard in a path is permitted');

          // exact path match
          if (pathParts.length == 1) {
            if (name == p && p.length > pathMatch.length) {
              pathMatch = p;
              break;
            }
          }

          // wildcard path match
          else {
            if (name.substr(0, pathParts[0].length) == pathParts[0] && name.substr(name.length - pathParts[1].length) == pathParts[1]) {
              pathMatch = p;
              wildcard = name.substr(pathParts[0].length, name.length - pathParts[1].length - pathParts[0].length);
            }
          }
        }

        var outPath = this.paths[pathMatch];
        if (wildcard)
          outPath = outPath.replace('*', wildcard);

        // percent encode just '#' in module names
        // according to https://github.com/jorendorff/js-loaders/blob/master/browser-loader.js#L238
        // we should encode everything, but it breaks for servers that don't expect it 
        // like in (https://github.com/systemjs/systemjs/issues/168)
        if (isBrowser)
          outPath = outPath.replace(/#/g, '%23');

        return toAbsoluteURL(this.baseURL, outPath);
      },

      enumerable: false,
      writable: true
    });

    $__Object$defineProperty(SystemLoader.prototype, "fetch", {
      value: function(load) {
        var self = this;
        return new Promise(function(resolve, reject) {
          fetchTextFromURL(toAbsoluteURL(self.baseURL, load.address), function(source) {
            resolve(source);
          }, reject);
        });
      },

      enumerable: false,
      writable: true
    });

    return SystemLoader;
  }(__global.LoaderPolyfill);

  var System = new SystemLoader();

  // note we have to export before runing "init" below
  if (typeof exports === 'object')
    module.exports = System;

  __global.System = System;

  // <script type="module"> support
  // allow a data-init function callback once loaded
  if (isBrowser && typeof document.getElementsByTagName != 'undefined') {
    var curScript = document.getElementsByTagName('script');
    curScript = curScript[curScript.length - 1];

    function completed() {
      document.removeEventListener( "DOMContentLoaded", completed, false );
      window.removeEventListener( "load", completed, false );
      ready();
    }

    function ready() {
      var scripts = document.getElementsByTagName('script');
      for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        if (script.type == 'module') {
          var source = script.innerHTML.substr(1);
          // It is important to reference the global System, rather than the one
          // in our closure. We want to ensure that downstream users/libraries
          // can override System w/ custom behavior.
          __global.System.module(source)['catch'](function(err) { setTimeout(function() { throw err; }); });
        }
      }
    }

    // DOM ready, taken from https://github.com/jquery/jquery/blob/master/src/core/ready.js#L63
    if (document.readyState === 'complete') {
      setTimeout(ready);
    }
    else if (document.addEventListener) {
      document.addEventListener('DOMContentLoaded', completed, false);
      window.addEventListener('load', completed, false);
    }

    // run the data-init function on the script tag
    if (curScript.getAttribute('data-init'))
      window[curScript.getAttribute('data-init')]();
  }
})();


// Define our eval outside of the scope of any other reference defined in this
// file to avoid adding those references to the evaluation scope.
function __eval(__source, __global, __load) {
  try {
    eval('(function() { var __moduleName = "' + (__load.name || '').replace('"', '\"') + '"; ' + __source + ' \n }).call(__global);');
  }
  catch(e) {
    if (e.name == 'SyntaxError' || e.name == 'TypeError')
      e.message = 'Evaluating ' + (__load.name || load.address) + '\n\t' + e.message;
    throw e;
  }
}

})(typeof window != 'undefined' ? window : (typeof WorkerGlobalScope != 'undefined' ?
                                           self : global));

/*
 * SystemJS v0.16.6
 */

(function($__global) {

$__global.upgradeSystemLoader = function() {
  $__global.upgradeSystemLoader = undefined;

  // indexOf polyfill for IE
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var isWindows = typeof process != 'undefined' && !!process.platform.match(/^win/);

  // Absolute URL parsing, from https://gist.github.com/Yaffle/1088850
  function parseURI(url) {
    var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/?#]*(?::[^:@\/?#]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
    // authority = '//' + user + ':' + pass '@' + hostname + ':' port
    return (m ? {
      href     : m[0] || '',
      protocol : m[1] || '',
      authority: m[2] || '',
      host     : m[3] || '',
      hostname : m[4] || '',
      port     : m[5] || '',
      pathname : m[6] || '',
      search   : m[7] || '',
      hash     : m[8] || ''
    } : null);
  }
  function toAbsoluteURL(base, href) {
    function removeDotSegments(input) {
      var output = [];
      input.replace(/^(\.\.?(\/|$))+/, '')
        .replace(/\/(\.(\/|$))+/g, '/')
        .replace(/\/\.\.$/, '/../')
        .replace(/\/?[^\/]*/g, function (p) {
          if (p === '/..')
            output.pop();
          else
            output.push(p);
      });
      return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
    }

    if (isWindows)
      href = href.replace(/\\/g, '/');

    href = parseURI(href || '');
    base = parseURI(base || '');

    return !href || !base ? null : (href.protocol || base.protocol) +
      (href.protocol || href.authority ? href.authority : base.authority) +
      removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
      (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
      href.hash;
  }

  // clone the original System loader
  var System;
  (function() {
    var originalSystem = $__global.System;
    System = $__global.System = new LoaderPolyfill(originalSystem);
    System.baseURL = originalSystem.baseURL;
    System.paths = { '*': '*.js' };
    System.originalSystem = originalSystem;
  })();

  System.noConflict = function() {
    $__global.SystemJS = System;
    $__global.System = System.originalSystem;
  }

  
/*
 * SystemJS Core
 * Code should be vaguely readable
 * 
 */
var originalSystem = $__global.System.originalSystem;
function core(loader) {
  /*
    __useDefault
    
    When a module object looks like:
    newModule(
      __useDefault: true,
      default: 'some-module'
    })

    Then importing that module provides the 'some-module'
    result directly instead of the full module.

    Useful for eg module.exports = function() {}
  */
  var loaderImport = loader['import'];
  loader['import'] = function(name, options) {
    return loaderImport.call(this, name, options).then(function(module) {
      return module.__useDefault ? module['default'] : module;
    });
  };

  // support the empty module, as a concept
  loader.set('@empty', loader.newModule({}));

  // include the node require since we're overriding it
  if (typeof require != 'undefined')
    loader._nodeRequire = require;

  /*
    Config
    Extends config merging one deep only

    loader.config({
      some: 'random',
      config: 'here',
      deep: {
        config: { too: 'too' }
      }
    });

    <=>

    loader.some = 'random';
    loader.config = 'here'
    loader.deep = loader.deep || {};
    loader.deep.config = { too: 'too' };
  */
  loader.config = function(cfg) {
    for (var c in cfg) {
      var v = cfg[c];
      if (typeof v == 'object' && !(v instanceof Array)) {
        this[c] = this[c] || {};
        for (var p in v)
          this[c][p] = v[p];
      }
      else
        this[c] = v;
    }
  };

  // override locate to allow baseURL to be document-relative
  var baseURI;
  if (typeof window == 'undefined' &&
      typeof WorkerGlobalScope == 'undefined') {
    baseURI = 'file:' + process.cwd() + '/';
    if (isWindows)
      baseURI = baseURI.replace(/\\/g, '/');
  }
  // Inside of a Web Worker
  else if(typeof window == 'undefined') {
    baseURI = loader.global.location.href;
  }
  else {
    baseURI = document.baseURI;
    if (!baseURI) {
      var bases = document.getElementsByTagName('base');
      baseURI = bases[0] && bases[0].href || window.location.href;
    }
  }

  var loaderLocate = loader.locate;
  var normalizedBaseURL;
  loader.locate = function(load) {
    if (this.baseURL != normalizedBaseURL) {
      normalizedBaseURL = toAbsoluteURL(baseURI, this.baseURL);

      if (normalizedBaseURL.substr(normalizedBaseURL.length - 1, 1) != '/')
        normalizedBaseURL += '/';
      this.baseURL = normalizedBaseURL;
    }

    return Promise.resolve(loaderLocate.call(this, load));
  };

  function applyExtensions(extensions, loader) {
    loader._extensions = [];
    for(var i = 0, len = extensions.length; i < len; i++) {
      extensions[i](loader);
    }
  }

  loader._extensions = loader._extensions || [];
  loader._extensions.push(core);

  loader.clone = function() {
    var originalLoader = this;
    var loader = new LoaderPolyfill(originalSystem);
    loader.baseURL = originalLoader.baseURL;
    loader.paths = { '*': '*.js' };
    applyExtensions(originalLoader._extensions, loader);
    return loader;
  };
}
/*
 * Meta Extension
 *
 * Sets default metadata on a load record (load.metadata) from
 * loader.meta[moduleName].
 * Also provides an inline meta syntax for module meta in source.
 *
 * Eg:
 *
 * loader.meta['my/module'] = { some: 'meta' };
 *
 * load.metadata.some = 'meta' will now be set on the load record.
 *
 * The same meta could be set with a my/module.js file containing:
 * 
 * my/module.js
 *   "some meta"; 
 *   "another meta";
 *   console.log('this is my/module');
 *
 * The benefit of inline meta is that coniguration doesn't need
 * to be known in advance, which is useful for modularising
 * configuration and avoiding the need for configuration injection.
 *
 *
 * Example
 * -------
 *
 * The simplest meta example is setting the module format:
 *
 * System.meta['my/module'] = { format: 'amd' };
 *
 * or inside 'my/module.js':
 *
 * "format amd";
 * define(...);
 * 
 */

function meta(loader) {
  var metaRegEx = /^(\s*\/\*.*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/;
  var metaPartRegEx = /\/\*.*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g;

  loader.meta = {};
  loader._extensions = loader._extensions || [];
  loader._extensions.push(meta);

  function setConfigMeta(loader, load) {
    var meta = loader.meta && loader.meta[load.name];
    if (meta) {
      for (var p in meta)
        load.metadata[p] = load.metadata[p] || meta[p];
    }
  }

  var loaderLocate = loader.locate;
  loader.locate = function(load) {
    setConfigMeta(this, load);
    return loaderLocate.call(this, load);
  }

  var loaderTranslate = loader.translate;
  loader.translate = function(load) {
    // detect any meta header syntax
    var meta = load.source.match(metaRegEx);
    if (meta) {
      var metaParts = meta[0].match(metaPartRegEx);
      for (var i = 0; i < metaParts.length; i++) {
        var len = metaParts[i].length;

        var firstChar = metaParts[i].substr(0, 1);
        if (metaParts[i].substr(len - 1, 1) == ';')
          len--;
      
        if (firstChar != '"' && firstChar != "'")
          continue;

        var metaString = metaParts[i].substr(1, metaParts[i].length - 3);

        var metaName = metaString.substr(0, metaString.indexOf(' '));
        if (metaName) {
          var metaValue = metaString.substr(metaName.length + 1, metaString.length - metaName.length - 1);

          if (load.metadata[metaName] instanceof Array)
            load.metadata[metaName].push(metaValue);
          else if (!load.metadata[metaName])
            load.metadata[metaName] = metaValue;
        }
      }
    }
    // config meta overrides
    setConfigMeta(this, load);
    
    return loaderTranslate.call(this, load);
  }
}
/*
 * Instantiate registry extension
 *
 * Supports Traceur System.register 'instantiate' output for loading ES6 as ES5.
 *
 * - Creates the loader.register function
 * - Also supports metadata.format = 'register' in instantiate for anonymous register modules
 * - Also supports metadata.deps, metadata.execute and metadata.executingRequire
 *     for handling dynamic modules alongside register-transformed ES6 modules
 *
 * Works as a standalone extension, but benefits from having a more 
 * advanced __eval defined like in SystemJS polyfill-wrapper-end.js
 *
 * The code here replicates the ES6 linking groups algorithm to ensure that
 * circular ES6 compiled into System.register can work alongside circular AMD 
 * and CommonJS, identically to the actual ES6 loader.
 *
 */
function register(loader) {
  if (typeof indexOf == 'undefined')
    indexOf = Array.prototype.indexOf;
  if (typeof __eval == 'undefined' || typeof document != 'undefined' && !document.addEventListener)
    __eval = 0 || eval; // uglify breaks without the 0 ||

  loader._extensions = loader._extensions || [];
  loader._extensions.push(register);

  // define exec for easy evaluation of a load record (load.name, load.source, load.address)
  // main feature is source maps support handling
  var curSystem;
  function exec(load) {
    var loader = this;
    // support sourceMappingURL (efficiently)
    var sourceMappingURL;
    var lastLineIndex = load.source.lastIndexOf('\n');
    if (lastLineIndex != -1) {
      if (load.source.substr(lastLineIndex + 1, 21) == '//# sourceMappingURL=') {
        sourceMappingURL = load.source.substr(lastLineIndex + 22, load.source.length - lastLineIndex - 22);
        if (typeof toAbsoluteURL != 'undefined')
          sourceMappingURL = toAbsoluteURL(load.address, sourceMappingURL);
      }
    }

    __eval(load.source, load.address, sourceMappingURL);
  }
  loader.__exec = exec;

  function dedupe(deps) {
    var newDeps = [];
    for (var i = 0, l = deps.length; i < l; i++)
      if (indexOf.call(newDeps, deps[i]) == -1)
        newDeps.push(deps[i])
    return newDeps;
  }

  /*
   * There are two variations of System.register:
   * 1. System.register for ES6 conversion (2-3 params) - System.register([name, ]deps, declare)
   *    see https://github.com/ModuleLoader/es6-module-loader/wiki/System.register-Explained
   *
   * 2. System.register for dynamic modules (3-4 params) - System.register([name, ]deps, executingRequire, execute)
   * the true or false statement 
   *
   * this extension implements the linking algorithm for the two variations identical to the spec
   * allowing compiled ES6 circular references to work alongside AMD and CJS circular references.
   *
   */
  // loader.register sets loader.defined for declarative modules
  var anonRegister;
  var calledRegister;
  function registerModule(name, deps, declare, execute) {
    if (typeof name != 'string') {
      execute = declare;
      declare = deps;
      deps = name;
      name = null;
    }

    calledRegister = true;
    
    var register;

    // dynamic
    if (typeof declare == 'boolean') {
      register = {
        declarative: false,
        deps: deps,
        execute: execute,
        executingRequire: declare
      };
    }
    else {
      // ES6 declarative
      register = {
        declarative: true,
        deps: deps,
        declare: declare
      };
    }
    
    // named register
    if (name) {
      register.name = name;
      // we never overwrite an existing define
      if (!(name in loader.defined))
        loader.defined[name] = register; 
    }
    // anonymous register
    else if (register.declarative) {
      if (anonRegister)
        throw new TypeError('Multiple anonymous System.register calls in the same module file.');
      anonRegister = register;
    }
  }
  /*
   * Registry side table - loader.defined
   * Registry Entry Contains:
   *    - name
   *    - deps 
   *    - declare for declarative modules
   *    - execute for dynamic modules, different to declarative execute on module
   *    - executingRequire indicates require drives execution for circularity of dynamic modules
   *    - declarative optional boolean indicating which of the above
   *
   * Can preload modules directly on System.defined['my/module'] = { deps, execute, executingRequire }
   *
   * Then the entry gets populated with derived information during processing:
   *    - normalizedDeps derived from deps, created in instantiate
   *    - groupIndex used by group linking algorithm
   *    - evaluated indicating whether evaluation has happend
   *    - module the module record object, containing:
   *      - exports actual module exports
   *      
   *    Then for declarative only we track dynamic bindings with the records:
   *      - name
   *      - setters declarative setter functions
   *      - exports actual module values
   *      - dependencies, module records of dependencies
   *      - importers, module records of dependents
   *
   * After linked and evaluated, entries are removed, declarative module records remain in separate
   * module binding table
   *
   */

  function defineRegister(loader) {
    if (loader.register)
      return;

    loader.register = registerModule;

    if (!loader.defined)
      loader.defined = {};
    
    // script injection mode calls this function synchronously on load
    var onScriptLoad = loader.onScriptLoad;
    loader.onScriptLoad = function(load) {
      onScriptLoad(load);
      // anonymous define
      if (anonRegister)
        load.metadata.entry = anonRegister;
      
      if (calledRegister) {
        load.metadata.format = load.metadata.format || 'register';
        load.metadata.registered = true;
      }
    }
  }

  defineRegister(loader);

  function buildGroups(entry, loader, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = loader.defined[depName];
      
      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;
      
      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {
        
        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, loader, groups);
    }
  }

  function link(name, loader) {
    var startEntry = loader.defined[name];

    // skip if already linked
    if (startEntry.module)
      return;

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, loader, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry, loader);
        else
          linkDynamicModule(entry, loader);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry, loader) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(loader.global, function(name, value) {
      module.locked = true;
      exports[name] = value;

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          importerModule.setters[importerIndex](exports);
        }
      }

      module.locked = false;
      return value;
    });
    
    module.setters = declaration.setters;
    module.execute = declaration.execute;

    if (!module.setters || !module.execute) {
      throw new TypeError('Invalid System.register form for ' + entry.name);
    }

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = loader.defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      // dynamic, already linked in our registry
      else if (depEntry && !depEntry.declarative) {
        if (depEntry.module.exports && depEntry.module.exports.__esModule)
          depExports = depEntry.module.exports;
        else
          depExports = { 'default': depEntry.module.exports, '__useDefault': true };
      }
      // in the loader registry
      else if (!depEntry) {
        depExports = loader.get(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry, loader);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else {
        module.dependencies.push(null);
      }

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name, loader) {
    var exports;
    var entry = loader.defined[name];

    if (!entry) {
      exports = loader.get(name);
      if (!exports)
        throw new Error('Unable to load dependency ' + name + '.');
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, [], loader);
    
      else if (!entry.evaluated)
        linkDynamicModule(entry, loader);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];
    
    return exports;
  }

  function linkDynamicModule(entry, loader) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = loader.defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry, loader);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(loader.global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i], loader);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);
    
    if (output)
      module.exports = output;
      
    /*if ( output && output.__esModule )
      entry.module = output;
    else if (output)
      entry.module['default'] = output;*/
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen, loader) {
    var entry = loader.defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!loader.defined[depName])
          loader.get(depName);
        else
          ensureEvaluated(depName, seen, loader);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(loader.global);
  }

  var registerRegEx = /System\.register/;

  var loaderFetch = loader.fetch;
  loader.fetch = function(load) {
    var loader = this;
    defineRegister(loader);
    if (loader.defined[load.name]) {
      load.metadata.format = 'defined';
      return '';
    }
    anonRegister = null;
    calledRegister = false;
    // the above get picked up by onScriptLoad
    return loaderFetch.call(loader, load);
  }

  var loaderTranslate = loader.translate;
  loader.translate = function(load) {
    this.register = registerModule;

    this.__exec = exec;

    load.metadata.deps = load.metadata.deps || [];

    // we run the meta detection here (register is after meta)
    return Promise.resolve(loaderTranslate.call(this, load)).then(function(source) {
      
      // dont run format detection for globals shimmed
      // ideally this should be in the global extension, but there is
      // currently no neat way to separate it
      if (load.metadata.init || load.metadata.exports)
        load.metadata.format = load.metadata.format || 'global';

      // run detection for register format
      if (load.metadata.format == 'register' || !load.metadata.format && load.source.match(registerRegEx))
        load.metadata.format = 'register';
      return source;
    });
  }


  var loaderInstantiate = loader.instantiate;
  loader.instantiate = function(load) {
    var loader = this;

    var entry;

    // first we check if this module has already been defined in the registry
    if (loader.defined[load.name]) {
      entry = loader.defined[load.name];
      entry.deps = entry.deps.concat(load.metadata.deps);
    }

    // picked up already by a script injection
    else if (load.metadata.entry)
      entry = load.metadata.entry;

    // otherwise check if it is dynamic
    else if (load.metadata.execute) {
      entry = {
        declarative: false,
        deps: load.metadata.deps || [],
        execute: load.metadata.execute,
        executingRequire: load.metadata.executingRequire // NodeJS-style requires or not
      };
    }

    // Contains System.register calls
    else if (load.metadata.format == 'register') {
      anonRegister = null;
      calledRegister = false;

      var curSystem = loader.global.System;

      loader.global.System = loader;

      loader.__exec(load);

      loader.global.System = curSystem;

      if (anonRegister)
        entry = anonRegister;

      if (!entry && System.defined[load.name])
        entry = System.defined[load.name];

      if (!calledRegister && !load.metadata.registered)
        throw new TypeError(load.name + ' detected as System.register but didn\'t execute.');
    }

    // named bundles are just an empty module
    if (!entry && load.metadata.format != 'es6')
      return {
        deps: load.metadata.deps,
        execute: function() {
          return loader.newModule({});
        }
      };

    // place this module onto defined for circular references
    if (entry)
      loader.defined[load.name] = entry;

    // no entry -> treat as ES6
    else
      return loaderInstantiate.call(this, load);

    entry.deps = dedupe(entry.deps);
    entry.name = load.name;

    // first, normalize all dependencies
    var normalizePromises = [];
    for (var i = 0, l = entry.deps.length; i < l; i++)
      normalizePromises.push(Promise.resolve(loader.normalize(entry.deps[i], load.name)));

    return Promise.all(normalizePromises).then(function(normalizedDeps) {

      entry.normalizedDeps = normalizedDeps;

      return {
        deps: entry.deps,
        execute: function() {
          // recursively ensure that the module and all its 
          // dependencies are linked (with dependency group handling)
          link(load.name, loader);

          // now handle dependency execution in correct order
          ensureEvaluated(load.name, [], loader);

          // remove from the registry
          loader.defined[load.name] = undefined;

          var module = entry.module.exports;

          if (!module || !entry.declarative && module.__esModule !== true)
            module = { 'default': module, __useDefault: true };

          // return the defined module object
          return loader.newModule(module);
        }
      };
    });
  }
}
/*
 * Extension to detect ES6 and auto-load Traceur or Babel for processing
 */
function es6(loader) {
  loader._extensions.push(es6);

  // good enough ES6 detection regex - format detections not designed to be accurate, but to handle the 99% use case
  var es6RegEx = /(^\s*|[}\);\n]\s*)(import\s+(['"]|(\*\s+as\s+)?[^"'\(\)\n;]+\s+from\s+['"]|\{)|export\s+\*\s+from\s+["']|export\s+(\{|default|function|class|var|const|let|async\s+function))/;

  var traceurRuntimeRegEx = /\$traceurRuntime\s*\./;
  var babelHelpersRegEx = /babelHelpers\s*\./;

  var transpilerNormalized, transpilerRuntimeNormalized;

  var firstLoad = true;

  var nodeResolver = typeof process != 'undefined' && typeof require != 'undefined' && require.resolve;

  function setConfig(loader, module, nodeModule) {
    loader.meta[module] = {format: 'global'};
    if (nodeResolver && !loader.paths[module]) {
      try {
        loader.paths[module] = require.resolve(nodeModule || module);
      }
      catch(e) {}
    }
  }

  var loaderLocate = loader.locate;
  loader.locate = function(load) {
    var self = this;
    if (firstLoad) {
      if (self.transpiler == 'traceur') {
        setConfig(self, 'traceur', 'traceur/bin/traceur.js');
        self.meta['traceur'].exports = 'traceur';
        setConfig(self, 'traceur-runtime', 'traceur/bin/traceur-runtime.js');
      }
      else if (self.transpiler == 'babel') {
        setConfig(self, 'babel', 'babel-core/browser.js');
        setConfig(self, 'babel-runtime', 'babel-core/external-helpers.js');
      }
      firstLoad = false;
    }
    return loaderLocate.call(self, load);
  };

  var loaderTranslate = loader.translate;
  loader.translate = function(load) {
    var loader = this;

    return loaderTranslate.call(loader, load)
    .then(function(source) {

      // detect ES6
      if (load.metadata.format == 'es6' || !load.metadata.format && source.match(es6RegEx)) {
        load.metadata.format = 'es6';
        return source;
      }

      if (load.metadata.format == 'register') {
        if (!loader.global.$traceurRuntime && load.source.match(traceurRuntimeRegEx)) {
          return loader['import']('traceur-runtime').then(function() {
            return source;
          });
        }
        if (!loader.global.babelHelpers && load.source.match(babelHelpersRegEx)) {
          return loader['import']('babel/external-helpers').then(function() {
            return source;
          });
        }
      }

      // ensure Traceur doesn't clobber the System global
      if (loader.transpiler == 'traceur')
        return Promise.all([
          transpilerNormalized || (transpilerNormalized = loader.normalize(loader.transpiler)),
          transpilerRuntimeNormalized || (transpilerRuntimeNormalized = loader.normalize(loader.transpiler + '-runtime'))
        ])
        .then(function(normalized) {
          if (load.name == normalized[0] || load.name == normalized[1])
            return '(function() { var curSystem = System; ' + source + '\nSystem = curSystem; })();';

          return source;
        });

      return source;
    });

  };

}
/*
  SystemJS Global Format

  Supports
    metadata.deps
    metadata.init
    metadata.exports

  Also detects writes to the global object avoiding global collisions.
  See the SystemJS readme global support section for further information.
*/
function global(loader) {

  loader._extensions.push(global);

  function readGlobalProperty(p, value) {
    var pParts = p.split('.');
    while (pParts.length)
      value = value[pParts.shift()];
    return value;
  }

  function createHelpers(loader) {
    if (loader.has('@@global-helpers'))
      return;

    var hasOwnProperty = loader.global.hasOwnProperty;
    var moduleGlobals = {};

    var curGlobalObj;
    var ignoredGlobalProps;

    function makeLookupObject(arr) {
      var out = {};
      for(var i = 0, len = arr.length; i < len; i++) {
        out[arr[i]] = true;
      }
      return out;
    }

    loader.set('@@global-helpers', loader.newModule({
      prepareGlobal: function(moduleName, deps, exportName) {
        // first, we add all the dependency modules to the global
        for (var i = 0; i < deps.length; i++) {
          var moduleGlobal = moduleGlobals[deps[i]];
          if (moduleGlobal)
            for (var m in moduleGlobal)
              loader.global[m] = moduleGlobal[m];
        }

        // If an exportName is defined there is no need to perform the next
        // expensive operation.
        if(exportName || exportName === false || loader.inferGlobals === false) {
          return;
        }

        // now store a complete copy of the global object
        // in order to detect changes
        curGlobalObj = {};
        ignoredGlobalProps = makeLookupObject(['indexedDB', 'sessionStorage', 'localStorage',
          'clipboardData', 'frames', 'webkitStorageInfo', 'toolbar', 'statusbar',
          'scrollbars', 'personalbar', 'menubar', 'locationbar', 'webkitIndexedDB',
          'screenTop', 'screenLeft'
        ]);
        for (var g in loader.global) {
          if (ignoredGlobalProps[g]) { continue; }
          if (!hasOwnProperty || loader.global.hasOwnProperty(g)) {
            try {
              curGlobalObj[g] = loader.global[g];
            } catch (e) {
              ignoredGlobalProps[g] = true;
            }
          }
        }
      },
      retrieveGlobal: function(moduleName, exportName, init) {
        var singleGlobal;
        var multipleExports;
        var exports = {};

        // run init
        if (init)
          singleGlobal = init.call(loader.global);

        // check for global changes, creating the globalObject for the module
        // if many globals, then a module object for those is created
        // if one global, then that is the module directly
        else if (exportName) {
          var firstPart = exportName.split('.')[0];
          singleGlobal = readGlobalProperty(exportName, loader.global);
          exports[firstPart] = loader.global[firstPart];
        }

        else if(exportName !== false && loader.inferGlobals !== false) {
          for (var g in loader.global) {
            if (ignoredGlobalProps[g])
              continue;
            if ((!hasOwnProperty || loader.global.hasOwnProperty(g)) && g != loader.global && curGlobalObj[g] != loader.global[g]) {
              exports[g] = loader.global[g];
              if (singleGlobal) {
                if (singleGlobal !== loader.global[g])
                  multipleExports = true;
              }
              else if (singleGlobal === undefined) {
                singleGlobal = loader.global[g];
              }
            }
          }
        }

        moduleGlobals[moduleName] = exports;

        return multipleExports ? exports : singleGlobal;
      }
    }));
  }

  createHelpers(loader);

  var loaderInstantiate = loader.instantiate;
  loader.instantiate = function(load) {
    var loader = this;

    createHelpers(loader);

    var exportName = load.metadata.exports;

    if (!load.metadata.format)
      load.metadata.format = 'global';

    // global is a fallback module format
    if (load.metadata.format == 'global') {
      load.metadata.execute = function(require, exports, module) {

        loader.get('@@global-helpers').prepareGlobal(module.id, load.metadata.deps, exportName);

        if (exportName)
          load.source += '\nthis["' + exportName + '"] = ' + exportName + ';';

        // disable module detection
        var define = loader.global.define;
        var require = loader.global.require;

        loader.global.define = undefined;
        loader.global.module = undefined;
        loader.global.exports = undefined;

        loader.__exec(load);

        loader.global.require = require;
        loader.global.define = define;

        return loader.get('@@global-helpers').retrieveGlobal(module.id, exportName, load.metadata.init);
      }
    }
    return loaderInstantiate.call(loader, load);
  }
}
/*
  SystemJS CommonJS Format
*/
function cjs(loader) {
  loader._extensions.push(cjs);

  // CJS Module Format
  // require('...') || exports[''] = ... || exports.asd = ... || module.exports = ...
  var cjsExportsRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.]|module\.)(exports\s*\[['"]|\exports\s*\.)|(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])module\.exports\s*\=/;
  // RegEx adjusted from https://github.com/jbrantly/yabble/blob/master/lib/yabble.js#L339
  var cjsRequireRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')\s*\)/g;
  var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;

  function getCJSDeps(source) {
    cjsRequireRegEx.lastIndex = 0;

    var deps = [];

    // remove comments from the source first, if not minified
    if (source.length / source.split('\n').length < 200)
      source = source.replace(commentRegEx, '');

    var match;

    while (match = cjsRequireRegEx.exec(source))
      deps.push(match[1].substr(1, match[1].length - 2));

    return deps;
  }

  var loaderInstantiate = loader.instantiate;
  loader.instantiate = function(load) {

    if (!load.metadata.format) {
      cjsExportsRegEx.lastIndex = 0;
      cjsRequireRegEx.lastIndex = 0;
      if (cjsRequireRegEx.exec(load.source) || cjsExportsRegEx.exec(load.source))
        load.metadata.format = 'cjs';
    }

    if (load.metadata.format == 'cjs') {
      load.metadata.deps = load.metadata.deps ? load.metadata.deps.concat(getCJSDeps(load.source)) : getCJSDeps(load.source);

      load.metadata.executingRequire = true;

      load.metadata.execute = function(require, exports, module) {
        var dirname = (load.address || '').split('/');
        dirname.pop();
        dirname = dirname.join('/');

        // if on the server, remove the "file:" part from the dirname
        if (System._nodeRequire)
          dirname = dirname.substr(5);

        var globals = loader.global._g = {
          global: loader.global,
          exports: exports,
          module: module,
          require: require,
          __filename: System._nodeRequire ? load.address.substr(5) : load.address,
          __dirname: dirname
        };


        // disable AMD detection
        var define = loader.global.define;
        loader.global.define = undefined;

        var execLoad = {
          name: load.name,
          source: '(function() {\n(function(global, exports, module, require, __filename, __dirname){\n' + load.source + 
                                  '\n}).call(_g.exports, _g.global, _g.exports, _g.module, _g.require, _g.__filename, _g.__dirname);})();',
          address: load.address
        };
        loader.__exec(execLoad);

        loader.global.define = define;

        loader.global._g = undefined;
      }
    }

    return loaderInstantiate.call(this, load);
  };
}
/*
  SystemJS AMD Format
  Provides the AMD module format definition at System.format.amd
  as well as a RequireJS-style require on System.require
*/
function amd(loader) {
  // by default we only enforce AMD noConflict mode in Node
  var isNode = typeof module != 'undefined' && module.exports;

  loader._extensions.push(amd);

  // AMD Module Format Detection RegEx
  // define([.., .., ..], ...)
  // define(varName); || define(function(require, exports) {}); || define({})
  var amdRegEx = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/;
  var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;

  var cjsRequirePre = "(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])";
  var cjsRequirePost = "\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)";

  var fnBracketRegEx = /\(([^\)]*)\)/;

  var wsRegEx = /^\s+|\s+$/g;

  var requireRegExs = {};

  function getCJSDeps(source, requireIndex) {

    // remove comments
    source = source.replace(commentRegEx, '');

    // determine the require alias
    var params = source.match(fnBracketRegEx);
    var requireAlias = (params[1].split(',')[requireIndex] || 'require').replace(wsRegEx, '');

    // find or generate the regex for this requireAlias
    var requireRegEx = requireRegExs[requireAlias] || (requireRegExs[requireAlias] = new RegExp(cjsRequirePre + requireAlias + cjsRequirePost, 'g'));

    requireRegEx.lastIndex = 0;

    var deps = [];

    var match;
    while (match = requireRegEx.exec(source))
      deps.push(match[2] || match[3]);

    return deps;
  }

  /*
    AMD-compatible require
    To copy RequireJS, set window.require = window.requirejs = loader.amdRequire
  */
  function require(names, callback, errback, referer) {
    // 'this' is bound to the loader
    var loader = this;

    // in amd, first arg can be a config object... we just ignore
    if (typeof names == 'object' && !(names instanceof Array))
      return require.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1));

    // amd require
    if (names instanceof Array)
      Promise.all(names.map(function(name) {
        return loader['import'](name, referer);
      })).then(function(modules) {
        if(callback) {
          callback.apply(null, modules);
        }
      }, errback);

    // commonjs require
    else if (typeof names == 'string') {
      var module = loader.get(names);
      return module.__useDefault ? module['default'] : module;
    }

    else
      throw new TypeError('Invalid require');
  };
  loader.amdRequire = function() {
    return require.apply(this, arguments);
  };

  function makeRequire(parentName, staticRequire, loader) {
    return function(names, callback, errback) {
      if (typeof names == 'string')
        return staticRequire(names);
      return require.call(loader, names, callback, errback, { name: parentName });
    }
  }

  // run once per loader
  function generateDefine(loader) {
    // script injection mode calls this function synchronously on load
    var onScriptLoad = loader.onScriptLoad;
    loader.onScriptLoad = function(load) {
      onScriptLoad(load);
      if (anonDefine || defineBundle) {
        load.metadata.format = 'defined';
        load.metadata.registered = true;
      }

      if (anonDefine) {
        load.metadata.deps = load.metadata.deps ? load.metadata.deps.concat(anonDefine.deps) : anonDefine.deps;
        load.metadata.execute = anonDefine.execute;
      }
    }

    function define(name, deps, factory) {
      if (typeof name != 'string') {
        factory = deps;
        deps = name;
        name = null;
      }
      if (!(deps instanceof Array)) {
        factory = deps;
        deps = ['require', 'exports', 'module'];
      }

      if (typeof factory != 'function')
        factory = (function(factory) {
          return function() { return factory; }
        })(factory);

      // in IE8, a trailing comma becomes a trailing undefined entry
      if (deps[deps.length - 1] === undefined)
        deps.pop();

      // remove system dependencies
      var requireIndex, exportsIndex, moduleIndex;
      
      if ((requireIndex = indexOf.call(deps, 'require')) != -1) {
        
        deps.splice(requireIndex, 1);

        var factoryText = factory.toString();

        deps = deps.concat(getCJSDeps(factoryText, requireIndex));
      }
        

      if ((exportsIndex = indexOf.call(deps, 'exports')) != -1)
        deps.splice(exportsIndex, 1);
      
      if ((moduleIndex = indexOf.call(deps, 'module')) != -1)
        deps.splice(moduleIndex, 1);

      var define = {
        deps: deps,
        execute: function(require, exports, module) {

          var depValues = [];
          for (var i = 0; i < deps.length; i++)
            depValues.push(require(deps[i]));

          module.uri = loader.baseURL + module.id;

          module.config = function() {};

          // add back in system dependencies
          if (moduleIndex != -1)
            depValues.splice(moduleIndex, 0, module);
          
          if (exportsIndex != -1)
            depValues.splice(exportsIndex, 0, exports);
          
          if (requireIndex != -1)
            depValues.splice(requireIndex, 0, makeRequire(module.id, require, loader));

          var output = factory.apply(global, depValues);

          if (typeof output == 'undefined' && module)
            output = module.exports;

          if (typeof output != 'undefined')
            return output;
        }
      };

      // anonymous define
      if (!name) {
        // already defined anonymously -> throw
        if (anonDefine)
          throw new TypeError('Multiple defines for anonymous module');
        anonDefine = define;
      }
      // named define
      else {
        // if it has no dependencies and we don't have any other
        // defines, then let this be an anonymous define
        if (deps.length == 0 && !anonDefine && !defineBundle)
          anonDefine = define;

        // otherwise its a bundle only
        else
          anonDefine = null;

        // the above is just to support single modules of the form:
        // define('jquery')
        // still loading anonymously
        // because it is done widely enough to be useful

        // note this is now a bundle
        defineBundle = true;

        // define the module through the register registry
        loader.register(name, define.deps, false, define.execute);
      }
    };
    define.amd = {};
    loader.amdDefine = define;
  }

  var anonDefine;
  // set to true if the current module turns out to be a named define bundle
  var defineBundle;

  var oldModule, oldExports, oldDefine;

  // adds define as a global (potentially just temporarily)
  function createDefine(loader) {
    if (!loader.amdDefine)
      generateDefine(loader);

    anonDefine = null;
    defineBundle = null;

    // ensure no NodeJS environment detection
    var global = loader.global;

    oldModule = global.module;
    oldExports = global.exports;
    oldDefine = global.define;

    global.module = undefined;
    global.exports = undefined;

    if (global.define && global.define === loader.amdDefine)
      return;

    global.define = loader.amdDefine;
  }

  function removeDefine(loader) {
    var global = loader.global;
    global.define = oldDefine;
    global.module = oldModule;
    global.exports = oldExports;
  }

  generateDefine(loader);

  if (loader.scriptLoader) {
    var loaderFetch = loader.fetch;
    loader.fetch = function(load) {
      createDefine(this);
      return loaderFetch.call(this, load);
    }
  }

  var loaderInstantiate = loader.instantiate;
  loader.instantiate = function(load) {
    var loader = this;

    if (load.metadata.format == 'amd' || !load.metadata.format && load.source.match(amdRegEx)) {
      load.metadata.format = 'amd';

      if (loader.execute !== false) {
        createDefine(loader);

        loader.__exec(load);

        removeDefine(loader);

        if (!anonDefine && !defineBundle && !isNode)
          throw new TypeError('AMD module ' + load.name + ' did not define');
      }

      if (anonDefine) {
        load.metadata.deps = load.metadata.deps ? load.metadata.deps.concat(anonDefine.deps) : anonDefine.deps;
        load.metadata.execute = anonDefine.execute;
      }
    }

    return loaderInstantiate.call(loader, load);
  }
}
/*
  SystemJS map support
  
  Provides map configuration through
    System.map['jquery'] = 'some/module/map'

  As well as contextual map config through
    System.map['bootstrap'] = {
      jquery: 'some/module/map2'
    }

  Note that this applies for subpaths, just like RequireJS

  jquery      -> 'some/module/map'
  jquery/path -> 'some/module/map/path'
  bootstrap   -> 'bootstrap'

  Inside any module name of the form 'bootstrap' or 'bootstrap/*'
    jquery    -> 'some/module/map2'
    jquery/p  -> 'some/module/map2/p'

  Maps are carefully applied from most specific contextual map, to least specific global map
*/
function map(loader) {
  loader.map = loader.map || {};

  loader._extensions.push(map);

  // return if prefix parts (separated by '/') match the name
  // eg prefixMatch('jquery/some/thing', 'jquery') -> true
  //    prefixMatch('jqueryhere/', 'jquery') -> false
  function prefixMatch(name, prefix) {
    if (name.length < prefix.length)
      return false;
    if (name.substr(0, prefix.length) != prefix)
      return false;
    if (name[prefix.length] && name[prefix.length] != '/')
      return false;
    return true;
  }

  // get the depth of a given path
  // eg pathLen('some/name') -> 2
  function pathLen(name) {
    var len = 1;
    for (var i = 0, l = name.length; i < l; i++)
      if (name[i] === '/')
        len++;
    return len;
  }

  function doMap(name, matchLen, map) {
    return map + name.substr(matchLen);
  }

  // given a relative-resolved module name and normalized parent name,
  // apply the map configuration
  function applyMap(name, parentName, loader) {
    var curMatch, curMatchLength = 0;
    var curParent, curParentMatchLength = 0;
    var tmpParentLength, tmpPrefixLength;
    var subPath;
    var nameParts;
    
    // first find most specific contextual match
    if (parentName) {
      for (var p in loader.map) {
        var curMap = loader.map[p];
        if (typeof curMap != 'object')
          continue;

        // most specific parent match wins first
        if (!prefixMatch(parentName, p))
          continue;

        tmpParentLength = pathLen(p);
        if (tmpParentLength <= curParentMatchLength)
          continue;

        for (var q in curMap) {
          // most specific name match wins
          if (!prefixMatch(name, q))
            continue;
          tmpPrefixLength = pathLen(q);
          if (tmpPrefixLength <= curMatchLength)
            continue;

          curMatch = q;
          curMatchLength = tmpPrefixLength;
          curParent = p;
          curParentMatchLength = tmpParentLength;
        }
      }
    }

    // if we found a contextual match, apply it now
    if (curMatch)
      return doMap(name, curMatch.length, loader.map[curParent][curMatch]);

    // now do the global map
    for (var p in loader.map) {
      var curMap = loader.map[p];
      if (typeof curMap != 'string')
        continue;

      if (!prefixMatch(name, p))
        continue;

      var tmpPrefixLength = pathLen(p);

      if (tmpPrefixLength <= curMatchLength)
        continue;

      curMatch = p;
      curMatchLength = tmpPrefixLength;
    }

    if (curMatch)
      return doMap(name, curMatch.length, loader.map[curMatch]);

    return name;
  }

  var loaderNormalize = loader.normalize;
  loader.normalize = function(name, parentName, parentAddress) {
    var loader = this;
    if (!loader.map)
      loader.map = {};

    var isPackage = false;
    if (name.substr(name.length - 1, 1) == '/') {
      isPackage = true;
      name += '#';
    }

    return Promise.resolve(loaderNormalize.call(loader, name, parentName, parentAddress))
    .then(function(name) {
      name = applyMap(name, parentName, loader);

      // Normalize "module/" into "module/module"
      // Convenient for packages
      if (isPackage) {
        var nameParts = name.split('/');
        nameParts.pop();
        var pkgName = nameParts.pop();
        nameParts.push(pkgName);
        nameParts.push(pkgName);
        name = nameParts.join('/');
      }

      return name;
    });
  }
}
/*
  SystemJS Plugin Support

  Supports plugin syntax with "!"

  The plugin name is loaded as a module itself, and can override standard loader hooks
  for the plugin resource. See the plugin section of the systemjs readme.
*/
function plugins(loader) {
  if (typeof indexOf == 'undefined')
    indexOf = Array.prototype.indexOf;

  loader._extensions.push(plugins);

  var loaderNormalize = loader.normalize;
  loader.normalize = function(name, parentName, parentAddress) {
    var loader = this;
    // if parent is a plugin, normalize against the parent plugin argument only
    var parentPluginIndex;
    if (parentName && (parentPluginIndex = parentName.indexOf('!')) != -1)
      parentName = parentName.substr(0, parentPluginIndex);

    return Promise.resolve(loaderNormalize.call(loader, name, parentName, parentAddress))
    .then(function(name) {
      // if this is a plugin, normalize the plugin name and the argument
      var pluginIndex = name.lastIndexOf('!');
      if (pluginIndex != -1) {
        var argumentName = name.substr(0, pluginIndex);

        // plugin name is part after "!" or the extension itself
        var pluginName = name.substr(pluginIndex + 1) || argumentName.substr(argumentName.lastIndexOf('.') + 1);

        // normalize the plugin name relative to the same parent
        return new Promise(function(resolve) {
          resolve(loader.normalize(pluginName, parentName, parentAddress));
        })
        // normalize the plugin argument
        .then(function(_pluginName) {
          pluginName = _pluginName;
          return loader.normalize(argumentName, parentName, parentAddress, true);
        })
        .then(function(argumentName) {
          return argumentName + '!' + pluginName;
        });
      }

      // standard normalization
      return name;
    });
  };

  var loaderLocate = loader.locate;
  loader.locate = function(load) {
    var loader = this;

    var name = load.name;

    // only fetch the plugin itself if this name isn't defined
    if (this.defined && this.defined[name])
      return loaderLocate.call(this, load);

    // plugin
    var pluginIndex = name.lastIndexOf('!');
    if (pluginIndex != -1) {
      var pluginName = name.substr(pluginIndex + 1);

      // the name to locate is the plugin argument only
      load.name = name.substr(0, pluginIndex);

      var pluginLoader = loader.pluginLoader || loader;

      // load the plugin module
      // NB ideally should use pluginLoader.load for normalized,
      //    but not currently working for some reason
      return pluginLoader['import'](pluginName)
      .then(function() {
        var plugin = pluginLoader.get(pluginName);
        plugin = plugin['default'] || plugin;

        // allow plugins to opt-out of build
        if (plugin.build === false && loader.pluginLoader)
          load.metadata.build = false;

        // store the plugin module itself on the metadata
        load.metadata.plugin = plugin;
        load.metadata.pluginName = pluginName;
        load.metadata.pluginArgument = load.name;
        load.metadata.buildType = plugin.buildType || "js";

        // run plugin locate if given
        if (plugin.locate)
          return plugin.locate.call(loader, load);

        // otherwise use standard locate without '.js' extension adding
        else
          return Promise.resolve(loader.locate(load))
          .then(function(address) {
            return address.replace(/\.js$/, '');
          });
      });
    }

    return loaderLocate.call(this, load);
  };

  var loaderFetch = loader.fetch;
  loader.fetch = function(load) {
    var loader = this;
    // ignore fetching build = false unless in a plugin loader
    if (load.metadata.build === false && loader.pluginLoader)
      return '';
    else if (load.metadata.plugin && load.metadata.plugin.fetch && !load.metadata.pluginFetchCalled) {
      load.metadata.pluginFetchCalled = true;
      return load.metadata.plugin.fetch.call(loader, load, loaderFetch);
    }
    else
      return loaderFetch.call(loader, load);
  };

  var loaderTranslate = loader.translate;
  loader.translate = function(load) {
    var loader = this;
    if (load.metadata.plugin && load.metadata.plugin.translate)
      return Promise.resolve(load.metadata.plugin.translate.call(loader, load)).then(function(result) {
        if (typeof result == 'string')
          load.source = result;
        return loaderTranslate.call(loader, load);
      });
    else
      return loaderTranslate.call(loader, load);
  };

  var loaderInstantiate = loader.instantiate;
  loader.instantiate = function(load) {
    var loader = this;
    if (load.metadata.plugin && load.metadata.plugin.instantiate)
       return Promise.resolve(load.metadata.plugin.instantiate.call(loader, load)).then(function(result) {
        if (result) {
          // load.metadata.format = 'defined';
          // load.metadata.execute = function() {
          //   return result;
          // };
          return result;
        }
        return loaderInstantiate.call(loader, load);
      });
    else if (load.metadata.plugin && load.metadata.plugin.build === false) {
      load.metadata.format = 'defined';
      load.metadata.deps.push(load.metadata.pluginName);
      load.metadata.execute = function() {
        return loader.newModule({});
      };
      return loaderInstantiate.call(loader, load);
    }
    else
      return loaderInstantiate.call(loader, load);
  }

}
/*
  System bundles

  Allows a bundle module to be specified which will be dynamically 
  loaded before trying to load a given module.

  For example:
  System.bundles['mybundle'] = ['jquery', 'bootstrap/js/bootstrap']

  Will result in a load to "mybundle" whenever a load to "jquery"
  or "bootstrap/js/bootstrap" is made.

  In this way, the bundle becomes the request that provides the module
*/

function bundles(loader) {
  if (typeof indexOf == 'undefined')
    indexOf = Array.prototype.indexOf;

  loader._extensions.push(bundles);

  // bundles support (just like RequireJS)
  // bundle name is module name of bundle itself
  // bundle is array of modules defined by the bundle
  // when a module in the bundle is requested, the bundle is loaded instead
  // of the form System.bundles['mybundle'] = ['jquery', 'bootstrap/js/bootstrap']
  loader.bundles = loader.bundles || {};

  var loaderFetch = loader.fetch;
  loader.fetch = function(load) {
    var loader = this;
    if (loader.trace)
      return loaderFetch.call(this, load);
    if (!loader.bundles)
      loader.bundles = {};

    // if this module is in a bundle, load the bundle first then
    for (var b in loader.bundles) {
      if (indexOf.call(loader.bundles[b], load.name) == -1)
        continue;
      // we do manual normalization in case the bundle is mapped
      // this is so we can still know the normalized name is a bundle
      return Promise.resolve(loader.normalize(b))
      .then(function(normalized) {
        loader.bundles[normalized] = loader.bundles[normalized] || loader.bundles[b];

        // note this module is a bundle in the meta
        loader.meta = loader.meta || {};
        loader.meta[normalized] = loader.meta[normalized] || {};
        loader.meta[normalized].bundle = true;

        return loader.load(normalized);
      })
      .then(function() {
        return '';
      });
    }
    return loaderFetch.call(this, load);
  }
}
/*
 * Dependency Tree Cache
 * 
 * Allows a build to pre-populate a dependency trace tree on the loader of 
 * the expected dependency tree, to be loaded upfront when requesting the
 * module, avoinding the n round trips latency of module loading, where 
 * n is the dependency tree depth.
 *
 * eg:
 * System.depCache = {
 *  'app': ['normalized', 'deps'],
 *  'normalized': ['another'],
 *  'deps': ['tree']
 * };
 * 
 * System.import('app') 
 * // simultaneously starts loading all of:
 * // 'normalized', 'deps', 'another', 'tree'
 * // before "app" source is even loaded
 */

function depCache(loader) {
  loader.depCache = loader.depCache || {};

  loader._extensions.push(depCache);

  var loaderLocate = loader.locate;
  loader.locate = function(load) {
    var loader = this;

    if (!loader.depCache)
      loader.depCache = {};

    // load direct deps, in turn will pick up their trace trees
    var deps = loader.depCache[load.name];
    if (deps)
      for (var i = 0; i < deps.length; i++)
        loader.load(deps[i]);

    return loaderLocate.call(loader, load);
  }
}
  
core(System);
meta(System);
register(System);
es6(System);
global(System);
cjs(System);
amd(System);
map(System);
plugins(System);
bundles(System);
depCache(System);

};

var $__curScript, __eval;

(function() {

  var doEval;

  __eval = function(source, address, sourceMap) {
    source += '\n//# sourceURL=' + address + (sourceMap ? '\n//# sourceMappingURL=' + sourceMap : '');

    try {
      doEval(source);
    }
    catch(e) {
      var msg = 'Error evaluating ' + address + '\n';
      if (e instanceof Error)
        e.message = msg + e.message;
      else
        e = msg + e;
      throw e;
    }
  };

  if (typeof document != 'undefined') {
    var head;

    var scripts = document.getElementsByTagName('script');
    $__curScript = scripts[scripts.length - 1];

    // globally scoped eval for the browser
    doEval = function(source) {
      if (!head)
        head = document.head || document.body || document.documentElement;

      var script = document.createElement('script');
      script.text = source;
      var onerror = window.onerror;
      var e;
      window.onerror = function(_e) {
        e = _e;
      }
      head.appendChild(script);
      head.removeChild(script);
      window.onerror = onerror;
      if (e)
        throw e;
    }

    if (!$__global.System || !$__global.LoaderPolyfill) {
      // determine the current script path as the base path
      var curPath = $__curScript.src;
      var basePath = curPath.substr(0, curPath.lastIndexOf('/') + 1);
      document.write(
        '<' + 'script type="text/javascript" src="' + basePath + 'steal-es6-module-loader.js" data-init="upgradeSystemLoader">' + '<' + '/script>'
      );
    }
    else {
      $__global.upgradeSystemLoader();
    }
  }
  else if (typeof WorkerGlobalScope != 'undefined' && typeof importScripts != 'undefined') {
    doEval = function(source) {
      try {
        eval(source);
      } catch(e) {
        throw e;
      }
    };

    if (!$__global.System || !$__global.LoaderPolyfill) {
      var basePath = '';
      try {
        throw new Error('Get worker base path via error stack');
      } catch (e) {
        e.stack.replace(/(?:at|@).*(http.+):[\d]+:[\d]+/, function (m, url) {
          basePath = url.replace(/\/[^\/]*$/, '/');
        });
      }
      importScripts(basePath + 'steal-es6-module-loader.js');
      $__global.upgradeSystemLoader();
    } else {
      $__global.upgradeSystemLoader();
    }
  }
  else {
    var es6ModuleLoader = require('steal-es6-module-loader');
    $__global.System = es6ModuleLoader.System;
    $__global.Loader = es6ModuleLoader.Loader;
    $__global.upgradeSystemLoader();
    module.exports = $__global.System;

    // global scoped eval for node
    var vm = require('vm');
    doEval = function(source, address, sourceMap) {
      vm.runInThisContext(source);
    }
  }
})();

})(typeof window != 'undefined' ? window : (typeof WorkerGlobalScope != 'undefined' ? self : global));

(function(global){

	// helpers
	var camelize = function(str){
		return str.replace(/-+(.)?/g, function(match, chr){ 
			return chr ? chr.toUpperCase() : '' 
		});
	},
		each = function( o, cb){
			var i, len;

			// weak array detection, but we only use this internally so don't
			// pass it weird stuff
			if ( typeof o.length == 'number' && (o.length - 1) in o) {
				for ( i = 0, len = o.length; i < len; i++ ) {
					cb.call(o[i], o[i], i, o);
				}
			} else {
				for ( i in o ) {
					if(o.hasOwnProperty(i)){
						cb.call(o[i], o[i], i, o);
					}
				}
			}
			return o;
		},
		map = function(o, cb) {
			var arr = [];
			each(o, function(item, i){
				arr[i] = cb(item, i);
			});
			return arr;
		},
		isString = function(o) {
			return typeof o == "string";
		},
		extend = function(d,s){
			each(s, function(v, p){
				d[p] = v;
			});
			return d;
		},
		dir = function(uri){
			var lastSlash = uri.lastIndexOf("/");
			//if no / slashes, check for \ slashes since it might be a windows path
			if(lastSlash === -1)
				lastSlash = uri.lastIndexOf("\\");
			if(lastSlash !== -1) {
				return uri.substr(0, lastSlash);
			} else {
				return uri;
			}
		},
		last = function(arr){
			return arr[arr.length - 1];
		},
		parseURI = function(url) {
			var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
				// authority = '//' + user + ':' + pass '@' + hostname + ':' port
				return (m ? {
				href     : m[0] || '',
				protocol : m[1] || '',
				authority: m[2] || '',
				host     : m[3] || '',
				hostname : m[4] || '',
				port     : m[5] || '',
				pathname : m[6] || '',
				search   : m[7] || '',
				hash     : m[8] || ''
			} : null);
		},
		joinURIs = function(base, href) {
			function removeDotSegments(input) {
				var output = [];
				input.replace(/^(\.\.?(\/|$))+/, '')
					.replace(/\/(\.(\/|$))+/g, '/')
					.replace(/\/\.\.$/, '/../')
					.replace(/\/?[^\/]*/g, function (p) {
						if (p === '/..') {
							output.pop();
						} else {
							output.push(p);
						}
					});
				return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
			}

			href = parseURI(href || '');
			base = parseURI(base || '');

			return !href || !base ? null : (href.protocol || base.protocol) +
				(href.protocol || href.authority ? href.authority : base.authority) +
				removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
					(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
					href.hash;
		},
		isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope,
		isBrowserWithWindow = typeof window !== "undefined",
		isNode = !isBrowserWithWindow && !isWebWorker && typeof require != 'undefined';

	var filename = function(uri){
		var lastSlash = uri.lastIndexOf("/");
		//if no / slashes, check for \ slashes since it might be a windows path
		if(lastSlash === -1)
			lastSlash = uri.lastIndexOf("\\");
		var matches = ( lastSlash == -1 ? uri : uri.substr(lastSlash+1) ).match(/^[\w-\s\.!]+/);
		return matches ? matches[0] : "";
	};
	
	var ext = function(uri){
		var fn = filename(uri);
		var dot = fn.lastIndexOf(".");
		if(dot !== -1) {
			return fn.substr(dot+1);
		} else {
			return "";
		}
	};

	var pluginCache = {};
	
	var normalize = function(name, loader){

		// Detech if this name contains a plugin part like: app.less!steal/less
		// and catch the plugin name so that when it is normalized we do not perform
		// Steal's normalization against it.
		var pluginIndex = name.lastIndexOf('!');
		var pluginPart = "";
		if (pluginIndex != -1) {
			// argumentName is the part before the !
			var argumentName = name.substr(0, pluginIndex);
			var pluginName = name.substr(pluginIndex + 1);
			pluginPart = "!" + pluginName;

			// Set the name to the argument name so that we can normalize it alone.
			name = argumentName;
		} 
		
		var last = filename(name),
			extension = ext(name);
		// if the name ends with /
		if(	name[name.length -1] === "/" ) {
			return name+filename( name.substr(0, name.length-1) ) + pluginPart;
		} else if(	!/^(\w+(?:s)?:\/\/|\.|file|\/)/.test(name) &&
			// and doesn't end with a dot
			 last.indexOf(".") === -1 
			) {
			return name+"/"+last + pluginPart;
		} else {
			if(extension === "js") {
				return name.substr(0, name.lastIndexOf(".")) + pluginPart;
			} else {
				return name + pluginPart;
			}
		}
	};

var cloneSteal = function(System){
	var loader = System || this.System;
	return makeSteal(this.addSteal(loader.clone()));
};

var makeSteal = function(System){

	System.set('@loader', System.newModule({'default':System, __useDefault: true}));
	System.config({
		map: {
			"@loader/@loader": "@loader",
			"@steal/@steal": "@steal"
		}
	});

	var configDeferred,
		devDeferred,
		appDeferred;

	var steal = function(){
		var args = arguments;
		var afterConfig = function(){
			var imports = [];
			var factory;
			each(args, function(arg){
				if(isString(arg)) {
					imports.push( steal.System['import']( normalize(arg) ) );
				} else if(typeof arg === "function") {
					factory = arg;
				}
			});

			var modules = Promise.all(imports);
			if(factory) {
				return modules.then(function(modules) {
			        return factory && factory.apply(null, modules);
			   });
			} else {
				return modules;
			}
		};
		if(System.isEnv("production")) {
			return afterConfig();
		} else {
			// wait until the config has loaded
			return configDeferred.then(afterConfig,afterConfig);
		}

	};

	System.set("@steal", System.newModule({"default":steal, __useDefault:true}));

	steal.System = System;
	steal.parseURI = parseURI;
	steal.joinURIs = joinURIs;
	steal.normalize = normalize;

	// System.ext = {bar: "path/to/bar"}
	// foo.bar! -> foo.bar!path/to/bar
	var addExt = function(loader) {

		loader.ext = {};

		var normalize = loader.normalize,
			endingExtension = /\.(\w+)!?$/;

		loader.normalize = function(name, parentName, parentAddress, pluginNormalize){
			if(pluginNormalize) {
				return normalize.apply(this, arguments);
			}

			var matches = name.match(endingExtension),
				ext,
				newName = name;

			if(matches && loader.ext[ext = matches[1]]) {
				var hasBang = name[name.length - 1] === "!";
				newName = name + (hasBang ? "" : "!") + loader.ext[ext];
			}
			return normalize.call(this, newName, parentName, parentAddress);
		};
	};

	if(typeof System){
		addExt(System);
	}



	// "path/to/folder/" -> "path/to/folder/folder"
	var addForwardSlash = function(loader) {
		var normalize = loader.normalize;

		var npmLike = /@.+#.+/;

		loader.normalize = function(name, parentName, parentAddress, pluginNormalize) {
			var lastPos = name.length - 1,
				secondToLast,
				folderName;

			if (name[lastPos] === "/") {
				secondToLast = name.substring(0, lastPos).lastIndexOf("/");
				folderName = name.substring(secondToLast + 1, lastPos);
				if(npmLike.test(folderName)) {
					folderName = folderName.substr(folderName.lastIndexOf("#") + 1);
				}

				name += folderName;
			}
			return normalize.call(this, name, parentName, parentAddress, pluginNormalize);
		};
	};

	if (typeof System) {
		addForwardSlash(System);
	}

function applyTraceExtension(loader){
	if(loader._extensions) {
		loader._extensions.push(applyTraceExtension);
	}

	loader._traceData = {
		loads: {},
		parentMap: {}
	};

	loader.getDependencies = function(moduleName){
		var load = this.getModuleLoad(moduleName);
		return load ? load.metadata.dependencies : undefined;
	};
	loader.getDependants = function(moduleName){
		var deps = [];
		var pars = this._traceData.parentMap[moduleName] || {};
		eachOf(pars, function(name) { deps.push(name); });
		return deps;
	};
	loader.getModuleLoad = function(moduleName){
		return this._traceData.loads[moduleName];
	};
	loader.getBundles = function(moduleName, visited){
		visited = visited || {};
		visited[moduleName] = true;
		var loader = this;
		var parentMap = loader._traceData.parentMap;
		var parents = parentMap[moduleName];
		if(!parents) return [moduleName];

		var bundles = [];
		eachOf(parents, function(parentName, value){
			if(!visited[parentName])
				bundles = bundles.concat(loader.getBundles(parentName, visited));
		});
		return bundles;
	};
	loader._allowModuleExecution = {};
	loader.allowModuleExecution = function(name){
		var loader = this;
		return loader.normalize(name).then(function(name){
			loader._allowModuleExecution[name] = true;
		});
	};

	function eachOf(obj, callback){
		var name, val;
		for(name in obj) {
			callback(name, obj[name]);
		}
	}

	var normalize = loader.normalize;
	loader.normalize = function(name, parentName){
		var normalizePromise = normalize.apply(this, arguments);

		if(parentName) {
			var parentMap = this._traceData.parentMap;
			return normalizePromise.then(function(name){
				if(!parentMap[name]) {
					parentMap[name] = {};
				}
				parentMap[name][parentName] = true;
				return name;
			});
		}

		return normalizePromise;
	};

	var emptyExecute = function(){
		return loader.newModule({});
	};


	var passThroughModules = {
		traceur: true,
		babel: true
	};
	var isAllowedToExecute = function(load){
		return passThroughModules[load.name] || this._allowModuleExecution[load.name];
	};

	var map = [].map || function(callback){
		var res = [];
		for(var i = 0, len = this.length; i < len; i++) {
			res.push(callback(this[i]));
		}
		return res;
	};

	var transpiledDepsExp = /System\.register\((\[.+?\])\,/;
	var singleQuoteExp = /'/g;
	var instantiate = loader.instantiate;
	loader.instantiate = function(load){
		this._traceData.loads[load.name] = load;
		var loader = this;
		var instantiatePromise = Promise.resolve(instantiate.apply(this, arguments));

		function finalizeResult(result){
			var preventExecution = loader.preventModuleExecution &&
				!isAllowedToExecute.call(loader, load);

			// deps either comes from the instantiate result, or if an
			// es6 module it was found in the transpile hook.
			var deps = result ? result.deps : load.metadata.deps;

			return Promise.all(map.call(deps, function(depName){
				return loader.normalize(depName, load.name);
			})).then(function(dependencies){
				load.metadata.deps = deps;
				load.metadata.dependencies = dependencies;

				if(preventExecution) {
					return {
						deps: deps,
						execute: emptyExecute
					};
				}

				return result;

			});
		}

		return instantiatePromise.then(function(result){
			// This must be es6
			if(!result) {
				return loader.transpile(load).then(function(source){
					load.metadata.transpiledSource = source;

					var depsMatches = transpiledDepsExp.exec(source);
					var depsSource = depsMatches ? depsMatches[1] : "[]";
					var deps = JSON.parse(depsSource.replace(singleQuoteExp, '"'));
					load.metadata.deps = deps;

					return finalizeResult(result);
				});
			}
			return finalizeResult(result);
		});
	};

	var transpile = loader.transpile;
	// Allow transpile to be memoized, but only once
	loader.transpile = function(load){
		var transpiled = load.metadata.transpiledSource;
		if(transpiled) {
			delete load.metadata.transpiledSource;
			return Promise.resolve(transpiled);
		}
		return transpile.apply(this, arguments);
	};
}

applyTraceExtension.name = "Trace";

if(typeof System !== "undefined") {
	applyTraceExtension(System);
}

/*
  SystemJS JSON Format
  Provides the JSON module format definition.
*/
function _SYSTEM_addJSON(loader) {
	var jsonTest = /^[\s\n\r]*[\{\[]/;
	var jsonExt = /\.json$/i;
	var jsExt = /\.js$/i;
	var inNode = typeof window === "undefined";

	// Add the extension to _extensions so that it can be cloned.
	loader._extensions.push(_SYSTEM_addJSON);

	// if someone has a moduleName that is .json, make sure it loads a json file
	// no matter what paths might do
	var loaderLocate = loader.locate;
	loader.locate = function(load){
	  return loaderLocate.apply(this, arguments).then(function(address){
		if(jsonExt.test(load.name)) {
			return address.replace(jsExt, "");
		}

	    return address;
	  });
	};

	// If we are in a build we should convert to CommonJS instead.
	if(inNode) {
		var loaderTranslate = loader.translate;
		loader.translate = function(load){
			if(jsonExt.test(load.name)) {
				var parsed = parse(load);
				if(parsed) {
					return "def" + "ine([], function(){\n" +
						"\treturn " + load.source + "\n});";
				}
			}

			return loaderTranslate.call(this, load);
		};
		return;
	}

	var loaderInstantiate = loader.instantiate;
	loader.instantiate = function(load) {
		var loader = this,
			parsed;

		parsed = parse(load);
		if(parsed) {
			load.metadata.format = 'json';

			load.metadata.execute = function(){
				return parsed;
			};
		}

		return loaderInstantiate.call(loader, load);
	};

	return loader;

	// Attempt to parse a load as json.
	function parse(load){
		if ( (load.metadata.format === 'json' || !load.metadata.format) && jsonTest.test(load.source)  ) {
			try {
				return JSON.parse(load.source);
			} catch(e) {}
		}

	}
}

if (typeof System !== "undefined") {
	_SYSTEM_addJSON(System);
}

	// Overwrites System.config with setter hooks
	var setterConfig = function(loader, configSpecial){
		var oldConfig = loader.config;

		loader.config =  function(cfg){

			var data = extend({},cfg);
			// check each special
			each(configSpecial, function(special, name){
				// if there is a setter and a value
				if(special.set && data[name]){
					// call the setter
					var res = special.set.call(loader,data[name], cfg);
					// if the setter returns a value
					if(res !== undefined) {
						// set that on the loader
						loader[name] = res;
					}
					// delete the property b/c setting is done
					delete data[name];
				}
			});
			oldConfig.call(this, data);
		};
	};

	var setIfNotPresent = function(obj, prop, value){
		if(!obj[prop]) {
			obj[prop] = value;
		}
	};

	// steal.js's default configuration values
	System.configMain = "@config";
	System.paths[System.configMain] = "stealconfig.js";
	System.env = (isWebWorker ? "worker" : "window") + "-development";
	System.ext = {
		css: '$css',
		less: '$less'
	};
	System.logLevel = 0;
	var cssBundlesNameGlob = "bundles/*.css",
		jsBundlesNameGlob = "bundles/*";
	setIfNotPresent(System.paths,cssBundlesNameGlob, "dist/bundles/*css");
	setIfNotPresent(System.paths,jsBundlesNameGlob, "dist/bundles/*.js");

	var configSetter = {
		set: function(val){
			var name = filename(val),
				root = dir(val);

			if(!isNode) {
				System.configPath = joinURIs( location.href, val);
			}
			System.configMain = name;
			System.paths[name] = name;
			addProductionBundles.call(this);
			this.config({ baseURL: (root === val ? "." : root) + "/" });
		}
	},
		mainSetter = {
			set: function(val){
				this.main = val;
				addProductionBundles.call(this);
			}
		};

	// checks if we're running in node, then prepends the "file:" protocol if we are
	var envPath = function(val) {
		if(isNode && !/^file:/.test(val)) {
			// If relative join with the current working directory
			if(val[0] === "." && (val[1] === "/" ||
								 (val[1] === "." && val[2] === "/"))) {
				val = require("path").join(process.cwd(), val);
			}
			if(!val) return val;

			return "file:" + val;
		}
		return val;
	};

	var fileSetter = function(prop) {
		return {
			set: function(val) {
				this[prop] = envPath(val);
			}
		};
	};

	var setToSystem = function(prop){
		return {
			set: function(val){
				if(typeof val === "object" && typeof steal.System[prop] === "object") {
					this[prop] = extend(this[prop] || {},val || {});
				} else {
					this[prop] = val;
				}
			}
		};
	};

	var pluginPart = function(name) {
		var bang = name.lastIndexOf("!");
		if(bang !== -1) {
			return name.substr(bang+1);
		}
	};
	var pluginResource = function(name){
		var bang = name.lastIndexOf("!");
		if(bang !== -1) {
			return name.substr(0, bang);
		}
	};

	var addProductionBundles = function(){
		if(this.loadBundles && this.main) {
			var main = this.main,
				bundlesDir = this.bundlesName || "bundles/",
				mainBundleName = bundlesDir+main;

			setIfNotPresent(this.meta, mainBundleName, {format:"amd"});

			// If the configMain has a plugin like package.json!npm,
			// plugin has to be defined prior to importing.
			var plugin = pluginPart(System.configMain);
			var bundle = [main, System.configMain];
			if(plugin){
				System.set(plugin, System.newModule({}));
			}
			plugin = pluginPart(main);
			if(plugin) {
				var resource = pluginResource(main);
				bundle.push(plugin);
				bundle.push(resource);

				mainBundleName = bundlesDir+resource.substr(0, resource.indexOf("."));
			}

			this.bundles[mainBundleName] = bundle;
		}
	};

	var setEnvsConfig = function(){
		if(this.envs) {
			var envConfig = this.envs[this.env];
			if(envConfig) {
				this.config(envConfig);
			}
		}
	};

	var setupLiveReload = function(){
		if(this.liveReloadInstalled) {
			var loader = this;
			this.import("live-reload", { name: "@@steal" }).then(function(reload){
				reload(loader.configMain, function(){
					setEnvsConfig.call(loader);
				});
			});
		}
	};

	var LESS_ENGINE = "less-2.4.0";
	var specialConfig;
	var envsSpecial = { map: true, paths: true, meta: true };
	setterConfig(System, specialConfig = {
		env: {
			set: function(val){
				this.env = val;

				if(this.isEnv("production")) {
					this.loadBundles = true;
				}

				addProductionBundles.call(this);
			}
		},
		envs: {
			set: function(val){
				// envs should be set, deep
				var envs = this.envs;
				if(!envs) envs = this.envs = {};
				each(val, function(cfg, name){
					var env = envs[name];
					if(!env) env = envs[name] = {};

					each(cfg, function(val, name){
						if(envsSpecial[name] && env[name]) {
							extend(env[name], val);
						} else {
							env[name] = val;
						}
					});

					//extend(env, cfg);
				});
			}
		},
		baseUrl: fileSetter("baseURL"),
		baseURL: fileSetter("baseURL"),
		root: fileSetter("baseURL"),  //backwards comp
		config: configSetter,
		configPath: configSetter,
		loadBundles: {
			set: function(val){
				this.loadBundles = val;
				addProductionBundles.call(this);
			}
		},
		startId: {
			set: function(val){
				mainSetter.set.call(this, normalize(val) );
			}
		},
		main: mainSetter,
		stealURL: {
			// http://domain.com/steal/steal.js?moduleName,env&
			set: function(url, cfg)	{
				System.stealURL = url;
				var urlParts = url.split("?");

				var path = urlParts.shift(),
					search = urlParts.join("?"),
					searchParts = search.split("&"),
					paths = path.split("/"),
					lastPart = paths.pop(),
					stealPath = paths.join("/");

				specialConfig.stealPath.set.call(this,stealPath, cfg);

				if (lastPart.indexOf("steal.production") > -1 && !cfg.env) {
					var platform = this.getPlatform() || (isWebWorker ? "worker" : "window");
					this.config({ env: platform+"-production" });
					addProductionBundles.call(this);
				}

				if(searchParts.length && searchParts[0].length) {
					var searchConfig = {},
						searchPart;
					for(var i =0; i < searchParts.length; i++) {
						searchPart = searchParts[i];
						var paramParts = searchPart.split("=");
						if(paramParts.length > 1) {
							searchConfig[paramParts[0]] = paramParts.slice(1).join("=");
						} else {
							if(steal.dev) {
								steal.dev.warn("Please use search params like ?main=main&env=production");
							}
							var oldParamParts = searchPart.split(",");
							if (oldParamParts[0]) {
								searchConfig.startId = oldParamParts[0];
							}
							if (oldParamParts[1]) {
								searchConfig.env = oldParamParts[1];
							}
						}
					}
					this.config(searchConfig);
				}

				// Split on / to get rootUrl




			}
		},
		// this gets called with the __dirname steal is in
		stealPath: {
			set: function(dirname, cfg) {
				dirname = envPath(dirname);
				var parts = dirname.split("/");

				// steal keeps this around to make things easy no matter how you are using it.
				setIfNotPresent(this.paths,"@dev", dirname+"/ext/dev.js");
				setIfNotPresent(this.paths,"$css", dirname+"/ext/css.js");
				setIfNotPresent(this.paths,"$less", dirname+"/ext/less.js");
				setIfNotPresent(this.paths,"npm", dirname+"/ext/npm.js");
				setIfNotPresent(this.paths,"npm-extension", dirname+"/ext/npm-extension.js");
				setIfNotPresent(this.paths,"npm-utils", dirname+"/ext/npm-utils.js");
				setIfNotPresent(this.paths,"npm-crawl", dirname+"/ext/npm-crawl.js");
				setIfNotPresent(this.paths,"semver", dirname+"/ext/semver.js");
				setIfNotPresent(this.paths,"bower", dirname+"/ext/bower.js");
				setIfNotPresent(this.paths,"live-reload", dirname+"/ext/live-reload.js");
				this.paths["traceur"] = dirname+"/ext/traceur.js";
				this.paths["traceur-runtime"] = dirname+"/ext/traceur-runtime.js";
				this.paths["babel"] = dirname+"/ext/babel.js";
				this.paths["babel-runtime"] = dirname+"/ext/babel-runtime.js";

				if(isNode) {
					System.register("less",[], false, function(){
						var r = require;
						return r('less');
					});

					if(this.configMain === "@config" && last(parts) === "steal") {
						parts.pop();
						if(last(parts) === "node_modules") {
							this.configMain = "package.json!npm";
							addProductionBundles.call(this);
							parts.pop();
						}
					}

				} else {
					setIfNotPresent(this.paths, "less", dirname + "/ext/less-engine.js");

					// make sure we don't set baseURL if something else is going to set it
					if(!cfg.root && !cfg.baseUrl && !cfg.baseURL && !cfg.config && !cfg.configPath ) {
						if ( last(parts) === "steal" ) {
							parts.pop();
							if ( last(parts) === "bower_components" ) {
								System.configMain = "bower.json!bower";
								addProductionBundles.call(this);
								parts.pop();
							}
							if (last(parts) === "node_modules") {
								System.configMain = "package.json!npm";
								addProductionBundles.call(this);
								parts.pop();
							}
						}
						this.config({ baseURL: parts.join("/")+"/"});
					}
				}
				System.stealPath = dirname;
			}
		},
		// System.config does not like being passed arrays.
		bundle: {
			set: function(val){
				System.bundle = val;
			}
		},
		bundlesPath: {
			set: function(val){
				this.paths[cssBundlesNameGlob] = val+"/*css";
				this.paths[jsBundlesNameGlob]  = val+"/*.js";
				return val;
			}
		},
		instantiated: {
			set: function(val){
				var loader = this;

				each(val || {}, function(value, name){
					loader.set(name,  loader.newModule(value));
				});
			}
		}
	});

	steal.config = function(cfg){
		if(typeof cfg === "string") {
			return System[cfg];
		} else {
			System.config(cfg);
		}
	};


if(typeof System !== "undefined") {
	addEnv(System);
}

function addEnv(loader){
	// Add the extension to _extensions so that it can be cloned.
	loader._extensions.push(addEnv);

	loader.getEnv = function(){
		var envParts = (this.env || "").split("-");
		// Fallback to this.env for legacy
		return envParts[1] || this.env;
	};
	loader.getPlatform = function(){
		var envParts = (this.env || "").split("-");
		return envParts.length === 2 ? envParts[0] : undefined;
	};

	loader.isEnv = function(name){
		return this.getEnv() === name;
	};

	loader.isPlatform = function(name){
		return this.getPlatform() === name;
	};
}

	var getScriptOptions = function () {

		var options = {},
			parts, src, query, startFile, env,
			scripts = document.getElementsByTagName("script");

		var script = scripts[scripts.length - 1];

		if (script) {
			options.stealURL = script.src;
			// Split on question mark to get query

			each(script.attributes, function(attr){
				var optionName =
					camelize( attr.nodeName.indexOf("data-") === 0 ?
						attr.nodeName.replace("data-","") :
						attr.nodeName );
				options[optionName] = (attr.value === "") ? true : attr.value;
			});

			var source = script.innerHTML.substr(1);
			if(/\S/.test(source)){
				options.mainSource = source;
			}
		}

		return options;
	};

	steal.startup = function(config){

		// Get options from the script tag
		if (isWebWorker) {
			var urlOptions = {
				stealURL: location.href
			};
		} else if(global.document) {
			var urlOptions = getScriptOptions();
		} else {
			// or the only option is where steal is.
			var urlOptions = {
				stealPath: __dirname
			};
		}

		// B: DO THINGS WITH OPTIONS
		// CALCULATE CURRENT LOCATION OF THINGS ...
		System.config(urlOptions);

		if(config){
			System.config(config);
		}

		setEnvsConfig.call(this.System);

		// Read the env now because we can't overwrite everything yet

		// immediate steals we do
		var steals = [];

		// we only load things with force = true
		if ( System.loadBundles ) {

			if(!System.main && System.isEnv("production")) {
				// prevent this warning from being removed by Uglify
				var warn = console && console.warn || function() {};
				warn.call(console, "Attribute 'main' is required in production environment. Please add it to the script tag.");
			}

			configDeferred = System["import"](System.configMain);

			appDeferred = configDeferred.then(function(cfg){
				setEnvsConfig.call(System);
				return System.main ? System["import"](System.main) : cfg;
			})["catch"](function(e){
				console.log(e);
			});

		} else {
			configDeferred = System["import"](System.configMain);

			devDeferred = configDeferred.then(function(){
				setEnvsConfig.call(System);
				setupLiveReload.call(System);

				// If a configuration was passed to startup we'll use that to overwrite
				// what was loaded in stealconfig.js
				// This means we call it twice, but that's ok
				if(config) {
					System.config(config);
				}

				return System["import"]("@dev");
			},function(e){
				console.log("steal - error loading @config.",e);
				return steal.System["import"]("@dev");
			});

			appDeferred = devDeferred.then(function(){
				// if there's a main, get it, otherwise, we are just loading
				// the config.
				if(!System.main || System.env === "build") {
					return configDeferred;
				}
				var main = System.main;
				if(typeof main === "string") {
					main = [main];
				}
				return Promise.all( map(main,function(main){
					return System["import"](main);
				}) );
			});

		}

		if(System.mainSource) {
			appDeferred = appDeferred.then(function(){
				System.module(System.mainSource);
			});
		}
		return appDeferred;
	};
	steal.done = function(){
		return appDeferred;
	};

	steal["import"] = function(){
		var names = arguments;
		var loader = this.System;

		function afterConfig(){
			var imports = [];
			each(names, function(name){
				imports.push(loader["import"](name));
			});
			if(imports.length > 1) {
				return Promise.all(imports);
			} else {
				return imports[0];
			}
		}

		if(!configDeferred) {
			steal.startup();
		}

		return configDeferred.then(afterConfig);
	};
	return steal;

};
/*
  SystemJS Steal Format
  Provides the Steal module format definition.
*/
function addSteal(loader) {

  // Steal Module Format Detection RegEx
  // steal(module, ...)
  var stealRegEx = /(?:^\s*|[}{\(\);,\n\?\&]\s*)steal\s*\(\s*((?:"[^"]+"\s*,|'[^']+'\s*,\s*)*)/;

  // What we stole.
  var stealInstantiateResult;
  
  function createSteal(loader) {
    stealInstantiateResult = null;

    // ensure no NodeJS environment detection
    loader.global.module = undefined;
    loader.global.exports = undefined;

    function steal() {
      var deps = [];
      var factory;
      
      for( var i = 0; i < arguments.length; i++ ) {
        if (typeof arguments[i] === 'string') {
          deps.push( normalize(arguments[i]) );
        } else {
          factory = arguments[i];
        }
      }

      if (typeof factory !== 'function') {
        factory = (function(factory) {
          return function() { return factory; };
        })(factory);
      }

      stealInstantiateResult = {
        deps: deps,
        execute: function(require, exports, moduleName) {

          var depValues = [];
          for (var i = 0; i < deps.length; i++) {
            depValues.push(require(deps[i]));
          }

          var output = factory.apply(loader.global, depValues);

          if (typeof output !== 'undefined') {
            return output;
          }
        }
      };
    }

    loader.global.steal = steal;
  }

  var loaderInstantiate = loader.instantiate;
  loader.instantiate = function(load) {
    var loader = this;

    if (load.metadata.format === 'steal' || !load.metadata.format && load.source.match(stealRegEx)) {
      load.metadata.format = 'steal';

      var oldSteal = loader.global.steal;

      createSteal(loader);

      loader.__exec(load);

      loader.global.steal = oldSteal;

      if (!stealInstantiateResult) {
        throw "Steal module " + load.name + " did not call steal";
      }

      if (stealInstantiateResult) {
        load.metadata.deps = load.metadata.deps ? load.metadata.deps.concat(stealInstantiateResult.deps) : stealInstantiateResult.deps;
        load.metadata.execute = stealInstantiateResult.execute;
      }
    }
    return loaderInstantiate.call(loader, load);
  };

  return loader;
}

if (typeof System !== "undefined") {
  addSteal(System);
}

	if( isNode ) {
		require('steal-systemjs');

		global.steal = makeSteal(System);
		global.steal.System = System;
		global.steal.dev = require("./ext/dev.js");
		steal.clone = cloneSteal;
		module.exports = global.steal;
		global.steal.addSteal = addSteal;
		require("system-json");

	} else {
		var oldSteal = global.steal;
		global.steal = makeSteal(System);
		global.steal.startup(oldSteal && typeof oldSteal == 'object' && oldSteal)
			.then(null, function(error){
				console.log("error",error,  error.stack);
				throw error;
			});
		global.steal.clone = cloneSteal;
		global.steal.addSteal = addSteal;
	}

})(typeof window == "undefined" ? (typeof global === "undefined" ? this : global) : window);

/*[add-define]*/
((typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self : window).define = System.amdDefine;
/*[system-bundles-config]*/
if(!System.bundlesPath) {
	System.paths["bundles/*.css"] ="../../../../../../../../../../../../../../../../dist/bundles/dev/*css";
	System.paths["bundles/*"] = "../../../../../../../../../../../../../../../../dist/bundles/dev/*.js";
}
System.bundles = {"bundles/stealmain.css!":["app/widgets/dataset/selectionSet/SelectionSetNode/selectionSetNode.less!$less","less/boot.less!$less"],"bundles/views.dataset.mo-fa6350d5":["system-text@0.1.0#text","app/domain/presets/tcga/model/TcgaPreset","js-data@2.8.2#dist/js-data-debug","js-data-angular@3.1.0#dist/js-data-angular","app/domain/presets/tcga/domain.presets.tcga.module","app/domain/presets/domain.presets.module","mev-bs-modal@0.0.1#src/view/modal/BsModal.tpl.html!system-text@0.1.0#text","mev-bs-modal@0.0.1#src/view/modal/BsModalDirective","mev-bs-modal@0.0.1#src/view/trigger/BsModalTriggerDirective","mev-bs-modal@0.0.1#src/mev-bs-modal","pouchdb","mev-domain-common@0.0.1#src/main/services/context/Context","mev-domain-common@0.0.1#src/main/services/selection/SelectionLocator","mev-domain-common@0.0.1#src/main/services/analysis/AnalysisLocator","mev-domain-common@0.0.1#src/main/services/annotations/AnnotationsLocator","worker-pouch","mev-domain-common@0.0.1#src/main/services/db/mevDb","bowser@1.4.0#src/bowser","mev-domain-common@0.0.1#src/main/services/settings/Settings","mev-domain-common@0.0.1#src/main/view/db/status/mevDbStatusDirective","mev-domain-common@0.0.1#src/main/mev-domain-common","angular-resource@1.5.8#angular-resource","angular-resource@1.5.8#index","mev-dataset@0.0.1#src/main/dataset/lib/datasetStatistics","mev-dataset@0.0.1#src/main/dataset/lib/selectionSort","mev-dataset@0.0.1#src/main/dataset/lib/selectionHelpers","mev-dataset@0.0.1#src/main/dataset/lib/expressionModule","q@1.4.1#q","mev-dataset@0.0.1#src/main/dataset/lib/DatasetValues32","mev-dataset@0.0.1#src/main/dataset/lib/DatasetValuesJson","mev-dataset@0.0.1#src/main/dataset/lib/DatasetValues","mev-dataset@0.0.1#src/main/dataset/lib/DatasetClass","mev-dataset@0.0.1#src/main/dataset/lib/AnalysisClass","mev-dataset@0.0.1#src/main/dataset/lib/loadAnalyses","mev-dataset@0.0.1#src/main/dataset/lib/setSelections","mev-dataset@0.0.1#src/main/dataset/lib/resetSelections","mev-dataset@0.0.1#src/main/dataset/Dataset","mev-dataset@0.0.1#src/main/endpoint/rest/DatasetRest","mev-dataset@0.0.1#src/main/mev-dataset","mev-annotations@0.0.1#src/main/endpoint/AnnotationProjectIdResource","mev-annotations@0.0.1#src/main/endpoint/AnnotationFieldsResource","mev-annotations@0.0.1#src/main/endpoint/AnnotationValuesResource","mev-annotations@0.0.1#src/main/endpoint/AnnotationExportResource","mev-annotations@0.0.1#src/main/model/AnnotationRepository","mev-annotations@0.0.1#src/main/mevAnnotations.module","mev-workspace@0.0.1#src/main/model/Workspace","mev-workspace@0.0.1#src/main/router/WorkspaceState","mev-workspace@0.0.1#src/main/router/WorkspaceStateInit","mev-workspace@0.0.1#src/main/view/list/WorkspaceList.tpl.html!system-text@0.1.0#text","mev-workspace@0.0.1#src/main/view/list/WorkspaceListDirective","mev-workspace@0.0.1#src/main/view/upload/UploadDataset.tpl.html!system-text@0.1.0#text","mev-workspace@0.0.1#src/main/view/upload/UploadDatasetDirective","mev-workspace@0.0.1#src/main/mev-workspace","app/domain/navigator/domain.navigator.module","app/domain/analysis/genesd/SigGenesFactory","app/domain/analysis/genesd/domain.analysis.genesd.module","app/domain/analysis/domain.analysis.module","app/domain/project/model/MevProject","app/domain/project/domain.project.module","app/domain/dataset/dashboard/services/dashboardItemsService","app/domain/dataset/dashboard/services/dashboardsService","app/domain/dataset/dashboard/DashboardFactory","app/domain/dataset/dashboard/domain.dataset.dashboard.module","app/domain/dataset/domain.dataset.module","app/domain/domain.module","blob@0.0.4#index","immediate@3.2.2#lib/nextTick","immediate@3.2.2#lib/mutation.js","immediate@3.2.2#lib/messageChannel","immediate@3.2.2#lib/stateChange","immediate@3.2.2#lib/timeout","immediate@3.2.2#lib/index","lie@2.7.7#lib/tryCatch","lie@2.7.7#lib/resolveThenable","lie@2.7.7#lib/states","lie@2.7.7#lib/handlers","lie@2.7.7#lib/unwrap","lie@2.7.7#lib/INTERNAL","lie@2.7.7#lib/queueItem","lie@2.7.7#lib/promise","lie@2.7.7#lib/resolve","lie@2.7.7#lib/reject","lie@2.7.7#lib/all","lie@2.7.7#lib/index","pouchdb-promise@0.0.0#index","blob-util@1.2.0#lib/index"],"bundles/views.dataset.mo-fa6350d5.css!":["mev-workspace@0.0.1#src/main/view/list/WorkspaceList.less!$less"],"bundles/app/views/dataset/views.dataset.module":["app/views/dataset/_controllers/DatasetProjectViewVM","app/views/dataset/_controllers/DatasetHomeVM","app/views/dataset/_controllers/DatasetHeatmapVMFactory","app/views/dataset/annotations/AnnotationsViewVM","angular-color-picker@1.0.10#angular-color-picker","app/views/dataset/selectionSets/controllers/SelectionSetsViewVM","app/views/dataset/selectionSets/controllers/SelectionSetViewVM","app/views/dataset/selectionSets/resolvers/SelectionSetResolver","app/views/dataset/selectionSets/edit/SelectionSetsEditOnEnter","app/views/dataset/selectionSets/edit/views.dataset.selectionSets.edit.tpl.html!system-text@0.1.0#text","app/views/dataset/selectionSets/edit/SelectionSetsEditDirective","app/views/dataset/selectionSets/views.dataset.selectionSets.module","app/views/dataset/columnSets/edit/views.dataset.columnSets.edit.module","app/views/dataset/columnSets/views.dataset.columnSets.module","app/views/dataset/rowSets/edit/views.dataset.rowSets.edit.module","app/views/dataset/rowSets/views.dataset.rowSets.module","app/views/dataset/analysis/kmeans/views.dataset.analysis.kmeans.module","app/views/dataset/analysis/nmf/views.dataset.analysis.nmf.module","app/views/dataset/analysis/histogram/views.dataset.analysis.histogram.module","app/views/dataset/analysis/genesd/views.dataset.analysis.genesd.module","app/views/dataset/analysis/genemad/views.dataset.analysis.genemad.module","d3@3.5.14#d3","nvd3@1.8.2-dev#build/nv.d3","angular-nvd3@1.0.5#dist/angular-nvd3","angular-nvd3@1.0.5#index","mev-glyph-alt@0.0.1#src/main/view/mevGlyphAltDirective","mev-glyph-alt@0.0.1#src/main/mev-glyph-alt","mev-chart-utils@0.0.1#src/main/tooltip/services/mevTooltipContent","mev-chart-utils@0.0.1#src/main/dimConfig/model/mevChartConfig","mev-chart-utils@0.0.1#src/main/dimConfig/model/mevChartDimConfig","mev-chart-utils@0.0.1#src/main/dimConfig/model/mevChartColorDimConfig","mev-chart-utils@0.0.1#src/main/colorLegend/view/mevChartColorLegend.tpl.html!system-text@0.1.0#text","mev-chart-utils@0.0.1#src/main/colorLegend/view/mevChartColorLegendDirective","save-svg-as-png@1.0.3#saveSvgAsPng","mev-chart-utils@0.0.1#src/main/saveAs/svgSaveAsPng","mev-chart-utils@0.0.1#src/main/saveAs/svgSaveAsDirective","mev-chart-utils@0.0.1#src/main/mev-chart-utils","crossfilter@1.3.12#crossfilter","crossfilter@1.3.12#index","mev-scatter-plot@0.0.0#src/_directives/scatterPlot.tpl.html!system-text@0.1.0#text","mev-scatter-plot@0.0.0#src/_directives/scatterPlotDirective","mev-scatter-plot@0.0.0#src/services/adaptors/Nvd3DataAdaptor","mev-scatter-plot@0.0.0#src/scatterPlot","mev-scatter-plot@0.0.0#index","lodash@4.13.1#lodash","mev-pca@0.0.0#src/view/pcaAnalysis.tpl.html!system-text@0.1.0#text","mev-pca@0.0.0#src/view/pcaAnalysisDirective","mev-pca@0.0.0#src/router/PcaState.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/model/BaseParam","mev-analysis@0.0.1#src/params/model/select/SelectParam","mev-analysis@0.0.1#src/params/model/parentAnalysis/ParentAnalysisParam","mev-analysis@0.0.1#src/params/model/selectionSet/SelectionSetParam","mev-pca@0.0.0#src/model/PcaAnalysisType","mev-pca@0.0.0#src/router/PcaStateVM","mev-pca@0.0.0#src/router/PcaState","mev-pca@0.0.0#src/pca.module","app/views/dataset/analysis/views.dataset.analysis.module","app/views/dataset/analyses/views.dataset.analyses.module","app/views/dataset/session/timeout/sessionTimeoutModal.tpl.html!system-text@0.1.0#text","app/views/dataset/session/timeout/SessionTimeoutState","app/views/dataset/session/views.dataset.session.module","extend@2.0.1#index","js/project/lib/HeatmapViewClass","js/project/lib/generateView","js/project/lib/ProjectClass","dataset/lib/datasetStatistics","dataset/lib/selectionSort","dataset/lib/selectionHelpers","dataset/lib/expressionModule","jsLru","dataset/lib/DatasetValues32","dataset/lib/DatasetValuesSourceHttp","dataset/lib/DatasetValuesCache","dataset/lib/DatasetClass","dataset/lib/AnalysisClass","dataset/lib/loadAnalyses","dataset/lib/setSelections","dataset/lib/resetSelections","angular-resource@1.5.0#angular-resource","angular-resource@1.5.0#index","api/Api","dataset/Dataset","js/project/Project","js/alertservice/AlertService","app/widgets/analysis/default/directives/defaultParameters.directive","app/widgets/analysis/default/widgets.analysis.default.module","app/widgets/analysis/analysisModal/directives/analysisModal.directive","app/widgets/analysis/analysisModal/widgets.analysis.modal.module","app/widgets/analysis/analysisLog/directives/analysisLog.tpl.html!system-text@0.1.0#text","app/widgets/analysis/analysisLog/directives/analysisLog.directive","app/widgets/analysis/analysisLog/widgets.analysis.log.module","app/widgets/analysis/analysisMenu/btnCreateSelection/btnCreateSelectionDirective","app/widgets/analysis/analysisMenu/btnExportSelection/btnExportSelectionDirective","app/widgets/analysis/analysisMenu/widgets.analysis.menu.module","app/widgets/analysis/any/directives/anyAnalysisDirective","app/widgets/analysis/any/widgets.analysis.any.module","app/widgets/analysis/analysisNode/directives/analysisNode.directive","app/widgets/analysis/analysisNode/widgets.analysis.analysisNode.module","app/widgets/analysis/genesd/directives/geneSdDirective","app/widgets/analysis/genesd/widgets.analysis.genesd.module","d3-tip@0.6.7#index","app/widgets/analysis/histogram/plot/rhistPlotDirective","app/widgets/analysis/histogram/widgets.analysis.histogram.module","app/widgets/analysis/widgets.analysis.module","ag-grid@2.3.7#dist/ag-grid.min","blueimp-canvas-to-blob@3.1.0#js/canvas-to-blob","notific8@2.3.1#dist/jquery.notific8.min","angular-ui-router@0.2.18#release/angular-ui-router","mev-analysis@0.0.1#src/params/view/text/TextParam.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/view/label/ParamLabel.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/view/label/ParamLabelDirective","mev-analysis@0.0.1#src/params/view/text/TextParamDirective","mev-analysis@0.0.1#src/params/view/integer/IntegerParam.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/view/integer/IntegerParamDirective","mev-analysis@0.0.1#src/params/view/boolean/BooleanParam.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/view/boolean/BooleanParamDirective","mev-analysis@0.0.1#src/params/view/selectionSet/SelectionSetParamDirective","mev-analysis@0.0.1#src/params/view/decimal/DecimalParam.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/view/decimal/DecimalParamDirective","mev-analysis@0.0.1#src/params/view/select/SelectParam.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/view/select/SelectParamDirective","mev-analysis@0.0.1#src/params/view/any/AnyParameter.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/view/any/AnyParameterDirective","mev-analysis@0.0.1#src/params/model/name/NameParam","mev-analysis@0.0.1#src/params/model/AnalysisParamsFactory","mev-analysis@0.0.1#src/params/model/annotationField/AnnotationFieldParam","mev-analysis@0.0.1#src/type/model/AnalysisTypes","mev-analysis@0.0.1#src/type/view/defaultTemplate/analysis.default.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/type/model/AnalysisType","mev-analysis@0.0.1#src/launch/AnalysisLauncher","mev-analysis@0.0.1#src/type/view/startForm/AnalysisStartForm.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/type/view/startForm/AnalysisStartFormDirective","mev-analysis@0.0.1#src/type/view/modal/AnalysisStartModal.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/type/view/modal/AnalysisStartModalHeader.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/type/view/modal/AnalysisStartModalDirective","mev-analysis@0.0.1#src/type/view/modal/AnalysisStartButton.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/type/view/modal/AnalysisStartButtonDirective","mev-analysis@0.0.1#src/type/view/route/AnalysisTypeState","mev-analysis@0.0.1#src/type/view/route/AnalysisError.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/type/view/route/AnalysisErrorState","mev-analysis@0.0.1#src/events/AnalysisEventBus","mev-analysis@0.0.1#src/endpoint/rest/AnalysisRest","mev-analysis@0.0.1#src/mevAnalysis.module","angular-utils-pagination@0.10.0#dirPagination","angular-utils-pagination@0.10.0#index","mev-results-table@0.0.1#src/view/mevResultsTable.tpl.html!system-text@0.1.0#text","papaparse@4.1.2#papaparse","mev-results-table@0.0.1#src/view/mevResultsTableDirective","mev-results-table@0.0.1#src/view/mevResultsTableDefaults","mev-results-table@0.0.1#src/view/mevResultsTableFilter","mev-results-table@0.0.1#src/view/mevResultsTableCompareFactory","mev-results-table@0.0.1#src/view/textOrNumberFilter","mev-results-table@0.0.1#src/mev-results-table","mev-dotplot@0.0.1#src/main/view/mevDotplot.tpl.html!system-text@0.1.0#text","mev-dotplot@0.0.1#src/main/view/mevDotplotDirective","mev-dotplot@0.0.1#src/main/services/mevDotplotNvd3Adaptor","mev-dotplot@0.0.1#src/main/services/mevDotplotDataAdaptor","mev-dotplot@0.0.1#src/main/mev-dotplot","mev-enrichment-dotplot@0.0.1#src/main/view/mevEnrichmentDotplot.tpl.html!system-text@0.1.0#text","mev-enrichment-dotplot@0.0.1#src/main/view/mevEnrichmentDotplotDirective","mev-enrichment-dotplot@0.0.1#src/main/services/mevEnrichmentDataAdaptor","mev-enrichment-dotplot@0.0.1#src/main/mev-enrichment-dotplot","mevPathwayEnrichment@0.0.1#src/router/PathwayEnrichmentState.tpl.html!system-text@0.1.0#text","mevPathwayEnrichment@0.0.1#src/model/PathwayEnrichmentInfo.tpl.html!system-text@0.1.0#text","mev-analysis@0.0.1#src/params/model/text/TextParam","mev-analysis@0.0.1#src/params/model/integer/IntegerParam","mev-analysis@0.0.1#src/params/model/decimal/DecimalParam","mevPathwayEnrichment@0.0.1#src/model/PathwayEnrichmentParams","mevPathwayEnrichment@0.0.1#src/model/PathwayEnrichmentAnalysisType","mevPathwayEnrichment@0.0.1#src/router/PathwayEnrichmentState","mevPathwayEnrichment@0.0.1#src/router/PathwayEnrichmentVM","mevPathwayEnrichment@0.0.1#src/pathwayEnrichment.module","angular-nvd3@1.0.6#dist/angular-nvd3","angular-nvd3@1.0.6#index","mev-hbarchart@0.0.1#src/main/view/mevHBarchart.tpl.html!system-text@0.1.0#text","mev-hbarchart@0.0.1#src/main/view/mevHBarchartDirective","mev-hbarchart@0.0.1#src/main/services/mevBarchartNvd3Adaptor","mev-hbarchart@0.0.1#src/main/mev-hbarchart","mev-gsea@0.0.1#src/main/model/gseaAnalysisType","mev-gsea@0.0.1#src/main/state/GseaState.tpl.html!system-text@0.1.0#text","mev-gsea@0.0.1#src/main/state/GseaState","mev-gsea@0.0.1#src/main/state/GseaVM","mev-gsea@0.0.1#src/main/mevGsea.module","d3@3.5.16#d3","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/generateScales","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/cellFilter","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/drawCells","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/drawSelections","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/drawAnalysis","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/updateCells","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/drawTree","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/colorBrewer","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/drawCluster","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/drawTopPanel","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/drawSidePanel","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/HeatmapVisualizationClass","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/lib/generateParams","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/directives/visHeatmap.tpl.html!system-text@0.1.0#text","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/directives/heatmapSettingsModalBody.tpl.html!system-text@0.1.0#text","mev-heatmap@0.0.1#src/main/view/colorBrewer/mevColorBrewer","mev-heatmap@0.0.1#src/main/view/alertService/mevHeatmapAlert","jquery-ui-bundle@1.11.4#jquery-ui","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/HeatmapVisualization","mev-heatmap@0.0.1#src/main/mev-heatmap","mev-hcl@0.0.1#src/main/router/HclState.tpl.html!system-text@0.1.0#text","mev-hcl@0.0.1#src/main/model/HclAnalysisType","mev-hcl@0.0.1#src/main/router/HclStateVM","mev-hcl@0.0.1#src/main/router/HclState","mev-hcl@0.0.1#src/main/mev-hcl","mev-topgo@0.0.1#src/main/router/TopgoState.tpl.html!system-text@0.1.0#text","mev-topgo@0.0.1#src/main/model/TopgoAnalysisType","mev-topgo@0.0.1#src/main/router/TopgoState","mev-topgo@0.0.1#src/main/router/TopgoVM","mev-topgo@0.0.1#src/main/mev-topgo","lodash@4.10.0#lodash","mev-normalization@0.0.1#src/main/model/NormalizationInfo.tpl.html!system-text@0.1.0#text","mev-normalization@0.0.1#src/main/model/NormalizationAnalysisType","mev-normalization@0.0.1#src/main/router/NormalizationState.tpl.html!system-text@0.1.0#text","mev-normalization@0.0.1#src/main/router/NormalizationState","mev-normalization@0.0.1#src/main/router/NormalizationVM","mev-normalization@0.0.1#src/main/mev-normalization","d3@3.5.17#d3","vega@2.5.2#vega.min.js","systemjs-plugin-json@0.1.0#json","mev-network-graph@0.0.1#src/main/view/mevNetwork.vegaspec.json!systemjs-plugin-json@0.1.0#json","mev-network-graph@0.0.1#src/main/view/mevNetwork.tpl.html!system-text@0.1.0#text","mev-network-graph@0.0.1#src/main/view/mevNetworkDirective","mev-network-graph@0.0.1#src/main/mev-network-graph","mev-wgcna@0.0.1#src/main/router/WgcnaState.tpl.html!system-text@0.1.0#text","mev-wgcna@0.0.1#src/main/model/WgcnaInfo.tpl.html!system-text@0.1.0#text","mev-wgcna@0.0.1#src/main/model/WgcnaAnalysisType","mev-wgcna@0.0.1#src/main/router/WgcnaState","mev-wgcna@0.0.1#src/main/router/WgcnaVM","mev-wgcna@0.0.1#src/main/mev-wgcna","mev-boxplot@0.0.1#src/main/view/d3Boxplot.module","lodash@4.14.0#lodash","mev-boxplot@0.0.1#src/main/model/BoxplotService","mev-boxplot@0.0.1#src/main/mev-boxplot","mev-edger@0.0.1#src/main/model/EdgerInfo.tpl.html!system-text@0.1.0#text","mev-edger@0.0.1#src/main/model/EdgerAnalysisType","mev-edger@0.0.1#src/main/router/EdgerState.tpl.html!system-text@0.1.0#text","mev-edger@0.0.1#src/main/router/EdgerState","mev-edger@0.0.1#src/main/router/EdgerVM.js","mev-edger@0.0.1#src/main/mev-edger","mev-limma@0.0.1#src/main/model/LimmaInfo.tpl.html!system-text@0.1.0#text","mev-limma@0.0.1#src/main/model/LimmaAnalysisType","mev-limma@0.0.1#src/main/router/LimmaState.tpl.html!system-text@0.1.0#text","mev-limma@0.0.1#src/main/router/LimmaState","mev-limma@0.0.1#src/main/router/LimmaVM","mev-limma@0.0.1#src/main/mev-limma","mev-analysis@0.0.1#src/params/model/boolean/BooleanParam","mev-ttest@0.0.1#src/main/model/tTestInfo.tpl.html!system-text@0.1.0#text","mev-ttest@0.0.1#src/main/model/tTestAnalysisType","mev-ttest@0.0.1#src/main/router/tTestState.tpl.html!system-text@0.1.0#text","mev-ttest@0.0.1#src/main/router/tTestState","mev-ttest@0.0.1#src/main/router/tTestVM","mev-ttest@0.0.1#src/main/mev-ttest","mev-anova@0.0.1#src/main/model/AnovaInfo.tpl.html!system-text@0.1.0#text","mev-anova@0.0.1#src/main/model/AnovaAnalysisType","mev-anova@0.0.1#src/main/router/AnovaState.tpl.html!system-text@0.1.0#text","mev-anova@0.0.1#src/main/router/AnovaState","mev-anova@0.0.1#src/main/router/AnovaVM","mev-anova@0.0.1#src/main/mev-anova","mev-deseq@0.0.1#src/main/model/DeseqInfo.tpl.html!system-text@0.1.0#text","mev-deseq@0.0.1#src/main/model/DeseqAnalysisType","mev-deseq@0.0.1#src/main/router/DeseqState.tpl.html!system-text@0.1.0#text","mev-deseq@0.0.1#src/main/router/DeseqState","mev-deseq@0.0.1#src/main/router/DeseqVM","mev-deseq@0.0.1#src/main/mev-deseq","mev-voom@0.0.1#src/main/model/VoomInfo.tpl.html!system-text@0.1.0#text","mev-voom@0.0.1#src/main/model/VoomAnalysisType","mev-voom@0.0.1#src/main/router/VoomState.tpl.html!system-text@0.1.0#text","mev-voom@0.0.1#src/main/router/VoomState","mev-voom@0.0.1#src/main/router/VoomVM","mev-voom@0.0.1#src/main/mev-voom","mev-kmeans@0.0.1#src/main/model/KmeansAnalysisType","mev-kmeans@0.0.1#src/main/router/KmeansState.tpl.html!system-text@0.1.0#text","mev-kmeans@0.0.1#src/main/router/KmeansState","mev-kmeans@0.0.1#src/main/router/KmeansVM","mev-kmeans@0.0.1#src/main/mev-kmeans","lodash@4.14.1#lodash","mev-time-function@0.0.1#src/main/view/healthVis/healthvis","mev-time-function@0.0.1#src/main/view/healthVis/healthVis_survival","mev-time-function@0.0.1#src/main/view/timeFunctionPlot.tpl.html!system-text@0.1.0#text","mev-time-function@0.0.1#src/main/view/timeFunctionDirective","mev-time-function@0.0.1#src/main/mev-time-function","mev-survival@0.0.1#src/main/model/SurvivalInfo.tpl.html!system-text@0.1.0#text","mev-survival@0.0.1#src/main/model/SurvivalAnalysisType","mev-survival@0.0.1#src/main/model/SurvivalAnalysisSrv","mev-survival@0.0.1#src/main/model/SurvivalColumnList","mev-survival@0.0.1#src/main/router/SurvivalState.tpl.html!system-text@0.1.0#text","mev-survival@0.0.1#src/main/router/SurvivalState","mev-survival@0.0.1#src/main/router/SurvivalVM","mev-survival@0.0.1#src/main/mev-survival","app/views/dataset/views.dataset.module"],"bundles/app/views/dataset/views.dataset.module.css!":["angular-color-picker@1.0.10#angular-color-picker.css!$css","mev-chart-utils@0.0.1#src/main/colorLegend/view/mevChartColorLegend.less!$less","mev-chart-utils@0.0.1#src/main/saveAs/svgSaveAs.less!$less","mev-chart-utils@0.0.1#src/main/style/mevChart.less!$less","mev-chart-utils@0.0.1#src/main/tooltip/style/mevTooltipContent.less!$less","nvd3@1.8.2-dev#build/nv.d3.css!$css","mev-scatter-plot@0.0.0#src/style/scatter.less!$less","mev-pca@0.0.0#src/style/pcaAnalysis.less!$less","app/widgets/analysis/any/style/widgets.analysis.any.less!$less","notific8@2.3.1#dist/jquery.notific8.css!$css","mev-analysis@0.0.1#src/type/view/startForm/AnalysisStartForm.less!$less","mev-analysis@0.0.1#src/type/view/modal/AnalysisStartModal.less!$less","mev-results-table@0.0.1#src/style/mevResultsTable.less!$less","mev-dotplot@0.0.1#src/main/style/mevDotplot.less!$less","mev-hbarchart@0.0.1#src/main/style/mevHBarchart.less!$less","mev-heatmap@0.0.1#src/main/view/heatmapvisualization/style/mev-heatmap.less!$less","mev-network-graph@0.0.1#src/main/view/mevNetwork.less!$less","mev-boxplot@0.0.1#src/main/style/boxplot.less!$less"],"bundles/app/views/datasets/views.datasets.module":["app/views/datasets/_controllers/DatasetsVM","app/views/datasets/_templates/views.datasets2.tpl.html!system-text@0.1.0#text","app/views/datasets/_templates/views.datasets.tutorials.tpl.html!system-text@0.1.0#text","app/views/datasets/_templates/views.datasets.google.tpl.html!system-text@0.1.0#text","app/views/datasets/_templates/views.datasets.upload.tpl.html!system-text@0.1.0#text","app/views/datasets/_templates/views.datasets.geods.tpl.html!system-text@0.1.0#text","app/views/datasets/_templates/views.datasets.imports.tpl.html!system-text@0.1.0#text","app/widgets/presets/_templates/PresetsListVM","app/widgets/presets/_templates/presetsList.tpl.html!system-text@0.1.0#text","app/widgets/presets/_templates/presetsListDirective","app/widgets/presets/widgets.presets.module","app/views/datasets/session/timeout/sessionTimeoutModal.tpl.html!system-text@0.1.0#text","app/views/datasets/session/timeout/SessionTimeoutState","app/views/datasets/session/views.datasets.session.module","ng-grid@2.0.14#ng-grid-2.0.14.min","geods/Geods.module","geods/import/GeodsImportCtrl","geods/import/geodsimport.tpl.html!system-text@0.1.0#text","geods/domain/GeodsSummaryViewModel","geods/domain/GeodsSummary","geods/services/MevGeodsSummaryResourceSrvc","geods/services/MevGeodsSearchResourceSrvc","geods/domain/GeodsSearchResult","geods/domain/GeodsSummaryFactory","geods/services/MevGeodsImportSrvc","geods/services/MevGeodsSummaryFactory","geods/import/GeodsImport.directives","geods","app/views/datasets/views.datasets.module"],"bundles/app/views/datasets/views.datasets.module.css!":["geods/import/geodsimport.less!$less"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global) {
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var utils = {
            extend: function (d, s) {
                for (var prop in s) {
                    d[prop] = s[prop];
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(res);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        return descriptor.packageName + (descriptor.version ? '@' + descriptor.version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName);
                    if (utils.path.isRelative(parsedModuleName.modulePath)) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refPkg.system || !refPkg.system.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                }
            },
            pkg: {
                name: function (pkg) {
                    return pkg.system && pkg.system.name || pkg.name;
                },
                main: function (pkg) {
                    return utils.path.removeJS(pkg.system && pkg.system.main || typeof pkg.browser === 'string' && pkg.browser || typeof pkg.jspm === 'string' && pkg.jspm || typeof pkg.jspm === 'object' && pkg.jspm.main || pkg.main || 'index');
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = pkg.system && pkg.system.directories && pkg.system.directories.lib;
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var packageFolder = utils.pkg.folderAddress(moduleAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : loader.npmPaths.__default;
                        } else {
                            return loader.npmPaths.__default;
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                hasDirectoriesLib: function (pkg) {
                    var system = pkg.system;
                    return system && system.directories && !!system.directories.lib;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                joinURIs: function (base, href) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    href = parseURI(href || '');
                    base = parseURI(base || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }()));
});
/*npm-extension*/
define('npm-extension', function (require, exports, module) {
    (function (global) {
        'format cjs';
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
        exports.addExtension = function (System) {
            var oldNormalize = System.normalize;
            System.normalize = function (name, parentName, parentAddress, pluginNormalize) {
                if (parentName && utils.path.isRelative(name) && !utils.moduleName.isNpm(parentName)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && refPkg === this.npmPaths.__default && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                if (depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var moduleName = utils.moduleName.create(parsedModuleName);
                    if (refPkg.system && refPkg.system.map && typeof refPkg.system.map[moduleName] === 'string') {
                        moduleName = refPkg.system.map[moduleName];
                    }
                    return oldNormalize.call(this, moduleName, parentName, parentAddress, pluginNormalize);
                } else {
                    if (depPkg === this.npmPaths.__default) {
                        var localName = parsedModuleName.modulePath ? parsedModuleName.modulePath + (parsedModuleName.plugin ? parsedModuleName.plugin : '') : utils.pkg.main(depPkg);
                        return oldNormalize.call(this, localName, parentName, parentAddress, pluginNormalize);
                    }
                    if (refPkg.browser && refPkg.browser[name]) {
                        return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                    }
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (address) {
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, pkg === loader.npmPaths.__default);
                            if (parsedModuleName.modulePath) {
                                return utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
        };
    }(function () {
        return this;
    }()));
});
/*bower*/
define('bower', [], function(){ return {}; });
/*bower_components/pouchdb/bower.json!bower*/
define('bower_components/pouchdb/bower.json!bower', ['@loader'], function (loader) {
    loader.config({
        'paths': {
            'pouchdb': 'bower_components/pouchdb/dist/pouchdb.js',
            'pouchdb/*': 'bower_components/pouchdb/dist/*.js'
        }
    });
});
/*bower_components/worker-pouch/bower.json!bower*/
define('bower_components/worker-pouch/bower.json!bower', [
    '@loader',
    'bower_components/pouchdb/bower.json!bower'
], function (loader) {
    loader.config({
        'paths': {
            'worker-pouch': 'bower_components/worker-pouch/dist/pouchdb.worker-pouch.js',
            'worker-pouch/*': 'bower_components/worker-pouch/dist/*.js'
        }
    });
});
/*bower.json!bower*/
define('bower.json!bower', [
    '@loader',
    'bower_components/pouchdb/bower.json!bower',
    'bower_components/worker-pouch/bower.json!bower'
], function (loader) {
    loader.config({
        'meta': {
            'angular-utils-ui-breadcrumbs': { 'deps': ['angular'] },
            'pouchdb': { 'format': 'global' },
            'worker-pouch': { 'deps': ['pouchdb'] }
        },
        'paths': {
            'mev-web': 'bower_components/mev-web/stealmain.js',
            'mev-web/*': 'bower_components/mev-web/*.js'
        }
    });
});
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module',
    'bower.json!bower'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'stealmain';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                cwd: function () {
                },
                env: { NODE_ENV: loader.env }
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        loader.npmPaths.__default = packages[0];
        var lib = packages[0].system && packages[0].system.directories && packages[0].system.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                fn.call(arr, arr[i]);
            }
        };
        var setupLiveReload = function () {
            var hasLiveReload = !!(loader.liveReloadInstalled || loader._liveMap);
            if (hasLiveReload) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        delete loader.npm;
                        delete loader.npmPaths;
                    });
                });
            }
        };
        forEach(packages, function (pkg) {
            if (pkg.system) {
                var main = pkg.system.main;
                delete pkg.system.main;
                delete pkg.system.configDependencies;
                loader.config(pkg.system);
                pkg.system.main = main;
            }
            if (pkg.globalBrowser) {
                setGlobalBrowser(pkg.globalBrowser, pkg);
            }
            var systemName = pkg.system && pkg.system.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
        setupLiveReload();
    }(loader, [
        {
            'name': 'mev-web',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/package.json',
            'main': 'stealmain.js',
            'system': {
                'bundle': [
                    'app/views/datasets/views.datasets.module',
                    'app/views/dataset/views.dataset.module'
                ],
                'configDependencies': ['bower.json!bower'],
                'paths': {
                    'mainmenu': '../javascript/mainmenu/MainMenu.module.js',
                    'geods': '../javascript/geods/Geods.package.js',
                    'geods/*': '../javascript/geods/*.js',
                    'colorbrewer/*': '../javascript/colorbrewer/*.js',
                    'extend': '../javascript/extend.js',
                    'alertservice/*': '../javascript/alertservice/*.js',
                    'api/*': '../javascript/api/*.js',
                    'dataset/*': '../javascript/dataset/*.js',
                    'heatmapvisualization/*': '../javascript/heatmapvisualization/*.js',
                    'dendogram/*': '../javascript/dendogram/*.js',
                    'jsLru': '../vendor/rsms/js-lru/lru.js',
                    'js/orefine/*': '../javascript/orefine/*.js',
                    'js/project/*': '../javascript/project/*.js',
                    'js/alertservice/*': '../javascript/alertservice/*.js'
                },
                'map': {
                    'ng': 'mui@0.0.0#mui',
                    'jquery-ui': 'jquery-ui-bundle@1.11.4#jquery-ui'
                },
                'meta': {
                    'bootstrap@3.3.6#js/bootstrap': { 'deps': ['jquery'] },
                    'notific8@2.3.1#dist/jquery.notific8.min': {
                        'deps': [
                            'jquery',
                            'notific8/dist/jquery.notific8.css'
                        ]
                    },
                    'pouchdb': { 'format': 'global' },
                    'worker-pouch': { 'deps': ['pouchdb'] },
                    'jquery-ui': { 'deps': ['jquery'] },
                    'ui-router-extras@0.1.2#release/ct-ui-router-extras': { 'deps': ['angular-ui-router'] },
                    'oclazyload@1.0.9#dist/ocLazyLoad': { 'deps': ['ui-router-extras'] }
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ag-grid',
            'version': '2.3.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/ag-grid/package.json',
            'main': 'dist/ag-grid.min.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-animate',
            'version': '1.5.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-animate/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular',
            'version': '1.4.10',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-resource',
            'version': '1.5.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-resource/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-color-picker',
            'version': '1.0.10',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-color-picker/package.json',
            'main': 'angular-color-picker.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-route',
            'version': '1.5.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-route/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-ui-bootstrap',
            'version': '0.14.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-ui-bootstrap/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-nvd3',
            'version': '1.0.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-nvd3/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-ui-router',
            'version': '0.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-ui-router/package.json',
            'main': 'release/angular-ui-router.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-utils-pagination',
            'version': '0.9.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-utils-pagination/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'blueimp-canvas-to-blob',
            'version': '3.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/blueimp-canvas-to-blob/package.json',
            'main': './js/canvas-to-blob.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'blob-util',
            'version': '1.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/blob-util/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'bootstrap',
            'version': '3.3.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/bootstrap/package.json',
            'main': './dist/js/npm',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'browser-filesaver',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/browser-filesaver/package.json',
            'main': 'FileSaver.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'crossfilter',
            'version': '1.3.12',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/crossfilter/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3',
            'version': '3.5.14',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/d3/package.json',
            'main': 'd3.js',
            'globalBrowser': {},
            'browser': 'd3.js'
        },
        {
            'name': 'd3-tip',
            'version': '0.6.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/d3-tip/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jquery',
            'version': '2.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jquery-ui-bundle',
            'version': '1.11.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/jquery-ui-bundle/package.json',
            'main': 'jquery-ui.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'js-data',
            'version': '2.8.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/js-data/package.json',
            'main': './dist/js-data-debug.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'js-data-angular',
            'version': '3.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/js-data-angular/package.json',
            'main': 'dist/js-data-angular.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'liver',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/liver/package.json',
            'main': 'live',
            'system': {},
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '4.11.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/lodash/package.json',
            'main': 'lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-analysis',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-analysis/package.json',
            'main': 'src/mevAnalysis.module.js',
            'system': { 'ext': { 'html': 'system-text' } },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-annotations',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-annotations/package.json',
            'main': 'src/main/mevAnnotations.module.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-anova',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-anova/package.json',
            'main': 'src/main/mev-anova.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-bootstrap-theme',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-bootstrap-theme/package.json',
            'main': 'src/mev-bootstrap-theme.js',
            'system': { 'meta': { 'bootstrap@3.3.1#js/bootstrap': { 'deps': ['jquery'] } } },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-bs-modal',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-bs-modal/package.json',
            'main': 'src/mev-bs-modal.js',
            'system': { 'ext': { 'html': 'system-text' } },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-dataset',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-dataset/package.json',
            'main': 'src/main/mev-dataset.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-deseq',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-deseq/package.json',
            'main': 'src/main/mev-deseq.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-domain-common',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-domain-common/package.json',
            'main': 'src/main/mev-domain-common.js',
            'system': {
                'configDependencies': ['bower.json!bower'],
                'meta': { 'worker-pouch': { 'deps': ['pouchdb'] } }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-edger',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-edger/package.json',
            'main': 'src/main/mev-edger.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-google-analytics',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-google-analytics/package.json',
            'main': 'src/main/mev-google-analytics.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-gsea',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-gsea/package.json',
            'main': 'src/main/mevGsea.module.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-hcl',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-hcl/package.json',
            'main': 'src/main/mev-hcl.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-heatmap',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-heatmap/package.json',
            'main': 'src/main/mev-heatmap.js',
            'system': {
                'map': { 'jquery-ui': 'jquery-ui-bundle@1.11.4#jquery-ui' },
                'meta': { 'jquery-ui': { 'deps': ['jquery'] } },
                'ext': {
                    'html': 'system-text',
                    'json': 'systemjs-plugin-json'
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-kmeans',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-kmeans/package.json',
            'main': 'src/main/mev-kmeans.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-limma',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-limma/package.json',
            'main': 'src/main/mev-limma.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-normalization',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-normalization/package.json',
            'main': 'src/main/mev-normalization.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-pca',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-pca/package.json',
            'main': 'src/pca.module',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-project',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-project/package.json',
            'main': 'src/main/mev-project.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-results-table',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-results-table/package.json',
            'main': 'src/mev-results-table.js',
            'system': { 'ext': { 'html': 'system-text' } },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-scatter-plot',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-scatter-plot/package.json',
            'main': 'index',
            'system': {
                'paths': {},
                'configDependencies': ['live-reload'],
                'ext': {
                    'html': 'system-text',
                    'json': 'systemjs-plugin-json'
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-steal-bootstrap',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-steal-bootstrap/package.json',
            'main': 'src/stealBootstrap.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-survival',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-survival/package.json',
            'main': 'src/main/mev-survival.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-topgo',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-topgo/package.json',
            'main': 'src/main/mev-topgo.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-ttest',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-ttest/package.json',
            'main': 'src/main/mev-ttest.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-voom',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-voom/package.json',
            'main': 'src/main/mev-voom.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-wgcna',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/package.json',
            'main': 'src/main/mev-wgcna.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-workspace',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-workspace/package.json',
            'main': 'src/main/mev-workspace.js',
            'system': {
                'meta': {
                    'pouchdb-all-dbs': { 'deps': ['pouchdb'] },
                    'ui-router-extras@0.1.2#release/ct-ui-router-extras': { 'deps': ['angular-ui-router'] }
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mevPathwayEnrichment',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mevPathwayEnrichment/package.json',
            'main': 'src/pathwayEnrichment.module.js',
            'system': {
                'ext': { 'html': 'system-text' },
                'configDependencies': ['bower.json!bower']
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mui',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mui/package.json',
            'main': 'mui',
            'system': {
                'meta': {
                    'mui@0.0.0#mui': { 'deps': ['angular'] },
                    'angular@1.4.10#index': { 'deps': ['jquery'] }
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ng-grid',
            'version': '2.0.14',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/ng-grid/package.json',
            'main': 'ng-grid-2.0.14.min.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'notific8',
            'version': '2.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/notific8/package.json',
            'main': 'dist/jquery.notific8.min.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'nvd3',
            'version': '1.8.2-dev',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/nvd3/package.json',
            'main': 'build/nv.d3.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'q',
            'version': '1.4.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/q/package.json',
            'main': 'q.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'oclazyload',
            'version': '1.0.9',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/oclazyload/package.json',
            'main': 'dist/ocLazyLoad.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ui-router-extras',
            'version': '0.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/ui-router-extras/package.json',
            'main': 'release/ct-ui-router-extras',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-utils-ui-breadcrumbs',
            'version': '0.2.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/angular-utils-ui-breadcrumbs/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'gulp',
            'version': '3.9.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'gulp-jasmine-browser',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'gulp-util',
            'version': '3.0.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'system-parse-amd',
            'version': '0.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/system-parse-amd/package.json',
            'main': 'system-parse-amd.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'system-text',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/system-text/package.json',
            'main': 'text',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'systemjs-plugin-json',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/systemjs-plugin-json/package.json',
            'main': 'json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'blob',
            'version': '0.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/blob-util/node_modules/blob/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-mock',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/liver/node_modules/mev-mock/package.json',
            'main': 'src/main/mev-mock.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'pouchdb-promise',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/blob-util/node_modules/pouchdb-promise/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': { 'bluebird': 'lie' }
        },
        {
            'name': 'angular-ui-router',
            'version': '0.2.18',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-analysis/node_modules/angular-ui-router/package.json',
            'main': 'release/angular-ui-router.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '2.4.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/liver/node_modules/lodash/package.json',
            'main': 'dist/lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '4.14.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-anova/node_modules/lodash/package.json',
            'main': 'lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'js-data-http',
            'version': '2.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/js-data-angular/node_modules/js-data-http/package.json',
            'main': './dist/js-data-http.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-boxplot',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-anova/node_modules/mev-boxplot/package.json',
            'main': 'src/main/mev-boxplot',
            'system': { 'ext': { 'html': 'system-text' } },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'bootstrap',
            'version': '3.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-bootstrap-theme/node_modules/bootstrap/package.json',
            'main': './dist/js/npm',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-mocks',
            'version': '1.5.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-dataset/node_modules/angular-mocks/package.json',
            'main': 'angular-mocks.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-resource',
            'version': '1.5.8',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-dataset/node_modules/angular-resource/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'bowser',
            'version': '1.4.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-domain-common/node_modules/bowser/package.json',
            'main': './src/bowser.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-hbarchart',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-gsea/node_modules/mev-hbarchart/package.json',
            'main': 'src/main/mev-hbarchart.js',
            'system': {
                'ext': {
                    'html': 'system-text',
                    'json': 'systemjs-plugin-json'
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3',
            'version': '3.5.16',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-heatmap/node_modules/d3/package.json',
            'main': 'd3.js',
            'globalBrowser': {},
            'browser': 'd3.js'
        },
        {
            'name': 'notific8',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-heatmap/node_modules/notific8/package.json',
            'main': 'dist/jquery.notific8.min.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'save-svg-as-png',
            'version': '1.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-heatmap/node_modules/save-svg-as-png/package.json',
            'main': 'saveSvgAsPng.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '4.10.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-normalization/node_modules/lodash/package.json',
            'main': 'lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '4.13.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-pca/node_modules/lodash/package.json',
            'main': 'lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-utils-pagination',
            'version': '0.10.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-results-table/node_modules/angular-utils-pagination/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-glyph-alt',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-results-table/node_modules/mev-glyph-alt/package.json',
            'main': 'src/main/mev-glyph-alt.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'papaparse',
            'version': '4.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-results-table/node_modules/papaparse/package.json',
            'main': 'papaparse.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-chart-utils',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-scatter-plot/node_modules/mev-chart-utils/package.json',
            'main': 'src/main/mev-chart-utils.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-time-function',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-survival/node_modules/mev-time-function/package.json',
            'main': 'src/main/mev-time-function.js',
            'system': {
                'ext': {
                    'html': 'system-text',
                    'json': 'systemjs-plugin-json'
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-enrichment-dotplot',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-topgo/node_modules/mev-enrichment-dotplot/package.json',
            'main': 'src/main/mev-enrichment-dotplot.js',
            'system': {
                'ext': {
                    'html': 'system-text',
                    'json': 'systemjs-plugin-json'
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-network-graph',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/package.json',
            'main': 'src/main/mev-network-graph.js',
            'system': {
                'map': { 'vega@2.5.2#index': 'vega@2.5.2#vega.min.js' },
                'ext': {
                    'html': 'system-text',
                    'json': 'systemjs-plugin-json'
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'archy',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/archy/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'deprecated',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/deprecated/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'chalk',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/chalk/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'interpret',
            'version': '0.6.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/interpret/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'liftoff',
            'version': '2.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'minimist',
            'version': '1.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/minimist/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'orchestrator',
            'version': '0.3.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/orchestrator/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'pretty-hrtime',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/pretty-hrtime/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'semver',
            'version': '4.3.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/semver/package.json',
            'main': 'semver.js',
            'globalBrowser': {},
            'browser': 'semver.browser.js'
        },
        {
            'name': 'tildify',
            'version': '1.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/tildify/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'v8flags',
            'version': '2.0.11',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/v8flags/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vinyl-fs',
            'version': '0.3.14',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'babel-polyfill',
            'version': '6.3.14',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/babel-polyfill/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'babel-runtime',
            'version': '6.3.19',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/babel-runtime/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'event-stream',
            'version': '3.3.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'express',
            'version': '4.13.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jasmine-core',
            'version': '2.4.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/jasmine-core/package.json',
            'main': './lib/jasmine-core.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.once',
            'version': '3.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/lodash.once/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lazypipe',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/lazypipe/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mime',
            'version': '1.3.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/mime/package.json',
            'main': 'mime.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'portfinder',
            'version': '0.4.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/portfinder/package.json',
            'main': './lib/portfinder',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'serve-favicon',
            'version': '2.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/serve-favicon/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'stream-reduce',
            'version': '1.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/stream-reduce/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'thenify',
            'version': '3.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/thenify/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'through2',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/package.json',
            'main': 'through2.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vinyl',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/vinyl/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'array-differ',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/array-differ/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'array-uniq',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/array-uniq/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'beeper',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/beeper/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'dateformat',
            'version': '1.0.12',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/package.json',
            'main': 'lib/dateformat',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'fancy-log',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/fancy-log/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'gulplog',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/gulplog/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'has-gulplog',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/has-gulplog/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._reescape',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash._reescape/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._reevaluate',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash._reevaluate/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._reinterpolate',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash._reinterpolate/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.template',
            'version': '3.6.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'multipipe',
            'version': '0.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/multipipe/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'object-assign',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/object-assign/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'replace-ext',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/replace-ext/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vinyl',
            'version': '0.5.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/vinyl/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'bluebird',
            'version': '1.2.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/blob-util/node_modules/pouchdb-promise/node_modules/bluebird/package.json',
            'main': './js/main/bluebird.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lie',
            'version': '2.7.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/blob-util/node_modules/pouchdb-promise/node_modules/lie/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'angular-nvd3',
            'version': '1.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-gsea/node_modules/mev-hbarchart/node_modules/angular-nvd3/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'browser-filesaver',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-scatter-plot/node_modules/mev-chart-utils/node_modules/browser-filesaver/package.json',
            'main': 'FileSaver.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mout',
            'version': '0.11.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/js-data-angular/node_modules/js-data-http/node_modules/mout/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'blueimp-canvas-to-blob',
            'version': '3.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-scatter-plot/node_modules/mev-chart-utils/node_modules/blueimp-canvas-to-blob/package.json',
            'main': './js/canvas-to-blob.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '4.14.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-survival/node_modules/mev-time-function/node_modules/lodash/package.json',
            'main': 'lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mev-dotplot',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-topgo/node_modules/mev-enrichment-dotplot/node_modules/mev-dotplot/package.json',
            'main': 'src/main/mev-dotplot.js',
            'system': {
                'ext': {
                    'html': 'system-text',
                    'json': 'systemjs-plugin-json'
                }
            },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'axios',
            'version': '0.5.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/js-data-angular/node_modules/js-data-http/node_modules/axios/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': { 'axios#lib/adapters/http.js': 'axios#lib/adapters/xhr.js' }
        },
        {
            'name': 'd3',
            'version': '3.5.17',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/d3/package.json',
            'main': 'd3.js',
            'globalBrowser': {},
            'browser': 'd3.js'
        },
        {
            'name': 'jquery',
            'version': '2.2.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ng-vega',
            'version': '1.3.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/ng-vega/package.json',
            'main': 'dist/ng-vega.min.js',
            'system': { 'map': { 'vega@2.4.2#index': 'vega@2.4.2#vega.min.js' } },
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vega',
            'version': '2.5.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {
                'buffer': '@empty',
                'canvas': '@empty',
                'fs': '@empty',
                'http': '@empty',
                'request': '@empty',
                'sync-request': '@empty',
                'url': '@empty'
            }
        },
        {
            'name': 'ansi-styles',
            'version': '2.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/chalk/node_modules/ansi-styles/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'escape-string-regexp',
            'version': '1.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/chalk/node_modules/escape-string-regexp/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'has-ansi',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/chalk/node_modules/has-ansi/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'strip-ansi',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/chalk/node_modules/strip-ansi/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'supports-color',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/chalk/node_modules/supports-color/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'extend',
            'version': '2.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/extend/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'flagged-respawn',
            'version': '0.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/flagged-respawn/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'findup-sync',
            'version': '0.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/findup-sync/package.json',
            'main': 'lib/findup-sync',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'rechoir',
            'version': '0.6.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/rechoir/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'resolve',
            'version': '1.1.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/resolve/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'end-of-stream',
            'version': '0.1.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/orchestrator/node_modules/end-of-stream/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'sequencify',
            'version': '0.0.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/orchestrator/node_modules/sequencify/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'stream-consume',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/orchestrator/node_modules/stream-consume/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'os-homedir',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/tildify/node_modules/os-homedir/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'user-home',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/v8flags/node_modules/user-home/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'defaults',
            'version': '1.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/defaults/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'glob-stream',
            'version': '3.1.18',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'glob-watcher',
            'version': '0.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'graceful-fs',
            'version': '3.0.8',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/graceful-fs/package.json',
            'main': 'graceful-fs.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mkdirp',
            'version': '0.5.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/mkdirp/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'strip-bom',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/strip-bom/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'through2',
            'version': '0.6.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/through2/package.json',
            'main': 'through2.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'core-js',
            'version': '1.2.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/babel-polyfill/node_modules/core-js/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vinyl',
            'version': '0.4.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/vinyl/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'babel-regenerator-runtime',
            'version': '6.3.13',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/babel-polyfill/node_modules/babel-regenerator-runtime/package.json',
            'main': 'runtime.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'babel-runtime',
            'version': '5.8.35',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/babel-polyfill/node_modules/babel-runtime/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'through',
            'version': '2.3.8',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/node_modules/through/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'duplexer',
            'version': '0.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/node_modules/duplexer/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'from',
            'version': '0.1.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/node_modules/from/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'map-stream',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/node_modules/map-stream/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'pause-stream',
            'version': '0.0.11',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/node_modules/pause-stream/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'split',
            'version': '0.3.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/node_modules/split/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'stream-combiner',
            'version': '0.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/event-stream/node_modules/stream-combiner/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'accepts',
            'version': '1.2.13',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/accepts/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'array-flatten',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/array-flatten/package.json',
            'main': 'array-flatten.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'content-disposition',
            'version': '0.5.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/content-disposition/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'content-type',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/content-type/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'cookie',
            'version': '0.1.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/cookie/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'cookie-signature',
            'version': '1.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/cookie-signature/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'debug',
            'version': '2.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/debug/package.json',
            'main': './node.js',
            'globalBrowser': {},
            'browser': './browser.js'
        },
        {
            'name': 'depd',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/depd/package.json',
            'globalBrowser': {},
            'browser': 'lib/browser/index.js'
        },
        {
            'name': 'escape-html',
            'version': '1.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/escape-html/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'etag',
            'version': '1.7.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/etag/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'finalhandler',
            'version': '0.4.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/finalhandler/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'fresh',
            'version': '0.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/fresh/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'merge-descriptors',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/merge-descriptors/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'methods',
            'version': '1.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/methods/package.json',
            'globalBrowser': {},
            'browser': { 'http': '@empty' }
        },
        {
            'name': 'on-finished',
            'version': '2.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/on-finished/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'parseurl',
            'version': '1.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/parseurl/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'path-to-regexp',
            'version': '0.1.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/path-to-regexp/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'proxy-addr',
            'version': '1.0.10',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/proxy-addr/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'qs',
            'version': '4.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/qs/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'range-parser',
            'version': '1.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/range-parser/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'send',
            'version': '0.13.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/send/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'serve-static',
            'version': '1.10.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/serve-static/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'type-is',
            'version': '1.6.11',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/type-is/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'utils-merge',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/utils-merge/package.json',
            'main': './index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vary',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/vary/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'stream-combiner',
            'version': '0.2.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/lazypipe/node_modules/stream-combiner/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.before',
            'version': '3.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/lodash.once/node_modules/lodash.before/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'async',
            'version': '0.9.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/portfinder/node_modules/async/package.json',
            'main': './lib/async',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ms',
            'version': '0.7.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/serve-favicon/node_modules/ms/package.json',
            'main': './index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'any-promise',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/thenify/node_modules/any-promise/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': { 'any-promise#register.js': 'any-promise#register-shim.js' }
        },
        {
            'name': 'readable-stream',
            'version': '2.0.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/readable-stream/package.json',
            'main': 'readable.js',
            'globalBrowser': {},
            'browser': { 'util': '@empty' }
        },
        {
            'name': 'xtend',
            'version': '4.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/xtend/package.json',
            'main': 'immutable',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'clone',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/vinyl/node_modules/clone/package.json',
            'main': 'clone.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'clone-stats',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/vinyl/node_modules/clone-stats/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': 'index.js'
        },
        {
            'name': 'meow',
            'version': '3.7.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'glogg',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/gulplog/node_modules/glogg/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'get-stdin',
            'version': '4.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/get-stdin/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'sparkles',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/has-gulplog/node_modules/sparkles/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._basecopy',
            'version': '3.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash._basecopy/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._basetostring',
            'version': '3.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash._basetostring/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._basevalues',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash._basevalues/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._isiterateecall',
            'version': '3.0.9',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash._isiterateecall/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.escape',
            'version': '3.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash.escape/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.keys',
            'version': '3.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash.keys/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.restparam',
            'version': '3.6.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash.restparam/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.templatesettings',
            'version': '3.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash.templatesettings/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'duplexer2',
            'version': '0.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'es6-promise',
            'version': '2.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/js-data-angular/node_modules/js-data-http/node_modules/axios/node_modules/es6-promise/package.json',
            'main': 'dist/es6-promise.js',
            'globalBrowser': {},
            'browser': { 'vertx': '@empty' }
        },
        {
            'name': 'immediate',
            'version': '3.2.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/blob-util/node_modules/pouchdb-promise/node_modules/lie/node_modules/immediate/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': { 'immediate#nextTick': '@empty' }
        },
        {
            'name': 'd3-geo-projection',
            'version': '0.2.16',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vega',
            'version': '2.4.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/ng-vega/node_modules/vega/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {
                'buffer': '@empty',
                'canvas': '@empty',
                'fs': '@empty',
                'http': '@empty',
                'request': '@empty',
                'sync-request': '@empty',
                'url': '@empty'
            }
        },
        {
            'name': 'angular',
            'version': '1.3.20',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/ng-vega/node_modules/angular/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'topojson',
            'version': '1.6.26',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/package.json',
            'main': 'server.js',
            'globalBrowser': {},
            'browser': 'build/topojson.js'
        },
        {
            'name': 'nvd3',
            'version': '1.8.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-gsea/node_modules/mev-hbarchart/node_modules/angular-nvd3/node_modules/nvd3/package.json',
            'main': 'build/nv.d3.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'datalib',
            'version': '1.6.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/package.json',
            'main': 'src/index.js',
            'globalBrowser': {},
            'browser': {
                'buffer': '@empty',
                'fs': '@empty',
                'http': '@empty',
                'request': '@empty',
                'sync-request': '@empty',
                'url': '@empty'
            }
        },
        {
            'name': 'vega-dataflow',
            'version': '1.4.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/vega-dataflow/package.json',
            'main': 'src/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3-cloud',
            'version': '1.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-cloud/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vega-expression',
            'version': '1.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/vega-expression/package.json',
            'main': 'src/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vega-event-selector',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/vega-event-selector/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vega-logging',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/vega-logging/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'vega-scenegraph',
            'version': '1.0.17',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/vega-scenegraph/package.json',
            'main': 'src/index.js',
            'globalBrowser': {},
            'browser': { 'canvas': '@empty' }
        },
        {
            'name': 'yargs',
            'version': '3.32.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'canvas',
            'version': '1.3.14',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/canvas/package.json',
            'main': './lib/canvas.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ansi-regex',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/chalk/node_modules/has-ansi/node_modules/ansi-regex/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'glob',
            'version': '5.0.15',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/findup-sync/node_modules/glob/package.json',
            'main': 'glob.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'once',
            'version': '1.3.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/orchestrator/node_modules/end-of-stream/node_modules/once/package.json',
            'main': 'once.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'glob',
            'version': '4.5.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/glob/package.json',
            'main': 'glob.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'minimatch',
            'version': '2.0.10',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/minimatch/package.json',
            'main': 'minimatch.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ordered-read-streams',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/ordered-read-streams/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'glob2base',
            'version': '0.0.12',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/glob2base/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'unique-stream',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/unique-stream/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'gaze',
            'version': '0.5.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/package.json',
            'main': 'lib/gaze',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'minimist',
            'version': '0.0.8',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/mkdirp/node_modules/minimist/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'first-chunk-stream',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/strip-bom/node_modules/first-chunk-stream/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'is-utf8',
            'version': '0.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/strip-bom/node_modules/is-utf8/package.json',
            'main': 'is-utf8.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'readable-stream',
            'version': '1.0.33',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/through2/node_modules/readable-stream/package.json',
            'main': 'readable.js',
            'globalBrowser': {},
            'browser': { 'util': '@empty' }
        },
        {
            'name': 'clone',
            'version': '0.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/vinyl/node_modules/clone/package.json',
            'main': 'clone.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mime-types',
            'version': '2.1.9',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/accepts/node_modules/mime-types/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'negotiator',
            'version': '0.5.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/accepts/node_modules/negotiator/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'unpipe',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/finalhandler/node_modules/unpipe/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ee-first',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/on-finished/node_modules/ee-first/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'forwarded',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/proxy-addr/node_modules/forwarded/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ipaddr.js',
            'version': '1.0.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/proxy-addr/node_modules/ipaddr.js/package.json',
            'main': './lib/ipaddr',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'destroy',
            'version': '1.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/send/node_modules/destroy/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'http-errors',
            'version': '1.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/send/node_modules/http-errors/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'statuses',
            'version': '1.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/send/node_modules/statuses/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'media-typer',
            'version': '0.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/type-is/node_modules/media-typer/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'core-util-is',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/readable-stream/node_modules/core-util-is/package.json',
            'main': 'lib/util.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'inherits',
            'version': '2.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/readable-stream/node_modules/inherits/package.json',
            'main': './inherits.js',
            'globalBrowser': {},
            'browser': './inherits_browser.js'
        },
        {
            'name': 'isarray',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/readable-stream/node_modules/isarray/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'process-nextick-args',
            'version': '1.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/readable-stream/node_modules/process-nextick-args/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'string_decoder',
            'version': '0.10.31',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/readable-stream/node_modules/string_decoder/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'util-deprecate',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/through2/node_modules/readable-stream/node_modules/util-deprecate/package.json',
            'main': 'node.js',
            'globalBrowser': {},
            'browser': 'browser.js'
        },
        {
            'name': 'camelcase-keys',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/camelcase-keys/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'decamelize',
            'version': '1.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/decamelize/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'loud-rejection',
            'version': '1.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/loud-rejection/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'normalize-package-data',
            'version': '2.3.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/package.json',
            'main': 'lib/normalize.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'map-obj',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/map-obj/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'read-pkg-up',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'object-assign',
            'version': '4.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/object-assign/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'redent',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/redent/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'trim-newlines',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/trim-newlines/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash._getnative',
            'version': '3.9.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash.keys/node_modules/lodash._getnative/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.isarray',
            'version': '3.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash.keys/node_modules/lodash.isarray/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash.isarguments',
            'version': '3.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/lodash.template/node_modules/lodash.keys/node_modules/lodash.isarguments/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'readable-stream',
            'version': '1.1.13',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/multipipe/node_modules/duplexer2/node_modules/readable-stream/package.json',
            'main': 'readable.js',
            'globalBrowser': {},
            'browser': { 'util': '@empty' }
        },
        {
            'name': 'datalib',
            'version': '1.7.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/ng-vega/node_modules/vega/node_modules/datalib/package.json',
            'main': 'src/index.js',
            'globalBrowser': {},
            'browser': {
                'buffer': '@empty',
                'fs': '@empty',
                'http': '@empty',
                'request': '@empty',
                'sync-request': '@empty',
                'url': '@empty'
            }
        },
        {
            'name': 'd3-dispatch',
            'version': '0.2.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-cloud/node_modules/d3-dispatch/package.json',
            'main': 'build/d3-dispatch.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'brfs',
            'version': '1.4.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3-dsv',
            'version': '0.1.14',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/d3-dsv/package.json',
            'main': 'build/d3-dsv.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3-format',
            'version': '0.4.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/d3-format/package.json',
            'main': 'build/d3-format.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3-time',
            'version': '0.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/d3-time/package.json',
            'main': 'build/d3-time.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3-time-format',
            'version': '0.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/d3-time-format/package.json',
            'main': 'build/d3-time-format.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'sync-request',
            'version': '2.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/package.json',
            'globalBrowser': {},
            'browser': './browser.js'
        },
        {
            'name': 'request',
            'version': '2.72.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3-queue',
            'version': '2.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/node_modules/d3-queue/package.json',
            'main': 'build/d3-queue.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'optimist',
            'version': '0.3.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/node_modules/optimist/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'rw',
            'version': '1.3.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/node_modules/rw/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'camelcase',
            'version': '2.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/camelcase/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'shapefile',
            'version': '0.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/node_modules/shapefile/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'cliui',
            'version': '3.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/cliui/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'decamelize',
            'version': '1.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/decamelize/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'os-locale',
            'version': '1.4.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/os-locale/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'string-width',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/string-width/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'window-size',
            'version': '0.1.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/window-size/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'y18n',
            'version': '3.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/y18n/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'nan',
            'version': '2.3.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/canvas/node_modules/nan/package.json',
            'main': 'include_dirs.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'inflight',
            'version': '1.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/findup-sync/node_modules/glob/node_modules/inflight/package.json',
            'main': 'inflight.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'minimatch',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/package.json',
            'main': 'minimatch.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'path-is-absolute',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/liftoff/node_modules/findup-sync/node_modules/glob/node_modules/path-is-absolute/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'wrappy',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/orchestrator/node_modules/end-of-stream/node_modules/once/node_modules/wrappy/package.json',
            'main': 'wrappy.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'brace-expansion',
            'version': '1.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/minimatch/node_modules/brace-expansion/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'find-index',
            'version': '0.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/glob2base/node_modules/find-index/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'globule',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/package.json',
            'main': 'lib/globule',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mime-db',
            'version': '1.21.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-jasmine-browser/node_modules/express/node_modules/accepts/node_modules/mime-types/node_modules/mime-db/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'camelcase',
            'version': '2.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/camelcase-keys/node_modules/camelcase/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'array-find-index',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/loud-rejection/node_modules/array-find-index/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'signal-exit',
            'version': '2.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/loud-rejection/node_modules/signal-exit/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'hosted-git-info',
            'version': '2.1.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/hosted-git-info/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'is-builtin-module',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/is-builtin-module/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'semver',
            'version': '5.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/semver/package.json',
            'main': 'semver.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'validate-npm-package-license',
            'version': '3.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/validate-npm-package-license/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'find-up',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/find-up/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'read-pkg',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'indent-string',
            'version': '2.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/redent/node_modules/indent-string/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'strip-indent',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/redent/node_modules/strip-indent/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'aws-sign2',
            'version': '0.6.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/aws-sign2/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'quote-stream',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/quote-stream/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'aws4',
            'version': '1.4.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/aws4/package.json',
            'main': 'aws4.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'bl',
            'version': '1.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/bl/package.json',
            'main': 'bl.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'caseless',
            'version': '0.11.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/caseless/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'combined-stream',
            'version': '1.0.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/combined-stream/package.json',
            'main': './lib/combined_stream',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'extend',
            'version': '3.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/extend/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'static-module',
            'version': '1.3.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'form-data',
            'version': '1.0.0-rc4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/form-data/package.json',
            'main': './lib/form_data',
            'globalBrowser': {},
            'browser': './lib/browser'
        },
        {
            'name': 'is-typedarray',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/is-typedarray/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'hawk',
            'version': '3.1.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/hawk/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': './lib/browser.js'
        },
        {
            'name': 'forever-agent',
            'version': '0.6.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/forever-agent/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'har-validator',
            'version': '2.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/package.json',
            'main': 'lib/index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'http-signature',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'isstream',
            'version': '0.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/isstream/package.json',
            'main': 'isstream.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mime-types',
            'version': '2.1.11',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/mime-types/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'node-uuid',
            'version': '1.4.7',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/node-uuid/package.json',
            'main': './uuid.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'json-stringify-safe',
            'version': '5.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/json-stringify-safe/package.json',
            'main': 'stringify.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'oauth-sign',
            'version': '0.8.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/oauth-sign/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'qs',
            'version': '6.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/qs/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'stringstream',
            'version': '0.0.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/stringstream/package.json',
            'main': 'stringstream.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'tough-cookie',
            'version': '2.2.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/tough-cookie/package.json',
            'main': './lib/cookie',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'tunnel-agent',
            'version': '0.4.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/tunnel-agent/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'concat-stream',
            'version': '1.5.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/concat-stream/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'http-response-object',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/http-response-object/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'spawn-sync',
            'version': '1.0.15',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/spawn-sync/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'wordwrap',
            'version': '0.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/node_modules/optimist/node_modules/wordwrap/package.json',
            'main': './index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'iconv-lite',
            'version': '0.2.11',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/node_modules/shapefile/node_modules/iconv-lite/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'd3-queue',
            'version': '1.2.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/topojson/node_modules/shapefile/node_modules/d3-queue/package.json',
            'main': 'build/queue.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'then-request',
            'version': '2.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/then-request/package.json',
            'globalBrowser': {},
            'browser': './browser.js'
        },
        {
            'name': 'strip-ansi',
            'version': '3.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/cliui/node_modules/strip-ansi/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'wrap-ansi',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/cliui/node_modules/wrap-ansi/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lcid',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/os-locale/node_modules/lcid/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'code-point-at',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/string-width/node_modules/code-point-at/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'is-fullwidth-code-point',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/string-width/node_modules/is-fullwidth-code-point/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'balanced-match',
            'version': '0.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'concat-map',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-stream/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lodash',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/lodash/package.json',
            'main': './dist/lodash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'minimatch',
            'version': '0.2.14',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/minimatch/package.json',
            'main': 'minimatch.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'glob',
            'version': '3.1.21',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/glob/package.json',
            'main': 'glob.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'builtin-modules',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/is-builtin-module/node_modules/builtin-modules/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'spdx-correct',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/validate-npm-package-license/node_modules/spdx-correct/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'spdx-expression-parse',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/validate-npm-package-license/node_modules/spdx-expression-parse/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'path-exists',
            'version': '2.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/find-up/node_modules/path-exists/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'pinkie-promise',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/find-up/node_modules/pinkie-promise/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'load-json-file',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/load-json-file/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'repeating',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/redent/node_modules/indent-string/node_modules/repeating/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'path-type',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/path-type/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'buffer-equal',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/quote-stream/node_modules/buffer-equal/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'concat-stream',
            'version': '1.4.10',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/concat-stream/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'escodegen',
            'version': '1.3.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/escodegen/package.json',
            'main': 'escodegen.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'falafel',
            'version': '1.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/falafel/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'has',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/has/package.json',
            'main': './src/index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'object-inspect',
            'version': '0.4.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/object-inspect/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'readable-stream',
            'version': '1.0.34',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/readable-stream/package.json',
            'main': 'readable.js',
            'globalBrowser': {},
            'browser': { 'util': '@empty' }
        },
        {
            'name': 'quote-stream',
            'version': '0.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/quote-stream/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'shallow-copy',
            'version': '0.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/shallow-copy/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'static-eval',
            'version': '0.2.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/static-eval/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'through2',
            'version': '0.4.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/through2/package.json',
            'main': 'through2.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'readable-stream',
            'version': '2.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/bl/node_modules/readable-stream/package.json',
            'main': 'readable.js',
            'globalBrowser': {},
            'browser': { 'util': '@empty' }
        },
        {
            'name': 'delayed-stream',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/combined-stream/node_modules/delayed-stream/package.json',
            'main': './lib/delayed_stream',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'async',
            'version': '1.5.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/form-data/node_modules/async/package.json',
            'main': 'lib/async.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'chalk',
            'version': '1.1.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/chalk/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'commander',
            'version': '2.9.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/commander/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'hoek',
            'version': '2.16.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/hawk/node_modules/hoek/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'is-my-json-valid',
            'version': '2.13.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/is-my-json-valid/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'boom',
            'version': '2.10.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/hawk/node_modules/boom/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'cryptiles',
            'version': '2.0.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/hawk/node_modules/cryptiles/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'sntp',
            'version': '1.0.9',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/hawk/node_modules/sntp/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jsprim',
            'version': '1.2.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/jsprim/package.json',
            'main': './lib/jsprim.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'assert-plus',
            'version': '0.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/assert-plus/package.json',
            'main': './assert.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'mime-db',
            'version': '1.23.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/mime-types/node_modules/mime-db/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'typedarray',
            'version': '0.0.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/concat-stream/node_modules/typedarray/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'os-shim',
            'version': '0.1.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/spawn-sync/node_modules/os-shim/package.json',
            'main': 'lib/os',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'http-basic',
            'version': '2.5.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/then-request/node_modules/http-basic/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'sshpk',
            'version': '1.8.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'promise',
            'version': '7.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/then-request/node_modules/promise/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'qs',
            'version': '6.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/then-request/node_modules/qs/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'graceful-fs',
            'version': '1.2.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/glob/node_modules/graceful-fs/package.json',
            'main': 'graceful-fs.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'number-is-nan',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/string-width/node_modules/code-point-at/node_modules/number-is-nan/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'inherits',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/glob/node_modules/inherits/package.json',
            'main': './inherits.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'sigmund',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/minimatch/node_modules/sigmund/package.json',
            'main': 'sigmund.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'invert-kv',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/yargs/node_modules/os-locale/node_modules/lcid/node_modules/invert-kv/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'lru-cache',
            'version': '2.7.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp/node_modules/vinyl-fs/node_modules/glob-watcher/node_modules/gaze/node_modules/globule/node_modules/minimatch/node_modules/lru-cache/package.json',
            'main': 'lib/lru-cache.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'spdx-license-ids',
            'version': '1.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/validate-npm-package-license/node_modules/spdx-correct/node_modules/spdx-license-ids/package.json',
            'main': 'spdx-license-ids.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'spdx-exceptions',
            'version': '1.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/validate-npm-package-license/node_modules/spdx-expression-parse/node_modules/spdx-exceptions/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'pinkie',
            'version': '2.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/find-up/node_modules/pinkie-promise/node_modules/pinkie/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'is-finite',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/redent/node_modules/indent-string/node_modules/repeating/node_modules/is-finite/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'graceful-fs',
            'version': '4.1.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/load-json-file/node_modules/graceful-fs/package.json',
            'main': 'graceful-fs.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'parse-json',
            'version': '2.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/load-json-file/node_modules/parse-json/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'pify',
            'version': '2.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/load-json-file/node_modules/pify/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'strip-bom',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/load-json-file/node_modules/strip-bom/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'esprima',
            'version': '1.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/escodegen/node_modules/esprima/package.json',
            'main': 'esprima.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'estraverse',
            'version': '1.5.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/escodegen/node_modules/estraverse/package.json',
            'main': 'estraverse.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'esutils',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/escodegen/node_modules/esutils/package.json',
            'main': 'lib/utils.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'source-map',
            'version': '0.1.43',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/escodegen/node_modules/source-map/package.json',
            'main': './lib/source-map.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'acorn',
            'version': '1.2.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/falafel/node_modules/acorn/package.json',
            'main': 'dist/acorn.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'foreach',
            'version': '2.0.5',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/falafel/node_modules/foreach/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'object-keys',
            'version': '1.0.9',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/falafel/node_modules/object-keys/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'function-bind',
            'version': '1.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/has/node_modules/function-bind/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'escodegen',
            'version': '0.0.28',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/static-eval/node_modules/escodegen/package.json',
            'main': 'escodegen.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'xtend',
            'version': '2.1.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/through2/node_modules/xtend/package.json',
            'main': 'index',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'isarray',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/bl/node_modules/readable-stream/node_modules/isarray/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ansi-styles',
            'version': '2.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/chalk/node_modules/ansi-styles/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'graceful-readlink',
            'version': '1.0.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/commander/node_modules/graceful-readlink/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'generate-function',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/is-my-json-valid/node_modules/generate-function/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jsonpointer',
            'version': '2.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/is-my-json-valid/node_modules/jsonpointer/package.json',
            'main': './jsonpointer',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'generate-object-property',
            'version': '1.2.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/is-my-json-valid/node_modules/generate-object-property/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'extsprintf',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/jsprim/node_modules/extsprintf/package.json',
            'main': './lib/extsprintf.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'verror',
            'version': '1.3.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/jsprim/node_modules/verror/package.json',
            'main': './lib/verror.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'json-schema',
            'version': '0.2.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/jsprim/node_modules/json-schema/package.json',
            'main': './lib/validate.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'asn1',
            'version': '0.2.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/asn1/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'assert-plus',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/assert-plus/package.json',
            'main': './assert.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'dashdash',
            'version': '1.13.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/dashdash/package.json',
            'main': './lib/dashdash.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'getpass',
            'version': '0.1.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/getpass/package.json',
            'main': 'lib/index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'tweetnacl',
            'version': '0.13.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/tweetnacl/package.json',
            'main': 'nacl-fast.js',
            'globalBrowser': {},
            'browser': {
                'buffer': '@empty',
                'crypto': '@empty'
            }
        },
        {
            'name': 'jsbn',
            'version': '0.1.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/jsbn/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'jodid25519',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/jodid25519/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'ecc-jsbn',
            'version': '0.1.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/http-signature/node_modules/sshpk/node_modules/ecc-jsbn/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'asap',
            'version': '2.0.3',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/sync-request/node_modules/then-request/node_modules/promise/node_modules/asap/package.json',
            'main': './asap.js',
            'globalBrowser': {},
            'browser': {
                'asap#asap.js': 'asap#browser-asap.js',
                'asap#raw.js': 'asap#browser-raw.js',
                'asap#test/domain.js': 'asap#test/browser-domain.js'
            }
        },
        {
            'name': 'error-ex',
            'version': '1.3.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/load-json-file/node_modules/parse-json/node_modules/error-ex/package.json',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'amdefine',
            'version': '1.0.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/escodegen/node_modules/source-map/node_modules/amdefine/package.json',
            'main': './amdefine.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'esprima',
            'version': '1.0.4',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/static-eval/node_modules/escodegen/node_modules/esprima/package.json',
            'main': 'esprima.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'estraverse',
            'version': '1.3.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/static-eval/node_modules/escodegen/node_modules/estraverse/package.json',
            'main': 'estraverse.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'source-map',
            'version': '0.5.6',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/static-eval/node_modules/escodegen/node_modules/source-map/package.json',
            'main': './source-map.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'object-keys',
            'version': '0.4.0',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/d3-geo-projection/node_modules/brfs/node_modules/static-module/node_modules/through2/node_modules/xtend/node_modules/object-keys/package.json',
            'main': 'index.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'is-property',
            'version': '1.0.2',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/mev-wgcna/node_modules/mev-network-graph/node_modules/vega/node_modules/datalib/node_modules/request/node_modules/har-validator/node_modules/is-my-json-valid/node_modules/generate-object-property/node_modules/is-property/package.json',
            'main': 'is-property.js',
            'globalBrowser': {},
            'browser': {}
        },
        {
            'name': 'is-arrayish',
            'version': '0.2.1',
            'fileUrl': 'file:/home/antony/git/mev2/mev/web/src/main/javascript/edu/dfci/cccb/mev/web/ui/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/read-pkg-up/node_modules/read-pkg/node_modules/load-json-file/node_modules/parse-json/node_modules/error-ex/node_modules/is-arrayish/package.json',
            'globalBrowser': {},
            'browser': {}
        }
    ]));
});
/*jquery@2.2.1#dist/jquery*/
(function (global, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    var arr = [];
    var document = window.document;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var version = '2.2.1', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: '',
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function (callback) {
            return jQuery.each(this, callback);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isArray: Array.isArray,
        isWindow: function (obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function (obj) {
            var realStringObj = obj && obj.toString();
            return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
        },
        isPlainObject: function (obj) {
            if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
            return true;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf('use strict') === 1) {
                    script = document.createElement('script');
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function (obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var tmp, args, proxy;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    if (typeof Symbol === 'function') {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        var length = !!obj && 'length' in obj && obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                var i = 0, len = list.length;
                for (; i < len; i++) {
                    if (list[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + identifier + ')'),
                'CLASS': new RegExp('^\\.(' + identifier + ')'),
                'TAG': new RegExp('^(' + identifier + '|[*])'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, unloadHandler = function () {
                setDocument();
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, nidselect, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                if (documentIsHTML) {
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;
                        } else if (context.nodeName.toLowerCase() !== 'object') {
                            if (nid = context.getAttribute('id')) {
                                nid = nid.replace(rescape, '\\$&');
                            } else {
                                context.setAttribute('id', nid = expando);
                            }
                            groups = tokenize(selector);
                            i = groups.length;
                            nidselect = ridentifier.test(nid) ? '#' + nid : '[id=\'' + nid + '\']';
                            while (i--) {
                                groups[i] = nidselect + ' ' + toSelector(groups[i]);
                            }
                            newSelector = groups.join(',');
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (nid === expando) {
                                    context.removeAttribute('id');
                                }
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement('div');
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = arr.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== 'undefined' && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            if ((parent = document.defaultView) && parent.top !== parent) {
                if (parent.addEventListener) {
                    parent.addEventListener('unload', unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent('onunload', unloadHandler);
                }
            }
            support.attributes = assert(function (div) {
                div.className = 'i';
                return !div.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (div) {
                div.appendChild(document.createComment(''));
                return !div.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            support.getById = assert(function (div) {
                docElem.appendChild(div).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m ? [m] : [];
                    }
                };
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
            } else {
                delete Expr.find['ID'];
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== 'undefined') {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                assert(function (div) {
                    docElem.appendChild(div).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
                    if (div.querySelectorAll('[msallowcapture^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!div.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!div.querySelectorAll('[id~=' + expando + '-]').length) {
                        rbuggyQSA.push('~=');
                    }
                    if (!div.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                    if (!div.querySelectorAll('a#' + expando + '+*').length) {
                        rbuggyQSA.push('.#.+[+~]');
                    }
                });
                assert(function (div) {
                    var input = document.createElement('input');
                    input.setAttribute('type', 'hidden');
                    div.appendChild(input).setAttribute('name', 'D');
                    if (div.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (!div.querySelectorAll(':enabled').length) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    div.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (div) {
                    support.disconnectedMatch = matches.call(div, 'div');
                    matches.call(div, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || '';
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else {
                                if (useCache) {
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                if (diff === false) {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                uniqueCache[type] = [
                                                    dirruns,
                                                    diff
                                                ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    text = text.replace(runescape, funescape);
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': function (elem) {
                    return elem.disabled === false;
                },
                'disabled': function (elem) {
                    return elem.disabled === true;
                },
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function (elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                            if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                uniqueCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context === document || context || outermost;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            if (!context && elem.ownerDocument !== document) {
                                setDocument(elem);
                                xml = !documentIsHTML;
                            }
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context || document, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (div1) {
            return div1.compareDocumentPosition(document.createElement('div')) & 1;
        });
        if (!assert(function (div) {
                div.innerHTML = '<a href=\'#\'></a>';
                return div.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (div) {
                div.innerHTML = '<input/>';
                div.firstChild.setAttribute('value', '');
                return div.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (div) {
                return div.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var dir = function (elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function (n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === 'string') {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + ' ' + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;
            if (!selector) {
                return this;
            }
            root = root || rootjQuery;
            if (typeof selector === 'string') {
                if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function () {
                locked = options.once;
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {
                        if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }
                if (!options.memory) {
                    memory = false;
                }
                firing = false;
                if (locked) {
                    if (memory) {
                        list = [];
                    } else {
                        list = '';
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (jQuery.isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && jQuery.type(arg) !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                },
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },
                disable: function () {
                    locked = queue = [];
                    list = memory = '';
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    locked = queue = [];
                    if (!memory) {
                        list = memory = '';
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        'rejected'
                    ],
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory')
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function (fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler('ready');
                jQuery(document).off('ready');
            }
        }
    });
    function completed() {
        document.removeEventListener('DOMContentLoaded', completed);
        window.removeEventListener('load', completed);
        jQuery.ready();
    }
    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
                window.setTimeout(jQuery.ready);
            } else {
                document.addEventListener('DOMContentLoaded', completed);
                window.addEventListener('load', completed);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        register: function (owner, initial) {
            var value = initial || {};
            if (owner.nodeType) {
                owner[this.expando] = value;
            } else {
                Object.defineProperty(owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true
                });
            }
            return owner[this.expando];
        },
        cache: function (owner) {
            if (!acceptData(owner)) {
                return {};
            }
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function (owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === 'string') {
                cache[data] = value;
            } else {
                for (prop in data) {
                    cache[prop] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
        },
        access: function (owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === 'string' && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, name, camel, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key === undefined) {
                this.register(owner);
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [
                            key,
                            camel
                        ];
                    } else {
                        name = camel;
                        name = name in cache ? [name] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {
                }
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, 'hasDataAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }
            return access(this, function (value) {
                var data, camelKey;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, '-$&').toLowerCase());
                    if (data !== undefined) {
                        return data;
                    }
                    camelKey = jQuery.camelCase(key);
                    data = dataUser.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                camelKey = jQuery.camelCase(key);
                this.each(function () {
                    var data = dataUser.get(this, camelKey);
                    dataUser.set(this, camelKey, value);
                    if (key.indexOf('-') > -1 && data !== undefined) {
                        dataUser.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    dataPriv.remove(elem, [
                        type + 'queue',
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = dataPriv.get(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHidden = function (elem, el) {
        elem = el || elem;
        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function () {
                return tween.cur();
            } : function () {
                return jQuery.css(elem, prop, '');
            }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), initialInUnit = (jQuery.cssNumber[prop] || unit !== 'px' && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3];
            valueParts = valueParts || [];
            initialInUnit = +initial || 1;
            do {
                scale = scale || '.5';
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);
            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([\w:-]+)/;
    var rscriptType = /^$|\/(?:java|ecma)script/i;
    var wrapMap = {
        option: [
            1,
            '<select multiple=\'multiple\'>',
            '</select>'
        ],
        thead: [
            1,
            '<table>',
            '</table>'
        ],
        col: [
            2,
            '<table><colgroup>',
            '</colgroup></table>'
        ],
        tr: [
            2,
            '<table><tbody>',
            '</tbody></table>'
        ],
        td: [
            3,
            '<table><tbody><tr>',
            '</tr></tbody></table>'
        ],
        _default: [
            0,
            '',
            ''
        ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var ret = typeof context.getElementsByTagName !== 'undefined' ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== 'undefined' ? context.querySelectorAll(tag || '*') : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
            dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'));
        }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (jQuery.type(elem) === 'object') {
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement('div'));
                    tag = (rtagName.exec(elem) || [
                        '',
                        ''
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = '';
                }
            }
        }
        fragment.textContent = '';
        i = 0;
        while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), 'script');
            if (contains) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || '')) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
        input.setAttribute('type', 'radio');
        input.setAttribute('checked', 'checked');
        input.setAttribute('name', 't');
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }());
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === 'object') {
            if (typeof selector !== 'string') {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === 'string') {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function (event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, 'handle events');
            }
        },
        dispatch: function (event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (dataPriv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (event.type !== 'click' || isNaN(event.button) || event.button < 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: ('altKey bubbles cancelable ctrlKey currentTarget detail eventPhase ' + 'metaKey relatedTarget shiftKey target timeStamp view which').split(' '),
        fixHooks: {},
        keyHooks: {
            props: 'char charCode key keyCode'.split(' '),
            filter: function (event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: ('button buttons clientX clientY offsetX offsetY pageX pageY ' + 'screenX screenY toElement').split(' '),
            filter: function (event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout',
        pointerenter: 'pointerover',
        pointerleave: 'pointerout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                hasScripts = scripts.length;
                for (; i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, 'script'));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || '') && !dataPriv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                            if (node.src) {
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, 'script'));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function (html) {
            return html.replace(rxhtmlTag, '<$1></$2>');
        },
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            return clone;
        },
        cleanData: function (elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        domManip: domManip,
        detach: function (selector) {
            return remove(this, selector, true);
        },
        remove: function (selector) {
            return remove(this, selector);
        },
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = '';
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var ignored = [];
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {
            HTML: 'block',
            BODY: 'block'
        };
    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === 'none' || !display) {
                iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles = function (elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    var swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var documentElement = document.documentElement;
    (function () {
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement('div'), div = document.createElement('div');
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        container.style.cssText = 'border:0;width:8px;height:0;top:0;left:-9999px;' + 'padding:0;margin-top:1px;position:absolute';
        container.appendChild(div);
        function computeStyleTests() {
            div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' + 'position:relative;display:block;' + 'margin:auto;border:1px;padding:1px;' + 'top:1%;width:50%';
            div.innerHTML = '';
            documentElement.appendChild(container);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== '1%';
            reliableMarginLeftVal = divStyle.marginLeft === '2px';
            boxSizingReliableVal = divStyle.width === '4px';
            div.style.marginRight = '50%';
            pixelMarginRightVal = divStyle.marginRight === '4px';
            documentElement.removeChild(container);
        }
        jQuery.extend(support, {
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function () {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelMarginRight: function () {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function () {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return reliableMarginLeftVal;
            },
            reliableMarginRight: function () {
                var ret, marginDiv = div.appendChild(document.createElement('div'));
                marginDiv.style.cssText = div.style.cssText = '-webkit-box-sizing:content-box;box-sizing:content-box;' + 'display:block;margin:0;border:0;padding:0';
                marginDiv.style.marginRight = marginDiv.style.width = '0';
                div.style.width = '1px';
                documentElement.appendChild(container);
                ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
                documentElement.removeChild(container);
                div.removeChild(marginDiv);
                return ret;
            }
        });
    }());
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
        if ((ret === '' || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
            ret = jQuery.style(elem, name);
        }
        if (computed) {
            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + '' : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400'
        }, cssPrefixes = [
            'Webkit',
            'O',
            'Moz',
            'ms'
        ], emptyStyle = document.createElement('div').style;
    function vendorPropName(name) {
        if (name in emptyStyle) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (document.msFullscreenElement && window.top !== window) {
            if (elem.getClientRects().length) {
                val = Math.round(elem.getBoundingClientRect()[name] * 100);
            }
        }
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = dataPriv.get(elem, 'olddisplay');
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === 'none') {
                    elem.style.display = '';
                }
                if (elem.style.display === '' && isHidden(elem)) {
                    values[index] = dataPriv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== 'none' || !hidden) {
                    dataPriv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                elem.style.display = show ? values[index] || '' : 'none';
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'animationIterationCount': true,
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': 'cssFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number') {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? '' : 'px');
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles);
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, 'marginLeft')) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
                return elem.getBoundingClientRect().left;
            })) + 'px';
        }
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            return swap(elem, { 'display': 'inline-block' }, curCSS, [
                elem,
                'marginRight'
            ]);
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: 'swing'
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = dataPriv.get(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            display = jQuery.css(elem, 'display');
            checkDisplay = display === 'none' ? dataPriv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
                style.display = 'inline-block';
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ('hidden' in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = dataPriv.access(elem, 'fxshow', {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                dataPriv.remove(elem, 'fxshow');
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                    }
                }
            }
        } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [
                            animation,
                            1,
                            0
                        ]);
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }]
        },
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.match(rnotwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [defaultPrefilter],
        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || dataPriv.get(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = dataPriv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function () {
        window.clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };
    (function () {
        var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
        input.type = 'checkbox';
        support.checkOn = input.value !== '';
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement('input');
        input.value = 't';
        input.type = 'radio';
        support.radioValue = input.value === 't';
    }());
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === 'undefined') {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + '');
                return value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return elem[name] = value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute('class') || '';
    }
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            if (typeof value === 'string' && value) {
                classes = value.match(rnotwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr('class', '');
            }
            if (typeof value === 'string' && value) {
                classes = value.match(rnotwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') > -1) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function () {
                var className, i, self, classNames;
                if (type === 'string') {
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === 'boolean') {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, '__className__', className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '');
                    }
                }
            });
        },
        hasClass: function (selector) {
            var className, elem, i = 0;
            className = ' ' + selector + ' ';
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (' ' + getClass(elem) + ' ').replace(rclass, ' ').indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    return jQuery.trim(elem.value);
                }
            },
            select: {
                get: function (elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') > -1) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.rnamespace = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function (type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    });
    jQuery.fn.extend({
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    support.focusin = 'onfocusin' in window;
    if (!support.focusin) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function (data) {
        return JSON.parse(data + '');
    };
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            xml = new window.DOMParser().parseFromString(data, 'text/xml');
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = '*/'.concat('*'), originAnchor = document.createElement('a');
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: 'GET',
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': jQuery.parseJSON,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || location.href) + '').replace(rhash, '').replace(rprotocol, location.protocol + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement('a');
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (state === 2) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, 'body')) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function (elem) {
        return !jQuery.expr.filters.visible(elem);
    };
    jQuery.expr.filters.visible = function (elem) {
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
            };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&').replace(r20, '+');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers['X-Requested-With']) {
                        headers['X-Requested-With'] = 'XMLHttpRequest';
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                                if (type === 'abort') {
                                    xhr.abort();
                                } else if (type === 'error') {
                                    if (typeof xhr.status !== 'number') {
                                        complete(0, 'error');
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string' ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback('error');
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback('abort');
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript' },
        contents: { script: /\b(?:java|ecma)script\b/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery('<script>').prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on('load error', callback = function (evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === 'error' ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument('').body;
        body.innerHTML = '<form></form><form></form>';
        return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        context = context || (support.createHTMLDocument ? document.implementation.createHTMLDocument('') : document);
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== 'string' && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(' ');
        if (off > -1) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || 'GET',
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(self, response || [
                        jqXHR.responseText,
                        status,
                        jqXHR
                    ]);
                });
            });
        }
        return this;
    };
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                    top: 0,
                    left: 0
                }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            box = elem.getBoundingClientRect();
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = 'pageYOffset' === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.extend({
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        },
        size: function () {
            return this.length;
        }
    });
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === 'function' && define.amd) {
        define('jquery@2.2.1#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*angular@1.4.10#angular*/
define('angular@1.4.10#angular', function (require, exports, module) {
    (function (global) {
        (function (window, document, undefined) {
            'use strict';
            function minErr(module, ErrorConstructor) {
                ErrorConstructor = ErrorConstructor || Error;
                return function () {
                    var SKIP_INDEXES = 2;
                    var templateArgs = arguments, code = templateArgs[0], message = '[' + (module ? module + ':' : '') + code + '] ', template = templateArgs[1], paramPrefix, i;
                    message += template.replace(/\{\d+\}/g, function (match) {
                        var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                        if (shiftedIndex < templateArgs.length) {
                            return toDebugString(templateArgs[shiftedIndex]);
                        }
                        return match;
                    });
                    message += '\nhttp://errors.angularjs.org/1.4.10/' + (module ? module + '/' : '') + code;
                    for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
                        message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
                    }
                    return new ErrorConstructor(message);
                };
            }
            var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
            var VALIDITY_STATE_PROPERTY = 'validity';
            var lowercase = function (string) {
                return isString(string) ? string.toLowerCase() : string;
            };
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var uppercase = function (string) {
                return isString(string) ? string.toUpperCase() : string;
            };
            var manualLowercase = function (s) {
                return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
                    return String.fromCharCode(ch.charCodeAt(0) | 32);
                }) : s;
            };
            var manualUppercase = function (s) {
                return isString(s) ? s.replace(/[a-z]/g, function (ch) {
                    return String.fromCharCode(ch.charCodeAt(0) & ~32);
                }) : s;
            };
            if ('i' !== 'I'.toLowerCase()) {
                lowercase = manualLowercase;
                uppercase = manualUppercase;
            }
            var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr('ng'), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
            msie = document.documentMode;
            function isArrayLike(obj) {
                if (obj == null || isWindow(obj))
                    return false;
                if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite)
                    return true;
                var length = 'length' in Object(obj) && obj.length;
                return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || typeof obj.item == 'function');
            }
            function forEach(obj, iterator, context) {
                var key, length;
                if (obj) {
                    if (isFunction(obj)) {
                        for (key in obj) {
                            if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    } else if (isArray(obj) || isArrayLike(obj)) {
                        var isPrimitive = typeof obj !== 'object';
                        for (key = 0, length = obj.length; key < length; key++) {
                            if (isPrimitive || key in obj) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    } else if (obj.forEach && obj.forEach !== forEach) {
                        obj.forEach(iterator, context, obj);
                    } else if (isBlankObject(obj)) {
                        for (key in obj) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    } else if (typeof obj.hasOwnProperty === 'function') {
                        for (key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    } else {
                        for (key in obj) {
                            if (hasOwnProperty.call(obj, key)) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    }
                }
                return obj;
            }
            function forEachSorted(obj, iterator, context) {
                var keys = Object.keys(obj).sort();
                for (var i = 0; i < keys.length; i++) {
                    iterator.call(context, obj[keys[i]], keys[i]);
                }
                return keys;
            }
            function reverseParams(iteratorFn) {
                return function (value, key) {
                    iteratorFn(key, value);
                };
            }
            function nextUid() {
                return ++uid;
            }
            function setHashKey(obj, h) {
                if (h) {
                    obj.$$hashKey = h;
                } else {
                    delete obj.$$hashKey;
                }
            }
            function baseExtend(dst, objs, deep) {
                var h = dst.$$hashKey;
                for (var i = 0, ii = objs.length; i < ii; ++i) {
                    var obj = objs[i];
                    if (!isObject(obj) && !isFunction(obj))
                        continue;
                    var keys = Object.keys(obj);
                    for (var j = 0, jj = keys.length; j < jj; j++) {
                        var key = keys[j];
                        var src = obj[key];
                        if (deep && isObject(src)) {
                            if (isDate(src)) {
                                dst[key] = new Date(src.valueOf());
                            } else if (isRegExp(src)) {
                                dst[key] = new RegExp(src);
                            } else if (src.nodeName) {
                                dst[key] = src.cloneNode(true);
                            } else if (isElement(src)) {
                                dst[key] = src.clone();
                            } else {
                                if (!isObject(dst[key]))
                                    dst[key] = isArray(src) ? [] : {};
                                baseExtend(dst[key], [src], true);
                            }
                        } else {
                            dst[key] = src;
                        }
                    }
                }
                setHashKey(dst, h);
                return dst;
            }
            function extend(dst) {
                return baseExtend(dst, slice.call(arguments, 1), false);
            }
            function merge(dst) {
                return baseExtend(dst, slice.call(arguments, 1), true);
            }
            function toInt(str) {
                return parseInt(str, 10);
            }
            function inherit(parent, extra) {
                return extend(Object.create(parent), extra);
            }
            function noop() {
            }
            noop.$inject = [];
            function identity($) {
                return $;
            }
            identity.$inject = [];
            function valueFn(value) {
                return function () {
                    return value;
                };
            }
            function hasCustomToString(obj) {
                return isFunction(obj.toString) && obj.toString !== toString;
            }
            function isUndefined(value) {
                return typeof value === 'undefined';
            }
            function isDefined(value) {
                return typeof value !== 'undefined';
            }
            function isObject(value) {
                return value !== null && typeof value === 'object';
            }
            function isBlankObject(value) {
                return value !== null && typeof value === 'object' && !getPrototypeOf(value);
            }
            function isString(value) {
                return typeof value === 'string';
            }
            function isNumber(value) {
                return typeof value === 'number';
            }
            function isDate(value) {
                return toString.call(value) === '[object Date]';
            }
            var isArray = Array.isArray;
            function isFunction(value) {
                return typeof value === 'function';
            }
            function isRegExp(value) {
                return toString.call(value) === '[object RegExp]';
            }
            function isWindow(obj) {
                return obj && obj.window === obj;
            }
            function isScope(obj) {
                return obj && obj.$evalAsync && obj.$watch;
            }
            function isFile(obj) {
                return toString.call(obj) === '[object File]';
            }
            function isFormData(obj) {
                return toString.call(obj) === '[object FormData]';
            }
            function isBlob(obj) {
                return toString.call(obj) === '[object Blob]';
            }
            function isBoolean(value) {
                return typeof value === 'boolean';
            }
            function isPromiseLike(obj) {
                return obj && isFunction(obj.then);
            }
            var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
            function isTypedArray(value) {
                return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
            }
            var trim = function (value) {
                return isString(value) ? value.trim() : value;
            };
            var escapeForRegexp = function (s) {
                return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
            };
            function isElement(node) {
                return !!(node && (node.nodeName || node.prop && node.attr && node.find));
            }
            function makeMap(str) {
                var obj = {}, items = str.split(','), i;
                for (i = 0; i < items.length; i++) {
                    obj[items[i]] = true;
                }
                return obj;
            }
            function nodeName_(element) {
                return lowercase(element.nodeName || element[0] && element[0].nodeName);
            }
            function includes(array, obj) {
                return Array.prototype.indexOf.call(array, obj) != -1;
            }
            function arrayRemove(array, value) {
                var index = array.indexOf(value);
                if (index >= 0) {
                    array.splice(index, 1);
                }
                return index;
            }
            function copy(source, destination) {
                var stackSource = [];
                var stackDest = [];
                if (destination) {
                    if (isTypedArray(destination)) {
                        throw ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot be mutated.');
                    }
                    if (source === destination) {
                        throw ngMinErr('cpi', 'Can\'t copy! Source and destination are identical.');
                    }
                    if (isArray(destination)) {
                        destination.length = 0;
                    } else {
                        forEach(destination, function (value, key) {
                            if (key !== '$$hashKey') {
                                delete destination[key];
                            }
                        });
                    }
                    stackSource.push(source);
                    stackDest.push(destination);
                    return copyRecurse(source, destination);
                }
                return copyElement(source);
                function copyRecurse(source, destination) {
                    var h = destination.$$hashKey;
                    var result, key;
                    if (isArray(source)) {
                        for (var i = 0, ii = source.length; i < ii; i++) {
                            destination.push(copyElement(source[i]));
                        }
                    } else if (isBlankObject(source)) {
                        for (key in source) {
                            destination[key] = copyElement(source[key]);
                        }
                    } else if (source && typeof source.hasOwnProperty === 'function') {
                        for (key in source) {
                            if (source.hasOwnProperty(key)) {
                                destination[key] = copyElement(source[key]);
                            }
                        }
                    } else {
                        for (key in source) {
                            if (hasOwnProperty.call(source, key)) {
                                destination[key] = copyElement(source[key]);
                            }
                        }
                    }
                    setHashKey(destination, h);
                    return destination;
                }
                function copyElement(source) {
                    if (!isObject(source)) {
                        return source;
                    }
                    var index = stackSource.indexOf(source);
                    if (index !== -1) {
                        return stackDest[index];
                    }
                    if (isWindow(source) || isScope(source)) {
                        throw ngMinErr('cpws', 'Can\'t copy! Making copies of Window or Scope instances is not supported.');
                    }
                    var needsRecurse = false;
                    var destination;
                    if (isArray(source)) {
                        destination = [];
                        needsRecurse = true;
                    } else if (isTypedArray(source)) {
                        destination = new source.constructor(source);
                    } else if (isDate(source)) {
                        destination = new Date(source.getTime());
                    } else if (isRegExp(source)) {
                        destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                        destination.lastIndex = source.lastIndex;
                    } else if (isBlob(source)) {
                        destination = new source.constructor([source], { type: source.type });
                    } else if (isFunction(source.cloneNode)) {
                        destination = source.cloneNode(true);
                    } else {
                        destination = Object.create(getPrototypeOf(source));
                        needsRecurse = true;
                    }
                    stackSource.push(source);
                    stackDest.push(destination);
                    return needsRecurse ? copyRecurse(source, destination) : destination;
                }
            }
            function shallowCopy(src, dst) {
                if (isArray(src)) {
                    dst = dst || [];
                    for (var i = 0, ii = src.length; i < ii; i++) {
                        dst[i] = src[i];
                    }
                } else if (isObject(src)) {
                    dst = dst || {};
                    for (var key in src) {
                        if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
                            dst[key] = src[key];
                        }
                    }
                }
                return dst || src;
            }
            function equals(o1, o2) {
                if (o1 === o2)
                    return true;
                if (o1 === null || o2 === null)
                    return false;
                if (o1 !== o1 && o2 !== o2)
                    return true;
                var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
                if (t1 == t2) {
                    if (t1 == 'object') {
                        if (isArray(o1)) {
                            if (!isArray(o2))
                                return false;
                            if ((length = o1.length) == o2.length) {
                                for (key = 0; key < length; key++) {
                                    if (!equals(o1[key], o2[key]))
                                        return false;
                                }
                                return true;
                            }
                        } else if (isDate(o1)) {
                            if (!isDate(o2))
                                return false;
                            return equals(o1.getTime(), o2.getTime());
                        } else if (isRegExp(o1)) {
                            return isRegExp(o2) ? o1.toString() == o2.toString() : false;
                        } else {
                            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                                return false;
                            keySet = createMap();
                            for (key in o1) {
                                if (key.charAt(0) === '$' || isFunction(o1[key]))
                                    continue;
                                if (!equals(o1[key], o2[key]))
                                    return false;
                                keySet[key] = true;
                            }
                            for (key in o2) {
                                if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                                    return false;
                            }
                            return true;
                        }
                    }
                }
                return false;
            }
            var csp = function () {
                if (!isDefined(csp.rules)) {
                    var ngCspElement = document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]');
                    if (ngCspElement) {
                        var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
                        csp.rules = {
                            noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf('no-unsafe-eval') !== -1,
                            noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf('no-inline-style') !== -1
                        };
                    } else {
                        csp.rules = {
                            noUnsafeEval: noUnsafeEval(),
                            noInlineStyle: false
                        };
                    }
                }
                return csp.rules;
                function noUnsafeEval() {
                    try {
                        new Function('');
                        return false;
                    } catch (e) {
                        return true;
                    }
                }
            };
            var jq = function () {
                if (isDefined(jq.name_))
                    return jq.name_;
                var el;
                var i, ii = ngAttrPrefixes.length, prefix, name;
                for (i = 0; i < ii; ++i) {
                    prefix = ngAttrPrefixes[i];
                    if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
                        name = el.getAttribute(prefix + 'jq');
                        break;
                    }
                }
                return jq.name_ = name;
            };
            function concat(array1, array2, index) {
                return array1.concat(slice.call(array2, index));
            }
            function sliceArgs(args, startIndex) {
                return slice.call(args, startIndex || 0);
            }
            function bind(self, fn) {
                var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
                if (isFunction(fn) && !(fn instanceof RegExp)) {
                    return curryArgs.length ? function () {
                        return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
                    } : function () {
                        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
                    };
                } else {
                    return fn;
                }
            }
            function toJsonReplacer(key, value) {
                var val = value;
                if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
                    val = undefined;
                } else if (isWindow(value)) {
                    val = '$WINDOW';
                } else if (value && document === value) {
                    val = '$DOCUMENT';
                } else if (isScope(value)) {
                    val = '$SCOPE';
                }
                return val;
            }
            function toJson(obj, pretty) {
                if (isUndefined(obj))
                    return undefined;
                if (!isNumber(pretty)) {
                    pretty = pretty ? 2 : null;
                }
                return JSON.stringify(obj, toJsonReplacer, pretty);
            }
            function fromJson(json) {
                return isString(json) ? JSON.parse(json) : json;
            }
            var ALL_COLONS = /:/g;
            function timezoneToOffset(timezone, fallback) {
                timezone = timezone.replace(ALL_COLONS, '');
                var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
                return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
            }
            function addDateMinutes(date, minutes) {
                date = new Date(date.getTime());
                date.setMinutes(date.getMinutes() + minutes);
                return date;
            }
            function convertTimezoneToLocal(date, timezone, reverse) {
                reverse = reverse ? -1 : 1;
                var dateTimezoneOffset = date.getTimezoneOffset();
                var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
            }
            function startingTag(element) {
                element = jqLite(element).clone();
                try {
                    element.empty();
                } catch (e) {
                }
                var elemHtml = jqLite('<div>').append(element).html();
                try {
                    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
                        return '<' + lowercase(nodeName);
                    });
                } catch (e) {
                    return lowercase(elemHtml);
                }
            }
            function tryDecodeURIComponent(value) {
                try {
                    return decodeURIComponent(value);
                } catch (e) {
                }
            }
            function parseKeyValue(keyValue) {
                var obj = {};
                forEach((keyValue || '').split('&'), function (keyValue) {
                    var splitPoint, key, val;
                    if (keyValue) {
                        key = keyValue = keyValue.replace(/\+/g, '%20');
                        splitPoint = keyValue.indexOf('=');
                        if (splitPoint !== -1) {
                            key = keyValue.substring(0, splitPoint);
                            val = keyValue.substring(splitPoint + 1);
                        }
                        key = tryDecodeURIComponent(key);
                        if (isDefined(key)) {
                            val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                            if (!hasOwnProperty.call(obj, key)) {
                                obj[key] = val;
                            } else if (isArray(obj[key])) {
                                obj[key].push(val);
                            } else {
                                obj[key] = [
                                    obj[key],
                                    val
                                ];
                            }
                        }
                    }
                });
                return obj;
            }
            function toKeyValue(obj) {
                var parts = [];
                forEach(obj, function (value, key) {
                    if (isArray(value)) {
                        forEach(value, function (arrayValue) {
                            parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
                        });
                    } else {
                        parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
                    }
                });
                return parts.length ? parts.join('&') : '';
            }
            function encodeUriSegment(val) {
                return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
            }
            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
            }
            var ngAttrPrefixes = [
                'ng-',
                'data-ng-',
                'ng:',
                'x-ng-'
            ];
            function getNgAttribute(element, ngAttr) {
                var attr, i, ii = ngAttrPrefixes.length;
                for (i = 0; i < ii; ++i) {
                    attr = ngAttrPrefixes[i] + ngAttr;
                    if (isString(attr = element.getAttribute(attr))) {
                        return attr;
                    }
                }
                return null;
            }
            function angularInit(element, bootstrap) {
                var appElement, module, config = {};
                forEach(ngAttrPrefixes, function (prefix) {
                    var name = prefix + 'app';
                    if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                        appElement = element;
                        module = element.getAttribute(name);
                    }
                });
                forEach(ngAttrPrefixes, function (prefix) {
                    var name = prefix + 'app';
                    var candidate;
                    if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
                        appElement = candidate;
                        module = candidate.getAttribute(name);
                    }
                });
                if (appElement) {
                    config.strictDi = getNgAttribute(appElement, 'strict-di') !== null;
                    bootstrap(appElement, module ? [module] : [], config);
                }
            }
            function bootstrap(element, modules, config) {
                if (!isObject(config))
                    config = {};
                var defaultConfig = { strictDi: false };
                config = extend(defaultConfig, config);
                var doBootstrap = function () {
                    element = jqLite(element);
                    if (element.injector()) {
                        var tag = element[0] === document ? 'document' : startingTag(element);
                        throw ngMinErr('btstrpd', 'App Already Bootstrapped with this Element \'{0}\'', tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
                    }
                    modules = modules || [];
                    modules.unshift([
                        '$provide',
                        function ($provide) {
                            $provide.value('$rootElement', element);
                        }
                    ]);
                    if (config.debugInfoEnabled) {
                        modules.push([
                            '$compileProvider',
                            function ($compileProvider) {
                                $compileProvider.debugInfoEnabled(true);
                            }
                        ]);
                    }
                    modules.unshift('ng');
                    var injector = createInjector(modules, config.strictDi);
                    injector.invoke([
                        '$rootScope',
                        '$rootElement',
                        '$compile',
                        '$injector',
                        function bootstrapApply(scope, element, compile, injector) {
                            scope.$apply(function () {
                                element.data('$injector', injector);
                                compile(element)(scope);
                            });
                        }
                    ]);
                    return injector;
                };
                var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
                var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
                if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
                    config.debugInfoEnabled = true;
                    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
                }
                if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
                    return doBootstrap();
                }
                window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
                angular.resumeBootstrap = function (extraModules) {
                    forEach(extraModules, function (module) {
                        modules.push(module);
                    });
                    return doBootstrap();
                };
                if (isFunction(angular.resumeDeferredBootstrap)) {
                    angular.resumeDeferredBootstrap();
                }
            }
            function reloadWithDebugInfo() {
                window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
                window.location.reload();
            }
            function getTestability(rootElement) {
                var injector = angular.element(rootElement).injector();
                if (!injector) {
                    throw ngMinErr('test', 'no injector found for element argument to getTestability');
                }
                return injector.get('$$testability');
            }
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            function snake_case(name, separator) {
                separator = separator || '_';
                return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                    return (pos ? separator : '') + letter.toLowerCase();
                });
            }
            var bindJQueryFired = false;
            var skipDestroyOnNextJQueryCleanData;
            function bindJQuery() {
                var originalCleanData;
                if (bindJQueryFired) {
                    return;
                }
                var jqName = jq();
                jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
                if (jQuery && jQuery.fn.on) {
                    jqLite = jQuery;
                    extend(jQuery.fn, {
                        scope: JQLitePrototype.scope,
                        isolateScope: JQLitePrototype.isolateScope,
                        controller: JQLitePrototype.controller,
                        injector: JQLitePrototype.injector,
                        inheritedData: JQLitePrototype.inheritedData
                    });
                    originalCleanData = jQuery.cleanData;
                    jQuery.cleanData = function (elems) {
                        var events;
                        if (!skipDestroyOnNextJQueryCleanData) {
                            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                                events = jQuery._data(elem, 'events');
                                if (events && events.$destroy) {
                                    jQuery(elem).triggerHandler('$destroy');
                                }
                            }
                        } else {
                            skipDestroyOnNextJQueryCleanData = false;
                        }
                        originalCleanData(elems);
                    };
                } else {
                    jqLite = JQLite;
                }
                angular.element = jqLite;
                bindJQueryFired = true;
            }
            function assertArg(arg, name, reason) {
                if (!arg) {
                    throw ngMinErr('areq', 'Argument \'{0}\' is {1}', name || '?', reason || 'required');
                }
                return arg;
            }
            function assertArgFn(arg, name, acceptArrayAnnotation) {
                if (acceptArrayAnnotation && isArray(arg)) {
                    arg = arg[arg.length - 1];
                }
                assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
                return arg;
            }
            function assertNotHasOwnProperty(name, context) {
                if (name === 'hasOwnProperty') {
                    throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
                }
            }
            function getter(obj, path, bindFnToScope) {
                if (!path)
                    return obj;
                var keys = path.split('.');
                var key;
                var lastInstance = obj;
                var len = keys.length;
                for (var i = 0; i < len; i++) {
                    key = keys[i];
                    if (obj) {
                        obj = (lastInstance = obj)[key];
                    }
                }
                if (!bindFnToScope && isFunction(obj)) {
                    return bind(lastInstance, obj);
                }
                return obj;
            }
            function getBlockNodes(nodes) {
                var node = nodes[0];
                var endNode = nodes[nodes.length - 1];
                var blockNodes;
                for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
                    if (blockNodes || nodes[i] !== node) {
                        if (!blockNodes) {
                            blockNodes = jqLite(slice.call(nodes, 0, i));
                        }
                        blockNodes.push(node);
                    }
                }
                return blockNodes || nodes;
            }
            function createMap() {
                return Object.create(null);
            }
            var NODE_TYPE_ELEMENT = 1;
            var NODE_TYPE_ATTRIBUTE = 2;
            var NODE_TYPE_TEXT = 3;
            var NODE_TYPE_COMMENT = 8;
            var NODE_TYPE_DOCUMENT = 9;
            var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
            function setupModuleLoader(window) {
                var $injectorMinErr = minErr('$injector');
                var ngMinErr = minErr('ng');
                function ensure(obj, name, factory) {
                    return obj[name] || (obj[name] = factory());
                }
                var angular = ensure(window, 'angular', Object);
                angular.$$minErr = angular.$$minErr || minErr;
                return ensure(angular, 'module', function () {
                    var modules = {};
                    return function module(name, requires, configFn) {
                        var assertNotHasOwnProperty = function (name, context) {
                            if (name === 'hasOwnProperty') {
                                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
                            }
                        };
                        assertNotHasOwnProperty(name, 'module');
                        if (requires && modules.hasOwnProperty(name)) {
                            modules[name] = null;
                        }
                        return ensure(modules, name, function () {
                            if (!requires) {
                                throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
                            }
                            var invokeQueue = [];
                            var configBlocks = [];
                            var runBlocks = [];
                            var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
                            var moduleInstance = {
                                _invokeQueue: invokeQueue,
                                _configBlocks: configBlocks,
                                _runBlocks: runBlocks,
                                requires: requires,
                                name: name,
                                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                                service: invokeLaterAndSetModuleName('$provide', 'service'),
                                value: invokeLater('$provide', 'value'),
                                constant: invokeLater('$provide', 'constant', 'unshift'),
                                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                                config: config,
                                run: function (block) {
                                    runBlocks.push(block);
                                    return this;
                                }
                            };
                            if (configFn) {
                                config(configFn);
                            }
                            return moduleInstance;
                            function invokeLater(provider, method, insertMethod, queue) {
                                if (!queue)
                                    queue = invokeQueue;
                                return function () {
                                    queue[insertMethod || 'push']([
                                        provider,
                                        method,
                                        arguments
                                    ]);
                                    return moduleInstance;
                                };
                            }
                            function invokeLaterAndSetModuleName(provider, method) {
                                return function (recipeName, factoryFunction) {
                                    if (factoryFunction && isFunction(factoryFunction))
                                        factoryFunction.$$moduleName = name;
                                    invokeQueue.push([
                                        provider,
                                        method,
                                        arguments
                                    ]);
                                    return moduleInstance;
                                };
                            }
                        });
                    };
                });
            }
            function serializeObject(obj) {
                var seen = [];
                return JSON.stringify(obj, function (key, val) {
                    val = toJsonReplacer(key, val);
                    if (isObject(val)) {
                        if (seen.indexOf(val) >= 0)
                            return '...';
                        seen.push(val);
                    }
                    return val;
                });
            }
            function toDebugString(obj) {
                if (typeof obj === 'function') {
                    return obj.toString().replace(/ \{[\s\S]*$/, '');
                } else if (isUndefined(obj)) {
                    return 'undefined';
                } else if (typeof obj !== 'string') {
                    return serializeObject(obj);
                }
                return obj;
            }
            var version = {
                full: '1.4.10',
                major: 1,
                minor: 4,
                dot: 10,
                codeName: 'benignant-oscillation'
            };
            function publishExternalAPI(angular) {
                extend(angular, {
                    'bootstrap': bootstrap,
                    'copy': copy,
                    'extend': extend,
                    'merge': merge,
                    'equals': equals,
                    'element': jqLite,
                    'forEach': forEach,
                    'injector': createInjector,
                    'noop': noop,
                    'bind': bind,
                    'toJson': toJson,
                    'fromJson': fromJson,
                    'identity': identity,
                    'isUndefined': isUndefined,
                    'isDefined': isDefined,
                    'isString': isString,
                    'isFunction': isFunction,
                    'isObject': isObject,
                    'isNumber': isNumber,
                    'isElement': isElement,
                    'isArray': isArray,
                    'version': version,
                    'isDate': isDate,
                    'lowercase': lowercase,
                    'uppercase': uppercase,
                    'callbacks': { counter: 0 },
                    'getTestability': getTestability,
                    '$$minErr': minErr,
                    '$$csp': csp,
                    'reloadWithDebugInfo': reloadWithDebugInfo
                });
                angularModule = setupModuleLoader(window);
                angularModule('ng', ['ngLocale'], [
                    '$provide',
                    function ngModule($provide) {
                        $provide.provider({ $$sanitizeUri: $$SanitizeUriProvider });
                        $provide.provider('$compile', $CompileProvider).directive({
                            a: htmlAnchorDirective,
                            input: inputDirective,
                            textarea: inputDirective,
                            form: formDirective,
                            script: scriptDirective,
                            select: selectDirective,
                            style: styleDirective,
                            option: optionDirective,
                            ngBind: ngBindDirective,
                            ngBindHtml: ngBindHtmlDirective,
                            ngBindTemplate: ngBindTemplateDirective,
                            ngClass: ngClassDirective,
                            ngClassEven: ngClassEvenDirective,
                            ngClassOdd: ngClassOddDirective,
                            ngCloak: ngCloakDirective,
                            ngController: ngControllerDirective,
                            ngForm: ngFormDirective,
                            ngHide: ngHideDirective,
                            ngIf: ngIfDirective,
                            ngInclude: ngIncludeDirective,
                            ngInit: ngInitDirective,
                            ngNonBindable: ngNonBindableDirective,
                            ngPluralize: ngPluralizeDirective,
                            ngRepeat: ngRepeatDirective,
                            ngShow: ngShowDirective,
                            ngStyle: ngStyleDirective,
                            ngSwitch: ngSwitchDirective,
                            ngSwitchWhen: ngSwitchWhenDirective,
                            ngSwitchDefault: ngSwitchDefaultDirective,
                            ngOptions: ngOptionsDirective,
                            ngTransclude: ngTranscludeDirective,
                            ngModel: ngModelDirective,
                            ngList: ngListDirective,
                            ngChange: ngChangeDirective,
                            pattern: patternDirective,
                            ngPattern: patternDirective,
                            required: requiredDirective,
                            ngRequired: requiredDirective,
                            minlength: minlengthDirective,
                            ngMinlength: minlengthDirective,
                            maxlength: maxlengthDirective,
                            ngMaxlength: maxlengthDirective,
                            ngValue: ngValueDirective,
                            ngModelOptions: ngModelOptionsDirective
                        }).directive({ ngInclude: ngIncludeFillContentDirective }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
                        $provide.provider({
                            $anchorScroll: $AnchorScrollProvider,
                            $animate: $AnimateProvider,
                            $animateCss: $CoreAnimateCssProvider,
                            $$animateJs: $$CoreAnimateJsProvider,
                            $$animateQueue: $$CoreAnimateQueueProvider,
                            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                            $browser: $BrowserProvider,
                            $cacheFactory: $CacheFactoryProvider,
                            $controller: $ControllerProvider,
                            $document: $DocumentProvider,
                            $exceptionHandler: $ExceptionHandlerProvider,
                            $filter: $FilterProvider,
                            $$forceReflow: $$ForceReflowProvider,
                            $interpolate: $InterpolateProvider,
                            $interval: $IntervalProvider,
                            $http: $HttpProvider,
                            $httpParamSerializer: $HttpParamSerializerProvider,
                            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                            $httpBackend: $HttpBackendProvider,
                            $xhrFactory: $xhrFactoryProvider,
                            $location: $LocationProvider,
                            $log: $LogProvider,
                            $parse: $ParseProvider,
                            $rootScope: $RootScopeProvider,
                            $q: $QProvider,
                            $$q: $$QProvider,
                            $sce: $SceProvider,
                            $sceDelegate: $SceDelegateProvider,
                            $sniffer: $SnifferProvider,
                            $templateCache: $TemplateCacheProvider,
                            $templateRequest: $TemplateRequestProvider,
                            $$testability: $$TestabilityProvider,
                            $timeout: $TimeoutProvider,
                            $window: $WindowProvider,
                            $$rAF: $$RAFProvider,
                            $$jqLite: $$jqLiteProvider,
                            $$HashMap: $$HashMapProvider,
                            $$cookieReader: $$CookieReaderProvider
                        });
                    }
                ]);
            }
            JQLite.expando = 'ng339';
            var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function (element, type, fn) {
                    element.addEventListener(type, fn, false);
                }, removeEventListenerFn = function (element, type, fn) {
                    element.removeEventListener(type, fn, false);
                };
            JQLite._data = function (node) {
                return this.cache[node[this.expando]] || {};
            };
            function jqNextId() {
                return ++jqId;
            }
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var MOZ_HACK_REGEXP = /^moz([A-Z])/;
            var MOUSE_EVENT_MAP = {
                mouseleave: 'mouseout',
                mouseenter: 'mouseover'
            };
            var jqLiteMinErr = minErr('jqLite');
            function camelCase(name) {
                return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
                    return offset ? letter.toUpperCase() : letter;
                }).replace(MOZ_HACK_REGEXP, 'Moz$1');
            }
            var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
            var HTML_REGEXP = /<|&#?\w+;/;
            var TAG_NAME_REGEXP = /<([\w:-]+)/;
            var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
            var wrapMap = {
                'option': [
                    1,
                    '<select multiple="multiple">',
                    '</select>'
                ],
                'thead': [
                    1,
                    '<table>',
                    '</table>'
                ],
                'col': [
                    2,
                    '<table><colgroup>',
                    '</colgroup></table>'
                ],
                'tr': [
                    2,
                    '<table><tbody>',
                    '</tbody></table>'
                ],
                'td': [
                    3,
                    '<table><tbody><tr>',
                    '</tr></tbody></table>'
                ],
                '_default': [
                    0,
                    '',
                    ''
                ]
            };
            wrapMap.optgroup = wrapMap.option;
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;
            function jqLiteIsTextNode(html) {
                return !HTML_REGEXP.test(html);
            }
            function jqLiteAcceptsData(node) {
                var nodeType = node.nodeType;
                return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
            }
            function jqLiteHasData(node) {
                for (var key in jqCache[node.ng339]) {
                    return true;
                }
                return false;
            }
            function jqLiteBuildFragment(html, context) {
                var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
                if (jqLiteIsTextNode(html)) {
                    nodes.push(context.createTextNode(html));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement('div'));
                    tag = (TAG_NAME_REGEXP.exec(html) || [
                        '',
                        ''
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, '<$1></$2>') + wrap[2];
                    i = wrap[0];
                    while (i--) {
                        tmp = tmp.lastChild;
                    }
                    nodes = concat(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = '';
                }
                fragment.textContent = '';
                fragment.innerHTML = '';
                forEach(nodes, function (node) {
                    fragment.appendChild(node);
                });
                return fragment;
            }
            function jqLiteParseHTML(html, context) {
                context = context || document;
                var parsed;
                if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
                    return [context.createElement(parsed[1])];
                }
                if (parsed = jqLiteBuildFragment(html, context)) {
                    return parsed.childNodes;
                }
                return [];
            }
            function jqLiteWrapNode(node, wrapper) {
                var parent = node.parentNode;
                if (parent) {
                    parent.replaceChild(wrapper, node);
                }
                wrapper.appendChild(node);
            }
            var jqLiteContains = Node.prototype.contains || function (arg) {
                return !!(this.compareDocumentPosition(arg) & 16);
            };
            function JQLite(element) {
                if (element instanceof JQLite) {
                    return element;
                }
                var argIsString;
                if (isString(element)) {
                    element = trim(element);
                    argIsString = true;
                }
                if (!(this instanceof JQLite)) {
                    if (argIsString && element.charAt(0) != '<') {
                        throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
                    }
                    return new JQLite(element);
                }
                if (argIsString) {
                    jqLiteAddNodes(this, jqLiteParseHTML(element));
                } else {
                    jqLiteAddNodes(this, element);
                }
            }
            function jqLiteClone(element) {
                return element.cloneNode(true);
            }
            function jqLiteDealoc(element, onlyDescendants) {
                if (!onlyDescendants)
                    jqLiteRemoveData(element);
                if (element.querySelectorAll) {
                    var descendants = element.querySelectorAll('*');
                    for (var i = 0, l = descendants.length; i < l; i++) {
                        jqLiteRemoveData(descendants[i]);
                    }
                }
            }
            function jqLiteOff(element, type, fn, unsupported) {
                if (isDefined(unsupported))
                    throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
                var expandoStore = jqLiteExpandoStore(element);
                var events = expandoStore && expandoStore.events;
                var handle = expandoStore && expandoStore.handle;
                if (!handle)
                    return;
                if (!type) {
                    for (type in events) {
                        if (type !== '$destroy') {
                            removeEventListenerFn(element, type, handle);
                        }
                        delete events[type];
                    }
                } else {
                    var removeHandler = function (type) {
                        var listenerFns = events[type];
                        if (isDefined(fn)) {
                            arrayRemove(listenerFns || [], fn);
                        }
                        if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                            removeEventListenerFn(element, type, handle);
                            delete events[type];
                        }
                    };
                    forEach(type.split(' '), function (type) {
                        removeHandler(type);
                        if (MOUSE_EVENT_MAP[type]) {
                            removeHandler(MOUSE_EVENT_MAP[type]);
                        }
                    });
                }
            }
            function jqLiteRemoveData(element, name) {
                var expandoId = element.ng339;
                var expandoStore = expandoId && jqCache[expandoId];
                if (expandoStore) {
                    if (name) {
                        delete expandoStore.data[name];
                        return;
                    }
                    if (expandoStore.handle) {
                        if (expandoStore.events.$destroy) {
                            expandoStore.handle({}, '$destroy');
                        }
                        jqLiteOff(element);
                    }
                    delete jqCache[expandoId];
                    element.ng339 = undefined;
                }
            }
            function jqLiteExpandoStore(element, createIfNecessary) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
                if (createIfNecessary && !expandoStore) {
                    element.ng339 = expandoId = jqNextId();
                    expandoStore = jqCache[expandoId] = {
                        events: {},
                        data: {},
                        handle: undefined
                    };
                }
                return expandoStore;
            }
            function jqLiteData(element, key, value) {
                if (jqLiteAcceptsData(element)) {
                    var isSimpleSetter = isDefined(value);
                    var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
                    var massGetter = !key;
                    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
                    var data = expandoStore && expandoStore.data;
                    if (isSimpleSetter) {
                        data[key] = value;
                    } else {
                        if (massGetter) {
                            return data;
                        } else {
                            if (isSimpleGetter) {
                                return data && data[key];
                            } else {
                                extend(data, key);
                            }
                        }
                    }
                }
            }
            function jqLiteHasClass(element, selector) {
                if (!element.getAttribute)
                    return false;
                return (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
            }
            function jqLiteRemoveClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    forEach(cssClasses.split(' '), function (cssClass) {
                        element.setAttribute('class', trim((' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' ')));
                    });
                }
            }
            function jqLiteAddClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ');
                    forEach(cssClasses.split(' '), function (cssClass) {
                        cssClass = trim(cssClass);
                        if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                            existingClasses += cssClass + ' ';
                        }
                    });
                    element.setAttribute('class', trim(existingClasses));
                }
            }
            function jqLiteAddNodes(root, elements) {
                if (elements) {
                    if (elements.nodeType) {
                        root[root.length++] = elements;
                    } else {
                        var length = elements.length;
                        if (typeof length === 'number' && elements.window !== elements) {
                            if (length) {
                                for (var i = 0; i < length; i++) {
                                    root[root.length++] = elements[i];
                                }
                            }
                        } else {
                            root[root.length++] = elements;
                        }
                    }
                }
            }
            function jqLiteController(element, name) {
                return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
            }
            function jqLiteInheritedData(element, name, value) {
                if (element.nodeType == NODE_TYPE_DOCUMENT) {
                    element = element.documentElement;
                }
                var names = isArray(name) ? name : [name];
                while (element) {
                    for (var i = 0, ii = names.length; i < ii; i++) {
                        if (isDefined(value = jqLite.data(element, names[i])))
                            return value;
                    }
                    element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
                }
            }
            function jqLiteEmpty(element) {
                jqLiteDealoc(element, true);
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }
            }
            function jqLiteRemove(element, keepData) {
                if (!keepData)
                    jqLiteDealoc(element);
                var parent = element.parentNode;
                if (parent)
                    parent.removeChild(element);
            }
            function jqLiteDocumentLoaded(action, win) {
                win = win || window;
                if (win.document.readyState === 'complete') {
                    win.setTimeout(action);
                } else {
                    jqLite(win).on('load', action);
                }
            }
            var JQLitePrototype = JQLite.prototype = {
                ready: function (fn) {
                    var fired = false;
                    function trigger() {
                        if (fired)
                            return;
                        fired = true;
                        fn();
                    }
                    if (document.readyState === 'complete') {
                        setTimeout(trigger);
                    } else {
                        this.on('DOMContentLoaded', trigger);
                        JQLite(window).on('load', trigger);
                    }
                },
                toString: function () {
                    var value = [];
                    forEach(this, function (e) {
                        value.push('' + e);
                    });
                    return '[' + value.join(', ') + ']';
                },
                eq: function (index) {
                    return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
                },
                length: 0,
                push: push,
                sort: [].sort,
                splice: [].splice
            };
            var BOOLEAN_ATTR = {};
            forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function (value) {
                BOOLEAN_ATTR[lowercase(value)] = value;
            });
            var BOOLEAN_ELEMENTS = {};
            forEach('input,select,option,textarea,button,form,details'.split(','), function (value) {
                BOOLEAN_ELEMENTS[value] = true;
            });
            var ALIASED_ATTR = {
                'ngMinlength': 'minlength',
                'ngMaxlength': 'maxlength',
                'ngMin': 'min',
                'ngMax': 'max',
                'ngPattern': 'pattern'
            };
            function getBooleanAttrName(element, name) {
                var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
                return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
            }
            function getAliasedAttrName(name) {
                return ALIASED_ATTR[name];
            }
            forEach({
                data: jqLiteData,
                removeData: jqLiteRemoveData,
                hasData: jqLiteHasData
            }, function (fn, name) {
                JQLite[name] = fn;
            });
            forEach({
                data: jqLiteData,
                inheritedData: jqLiteInheritedData,
                scope: function (element) {
                    return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, [
                        '$isolateScope',
                        '$scope'
                    ]);
                },
                isolateScope: function (element) {
                    return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
                },
                controller: jqLiteController,
                injector: function (element) {
                    return jqLiteInheritedData(element, '$injector');
                },
                removeAttr: function (element, name) {
                    element.removeAttribute(name);
                },
                hasClass: jqLiteHasClass,
                css: function (element, name, value) {
                    name = camelCase(name);
                    if (isDefined(value)) {
                        element.style[name] = value;
                    } else {
                        return element.style[name];
                    }
                },
                attr: function (element, name, value) {
                    var nodeType = element.nodeType;
                    if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
                        return;
                    }
                    var lowercasedName = lowercase(name);
                    if (BOOLEAN_ATTR[lowercasedName]) {
                        if (isDefined(value)) {
                            if (!!value) {
                                element[name] = true;
                                element.setAttribute(name, lowercasedName);
                            } else {
                                element[name] = false;
                                element.removeAttribute(lowercasedName);
                            }
                        } else {
                            return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                        }
                    } else if (isDefined(value)) {
                        element.setAttribute(name, value);
                    } else if (element.getAttribute) {
                        var ret = element.getAttribute(name, 2);
                        return ret === null ? undefined : ret;
                    }
                },
                prop: function (element, name, value) {
                    if (isDefined(value)) {
                        element[name] = value;
                    } else {
                        return element[name];
                    }
                },
                text: function () {
                    getText.$dv = '';
                    return getText;
                    function getText(element, value) {
                        if (isUndefined(value)) {
                            var nodeType = element.nodeType;
                            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : '';
                        }
                        element.textContent = value;
                    }
                }(),
                val: function (element, value) {
                    if (isUndefined(value)) {
                        if (element.multiple && nodeName_(element) === 'select') {
                            var result = [];
                            forEach(element.options, function (option) {
                                if (option.selected) {
                                    result.push(option.value || option.text);
                                }
                            });
                            return result.length === 0 ? null : result;
                        }
                        return element.value;
                    }
                    element.value = value;
                },
                html: function (element, value) {
                    if (isUndefined(value)) {
                        return element.innerHTML;
                    }
                    jqLiteDealoc(element, true);
                    element.innerHTML = value;
                },
                empty: jqLiteEmpty
            }, function (fn, name) {
                JQLite.prototype[name] = function (arg1, arg2) {
                    var i, key;
                    var nodeCount = this.length;
                    if (fn !== jqLiteEmpty && isUndefined(fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
                        if (isObject(arg1)) {
                            for (i = 0; i < nodeCount; i++) {
                                if (fn === jqLiteData) {
                                    fn(this[i], arg1);
                                } else {
                                    for (key in arg1) {
                                        fn(this[i], key, arg1[key]);
                                    }
                                }
                            }
                            return this;
                        } else {
                            var value = fn.$dv;
                            var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                            for (var j = 0; j < jj; j++) {
                                var nodeValue = fn(this[j], arg1, arg2);
                                value = value ? value + nodeValue : nodeValue;
                            }
                            return value;
                        }
                    } else {
                        for (i = 0; i < nodeCount; i++) {
                            fn(this[i], arg1, arg2);
                        }
                        return this;
                    }
                };
            });
            function createEventHandler(element, events) {
                var eventHandler = function (event, type) {
                    event.isDefaultPrevented = function () {
                        return event.defaultPrevented;
                    };
                    var eventFns = events[type || event.type];
                    var eventFnsLength = eventFns ? eventFns.length : 0;
                    if (!eventFnsLength)
                        return;
                    if (isUndefined(event.immediatePropagationStopped)) {
                        var originalStopImmediatePropagation = event.stopImmediatePropagation;
                        event.stopImmediatePropagation = function () {
                            event.immediatePropagationStopped = true;
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            }
                            if (originalStopImmediatePropagation) {
                                originalStopImmediatePropagation.call(event);
                            }
                        };
                    }
                    event.isImmediatePropagationStopped = function () {
                        return event.immediatePropagationStopped === true;
                    };
                    var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                    if (eventFnsLength > 1) {
                        eventFns = shallowCopy(eventFns);
                    }
                    for (var i = 0; i < eventFnsLength; i++) {
                        if (!event.isImmediatePropagationStopped()) {
                            handlerWrapper(element, event, eventFns[i]);
                        }
                    }
                };
                eventHandler.elem = element;
                return eventHandler;
            }
            function defaultHandlerWrapper(element, event, handler) {
                handler.call(element, event);
            }
            function specialMouseHandlerWrapper(target, event, handler) {
                var related = event.relatedTarget;
                if (!related || related !== target && !jqLiteContains.call(target, related)) {
                    handler.call(target, event);
                }
            }
            forEach({
                removeData: jqLiteRemoveData,
                on: function jqLiteOn(element, type, fn, unsupported) {
                    if (isDefined(unsupported))
                        throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
                    if (!jqLiteAcceptsData(element)) {
                        return;
                    }
                    var expandoStore = jqLiteExpandoStore(element, true);
                    var events = expandoStore.events;
                    var handle = expandoStore.handle;
                    if (!handle) {
                        handle = expandoStore.handle = createEventHandler(element, events);
                    }
                    var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
                    var i = types.length;
                    var addHandler = function (type, specialHandlerWrapper, noEventListener) {
                        var eventFns = events[type];
                        if (!eventFns) {
                            eventFns = events[type] = [];
                            eventFns.specialHandlerWrapper = specialHandlerWrapper;
                            if (type !== '$destroy' && !noEventListener) {
                                addEventListenerFn(element, type, handle);
                            }
                        }
                        eventFns.push(fn);
                    };
                    while (i--) {
                        type = types[i];
                        if (MOUSE_EVENT_MAP[type]) {
                            addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                            addHandler(type, undefined, true);
                        } else {
                            addHandler(type);
                        }
                    }
                },
                off: jqLiteOff,
                one: function (element, type, fn) {
                    element = jqLite(element);
                    element.on(type, function onFn() {
                        element.off(type, fn);
                        element.off(type, onFn);
                    });
                    element.on(type, fn);
                },
                replaceWith: function (element, replaceNode) {
                    var index, parent = element.parentNode;
                    jqLiteDealoc(element);
                    forEach(new JQLite(replaceNode), function (node) {
                        if (index) {
                            parent.insertBefore(node, index.nextSibling);
                        } else {
                            parent.replaceChild(node, element);
                        }
                        index = node;
                    });
                },
                children: function (element) {
                    var children = [];
                    forEach(element.childNodes, function (element) {
                        if (element.nodeType === NODE_TYPE_ELEMENT) {
                            children.push(element);
                        }
                    });
                    return children;
                },
                contents: function (element) {
                    return element.contentDocument || element.childNodes || [];
                },
                append: function (element, node) {
                    var nodeType = element.nodeType;
                    if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
                        return;
                    node = new JQLite(node);
                    for (var i = 0, ii = node.length; i < ii; i++) {
                        var child = node[i];
                        element.appendChild(child);
                    }
                },
                prepend: function (element, node) {
                    if (element.nodeType === NODE_TYPE_ELEMENT) {
                        var index = element.firstChild;
                        forEach(new JQLite(node), function (child) {
                            element.insertBefore(child, index);
                        });
                    }
                },
                wrap: function (element, wrapNode) {
                    jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
                },
                remove: jqLiteRemove,
                detach: function (element) {
                    jqLiteRemove(element, true);
                },
                after: function (element, newElement) {
                    var index = element, parent = element.parentNode;
                    newElement = new JQLite(newElement);
                    for (var i = 0, ii = newElement.length; i < ii; i++) {
                        var node = newElement[i];
                        parent.insertBefore(node, index.nextSibling);
                        index = node;
                    }
                },
                addClass: jqLiteAddClass,
                removeClass: jqLiteRemoveClass,
                toggleClass: function (element, selector, condition) {
                    if (selector) {
                        forEach(selector.split(' '), function (className) {
                            var classCondition = condition;
                            if (isUndefined(classCondition)) {
                                classCondition = !jqLiteHasClass(element, className);
                            }
                            (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                        });
                    }
                },
                parent: function (element) {
                    var parent = element.parentNode;
                    return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
                },
                next: function (element) {
                    return element.nextElementSibling;
                },
                find: function (element, selector) {
                    if (element.getElementsByTagName) {
                        return element.getElementsByTagName(selector);
                    } else {
                        return [];
                    }
                },
                clone: jqLiteClone,
                triggerHandler: function (element, event, extraParameters) {
                    var dummyEvent, eventFnsCopy, handlerArgs;
                    var eventName = event.type || event;
                    var expandoStore = jqLiteExpandoStore(element);
                    var events = expandoStore && expandoStore.events;
                    var eventFns = events && events[eventName];
                    if (eventFns) {
                        dummyEvent = {
                            preventDefault: function () {
                                this.defaultPrevented = true;
                            },
                            isDefaultPrevented: function () {
                                return this.defaultPrevented === true;
                            },
                            stopImmediatePropagation: function () {
                                this.immediatePropagationStopped = true;
                            },
                            isImmediatePropagationStopped: function () {
                                return this.immediatePropagationStopped === true;
                            },
                            stopPropagation: noop,
                            type: eventName,
                            target: element
                        };
                        if (event.type) {
                            dummyEvent = extend(dummyEvent, event);
                        }
                        eventFnsCopy = shallowCopy(eventFns);
                        handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
                        forEach(eventFnsCopy, function (fn) {
                            if (!dummyEvent.isImmediatePropagationStopped()) {
                                fn.apply(element, handlerArgs);
                            }
                        });
                    }
                }
            }, function (fn, name) {
                JQLite.prototype[name] = function (arg1, arg2, arg3) {
                    var value;
                    for (var i = 0, ii = this.length; i < ii; i++) {
                        if (isUndefined(value)) {
                            value = fn(this[i], arg1, arg2, arg3);
                            if (isDefined(value)) {
                                value = jqLite(value);
                            }
                        } else {
                            jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                        }
                    }
                    return isDefined(value) ? value : this;
                };
                JQLite.prototype.bind = JQLite.prototype.on;
                JQLite.prototype.unbind = JQLite.prototype.off;
            });
            function $$jqLiteProvider() {
                this.$get = function $$jqLite() {
                    return extend(JQLite, {
                        hasClass: function (node, classes) {
                            if (node.attr)
                                node = node[0];
                            return jqLiteHasClass(node, classes);
                        },
                        addClass: function (node, classes) {
                            if (node.attr)
                                node = node[0];
                            return jqLiteAddClass(node, classes);
                        },
                        removeClass: function (node, classes) {
                            if (node.attr)
                                node = node[0];
                            return jqLiteRemoveClass(node, classes);
                        }
                    });
                };
            }
            function hashKey(obj, nextUidFn) {
                var key = obj && obj.$$hashKey;
                if (key) {
                    if (typeof key === 'function') {
                        key = obj.$$hashKey();
                    }
                    return key;
                }
                var objType = typeof obj;
                if (objType == 'function' || objType == 'object' && obj !== null) {
                    key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
                } else {
                    key = objType + ':' + obj;
                }
                return key;
            }
            function HashMap(array, isolatedUid) {
                if (isolatedUid) {
                    var uid = 0;
                    this.nextUid = function () {
                        return ++uid;
                    };
                }
                forEach(array, this.put, this);
            }
            HashMap.prototype = {
                put: function (key, value) {
                    this[hashKey(key, this.nextUid)] = value;
                },
                get: function (key) {
                    return this[hashKey(key, this.nextUid)];
                },
                remove: function (key) {
                    var value = this[key = hashKey(key, this.nextUid)];
                    delete this[key];
                    return value;
                }
            };
            var $$HashMapProvider = [function () {
                    this.$get = [function () {
                            return HashMap;
                        }];
                }];
            var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
            var FN_ARG_SPLIT = /,/;
            var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
            var $injectorMinErr = minErr('$injector');
            function anonFn(fn) {
                var fnText = fn.toString().replace(STRIP_COMMENTS, ''), args = fnText.match(FN_ARGS);
                if (args) {
                    return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
                }
                return 'fn';
            }
            function annotate(fn, strictDi, name) {
                var $inject, fnText, argDecl, last;
                if (typeof fn === 'function') {
                    if (!($inject = fn.$inject)) {
                        $inject = [];
                        if (fn.length) {
                            if (strictDi) {
                                if (!isString(name) || !name) {
                                    name = fn.name || anonFn(fn);
                                }
                                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
                            }
                            fnText = fn.toString().replace(STRIP_COMMENTS, '');
                            argDecl = fnText.match(FN_ARGS);
                            forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                                arg.replace(FN_ARG, function (all, underscore, name) {
                                    $inject.push(name);
                                });
                            });
                        }
                        fn.$inject = $inject;
                    }
                } else if (isArray(fn)) {
                    last = fn.length - 1;
                    assertArgFn(fn[last], 'fn');
                    $inject = fn.slice(0, last);
                } else {
                    assertArgFn(fn, 'fn', true);
                }
                return $inject;
            }
            function createInjector(modulesToLoad, strictDi) {
                strictDi = strictDi === true;
                var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap([], true), providerCache = {
                        $provide: {
                            provider: supportObject(provider),
                            factory: supportObject(factory),
                            service: supportObject(service),
                            value: supportObject(value),
                            constant: supportObject(constant),
                            decorator: decorator
                        }
                    }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
                        if (angular.isString(caller)) {
                            path.push(caller);
                        }
                        throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' <- '));
                    }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (serviceName, caller) {
                        var provider = providerInjector.get(serviceName + providerSuffix, caller);
                        return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
                    });
                forEach(loadModules(modulesToLoad), function (fn) {
                    if (fn)
                        instanceInjector.invoke(fn);
                });
                return instanceInjector;
                function supportObject(delegate) {
                    return function (key, value) {
                        if (isObject(key)) {
                            forEach(key, reverseParams(delegate));
                        } else {
                            return delegate(key, value);
                        }
                    };
                }
                function provider(name, provider_) {
                    assertNotHasOwnProperty(name, 'service');
                    if (isFunction(provider_) || isArray(provider_)) {
                        provider_ = providerInjector.instantiate(provider_);
                    }
                    if (!provider_.$get) {
                        throw $injectorMinErr('pget', 'Provider \'{0}\' must define $get factory method.', name);
                    }
                    return providerCache[name + providerSuffix] = provider_;
                }
                function enforceReturnValue(name, factory) {
                    return function enforcedReturnValue() {
                        var result = instanceInjector.invoke(factory, this);
                        if (isUndefined(result)) {
                            throw $injectorMinErr('undef', 'Provider \'{0}\' must return a value from $get factory method.', name);
                        }
                        return result;
                    };
                }
                function factory(name, factoryFn, enforce) {
                    return provider(name, { $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn });
                }
                function service(name, constructor) {
                    return factory(name, [
                        '$injector',
                        function ($injector) {
                            return $injector.instantiate(constructor);
                        }
                    ]);
                }
                function value(name, val) {
                    return factory(name, valueFn(val), false);
                }
                function constant(name, value) {
                    assertNotHasOwnProperty(name, 'constant');
                    providerCache[name] = value;
                    instanceCache[name] = value;
                }
                function decorator(serviceName, decorFn) {
                    var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                    origProvider.$get = function () {
                        var origInstance = instanceInjector.invoke(orig$get, origProvider);
                        return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
                    };
                }
                function loadModules(modulesToLoad) {
                    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
                    var runBlocks = [], moduleFn;
                    forEach(modulesToLoad, function (module) {
                        if (loadedModules.get(module))
                            return;
                        loadedModules.put(module, true);
                        function runInvokeQueue(queue) {
                            var i, ii;
                            for (i = 0, ii = queue.length; i < ii; i++) {
                                var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                            }
                        }
                        try {
                            if (isString(module)) {
                                moduleFn = angularModule(module);
                                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                                runInvokeQueue(moduleFn._invokeQueue);
                                runInvokeQueue(moduleFn._configBlocks);
                            } else if (isFunction(module)) {
                                runBlocks.push(providerInjector.invoke(module));
                            } else if (isArray(module)) {
                                runBlocks.push(providerInjector.invoke(module));
                            } else {
                                assertArgFn(module, 'module');
                            }
                        } catch (e) {
                            if (isArray(module)) {
                                module = module[module.length - 1];
                            }
                            if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                                e = e.message + '\n' + e.stack;
                            }
                            throw $injectorMinErr('modulerr', 'Failed to instantiate module {0} due to:\n{1}', module, e.stack || e.message || e);
                        }
                    });
                    return runBlocks;
                }
                function createInternalInjector(cache, factory) {
                    function getService(serviceName, caller) {
                        if (cache.hasOwnProperty(serviceName)) {
                            if (cache[serviceName] === INSTANTIATING) {
                                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
                            }
                            return cache[serviceName];
                        } else {
                            try {
                                path.unshift(serviceName);
                                cache[serviceName] = INSTANTIATING;
                                return cache[serviceName] = factory(serviceName, caller);
                            } catch (err) {
                                if (cache[serviceName] === INSTANTIATING) {
                                    delete cache[serviceName];
                                }
                                throw err;
                            } finally {
                                path.shift();
                            }
                        }
                    }
                    function invoke(fn, self, locals, serviceName) {
                        if (typeof locals === 'string') {
                            serviceName = locals;
                            locals = null;
                        }
                        var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), length, i, key;
                        for (i = 0, length = $inject.length; i < length; i++) {
                            key = $inject[i];
                            if (typeof key !== 'string') {
                                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
                            }
                            args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                        }
                        if (isArray(fn)) {
                            fn = fn[length];
                        }
                        return fn.apply(self, args);
                    }
                    function instantiate(Type, locals, serviceName) {
                        var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
                        var returnedValue = invoke(Type, instance, locals, serviceName);
                        return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
                    }
                    return {
                        invoke: invoke,
                        instantiate: instantiate,
                        get: getService,
                        annotate: createInjector.$$annotate,
                        has: function (name) {
                            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                        }
                    };
                }
            }
            createInjector.$$annotate = annotate;
            function $AnchorScrollProvider() {
                var autoScrollingEnabled = true;
                this.disableAutoScrolling = function () {
                    autoScrollingEnabled = false;
                };
                this.$get = [
                    '$window',
                    '$location',
                    '$rootScope',
                    function ($window, $location, $rootScope) {
                        var document = $window.document;
                        function getFirstAnchor(list) {
                            var result = null;
                            Array.prototype.some.call(list, function (element) {
                                if (nodeName_(element) === 'a') {
                                    result = element;
                                    return true;
                                }
                            });
                            return result;
                        }
                        function getYOffset() {
                            var offset = scroll.yOffset;
                            if (isFunction(offset)) {
                                offset = offset();
                            } else if (isElement(offset)) {
                                var elem = offset[0];
                                var style = $window.getComputedStyle(elem);
                                if (style.position !== 'fixed') {
                                    offset = 0;
                                } else {
                                    offset = elem.getBoundingClientRect().bottom;
                                }
                            } else if (!isNumber(offset)) {
                                offset = 0;
                            }
                            return offset;
                        }
                        function scrollTo(elem) {
                            if (elem) {
                                elem.scrollIntoView();
                                var offset = getYOffset();
                                if (offset) {
                                    var elemTop = elem.getBoundingClientRect().top;
                                    $window.scrollBy(0, elemTop - offset);
                                }
                            } else {
                                $window.scrollTo(0, 0);
                            }
                        }
                        function scroll(hash) {
                            hash = isString(hash) ? hash : $location.hash();
                            var elm;
                            if (!hash)
                                scrollTo(null);
                            else if (elm = document.getElementById(hash))
                                scrollTo(elm);
                            else if (elm = getFirstAnchor(document.getElementsByName(hash)))
                                scrollTo(elm);
                            else if (hash === 'top')
                                scrollTo(null);
                        }
                        if (autoScrollingEnabled) {
                            $rootScope.$watch(function autoScrollWatch() {
                                return $location.hash();
                            }, function autoScrollWatchAction(newVal, oldVal) {
                                if (newVal === oldVal && newVal === '')
                                    return;
                                jqLiteDocumentLoaded(function () {
                                    $rootScope.$evalAsync(scroll);
                                });
                            });
                        }
                        return scroll;
                    }
                ];
            }
            var $animateMinErr = minErr('$animate');
            var ELEMENT_NODE = 1;
            var NG_ANIMATE_CLASSNAME = 'ng-animate';
            function mergeClasses(a, b) {
                if (!a && !b)
                    return '';
                if (!a)
                    return b;
                if (!b)
                    return a;
                if (isArray(a))
                    a = a.join(' ');
                if (isArray(b))
                    b = b.join(' ');
                return a + ' ' + b;
            }
            function extractElementNode(element) {
                for (var i = 0; i < element.length; i++) {
                    var elm = element[i];
                    if (elm.nodeType === ELEMENT_NODE) {
                        return elm;
                    }
                }
            }
            function splitClasses(classes) {
                if (isString(classes)) {
                    classes = classes.split(' ');
                }
                var obj = createMap();
                forEach(classes, function (klass) {
                    if (klass.length) {
                        obj[klass] = true;
                    }
                });
                return obj;
            }
            function prepareAnimateOptions(options) {
                return isObject(options) ? options : {};
            }
            var $$CoreAnimateJsProvider = function () {
                this.$get = function () {
                };
            };
            var $$CoreAnimateQueueProvider = function () {
                var postDigestQueue = new HashMap();
                var postDigestElements = [];
                this.$get = [
                    '$$AnimateRunner',
                    '$rootScope',
                    function ($$AnimateRunner, $rootScope) {
                        return {
                            enabled: noop,
                            on: noop,
                            off: noop,
                            pin: noop,
                            push: function (element, event, options, domOperation) {
                                domOperation && domOperation();
                                options = options || {};
                                options.from && element.css(options.from);
                                options.to && element.css(options.to);
                                if (options.addClass || options.removeClass) {
                                    addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                                }
                                var runner = new $$AnimateRunner();
                                runner.complete();
                                return runner;
                            }
                        };
                        function updateData(data, classes, value) {
                            var changed = false;
                            if (classes) {
                                classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
                                forEach(classes, function (className) {
                                    if (className) {
                                        changed = true;
                                        data[className] = value;
                                    }
                                });
                            }
                            return changed;
                        }
                        function handleCSSClassChanges() {
                            forEach(postDigestElements, function (element) {
                                var data = postDigestQueue.get(element);
                                if (data) {
                                    var existing = splitClasses(element.attr('class'));
                                    var toAdd = '';
                                    var toRemove = '';
                                    forEach(data, function (status, className) {
                                        var hasClass = !!existing[className];
                                        if (status !== hasClass) {
                                            if (status) {
                                                toAdd += (toAdd.length ? ' ' : '') + className;
                                            } else {
                                                toRemove += (toRemove.length ? ' ' : '') + className;
                                            }
                                        }
                                    });
                                    forEach(element, function (elm) {
                                        toAdd && jqLiteAddClass(elm, toAdd);
                                        toRemove && jqLiteRemoveClass(elm, toRemove);
                                    });
                                    postDigestQueue.remove(element);
                                }
                            });
                            postDigestElements.length = 0;
                        }
                        function addRemoveClassesPostDigest(element, add, remove) {
                            var data = postDigestQueue.get(element) || {};
                            var classesAdded = updateData(data, add, true);
                            var classesRemoved = updateData(data, remove, false);
                            if (classesAdded || classesRemoved) {
                                postDigestQueue.put(element, data);
                                postDigestElements.push(element);
                                if (postDigestElements.length === 1) {
                                    $rootScope.$$postDigest(handleCSSClassChanges);
                                }
                            }
                        }
                    }
                ];
            };
            var $AnimateProvider = [
                '$provide',
                function ($provide) {
                    var provider = this;
                    this.$$registeredAnimations = Object.create(null);
                    this.register = function (name, factory) {
                        if (name && name.charAt(0) !== '.') {
                            throw $animateMinErr('notcsel', 'Expecting class selector starting with \'.\' got \'{0}\'.', name);
                        }
                        var key = name + '-animation';
                        provider.$$registeredAnimations[name.substr(1)] = key;
                        $provide.factory(key, factory);
                    };
                    this.classNameFilter = function (expression) {
                        if (arguments.length === 1) {
                            this.$$classNameFilter = expression instanceof RegExp ? expression : null;
                            if (this.$$classNameFilter) {
                                var reservedRegex = new RegExp('(\\s+|\\/)' + NG_ANIMATE_CLASSNAME + '(\\s+|\\/)');
                                if (reservedRegex.test(this.$$classNameFilter.toString())) {
                                    throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                                }
                            }
                        }
                        return this.$$classNameFilter;
                    };
                    this.$get = [
                        '$$animateQueue',
                        function ($$animateQueue) {
                            function domInsert(element, parentElement, afterElement) {
                                if (afterElement) {
                                    var afterNode = extractElementNode(afterElement);
                                    if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                                        afterElement = null;
                                    }
                                }
                                afterElement ? afterElement.after(element) : parentElement.prepend(element);
                            }
                            return {
                                on: $$animateQueue.on,
                                off: $$animateQueue.off,
                                pin: $$animateQueue.pin,
                                enabled: $$animateQueue.enabled,
                                cancel: function (runner) {
                                    runner.end && runner.end();
                                },
                                enter: function (element, parent, after, options) {
                                    parent = parent && jqLite(parent);
                                    after = after && jqLite(after);
                                    parent = parent || after.parent();
                                    domInsert(element, parent, after);
                                    return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
                                },
                                move: function (element, parent, after, options) {
                                    parent = parent && jqLite(parent);
                                    after = after && jqLite(after);
                                    parent = parent || after.parent();
                                    domInsert(element, parent, after);
                                    return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
                                },
                                leave: function (element, options) {
                                    return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function () {
                                        element.remove();
                                    });
                                },
                                addClass: function (element, className, options) {
                                    options = prepareAnimateOptions(options);
                                    options.addClass = mergeClasses(options.addclass, className);
                                    return $$animateQueue.push(element, 'addClass', options);
                                },
                                removeClass: function (element, className, options) {
                                    options = prepareAnimateOptions(options);
                                    options.removeClass = mergeClasses(options.removeClass, className);
                                    return $$animateQueue.push(element, 'removeClass', options);
                                },
                                setClass: function (element, add, remove, options) {
                                    options = prepareAnimateOptions(options);
                                    options.addClass = mergeClasses(options.addClass, add);
                                    options.removeClass = mergeClasses(options.removeClass, remove);
                                    return $$animateQueue.push(element, 'setClass', options);
                                },
                                animate: function (element, from, to, className, options) {
                                    options = prepareAnimateOptions(options);
                                    options.from = options.from ? extend(options.from, from) : from;
                                    options.to = options.to ? extend(options.to, to) : to;
                                    className = className || 'ng-inline-animate';
                                    options.tempClasses = mergeClasses(options.tempClasses, className);
                                    return $$animateQueue.push(element, 'animate', options);
                                }
                            };
                        }
                    ];
                }
            ];
            var $$AnimateAsyncRunFactoryProvider = function () {
                this.$get = [
                    '$$rAF',
                    function ($$rAF) {
                        var waitQueue = [];
                        function waitForTick(fn) {
                            waitQueue.push(fn);
                            if (waitQueue.length > 1)
                                return;
                            $$rAF(function () {
                                for (var i = 0; i < waitQueue.length; i++) {
                                    waitQueue[i]();
                                }
                                waitQueue = [];
                            });
                        }
                        return function () {
                            var passed = false;
                            waitForTick(function () {
                                passed = true;
                            });
                            return function (callback) {
                                passed ? callback() : waitForTick(callback);
                            };
                        };
                    }
                ];
            };
            var $$AnimateRunnerFactoryProvider = function () {
                this.$get = [
                    '$q',
                    '$sniffer',
                    '$$animateAsyncRun',
                    '$document',
                    '$timeout',
                    function ($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
                        var INITIAL_STATE = 0;
                        var DONE_PENDING_STATE = 1;
                        var DONE_COMPLETE_STATE = 2;
                        AnimateRunner.chain = function (chain, callback) {
                            var index = 0;
                            next();
                            function next() {
                                if (index === chain.length) {
                                    callback(true);
                                    return;
                                }
                                chain[index](function (response) {
                                    if (response === false) {
                                        callback(false);
                                        return;
                                    }
                                    index++;
                                    next();
                                });
                            }
                        };
                        AnimateRunner.all = function (runners, callback) {
                            var count = 0;
                            var status = true;
                            forEach(runners, function (runner) {
                                runner.done(onProgress);
                            });
                            function onProgress(response) {
                                status = status && response;
                                if (++count === runners.length) {
                                    callback(status);
                                }
                            }
                        };
                        function AnimateRunner(host) {
                            this.setHost(host);
                            var rafTick = $$animateAsyncRun();
                            var timeoutTick = function (fn) {
                                $timeout(fn, 0, false);
                            };
                            this._doneCallbacks = [];
                            this._tick = function (fn) {
                                var doc = $document[0];
                                if (doc && doc.hidden) {
                                    timeoutTick(fn);
                                } else {
                                    rafTick(fn);
                                }
                            };
                            this._state = 0;
                        }
                        AnimateRunner.prototype = {
                            setHost: function (host) {
                                this.host = host || {};
                            },
                            done: function (fn) {
                                if (this._state === DONE_COMPLETE_STATE) {
                                    fn();
                                } else {
                                    this._doneCallbacks.push(fn);
                                }
                            },
                            progress: noop,
                            getPromise: function () {
                                if (!this.promise) {
                                    var self = this;
                                    this.promise = $q(function (resolve, reject) {
                                        self.done(function (status) {
                                            status === false ? reject() : resolve();
                                        });
                                    });
                                }
                                return this.promise;
                            },
                            then: function (resolveHandler, rejectHandler) {
                                return this.getPromise().then(resolveHandler, rejectHandler);
                            },
                            'catch': function (handler) {
                                return this.getPromise()['catch'](handler);
                            },
                            'finally': function (handler) {
                                return this.getPromise()['finally'](handler);
                            },
                            pause: function () {
                                if (this.host.pause) {
                                    this.host.pause();
                                }
                            },
                            resume: function () {
                                if (this.host.resume) {
                                    this.host.resume();
                                }
                            },
                            end: function () {
                                if (this.host.end) {
                                    this.host.end();
                                }
                                this._resolve(true);
                            },
                            cancel: function () {
                                if (this.host.cancel) {
                                    this.host.cancel();
                                }
                                this._resolve(false);
                            },
                            complete: function (response) {
                                var self = this;
                                if (self._state === INITIAL_STATE) {
                                    self._state = DONE_PENDING_STATE;
                                    self._tick(function () {
                                        self._resolve(response);
                                    });
                                }
                            },
                            _resolve: function (response) {
                                if (this._state !== DONE_COMPLETE_STATE) {
                                    forEach(this._doneCallbacks, function (fn) {
                                        fn(response);
                                    });
                                    this._doneCallbacks.length = 0;
                                    this._state = DONE_COMPLETE_STATE;
                                }
                            }
                        };
                        return AnimateRunner;
                    }
                ];
            };
            var $CoreAnimateCssProvider = function () {
                this.$get = [
                    '$$rAF',
                    '$q',
                    '$$AnimateRunner',
                    function ($$rAF, $q, $$AnimateRunner) {
                        return function (element, initialOptions) {
                            var options = initialOptions || {};
                            if (!options.$$prepared) {
                                options = copy(options);
                            }
                            if (options.cleanupStyles) {
                                options.from = options.to = null;
                            }
                            if (options.from) {
                                element.css(options.from);
                                options.from = null;
                            }
                            var closed, runner = new $$AnimateRunner();
                            return {
                                start: run,
                                end: run
                            };
                            function run() {
                                $$rAF(function () {
                                    applyAnimationContents();
                                    if (!closed) {
                                        runner.complete();
                                    }
                                    closed = true;
                                });
                                return runner;
                            }
                            function applyAnimationContents() {
                                if (options.addClass) {
                                    element.addClass(options.addClass);
                                    options.addClass = null;
                                }
                                if (options.removeClass) {
                                    element.removeClass(options.removeClass);
                                    options.removeClass = null;
                                }
                                if (options.to) {
                                    element.css(options.to);
                                    options.to = null;
                                }
                            }
                        };
                    }
                ];
            };
            function Browser(window, document, $log, $sniffer) {
                var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
                self.isMock = false;
                var outstandingRequestCount = 0;
                var outstandingRequestCallbacks = [];
                self.$$completeOutstandingRequest = completeOutstandingRequest;
                self.$$incOutstandingRequestCount = function () {
                    outstandingRequestCount++;
                };
                function completeOutstandingRequest(fn) {
                    try {
                        fn.apply(null, sliceArgs(arguments, 1));
                    } finally {
                        outstandingRequestCount--;
                        if (outstandingRequestCount === 0) {
                            while (outstandingRequestCallbacks.length) {
                                try {
                                    outstandingRequestCallbacks.pop()();
                                } catch (e) {
                                    $log.error(e);
                                }
                            }
                        }
                    }
                }
                function getHash(url) {
                    var index = url.indexOf('#');
                    return index === -1 ? '' : url.substr(index);
                }
                self.notifyWhenNoOutstandingRequests = function (callback) {
                    if (outstandingRequestCount === 0) {
                        callback();
                    } else {
                        outstandingRequestCallbacks.push(callback);
                    }
                };
                var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find('base'), pendingLocation = null;
                cacheState();
                lastHistoryState = cachedState;
                self.url = function (url, replace, state) {
                    if (isUndefined(state)) {
                        state = null;
                    }
                    if (location !== window.location)
                        location = window.location;
                    if (history !== window.history)
                        history = window.history;
                    if (url) {
                        var sameState = lastHistoryState === state;
                        if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                            return self;
                        }
                        var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                        lastBrowserUrl = url;
                        lastHistoryState = state;
                        if ($sniffer.history && (!sameBase || !sameState)) {
                            history[replace ? 'replaceState' : 'pushState'](state, '', url);
                            cacheState();
                            lastHistoryState = cachedState;
                        } else {
                            if (!sameBase || pendingLocation) {
                                pendingLocation = url;
                            }
                            if (replace) {
                                location.replace(url);
                            } else if (!sameBase) {
                                location.href = url;
                            } else {
                                location.hash = getHash(url);
                            }
                            if (location.href !== url) {
                                pendingLocation = url;
                            }
                        }
                        return self;
                    } else {
                        return pendingLocation || location.href.replace(/%27/g, '\'');
                    }
                };
                self.state = function () {
                    return cachedState;
                };
                var urlChangeListeners = [], urlChangeInit = false;
                function cacheStateAndFireUrlChange() {
                    pendingLocation = null;
                    cacheState();
                    fireUrlChange();
                }
                function getCurrentState() {
                    try {
                        return history.state;
                    } catch (e) {
                    }
                }
                var lastCachedState = null;
                function cacheState() {
                    cachedState = getCurrentState();
                    cachedState = isUndefined(cachedState) ? null : cachedState;
                    if (equals(cachedState, lastCachedState)) {
                        cachedState = lastCachedState;
                    }
                    lastCachedState = cachedState;
                }
                function fireUrlChange() {
                    if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                        return;
                    }
                    lastBrowserUrl = self.url();
                    lastHistoryState = cachedState;
                    forEach(urlChangeListeners, function (listener) {
                        listener(self.url(), cachedState);
                    });
                }
                self.onUrlChange = function (callback) {
                    if (!urlChangeInit) {
                        if ($sniffer.history)
                            jqLite(window).on('popstate', cacheStateAndFireUrlChange);
                        jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
                        urlChangeInit = true;
                    }
                    urlChangeListeners.push(callback);
                    return callback;
                };
                self.$$applicationDestroyed = function () {
                    jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
                };
                self.$$checkUrlChange = fireUrlChange;
                self.baseHref = function () {
                    var href = baseElement.attr('href');
                    return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
                };
                self.defer = function (fn, delay) {
                    var timeoutId;
                    outstandingRequestCount++;
                    timeoutId = setTimeout(function () {
                        delete pendingDeferIds[timeoutId];
                        completeOutstandingRequest(fn);
                    }, delay || 0);
                    pendingDeferIds[timeoutId] = true;
                    return timeoutId;
                };
                self.defer.cancel = function (deferId) {
                    if (pendingDeferIds[deferId]) {
                        delete pendingDeferIds[deferId];
                        clearTimeout(deferId);
                        completeOutstandingRequest(noop);
                        return true;
                    }
                    return false;
                };
            }
            function $BrowserProvider() {
                this.$get = [
                    '$window',
                    '$log',
                    '$sniffer',
                    '$document',
                    function ($window, $log, $sniffer, $document) {
                        return new Browser($window, $document, $log, $sniffer);
                    }
                ];
            }
            function $CacheFactoryProvider() {
                this.$get = function () {
                    var caches = {};
                    function cacheFactory(cacheId, options) {
                        if (cacheId in caches) {
                            throw minErr('$cacheFactory')('iid', 'CacheId \'{0}\' is already taken!', cacheId);
                        }
                        var size = 0, stats = extend({}, options, { id: cacheId }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                        return caches[cacheId] = {
                            put: function (key, value) {
                                if (isUndefined(value))
                                    return;
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
                                    refresh(lruEntry);
                                }
                                if (!(key in data))
                                    size++;
                                data[key] = value;
                                if (size > capacity) {
                                    this.remove(staleEnd.key);
                                }
                                return value;
                            },
                            get: function (key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry)
                                        return;
                                    refresh(lruEntry);
                                }
                                return data[key];
                            },
                            remove: function (key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry)
                                        return;
                                    if (lruEntry == freshEnd)
                                        freshEnd = lruEntry.p;
                                    if (lruEntry == staleEnd)
                                        staleEnd = lruEntry.n;
                                    link(lruEntry.n, lruEntry.p);
                                    delete lruHash[key];
                                }
                                if (!(key in data))
                                    return;
                                delete data[key];
                                size--;
                            },
                            removeAll: function () {
                                data = createMap();
                                size = 0;
                                lruHash = createMap();
                                freshEnd = staleEnd = null;
                            },
                            destroy: function () {
                                data = null;
                                stats = null;
                                lruHash = null;
                                delete caches[cacheId];
                            },
                            info: function () {
                                return extend({}, stats, { size: size });
                            }
                        };
                        function refresh(entry) {
                            if (entry != freshEnd) {
                                if (!staleEnd) {
                                    staleEnd = entry;
                                } else if (staleEnd == entry) {
                                    staleEnd = entry.n;
                                }
                                link(entry.n, entry.p);
                                link(entry, freshEnd);
                                freshEnd = entry;
                                freshEnd.n = null;
                            }
                        }
                        function link(nextEntry, prevEntry) {
                            if (nextEntry != prevEntry) {
                                if (nextEntry)
                                    nextEntry.p = prevEntry;
                                if (prevEntry)
                                    prevEntry.n = nextEntry;
                            }
                        }
                    }
                    cacheFactory.info = function () {
                        var info = {};
                        forEach(caches, function (cache, cacheId) {
                            info[cacheId] = cache.info();
                        });
                        return info;
                    };
                    cacheFactory.get = function (cacheId) {
                        return caches[cacheId];
                    };
                    return cacheFactory;
                };
            }
            function $TemplateCacheProvider() {
                this.$get = [
                    '$cacheFactory',
                    function ($cacheFactory) {
                        return $cacheFactory('templates');
                    }
                ];
            }
            var $compileMinErr = minErr('$compile');
            $CompileProvider.$inject = [
                '$provide',
                '$$sanitizeUriProvider'
            ];
            function $CompileProvider($provide, $$sanitizeUriProvider) {
                var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
                var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
                var bindingCache = createMap();
                function parseIsolateBindings(scope, directiveName, isController) {
                    var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
                    var bindings = {};
                    forEach(scope, function (definition, scopeName) {
                        if (definition in bindingCache) {
                            bindings[scopeName] = bindingCache[definition];
                            return;
                        }
                        var match = definition.match(LOCAL_REGEXP);
                        if (!match) {
                            throw $compileMinErr('iscp', 'Invalid {3} for directive \'{0}\'.' + ' Definition: {... {1}: \'{2}\' ...}', directiveName, scopeName, definition, isController ? 'controller bindings definition' : 'isolate scope definition');
                        }
                        bindings[scopeName] = {
                            mode: match[1][0],
                            collection: match[2] === '*',
                            optional: match[3] === '?',
                            attrName: match[4] || scopeName
                        };
                        if (match[4]) {
                            bindingCache[definition] = bindings[scopeName];
                        }
                    });
                    return bindings;
                }
                function parseDirectiveBindings(directive, directiveName) {
                    var bindings = {
                        isolateScope: null,
                        bindToController: null
                    };
                    if (isObject(directive.scope)) {
                        if (directive.bindToController === true) {
                            bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                            bindings.isolateScope = {};
                        } else {
                            bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                        }
                    }
                    if (isObject(directive.bindToController)) {
                        bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
                    }
                    if (isObject(bindings.bindToController)) {
                        var controller = directive.controller;
                        var controllerAs = directive.controllerAs;
                        if (!controller) {
                            throw $compileMinErr('noctrl', 'Cannot bind to controller without directive \'{0}\'s controller.', directiveName);
                        } else if (!identifierForController(controller, controllerAs)) {
                            throw $compileMinErr('noident', 'Cannot bind to controller without identifier for directive \'{0}\'.', directiveName);
                        }
                    }
                    return bindings;
                }
                function assertValidDirectiveName(name) {
                    var letter = name.charAt(0);
                    if (!letter || letter !== lowercase(letter)) {
                        throw $compileMinErr('baddir', 'Directive name \'{0}\' is invalid. The first character must be a lowercase letter', name);
                    }
                    if (name !== name.trim()) {
                        throw $compileMinErr('baddir', 'Directive name \'{0}\' is invalid. The name should not contain leading or trailing whitespaces', name);
                    }
                }
                this.directive = function registerDirective(name, directiveFactory) {
                    assertNotHasOwnProperty(name, 'directive');
                    if (isString(name)) {
                        assertValidDirectiveName(name);
                        assertArg(directiveFactory, 'directiveFactory');
                        if (!hasDirectives.hasOwnProperty(name)) {
                            hasDirectives[name] = [];
                            $provide.factory(name + Suffix, [
                                '$injector',
                                '$exceptionHandler',
                                function ($injector, $exceptionHandler) {
                                    var directives = [];
                                    forEach(hasDirectives[name], function (directiveFactory, index) {
                                        try {
                                            var directive = $injector.invoke(directiveFactory);
                                            if (isFunction(directive)) {
                                                directive = { compile: valueFn(directive) };
                                            } else if (!directive.compile && directive.link) {
                                                directive.compile = valueFn(directive.link);
                                            }
                                            directive.priority = directive.priority || 0;
                                            directive.index = index;
                                            directive.name = directive.name || name;
                                            directive.require = directive.require || directive.controller && directive.name;
                                            directive.restrict = directive.restrict || 'EA';
                                            directive.$$moduleName = directiveFactory.$$moduleName;
                                            directives.push(directive);
                                        } catch (e) {
                                            $exceptionHandler(e);
                                        }
                                    });
                                    return directives;
                                }
                            ]);
                        }
                        hasDirectives[name].push(directiveFactory);
                    } else {
                        forEach(name, reverseParams(registerDirective));
                    }
                    return this;
                };
                this.aHrefSanitizationWhitelist = function (regexp) {
                    if (isDefined(regexp)) {
                        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                        return this;
                    } else {
                        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
                    }
                };
                this.imgSrcSanitizationWhitelist = function (regexp) {
                    if (isDefined(regexp)) {
                        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                        return this;
                    } else {
                        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
                    }
                };
                var debugInfoEnabled = true;
                this.debugInfoEnabled = function (enabled) {
                    if (isDefined(enabled)) {
                        debugInfoEnabled = enabled;
                        return this;
                    }
                    return debugInfoEnabled;
                };
                this.$get = [
                    '$injector',
                    '$interpolate',
                    '$exceptionHandler',
                    '$templateRequest',
                    '$parse',
                    '$controller',
                    '$rootScope',
                    '$sce',
                    '$animate',
                    '$$sanitizeUri',
                    function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
                        var Attributes = function (element, attributesToCopy) {
                            if (attributesToCopy) {
                                var keys = Object.keys(attributesToCopy);
                                var i, l, key;
                                for (i = 0, l = keys.length; i < l; i++) {
                                    key = keys[i];
                                    this[key] = attributesToCopy[key];
                                }
                            } else {
                                this.$attr = {};
                            }
                            this.$$element = element;
                        };
                        Attributes.prototype = {
                            $normalize: directiveNormalize,
                            $addClass: function (classVal) {
                                if (classVal && classVal.length > 0) {
                                    $animate.addClass(this.$$element, classVal);
                                }
                            },
                            $removeClass: function (classVal) {
                                if (classVal && classVal.length > 0) {
                                    $animate.removeClass(this.$$element, classVal);
                                }
                            },
                            $updateClass: function (newClasses, oldClasses) {
                                var toAdd = tokenDifference(newClasses, oldClasses);
                                if (toAdd && toAdd.length) {
                                    $animate.addClass(this.$$element, toAdd);
                                }
                                var toRemove = tokenDifference(oldClasses, newClasses);
                                if (toRemove && toRemove.length) {
                                    $animate.removeClass(this.$$element, toRemove);
                                }
                            },
                            $set: function (key, value, writeAttr, attrName) {
                                var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                                if (booleanKey) {
                                    this.$$element.prop(key, value);
                                    attrName = booleanKey;
                                } else if (aliasedKey) {
                                    this[aliasedKey] = value;
                                    observer = aliasedKey;
                                }
                                this[key] = value;
                                if (attrName) {
                                    this.$attr[key] = attrName;
                                } else {
                                    attrName = this.$attr[key];
                                    if (!attrName) {
                                        this.$attr[key] = attrName = snake_case(key, '-');
                                    }
                                }
                                nodeName = nodeName_(this.$$element);
                                if (nodeName === 'a' && key === 'href' || nodeName === 'img' && key === 'src') {
                                    this[key] = value = $$sanitizeUri(value, key === 'src');
                                } else if (nodeName === 'img' && key === 'srcset') {
                                    var result = '';
                                    var trimmedSrcset = trim(value);
                                    var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                                    var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                                    var rawUris = trimmedSrcset.split(pattern);
                                    var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                                    for (var i = 0; i < nbrUrisWith2parts; i++) {
                                        var innerIdx = i * 2;
                                        result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                                        result += ' ' + trim(rawUris[innerIdx + 1]);
                                    }
                                    var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                                    result += $$sanitizeUri(trim(lastTuple[0]), true);
                                    if (lastTuple.length === 2) {
                                        result += ' ' + trim(lastTuple[1]);
                                    }
                                    this[key] = value = result;
                                }
                                if (writeAttr !== false) {
                                    if (value === null || isUndefined(value)) {
                                        this.$$element.removeAttr(attrName);
                                    } else {
                                        this.$$element.attr(attrName, value);
                                    }
                                }
                                var $$observers = this.$$observers;
                                $$observers && forEach($$observers[observer], function (fn) {
                                    try {
                                        fn(value);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                });
                            },
                            $observe: function (key, fn) {
                                var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                                listeners.push(fn);
                                $rootScope.$evalAsync(function () {
                                    if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                                        fn(attrs[key]);
                                    }
                                });
                                return function () {
                                    arrayRemove(listeners, fn);
                                };
                            }
                        };
                        function safeAddClass($element, className) {
                            try {
                                $element.addClass(className);
                            } catch (e) {
                            }
                        }
                        var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' && endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
                                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                        var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                        compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                            var bindings = $element.data('$binding') || [];
                            if (isArray(binding)) {
                                bindings = bindings.concat(binding);
                            } else {
                                bindings.push(binding);
                            }
                            $element.data('$binding', bindings);
                        } : noop;
                        compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                            safeAddClass($element, 'ng-binding');
                        } : noop;
                        compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                            var dataName = isolated ? noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope';
                            $element.data(dataName, scope);
                        } : noop;
                        compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
                        } : noop;
                        return compile;
                        function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                            if (!($compileNodes instanceof jqLite)) {
                                $compileNodes = jqLite($compileNodes);
                            }
                            var NOT_EMPTY = /\S+/;
                            for (var i = 0, len = $compileNodes.length; i < len; i++) {
                                var domNode = $compileNodes[i];
                                if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                                    jqLiteWrapNode(domNode, $compileNodes[i] = document.createElement('span'));
                                }
                            }
                            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                            compile.$$addScopeClass($compileNodes);
                            var namespace = null;
                            return function publicLinkFn(scope, cloneConnectFn, options) {
                                assertArg(scope, 'scope');
                                if (previousCompileContext && previousCompileContext.needsNewScope) {
                                    scope = scope.$parent.$new();
                                }
                                options = options || {};
                                var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                                if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                                    parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                                }
                                if (!namespace) {
                                    namespace = detectNamespaceForChildElements(futureParentElement);
                                }
                                var $linkNode;
                                if (namespace !== 'html') {
                                    $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
                                } else if (cloneConnectFn) {
                                    $linkNode = JQLitePrototype.clone.call($compileNodes);
                                } else {
                                    $linkNode = $compileNodes;
                                }
                                if (transcludeControllers) {
                                    for (var controllerName in transcludeControllers) {
                                        $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                                    }
                                }
                                compile.$$addScopeInfo($linkNode, scope);
                                if (cloneConnectFn)
                                    cloneConnectFn($linkNode, scope);
                                if (compositeLinkFn)
                                    compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                                return $linkNode;
                            };
                        }
                        function detectNamespaceForChildElements(parentElement) {
                            var node = parentElement && parentElement[0];
                            if (!node) {
                                return 'html';
                            } else {
                                return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
                            }
                        }
                        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                            var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                            for (var i = 0; i < nodeList.length; i++) {
                                attrs = new Attributes();
                                directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                                if (nodeLinkFn && nodeLinkFn.scope) {
                                    compile.$$addScopeClass(attrs.$$element);
                                }
                                childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                                if (nodeLinkFn || childLinkFn) {
                                    linkFns.push(i, nodeLinkFn, childLinkFn);
                                    linkFnFound = true;
                                    nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                                }
                                previousCompileContext = null;
                            }
                            return linkFnFound ? compositeLinkFn : null;
                            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                                var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                                var stableNodeList;
                                if (nodeLinkFnFound) {
                                    var nodeListLength = nodeList.length;
                                    stableNodeList = new Array(nodeListLength);
                                    for (i = 0; i < linkFns.length; i += 3) {
                                        idx = linkFns[i];
                                        stableNodeList[idx] = nodeList[idx];
                                    }
                                } else {
                                    stableNodeList = nodeList;
                                }
                                for (i = 0, ii = linkFns.length; i < ii;) {
                                    node = stableNodeList[linkFns[i++]];
                                    nodeLinkFn = linkFns[i++];
                                    childLinkFn = linkFns[i++];
                                    if (nodeLinkFn) {
                                        if (nodeLinkFn.scope) {
                                            childScope = scope.$new();
                                            compile.$$addScopeInfo(jqLite(node), childScope);
                                        } else {
                                            childScope = scope;
                                        }
                                        if (nodeLinkFn.transcludeOnThisElement) {
                                            childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                                        } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                            childBoundTranscludeFn = parentBoundTranscludeFn;
                                        } else if (!parentBoundTranscludeFn && transcludeFn) {
                                            childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                                        } else {
                                            childBoundTranscludeFn = null;
                                        }
                                        nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                                    } else if (childLinkFn) {
                                        childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                                    }
                                }
                            }
                        }
                        function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                            var boundTranscludeFn = function (transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                                if (!transcludedScope) {
                                    transcludedScope = scope.$new(false, containingScope);
                                    transcludedScope.$$transcluded = true;
                                }
                                return transcludeFn(transcludedScope, cloneFn, {
                                    parentBoundTranscludeFn: previousBoundTranscludeFn,
                                    transcludeControllers: controllers,
                                    futureParentElement: futureParentElement
                                });
                            };
                            return boundTranscludeFn;
                        }
                        function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                            var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                            switch (nodeType) {
                            case NODE_TYPE_ELEMENT:
                                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                                for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                    var attrStartName = false;
                                    var attrEndName = false;
                                    attr = nAttrs[j];
                                    name = attr.name;
                                    value = trim(attr.value);
                                    ngAttrName = directiveNormalize(name);
                                    if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                                        name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function (match, letter) {
                                            return letter.toUpperCase();
                                        });
                                    }
                                    var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                                    if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                                        attrStartName = name;
                                        attrEndName = name.substr(0, name.length - 5) + 'end';
                                        name = name.substr(0, name.length - 6);
                                    }
                                    nName = directiveNormalize(name.toLowerCase());
                                    attrsMap[nName] = name;
                                    if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                        attrs[nName] = value;
                                        if (getBooleanAttrName(node, nName)) {
                                            attrs[nName] = true;
                                        }
                                    }
                                    addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                                    addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                                }
                                className = node.className;
                                if (isObject(className)) {
                                    className = className.animVal;
                                }
                                if (isString(className) && className !== '') {
                                    while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                                        nName = directiveNormalize(match[2]);
                                        if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                                            attrs[nName] = trim(match[3]);
                                        }
                                        className = className.substr(match.index + match[0].length);
                                    }
                                }
                                break;
                            case NODE_TYPE_TEXT:
                                if (msie === 11) {
                                    while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                                        node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                                        node.parentNode.removeChild(node.nextSibling);
                                    }
                                }
                                addTextInterpolateDirective(directives, node.nodeValue);
                                break;
                            case NODE_TYPE_COMMENT:
                                try {
                                    match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                                    if (match) {
                                        nName = directiveNormalize(match[1]);
                                        if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                                            attrs[nName] = trim(match[2]);
                                        }
                                    }
                                } catch (e) {
                                }
                                break;
                            }
                            directives.sort(byPriority);
                            return directives;
                        }
                        function groupScan(node, attrStart, attrEnd) {
                            var nodes = [];
                            var depth = 0;
                            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                                do {
                                    if (!node) {
                                        throw $compileMinErr('uterdir', 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.', attrStart, attrEnd);
                                    }
                                    if (node.nodeType == NODE_TYPE_ELEMENT) {
                                        if (node.hasAttribute(attrStart))
                                            depth++;
                                        if (node.hasAttribute(attrEnd))
                                            depth--;
                                    }
                                    nodes.push(node);
                                    node = node.nextSibling;
                                } while (depth > 0);
                            } else {
                                nodes.push(node);
                            }
                            return jqLite(nodes);
                        }
                        function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                            return function (scope, element, attrs, controllers, transcludeFn) {
                                element = groupScan(element[0], attrStart, attrEnd);
                                return linkFn(scope, element, attrs, controllers, transcludeFn);
                            };
                        }
                        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                            previousCompileContext = previousCompileContext || {};
                            var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
                            for (var i = 0, ii = directives.length; i < ii; i++) {
                                directive = directives[i];
                                var attrStart = directive.$$start;
                                var attrEnd = directive.$$end;
                                if (attrStart) {
                                    $compileNode = groupScan(compileNode, attrStart, attrEnd);
                                }
                                $template = undefined;
                                if (terminalPriority > directive.priority) {
                                    break;
                                }
                                if (directiveValue = directive.scope) {
                                    if (!directive.templateUrl) {
                                        if (isObject(directiveValue)) {
                                            assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                            newIsolateScopeDirective = directive;
                                        } else {
                                            assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                                        }
                                    }
                                    newScopeDirective = newScopeDirective || directive;
                                }
                                directiveName = directive.name;
                                if (!directive.templateUrl && directive.controller) {
                                    directiveValue = directive.controller;
                                    controllerDirectives = controllerDirectives || createMap();
                                    assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
                                    controllerDirectives[directiveName] = directive;
                                }
                                if (directiveValue = directive.transclude) {
                                    hasTranscludeDirective = true;
                                    if (!directive.$$tlb) {
                                        assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                                        nonTlbTranscludeDirective = directive;
                                    }
                                    if (directiveValue == 'element') {
                                        hasElementTranscludeDirective = true;
                                        terminalPriority = directive.priority;
                                        $template = $compileNode;
                                        $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                                        compileNode = $compileNode[0];
                                        replaceWith(jqCollection, sliceArgs($template), compileNode);
                                        childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, { nonTlbTranscludeDirective: nonTlbTranscludeDirective });
                                    } else {
                                        $template = jqLite(jqLiteClone(compileNode)).contents();
                                        $compileNode.empty();
                                        childTranscludeFn = compile($template, transcludeFn, undefined, undefined, { needsNewScope: directive.$$isolateScope || directive.$$newScope });
                                    }
                                }
                                if (directive.template) {
                                    hasTemplate = true;
                                    assertNoDuplicate('template', templateDirective, directive, $compileNode);
                                    templateDirective = directive;
                                    directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                                    directiveValue = denormalizeTemplate(directiveValue);
                                    if (directive.replace) {
                                        replaceDirective = directive;
                                        if (jqLiteIsTextNode(directiveValue)) {
                                            $template = [];
                                        } else {
                                            $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                                        }
                                        compileNode = $template[0];
                                        if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                            throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', directiveName, '');
                                        }
                                        replaceWith(jqCollection, $compileNode, compileNode);
                                        var newTemplateAttrs = { $attr: {} };
                                        var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                                        var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                        if (newIsolateScopeDirective || newScopeDirective) {
                                            markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                                        }
                                        directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                                        ii = directives.length;
                                    } else {
                                        $compileNode.html(directiveValue);
                                    }
                                }
                                if (directive.templateUrl) {
                                    hasTemplate = true;
                                    assertNoDuplicate('template', templateDirective, directive, $compileNode);
                                    templateDirective = directive;
                                    if (directive.replace) {
                                        replaceDirective = directive;
                                    }
                                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                        controllerDirectives: controllerDirectives,
                                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                        newIsolateScopeDirective: newIsolateScopeDirective,
                                        templateDirective: templateDirective,
                                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                    });
                                    ii = directives.length;
                                } else if (directive.compile) {
                                    try {
                                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                        if (isFunction(linkFn)) {
                                            addLinkFns(null, linkFn, attrStart, attrEnd);
                                        } else if (linkFn) {
                                            addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e, startingTag($compileNode));
                                    }
                                }
                                if (directive.terminal) {
                                    nodeLinkFn.terminal = true;
                                    terminalPriority = Math.max(terminalPriority, directive.priority);
                                }
                            }
                            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                            nodeLinkFn.templateOnThisElement = hasTemplate;
                            nodeLinkFn.transclude = childTranscludeFn;
                            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                            return nodeLinkFn;
                            function addLinkFns(pre, post, attrStart, attrEnd) {
                                if (pre) {
                                    if (attrStart)
                                        pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                                    pre.require = directive.require;
                                    pre.directiveName = directiveName;
                                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                        pre = cloneAndAnnotateFn(pre, { isolateScope: true });
                                    }
                                    preLinkFns.push(pre);
                                }
                                if (post) {
                                    if (attrStart)
                                        post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                                    post.require = directive.require;
                                    post.directiveName = directiveName;
                                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                        post = cloneAndAnnotateFn(post, { isolateScope: true });
                                    }
                                    postLinkFns.push(post);
                                }
                            }
                            function getControllers(directiveName, require, $element, elementControllers) {
                                var value;
                                if (isString(require)) {
                                    var match = require.match(REQUIRE_PREFIX_REGEXP);
                                    var name = require.substring(match[0].length);
                                    var inheritType = match[1] || match[3];
                                    var optional = match[2] === '?';
                                    if (inheritType === '^^') {
                                        $element = $element.parent();
                                    } else {
                                        value = elementControllers && elementControllers[name];
                                        value = value && value.instance;
                                    }
                                    if (!value) {
                                        var dataName = '$' + name + 'Controller';
                                        value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                                    }
                                    if (!value && !optional) {
                                        throw $compileMinErr('ctreq', 'Controller \'{0}\', required by directive \'{1}\', can\'t be found!', name, directiveName);
                                    }
                                } else if (isArray(require)) {
                                    value = [];
                                    for (var i = 0, ii = require.length; i < ii; i++) {
                                        value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                                    }
                                }
                                return value || null;
                            }
                            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
                                var elementControllers = createMap();
                                for (var controllerKey in controllerDirectives) {
                                    var directive = controllerDirectives[controllerKey];
                                    var locals = {
                                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                        $element: $element,
                                        $attrs: attrs,
                                        $transclude: transcludeFn
                                    };
                                    var controller = directive.controller;
                                    if (controller == '@') {
                                        controller = attrs[directive.name];
                                    }
                                    var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                                    elementControllers[directive.name] = controllerInstance;
                                    $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                                }
                                return elementControllers;
                            }
                            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                                var linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, removeScopeBindingWatches, removeControllerBindingWatches;
                                if (compileNode === linkNode) {
                                    attrs = templateAttrs;
                                    $element = templateAttrs.$$element;
                                } else {
                                    $element = jqLite(linkNode);
                                    attrs = new Attributes($element, templateAttrs);
                                }
                                controllerScope = scope;
                                if (newIsolateScopeDirective) {
                                    isolateScope = scope.$new(true);
                                } else if (newScopeDirective) {
                                    controllerScope = scope.$parent;
                                }
                                if (boundTranscludeFn) {
                                    transcludeFn = controllersBoundTransclude;
                                    transcludeFn.$$boundTransclude = boundTranscludeFn;
                                }
                                if (controllerDirectives) {
                                    elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
                                }
                                if (newIsolateScopeDirective) {
                                    compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                                    compile.$$addScopeClass($element, true);
                                    isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                                    removeScopeBindingWatches = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                                    if (removeScopeBindingWatches) {
                                        isolateScope.$on('$destroy', removeScopeBindingWatches);
                                    }
                                }
                                for (var name in elementControllers) {
                                    var controllerDirective = controllerDirectives[name];
                                    var controller = elementControllers[name];
                                    var bindings = controllerDirective.$$bindings.bindToController;
                                    if (controller.identifier && bindings) {
                                        removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                    }
                                    var controllerResult = controller();
                                    if (controllerResult !== controller.instance) {
                                        controller.instance = controllerResult;
                                        $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                                        removeControllerBindingWatches && removeControllerBindingWatches();
                                        removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                    }
                                }
                                for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                                    linkFn = preLinkFns[i];
                                    invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                                }
                                var scopeToChild = scope;
                                if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                                    scopeToChild = isolateScope;
                                }
                                childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                                for (i = postLinkFns.length - 1; i >= 0; i--) {
                                    linkFn = postLinkFns[i];
                                    invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                                }
                                function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                                    var transcludeControllers;
                                    if (!isScope(scope)) {
                                        futureParentElement = cloneAttachFn;
                                        cloneAttachFn = scope;
                                        scope = undefined;
                                    }
                                    if (hasElementTranscludeDirective) {
                                        transcludeControllers = elementControllers;
                                    }
                                    if (!futureParentElement) {
                                        futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                                    }
                                    return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                }
                            }
                        }
                        function markDirectiveScope(directives, isolateScope, newScope) {
                            for (var j = 0, jj = directives.length; j < jj; j++) {
                                directives[j] = inherit(directives[j], {
                                    $$isolateScope: isolateScope,
                                    $$newScope: newScope
                                });
                            }
                        }
                        function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                            if (name === ignoreDirective)
                                return null;
                            var match = null;
                            if (hasDirectives.hasOwnProperty(name)) {
                                for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                    try {
                                        directive = directives[i];
                                        if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                            if (startAttrName) {
                                                directive = inherit(directive, {
                                                    $$start: startAttrName,
                                                    $$end: endAttrName
                                                });
                                            }
                                            if (!directive.$$bindings) {
                                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                                if (isObject(bindings.isolateScope)) {
                                                    directive.$$isolateBindings = bindings.isolateScope;
                                                }
                                            }
                                            tDirectives.push(directive);
                                            match = directive;
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            return match;
                        }
                        function directiveIsMultiElement(name) {
                            if (hasDirectives.hasOwnProperty(name)) {
                                for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                    directive = directives[i];
                                    if (directive.multiElement) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        }
                        function mergeTemplateAttributes(dst, src) {
                            var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                            forEach(dst, function (value, key) {
                                if (key.charAt(0) != '$') {
                                    if (src[key] && src[key] !== value) {
                                        value += (key === 'style' ? ';' : ' ') + src[key];
                                    }
                                    dst.$set(key, value, true, srcAttr[key]);
                                }
                            });
                            forEach(src, function (value, key) {
                                if (key == 'class') {
                                    safeAddClass($element, value);
                                    dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
                                } else if (key == 'style') {
                                    $element.attr('style', $element.attr('style') + ';' + value);
                                    dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
                                } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                                    dst[key] = value;
                                    dstAttr[key] = srcAttr[key];
                                }
                            });
                        }
                        function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                            var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                                    templateUrl: null,
                                    transclude: null,
                                    replace: null,
                                    $$originalDirective: origAsyncDirective
                                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                            $compileNode.empty();
                            $templateRequest(templateUrl).then(function (content) {
                                var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                                content = denormalizeTemplate(content);
                                if (origAsyncDirective.replace) {
                                    if (jqLiteIsTextNode(content)) {
                                        $template = [];
                                    } else {
                                        $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                                    }
                                    compileNode = $template[0];
                                    if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                        throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', origAsyncDirective.name, templateUrl);
                                    }
                                    tempTemplateAttrs = { $attr: {} };
                                    replaceWith($rootElement, $compileNode, compileNode);
                                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                    if (isObject(origAsyncDirective.scope)) {
                                        markDirectiveScope(templateDirectives, true);
                                    }
                                    directives = templateDirectives.concat(directives);
                                    mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                                } else {
                                    compileNode = beforeTemplateCompileNode;
                                    $compileNode.html(content);
                                }
                                directives.unshift(derivedSyncDirective);
                                afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                                forEach($rootElement, function (node, i) {
                                    if (node == compileNode) {
                                        $rootElement[i] = $compileNode[0];
                                    }
                                });
                                afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                                while (linkQueue.length) {
                                    var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                                    if (scope.$$destroyed)
                                        continue;
                                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                        var oldClasses = beforeTemplateLinkNode.className;
                                        if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                            linkNode = jqLiteClone(compileNode);
                                        }
                                        replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                                        safeAddClass(jqLite(linkNode), oldClasses);
                                    }
                                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                    } else {
                                        childBoundTranscludeFn = boundTranscludeFn;
                                    }
                                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                                }
                                linkQueue = null;
                            });
                            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                                var childBoundTranscludeFn = boundTranscludeFn;
                                if (scope.$$destroyed)
                                    return;
                                if (linkQueue) {
                                    linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                                } else {
                                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                    }
                                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                                }
                            };
                        }
                        function byPriority(a, b) {
                            var diff = b.priority - a.priority;
                            if (diff !== 0)
                                return diff;
                            if (a.name !== b.name)
                                return a.name < b.name ? -1 : 1;
                            return a.index - b.index;
                        }
                        function assertNoDuplicate(what, previousDirective, directive, element) {
                            function wrapModuleNameIfDefined(moduleName) {
                                return moduleName ? ' (module: ' + moduleName + ')' : '';
                            }
                            if (previousDirective) {
                                throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                            }
                        }
                        function addTextInterpolateDirective(directives, text) {
                            var interpolateFn = $interpolate(text, true);
                            if (interpolateFn) {
                                directives.push({
                                    priority: 0,
                                    compile: function textInterpolateCompileFn(templateNode) {
                                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                                        if (hasCompileParent)
                                            compile.$$addBindingClass(templateNodeParent);
                                        return function textInterpolateLinkFn(scope, node) {
                                            var parent = node.parent();
                                            if (!hasCompileParent)
                                                compile.$$addBindingClass(parent);
                                            compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                                node[0].nodeValue = value;
                                            });
                                        };
                                    }
                                });
                            }
                        }
                        function wrapTemplate(type, template) {
                            type = lowercase(type || 'html');
                            switch (type) {
                            case 'svg':
                            case 'math':
                                var wrapper = document.createElement('div');
                                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                                return wrapper.childNodes[0].childNodes;
                            default:
                                return template;
                            }
                        }
                        function getTrustedContext(node, attrNormalizedName) {
                            if (attrNormalizedName == 'srcdoc') {
                                return $sce.HTML;
                            }
                            var tag = nodeName_(node);
                            if (attrNormalizedName == 'xlinkHref' || tag == 'form' && attrNormalizedName == 'action' || tag != 'img' && (attrNormalizedName == 'src' || attrNormalizedName == 'ngSrc')) {
                                return $sce.RESOURCE_URL;
                            }
                        }
                        function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                            var trustedContext = getTrustedContext(node, name);
                            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
                            if (!interpolateFn)
                                return;
                            if (name === 'multiple' && nodeName_(node) === 'select') {
                                throw $compileMinErr('selmulti', 'Binding to the \'multiple\' attribute is not supported. Element: {0}', startingTag(node));
                            }
                            directives.push({
                                priority: 100,
                                compile: function () {
                                    return {
                                        pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                            var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                                throw $compileMinErr('nodomevents', 'Interpolations for HTML DOM event attributes are disallowed.  Please use the ' + 'ng- versions (such as ng-click instead of onclick) instead.');
                                            }
                                            var newValue = attr[name];
                                            if (newValue !== value) {
                                                interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                                value = newValue;
                                            }
                                            if (!interpolateFn)
                                                return;
                                            attr[name] = interpolateFn(scope);
                                            ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                            (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                                if (name === 'class' && newValue != oldValue) {
                                                    attr.$updateClass(newValue, oldValue);
                                                } else {
                                                    attr.$set(name, newValue);
                                                }
                                            });
                                        }
                                    };
                                }
                            });
                        }
                        function replaceWith($rootElement, elementsToRemove, newNode) {
                            var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                            if ($rootElement) {
                                for (i = 0, ii = $rootElement.length; i < ii; i++) {
                                    if ($rootElement[i] == firstElementToRemove) {
                                        $rootElement[i++] = newNode;
                                        for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                                            if (j2 < jj) {
                                                $rootElement[j] = $rootElement[j2];
                                            } else {
                                                delete $rootElement[j];
                                            }
                                        }
                                        $rootElement.length -= removeCount - 1;
                                        if ($rootElement.context === firstElementToRemove) {
                                            $rootElement.context = newNode;
                                        }
                                        break;
                                    }
                                }
                            }
                            if (parent) {
                                parent.replaceChild(newNode, firstElementToRemove);
                            }
                            var fragment = document.createDocumentFragment();
                            fragment.appendChild(firstElementToRemove);
                            if (jqLite.hasData(firstElementToRemove)) {
                                jqLite.data(newNode, jqLite.data(firstElementToRemove));
                                if (!jQuery) {
                                    delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                                } else {
                                    skipDestroyOnNextJQueryCleanData = true;
                                    jQuery.cleanData([firstElementToRemove]);
                                }
                            }
                            for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                                var element = elementsToRemove[k];
                                jqLite(element).remove();
                                fragment.appendChild(element);
                                delete elementsToRemove[k];
                            }
                            elementsToRemove[0] = newNode;
                            elementsToRemove.length = 1;
                        }
                        function cloneAndAnnotateFn(fn, annotation) {
                            return extend(function () {
                                return fn.apply(null, arguments);
                            }, fn, annotation);
                        }
                        function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                            try {
                                linkFn(scope, $element, attrs, controllers, transcludeFn);
                            } catch (e) {
                                $exceptionHandler(e, startingTag($element));
                            }
                        }
                        function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                            var removeWatchCollection = [];
                            forEach(bindings, function (definition, scopeName) {
                                var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare;
                                switch (mode) {
                                case '@':
                                    if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                                        destination[scopeName] = attrs[attrName] = void 0;
                                    }
                                    attrs.$observe(attrName, function (value) {
                                        if (isString(value)) {
                                            destination[scopeName] = value;
                                        }
                                    });
                                    attrs.$$observers[attrName].$$scope = scope;
                                    lastValue = attrs[attrName];
                                    if (isString(lastValue)) {
                                        destination[scopeName] = $interpolate(lastValue)(scope);
                                    } else if (isBoolean(lastValue)) {
                                        destination[scopeName] = lastValue;
                                    }
                                    break;
                                case '=':
                                    if (!hasOwnProperty.call(attrs, attrName)) {
                                        if (optional)
                                            break;
                                        attrs[attrName] = void 0;
                                    }
                                    if (optional && !attrs[attrName])
                                        break;
                                    parentGet = $parse(attrs[attrName]);
                                    if (parentGet.literal) {
                                        compare = equals;
                                    } else {
                                        compare = function (a, b) {
                                            return a === b || a !== a && b !== b;
                                        };
                                    }
                                    parentSet = parentGet.assign || function () {
                                        lastValue = destination[scopeName] = parentGet(scope);
                                        throw $compileMinErr('nonassign', 'Expression \'{0}\' in attribute \'{1}\' used with directive \'{2}\' is non-assignable!', attrs[attrName], attrName, directive.name);
                                    };
                                    lastValue = destination[scopeName] = parentGet(scope);
                                    var parentValueWatch = function parentValueWatch(parentValue) {
                                        if (!compare(parentValue, destination[scopeName])) {
                                            if (!compare(parentValue, lastValue)) {
                                                destination[scopeName] = parentValue;
                                            } else {
                                                parentSet(scope, parentValue = destination[scopeName]);
                                            }
                                        }
                                        return lastValue = parentValue;
                                    };
                                    parentValueWatch.$stateful = true;
                                    var removeWatch;
                                    if (definition.collection) {
                                        removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                    } else {
                                        removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                    }
                                    removeWatchCollection.push(removeWatch);
                                    break;
                                case '&':
                                    parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                                    if (parentGet === noop && optional)
                                        break;
                                    destination[scopeName] = function (locals) {
                                        return parentGet(scope, locals);
                                    };
                                    break;
                                }
                            });
                            return removeWatchCollection.length && function removeWatches() {
                                for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                                    removeWatchCollection[i]();
                                }
                            };
                        }
                    }
                ];
            }
            var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
            function directiveNormalize(name) {
                return camelCase(name.replace(PREFIX_REGEXP, ''));
            }
            function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
            }
            function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
            }
            function tokenDifference(str1, str2) {
                var values = '', tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
                outer:
                    for (var i = 0; i < tokens1.length; i++) {
                        var token = tokens1[i];
                        for (var j = 0; j < tokens2.length; j++) {
                            if (token == tokens2[j])
                                continue outer;
                        }
                        values += (values.length > 0 ? ' ' : '') + token;
                    }
                return values;
            }
            function removeComments(jqNodes) {
                jqNodes = jqLite(jqNodes);
                var i = jqNodes.length;
                if (i <= 1) {
                    return jqNodes;
                }
                while (i--) {
                    var node = jqNodes[i];
                    if (node.nodeType === NODE_TYPE_COMMENT) {
                        splice.call(jqNodes, i, 1);
                    }
                }
                return jqNodes;
            }
            var $controllerMinErr = minErr('$controller');
            var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
            function identifierForController(controller, ident) {
                if (ident && isString(ident))
                    return ident;
                if (isString(controller)) {
                    var match = CNTRL_REG.exec(controller);
                    if (match)
                        return match[3];
                }
            }
            function $ControllerProvider() {
                var controllers = {}, globals = false;
                this.register = function (name, constructor) {
                    assertNotHasOwnProperty(name, 'controller');
                    if (isObject(name)) {
                        extend(controllers, name);
                    } else {
                        controllers[name] = constructor;
                    }
                };
                this.allowGlobals = function () {
                    globals = true;
                };
                this.$get = [
                    '$injector',
                    '$window',
                    function ($injector, $window) {
                        return function (expression, locals, later, ident) {
                            var instance, match, constructor, identifier;
                            later = later === true;
                            if (ident && isString(ident)) {
                                identifier = ident;
                            }
                            if (isString(expression)) {
                                match = expression.match(CNTRL_REG);
                                if (!match) {
                                    throw $controllerMinErr('ctrlfmt', 'Badly formed controller string \'{0}\'. ' + 'Must match `__name__ as __id__` or `__name__`.', expression);
                                }
                                constructor = match[1], identifier = identifier || match[3];
                                expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                                assertArgFn(expression, constructor, true);
                            }
                            if (later) {
                                var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                                instance = Object.create(controllerPrototype || null);
                                if (identifier) {
                                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                                }
                                var instantiate;
                                return instantiate = extend(function () {
                                    var result = $injector.invoke(expression, instance, locals, constructor);
                                    if (result !== instance && (isObject(result) || isFunction(result))) {
                                        instance = result;
                                        if (identifier) {
                                            addIdentifier(locals, identifier, instance, constructor || expression.name);
                                        }
                                    }
                                    return instance;
                                }, {
                                    instance: instance,
                                    identifier: identifier
                                });
                            }
                            instance = $injector.instantiate(expression, locals, constructor);
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                            return instance;
                        };
                        function addIdentifier(locals, identifier, instance, name) {
                            if (!(locals && isObject(locals.$scope))) {
                                throw minErr('$controller')('noscp', 'Cannot export controller \'{0}\' as \'{1}\'! No $scope object provided via `locals`.', name, identifier);
                            }
                            locals.$scope[identifier] = instance;
                        }
                    }
                ];
            }
            function $DocumentProvider() {
                this.$get = [
                    '$window',
                    function (window) {
                        return jqLite(window.document);
                    }
                ];
            }
            function $ExceptionHandlerProvider() {
                this.$get = [
                    '$log',
                    function ($log) {
                        return function (exception, cause) {
                            $log.error.apply($log, arguments);
                        };
                    }
                ];
            }
            var $$ForceReflowProvider = function () {
                this.$get = [
                    '$document',
                    function ($document) {
                        return function (domNode) {
                            if (domNode) {
                                if (!domNode.nodeType && domNode instanceof jqLite) {
                                    domNode = domNode[0];
                                }
                            } else {
                                domNode = $document[0].body;
                            }
                            return domNode.offsetWidth + 1;
                        };
                    }
                ];
            };
            var APPLICATION_JSON = 'application/json';
            var CONTENT_TYPE_APPLICATION_JSON = { 'Content-Type': APPLICATION_JSON + ';charset=utf-8' };
            var JSON_START = /^\[|^\{(?!\{)/;
            var JSON_ENDS = {
                '[': /]$/,
                '{': /}$/
            };
            var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
            var $httpMinErr = minErr('$http');
            var $httpMinErrLegacyFn = function (method) {
                return function () {
                    throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
                };
            };
            function serializeValue(v) {
                if (isObject(v)) {
                    return isDate(v) ? v.toISOString() : toJson(v);
                }
                return v;
            }
            function $HttpParamSerializerProvider() {
                this.$get = function () {
                    return function ngParamSerializer(params) {
                        if (!params)
                            return '';
                        var parts = [];
                        forEachSorted(params, function (value, key) {
                            if (value === null || isUndefined(value))
                                return;
                            if (isArray(value)) {
                                forEach(value, function (v, k) {
                                    parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                                });
                            } else {
                                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
                            }
                        });
                        return parts.join('&');
                    };
                };
            }
            function $HttpParamSerializerJQLikeProvider() {
                this.$get = function () {
                    return function jQueryLikeParamSerializer(params) {
                        if (!params)
                            return '';
                        var parts = [];
                        serialize(params, '', true);
                        return parts.join('&');
                        function serialize(toSerialize, prefix, topLevel) {
                            if (toSerialize === null || isUndefined(toSerialize))
                                return;
                            if (isArray(toSerialize)) {
                                forEach(toSerialize, function (value, index) {
                                    serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                                });
                            } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                                forEachSorted(toSerialize, function (value, key) {
                                    serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                                });
                            } else {
                                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
                            }
                        }
                    };
                };
            }
            function defaultHttpResponseTransform(data, headers) {
                if (isString(data)) {
                    var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
                    if (tempData) {
                        var contentType = headers('Content-Type');
                        if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                            data = fromJson(tempData);
                        }
                    }
                }
                return data;
            }
            function isJsonLike(str) {
                var jsonStart = str.match(JSON_START);
                return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
            }
            function parseHeaders(headers) {
                var parsed = createMap(), i;
                function fillInParsed(key, val) {
                    if (key) {
                        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                    }
                }
                if (isString(headers)) {
                    forEach(headers.split('\n'), function (line) {
                        i = line.indexOf(':');
                        fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
                    });
                } else if (isObject(headers)) {
                    forEach(headers, function (headerVal, headerKey) {
                        fillInParsed(lowercase(headerKey), trim(headerVal));
                    });
                }
                return parsed;
            }
            function headersGetter(headers) {
                var headersObj;
                return function (name) {
                    if (!headersObj)
                        headersObj = parseHeaders(headers);
                    if (name) {
                        var value = headersObj[lowercase(name)];
                        if (value === void 0) {
                            value = null;
                        }
                        return value;
                    }
                    return headersObj;
                };
            }
            function transformData(data, headers, status, fns) {
                if (isFunction(fns)) {
                    return fns(data, headers, status);
                }
                forEach(fns, function (fn) {
                    data = fn(data, headers, status);
                });
                return data;
            }
            function isSuccess(status) {
                return 200 <= status && status < 300;
            }
            function $HttpProvider() {
                var defaults = this.defaults = {
                    transformResponse: [defaultHttpResponseTransform],
                    transformRequest: [function (d) {
                            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
                        }],
                    headers: {
                        common: { 'Accept': 'application/json, text/plain, */*' },
                        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                    },
                    xsrfCookieName: 'XSRF-TOKEN',
                    xsrfHeaderName: 'X-XSRF-TOKEN',
                    paramSerializer: '$httpParamSerializer'
                };
                var useApplyAsync = false;
                this.useApplyAsync = function (value) {
                    if (isDefined(value)) {
                        useApplyAsync = !!value;
                        return this;
                    }
                    return useApplyAsync;
                };
                var useLegacyPromise = true;
                this.useLegacyPromiseExtensions = function (value) {
                    if (isDefined(value)) {
                        useLegacyPromise = !!value;
                        return this;
                    }
                    return useLegacyPromise;
                };
                var interceptorFactories = this.interceptors = [];
                this.$get = [
                    '$httpBackend',
                    '$$cookieReader',
                    '$cacheFactory',
                    '$rootScope',
                    '$q',
                    '$injector',
                    function ($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
                        var defaultCache = $cacheFactory('$http');
                        defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                        var reversedInterceptors = [];
                        forEach(interceptorFactories, function (interceptorFactory) {
                            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                        });
                        function $http(requestConfig) {
                            if (!angular.isObject(requestConfig)) {
                                throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
                            }
                            if (!isString(requestConfig.url)) {
                                throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
                            }
                            var config = extend({
                                method: 'get',
                                transformRequest: defaults.transformRequest,
                                transformResponse: defaults.transformResponse,
                                paramSerializer: defaults.paramSerializer
                            }, requestConfig);
                            config.headers = mergeHeaders(requestConfig);
                            config.method = uppercase(config.method);
                            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                            var serverRequest = function (config) {
                                var headers = config.headers;
                                var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                                if (isUndefined(reqData)) {
                                    forEach(headers, function (value, header) {
                                        if (lowercase(header) === 'content-type') {
                                            delete headers[header];
                                        }
                                    });
                                }
                                if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                                    config.withCredentials = defaults.withCredentials;
                                }
                                return sendReq(config, reqData).then(transformResponse, transformResponse);
                            };
                            var chain = [
                                serverRequest,
                                undefined
                            ];
                            var promise = $q.when(config);
                            forEach(reversedInterceptors, function (interceptor) {
                                if (interceptor.request || interceptor.requestError) {
                                    chain.unshift(interceptor.request, interceptor.requestError);
                                }
                                if (interceptor.response || interceptor.responseError) {
                                    chain.push(interceptor.response, interceptor.responseError);
                                }
                            });
                            while (chain.length) {
                                var thenFn = chain.shift();
                                var rejectFn = chain.shift();
                                promise = promise.then(thenFn, rejectFn);
                            }
                            if (useLegacyPromise) {
                                promise.success = function (fn) {
                                    assertArgFn(fn, 'fn');
                                    promise.then(function (response) {
                                        fn(response.data, response.status, response.headers, config);
                                    });
                                    return promise;
                                };
                                promise.error = function (fn) {
                                    assertArgFn(fn, 'fn');
                                    promise.then(null, function (response) {
                                        fn(response.data, response.status, response.headers, config);
                                    });
                                    return promise;
                                };
                            } else {
                                promise.success = $httpMinErrLegacyFn('success');
                                promise.error = $httpMinErrLegacyFn('error');
                            }
                            return promise;
                            function transformResponse(response) {
                                var resp = extend({}, response);
                                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                                return isSuccess(response.status) ? resp : $q.reject(resp);
                            }
                            function executeHeaderFns(headers, config) {
                                var headerContent, processedHeaders = {};
                                forEach(headers, function (headerFn, header) {
                                    if (isFunction(headerFn)) {
                                        headerContent = headerFn(config);
                                        if (headerContent != null) {
                                            processedHeaders[header] = headerContent;
                                        }
                                    } else {
                                        processedHeaders[header] = headerFn;
                                    }
                                });
                                return processedHeaders;
                            }
                            function mergeHeaders(config) {
                                var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                                defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                                defaultHeadersIteration:
                                    for (defHeaderName in defHeaders) {
                                        lowercaseDefHeaderName = lowercase(defHeaderName);
                                        for (reqHeaderName in reqHeaders) {
                                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                                continue defaultHeadersIteration;
                                            }
                                        }
                                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                                    }
                                return executeHeaderFns(reqHeaders, shallowCopy(config));
                            }
                        }
                        $http.pendingRequests = [];
                        createShortMethods('get', 'delete', 'head', 'jsonp');
                        createShortMethodsWithData('post', 'put', 'patch');
                        $http.defaults = defaults;
                        return $http;
                        function createShortMethods(names) {
                            forEach(arguments, function (name) {
                                $http[name] = function (url, config) {
                                    return $http(extend({}, config || {}, {
                                        method: name,
                                        url: url
                                    }));
                                };
                            });
                        }
                        function createShortMethodsWithData(name) {
                            forEach(arguments, function (name) {
                                $http[name] = function (url, data, config) {
                                    return $http(extend({}, config || {}, {
                                        method: name,
                                        url: url,
                                        data: data
                                    }));
                                };
                            });
                        }
                        function sendReq(config, reqData) {
                            var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.paramSerializer(config.params));
                            $http.pendingRequests.push(config);
                            promise.then(removePendingReq, removePendingReq);
                            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
                                cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                            }
                            if (cache) {
                                cachedResp = cache.get(url);
                                if (isDefined(cachedResp)) {
                                    if (isPromiseLike(cachedResp)) {
                                        cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                                    } else {
                                        if (isArray(cachedResp)) {
                                            resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                                        } else {
                                            resolvePromise(cachedResp, 200, {}, 'OK');
                                        }
                                    }
                                } else {
                                    cache.put(url, promise);
                                }
                            }
                            if (isUndefined(cachedResp)) {
                                var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                                if (xsrfValue) {
                                    reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                                }
                                $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                            }
                            return promise;
                            function done(status, response, headersString, statusText) {
                                if (cache) {
                                    if (isSuccess(status)) {
                                        cache.put(url, [
                                            status,
                                            response,
                                            parseHeaders(headersString),
                                            statusText
                                        ]);
                                    } else {
                                        cache.remove(url);
                                    }
                                }
                                function resolveHttpPromise() {
                                    resolvePromise(response, status, headersString, statusText);
                                }
                                if (useApplyAsync) {
                                    $rootScope.$applyAsync(resolveHttpPromise);
                                } else {
                                    resolveHttpPromise();
                                    if (!$rootScope.$$phase)
                                        $rootScope.$apply();
                                }
                            }
                            function resolvePromise(response, status, headers, statusText) {
                                status = status >= -1 ? status : 0;
                                (isSuccess(status) ? deferred.resolve : deferred.reject)({
                                    data: response,
                                    status: status,
                                    headers: headersGetter(headers),
                                    config: config,
                                    statusText: statusText
                                });
                            }
                            function resolvePromiseWithResult(result) {
                                resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                            }
                            function removePendingReq() {
                                var idx = $http.pendingRequests.indexOf(config);
                                if (idx !== -1)
                                    $http.pendingRequests.splice(idx, 1);
                            }
                        }
                        function buildUrl(url, serializedParams) {
                            if (serializedParams.length > 0) {
                                url += (url.indexOf('?') == -1 ? '?' : '&') + serializedParams;
                            }
                            return url;
                        }
                    }
                ];
            }
            function $xhrFactoryProvider() {
                this.$get = function () {
                    return function createXhr() {
                        return new window.XMLHttpRequest();
                    };
                };
            }
            function $HttpBackendProvider() {
                this.$get = [
                    '$browser',
                    '$window',
                    '$document',
                    '$xhrFactory',
                    function ($browser, $window, $document, $xhrFactory) {
                        return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
                    }
                ];
            }
            function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
                return function (method, url, post, callback, headers, timeout, withCredentials, responseType) {
                    $browser.$$incOutstandingRequestCount();
                    url = url || $browser.url();
                    if (lowercase(method) == 'jsonp') {
                        var callbackId = '_' + (callbacks.counter++).toString(36);
                        callbacks[callbackId] = function (data) {
                            callbacks[callbackId].data = data;
                            callbacks[callbackId].called = true;
                        };
                        var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function (status, text) {
                            completeRequest(callback, status, callbacks[callbackId].data, '', text);
                            callbacks[callbackId] = noop;
                        });
                    } else {
                        var xhr = createXhr(method, url);
                        xhr.open(method, url, true);
                        forEach(headers, function (value, key) {
                            if (isDefined(value)) {
                                xhr.setRequestHeader(key, value);
                            }
                        });
                        xhr.onload = function requestLoaded() {
                            var statusText = xhr.statusText || '';
                            var response = 'response' in xhr ? xhr.response : xhr.responseText;
                            var status = xhr.status === 1223 ? 204 : xhr.status;
                            if (status === 0) {
                                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
                            }
                            completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                        };
                        var requestError = function () {
                            completeRequest(callback, -1, null, null, '');
                        };
                        xhr.onerror = requestError;
                        xhr.onabort = requestError;
                        if (withCredentials) {
                            xhr.withCredentials = true;
                        }
                        if (responseType) {
                            try {
                                xhr.responseType = responseType;
                            } catch (e) {
                                if (responseType !== 'json') {
                                    throw e;
                                }
                            }
                        }
                        xhr.send(isUndefined(post) ? null : post);
                    }
                    if (timeout > 0) {
                        var timeoutId = $browserDefer(timeoutRequest, timeout);
                    } else if (isPromiseLike(timeout)) {
                        timeout.then(timeoutRequest);
                    }
                    function timeoutRequest() {
                        jsonpDone && jsonpDone();
                        xhr && xhr.abort();
                    }
                    function completeRequest(callback, status, response, headersString, statusText) {
                        if (isDefined(timeoutId)) {
                            $browserDefer.cancel(timeoutId);
                        }
                        jsonpDone = xhr = null;
                        callback(status, response, headersString, statusText);
                        $browser.$$completeOutstandingRequest(noop);
                    }
                };
                function jsonpReq(url, callbackId, done) {
                    var script = rawDocument.createElement('script'), callback = null;
                    script.type = 'text/javascript';
                    script.src = url;
                    script.async = true;
                    callback = function (event) {
                        removeEventListenerFn(script, 'load', callback);
                        removeEventListenerFn(script, 'error', callback);
                        rawDocument.body.removeChild(script);
                        script = null;
                        var status = -1;
                        var text = 'unknown';
                        if (event) {
                            if (event.type === 'load' && !callbacks[callbackId].called) {
                                event = { type: 'error' };
                            }
                            text = event.type;
                            status = event.type === 'error' ? 404 : 200;
                        }
                        if (done) {
                            done(status, text);
                        }
                    };
                    addEventListenerFn(script, 'load', callback);
                    addEventListenerFn(script, 'error', callback);
                    rawDocument.body.appendChild(script);
                    return callback;
                }
            }
            var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
            $interpolateMinErr.throwNoconcat = function (text) {
                throw $interpolateMinErr('noconcat', 'Error while interpolating: {0}\nStrict Contextual Escaping disallows ' + 'interpolations that concatenate multiple expressions when a trusted value is ' + 'required.  See http://docs.angularjs.org/api/ng.$sce', text);
            };
            $interpolateMinErr.interr = function (text, err) {
                return $interpolateMinErr('interr', 'Can\'t interpolate: {0}\n{1}', text, err.toString());
            };
            function $InterpolateProvider() {
                var startSymbol = '{{';
                var endSymbol = '}}';
                this.startSymbol = function (value) {
                    if (value) {
                        startSymbol = value;
                        return this;
                    } else {
                        return startSymbol;
                    }
                };
                this.endSymbol = function (value) {
                    if (value) {
                        endSymbol = value;
                        return this;
                    } else {
                        return endSymbol;
                    }
                };
                this.$get = [
                    '$parse',
                    '$exceptionHandler',
                    '$sce',
                    function ($parse, $exceptionHandler, $sce) {
                        var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
                        function escape(ch) {
                            return '\\\\\\' + ch;
                        }
                        function unescapeText(text) {
                            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                        }
                        function stringify(value) {
                            if (value == null) {
                                return '';
                            }
                            switch (typeof value) {
                            case 'string':
                                break;
                            case 'number':
                                value = '' + value;
                                break;
                            default:
                                value = toJson(value);
                            }
                            return value;
                        }
                        function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                            allOrNothing = !!allOrNothing;
                            var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                            while (index < textLength) {
                                if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                                    if (index !== startIndex) {
                                        concat.push(unescapeText(text.substring(index, startIndex)));
                                    }
                                    exp = text.substring(startIndex + startSymbolLength, endIndex);
                                    expressions.push(exp);
                                    parseFns.push($parse(exp, parseStringifyInterceptor));
                                    index = endIndex + endSymbolLength;
                                    expressionPositions.push(concat.length);
                                    concat.push('');
                                } else {
                                    if (index !== textLength) {
                                        concat.push(unescapeText(text.substring(index)));
                                    }
                                    break;
                                }
                            }
                            if (trustedContext && concat.length > 1) {
                                $interpolateMinErr.throwNoconcat(text);
                            }
                            if (!mustHaveExpression || expressions.length) {
                                var compute = function (values) {
                                    for (var i = 0, ii = expressions.length; i < ii; i++) {
                                        if (allOrNothing && isUndefined(values[i]))
                                            return;
                                        concat[expressionPositions[i]] = values[i];
                                    }
                                    return concat.join('');
                                };
                                var getValue = function (value) {
                                    return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                                };
                                return extend(function interpolationFn(context) {
                                    var i = 0;
                                    var ii = expressions.length;
                                    var values = new Array(ii);
                                    try {
                                        for (; i < ii; i++) {
                                            values[i] = parseFns[i](context);
                                        }
                                        return compute(values);
                                    } catch (err) {
                                        $exceptionHandler($interpolateMinErr.interr(text, err));
                                    }
                                }, {
                                    exp: text,
                                    expressions: expressions,
                                    $$watchDelegate: function (scope, listener) {
                                        var lastValue;
                                        return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                            var currValue = compute(values);
                                            if (isFunction(listener)) {
                                                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                            }
                                            lastValue = currValue;
                                        });
                                    }
                                });
                            }
                            function parseStringifyInterceptor(value) {
                                try {
                                    value = getValue(value);
                                    return allOrNothing && !isDefined(value) ? value : stringify(value);
                                } catch (err) {
                                    $exceptionHandler($interpolateMinErr.interr(text, err));
                                }
                            }
                        }
                        $interpolate.startSymbol = function () {
                            return startSymbol;
                        };
                        $interpolate.endSymbol = function () {
                            return endSymbol;
                        };
                        return $interpolate;
                    }
                ];
            }
            function $IntervalProvider() {
                this.$get = [
                    '$rootScope',
                    '$window',
                    '$q',
                    '$$q',
                    function ($rootScope, $window, $q, $$q) {
                        var intervals = {};
                        function interval(fn, delay, count, invokeApply) {
                            var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                            count = isDefined(count) ? count : 0;
                            promise.then(null, null, !hasParams ? fn : function () {
                                fn.apply(null, args);
                            });
                            promise.$$intervalId = setInterval(function tick() {
                                deferred.notify(iteration++);
                                if (count > 0 && iteration >= count) {
                                    deferred.resolve(iteration);
                                    clearInterval(promise.$$intervalId);
                                    delete intervals[promise.$$intervalId];
                                }
                                if (!skipApply)
                                    $rootScope.$apply();
                            }, delay);
                            intervals[promise.$$intervalId] = deferred;
                            return promise;
                        }
                        interval.cancel = function (promise) {
                            if (promise && promise.$$intervalId in intervals) {
                                intervals[promise.$$intervalId].reject('canceled');
                                $window.clearInterval(promise.$$intervalId);
                                delete intervals[promise.$$intervalId];
                                return true;
                            }
                            return false;
                        };
                        return interval;
                    }
                ];
            }
            var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
                    'http': 80,
                    'https': 443,
                    'ftp': 21
                };
            var $locationMinErr = minErr('$location');
            function encodePath(path) {
                var segments = path.split('/'), i = segments.length;
                while (i--) {
                    segments[i] = encodeUriSegment(segments[i]);
                }
                return segments.join('/');
            }
            function parseAbsoluteUrl(absoluteUrl, locationObj) {
                var parsedUrl = urlResolve(absoluteUrl);
                locationObj.$$protocol = parsedUrl.protocol;
                locationObj.$$host = parsedUrl.hostname;
                locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
            }
            function parseAppUrl(relativeUrl, locationObj) {
                var prefixed = relativeUrl.charAt(0) !== '/';
                if (prefixed) {
                    relativeUrl = '/' + relativeUrl;
                }
                var match = urlResolve(relativeUrl);
                locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
                locationObj.$$search = parseKeyValue(match.search);
                locationObj.$$hash = decodeURIComponent(match.hash);
                if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
                    locationObj.$$path = '/' + locationObj.$$path;
                }
            }
            function beginsWith(begin, whole) {
                if (whole.indexOf(begin) === 0) {
                    return whole.substr(begin.length);
                }
            }
            function stripHash(url) {
                var index = url.indexOf('#');
                return index == -1 ? url : url.substr(0, index);
            }
            function trimEmptyHash(url) {
                return url.replace(/(#.+)|#$/, '$1');
            }
            function stripFile(url) {
                return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
            }
            function serverBase(url) {
                return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
            }
            function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
                this.$$html5 = true;
                basePrefix = basePrefix || '';
                parseAbsoluteUrl(appBase, this);
                this.$$parse = function (url) {
                    var pathUrl = beginsWith(appBaseNoFile, url);
                    if (!isString(pathUrl)) {
                        throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                    }
                    parseAppUrl(pathUrl, this);
                    if (!this.$$path) {
                        this.$$path = '/';
                    }
                    this.$$compose();
                };
                this.$$compose = function () {
                    var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                    this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
                };
                this.$$parseLinkUrl = function (url, relHref) {
                    if (relHref && relHref[0] === '#') {
                        this.hash(relHref.slice(1));
                        return true;
                    }
                    var appUrl, prevAppUrl;
                    var rewrittenUrl;
                    if (isDefined(appUrl = beginsWith(appBase, url))) {
                        prevAppUrl = appUrl;
                        if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
                            rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
                        } else {
                            rewrittenUrl = appBase + prevAppUrl;
                        }
                    } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
                        rewrittenUrl = appBaseNoFile + appUrl;
                    } else if (appBaseNoFile == url + '/') {
                        rewrittenUrl = appBaseNoFile;
                    }
                    if (rewrittenUrl) {
                        this.$$parse(rewrittenUrl);
                    }
                    return !!rewrittenUrl;
                };
            }
            function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
                parseAbsoluteUrl(appBase, this);
                this.$$parse = function (url) {
                    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
                    var withoutHashUrl;
                    if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
                        withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
                        if (isUndefined(withoutHashUrl)) {
                            withoutHashUrl = withoutBaseUrl;
                        }
                    } else {
                        if (this.$$html5) {
                            withoutHashUrl = withoutBaseUrl;
                        } else {
                            withoutHashUrl = '';
                            if (isUndefined(withoutBaseUrl)) {
                                appBase = url;
                                this.replace();
                            }
                        }
                    }
                    parseAppUrl(withoutHashUrl, this);
                    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
                    this.$$compose();
                    function removeWindowsDriveName(path, url, base) {
                        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                        var firstPathSegmentMatch;
                        if (url.indexOf(base) === 0) {
                            url = url.replace(base, '');
                        }
                        if (windowsFilePathExp.exec(url)) {
                            return path;
                        }
                        firstPathSegmentMatch = windowsFilePathExp.exec(path);
                        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
                    }
                };
                this.$$compose = function () {
                    var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
                };
                this.$$parseLinkUrl = function (url, relHref) {
                    if (stripHash(appBase) == stripHash(url)) {
                        this.$$parse(url);
                        return true;
                    }
                    return false;
                };
            }
            function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
                this.$$html5 = true;
                LocationHashbangUrl.apply(this, arguments);
                this.$$parseLinkUrl = function (url, relHref) {
                    if (relHref && relHref[0] === '#') {
                        this.hash(relHref.slice(1));
                        return true;
                    }
                    var rewrittenUrl;
                    var appUrl;
                    if (appBase == stripHash(url)) {
                        rewrittenUrl = url;
                    } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                        rewrittenUrl = appBase + hashPrefix + appUrl;
                    } else if (appBaseNoFile === url + '/') {
                        rewrittenUrl = appBaseNoFile;
                    }
                    if (rewrittenUrl) {
                        this.$$parse(rewrittenUrl);
                    }
                    return !!rewrittenUrl;
                };
                this.$$compose = function () {
                    var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                    this.$$absUrl = appBase + hashPrefix + this.$$url;
                };
            }
            var locationPrototype = {
                $$html5: false,
                $$replace: false,
                absUrl: locationGetter('$$absUrl'),
                url: function (url) {
                    if (isUndefined(url)) {
                        return this.$$url;
                    }
                    var match = PATH_MATCH.exec(url);
                    if (match[1] || url === '')
                        this.path(decodeURIComponent(match[1]));
                    if (match[2] || match[1] || url === '')
                        this.search(match[3] || '');
                    this.hash(match[5] || '');
                    return this;
                },
                protocol: locationGetter('$$protocol'),
                host: locationGetter('$$host'),
                port: locationGetter('$$port'),
                path: locationGetterSetter('$$path', function (path) {
                    path = path !== null ? path.toString() : '';
                    return path.charAt(0) == '/' ? path : '/' + path;
                }),
                search: function (search, paramValue) {
                    switch (arguments.length) {
                    case 0:
                        return this.$$search;
                    case 1:
                        if (isString(search) || isNumber(search)) {
                            search = search.toString();
                            this.$$search = parseKeyValue(search);
                        } else if (isObject(search)) {
                            search = copy(search, {});
                            forEach(search, function (value, key) {
                                if (value == null)
                                    delete search[key];
                            });
                            this.$$search = search;
                        } else {
                            throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
                        }
                        break;
                    default:
                        if (isUndefined(paramValue) || paramValue === null) {
                            delete this.$$search[search];
                        } else {
                            this.$$search[search] = paramValue;
                        }
                    }
                    this.$$compose();
                    return this;
                },
                hash: locationGetterSetter('$$hash', function (hash) {
                    return hash !== null ? hash.toString() : '';
                }),
                replace: function () {
                    this.$$replace = true;
                    return this;
                }
            };
            forEach([
                LocationHashbangInHtml5Url,
                LocationHashbangUrl,
                LocationHtml5Url
            ], function (Location) {
                Location.prototype = Object.create(locationPrototype);
                Location.prototype.state = function (state) {
                    if (!arguments.length) {
                        return this.$$state;
                    }
                    if (Location !== LocationHtml5Url || !this.$$html5) {
                        throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
                    }
                    this.$$state = isUndefined(state) ? null : state;
                    return this;
                };
            });
            function locationGetter(property) {
                return function () {
                    return this[property];
                };
            }
            function locationGetterSetter(property, preprocess) {
                return function (value) {
                    if (isUndefined(value)) {
                        return this[property];
                    }
                    this[property] = preprocess(value);
                    this.$$compose();
                    return this;
                };
            }
            function $LocationProvider() {
                var hashPrefix = '', html5Mode = {
                        enabled: false,
                        requireBase: true,
                        rewriteLinks: true
                    };
                this.hashPrefix = function (prefix) {
                    if (isDefined(prefix)) {
                        hashPrefix = prefix;
                        return this;
                    } else {
                        return hashPrefix;
                    }
                };
                this.html5Mode = function (mode) {
                    if (isBoolean(mode)) {
                        html5Mode.enabled = mode;
                        return this;
                    } else if (isObject(mode)) {
                        if (isBoolean(mode.enabled)) {
                            html5Mode.enabled = mode.enabled;
                        }
                        if (isBoolean(mode.requireBase)) {
                            html5Mode.requireBase = mode.requireBase;
                        }
                        if (isBoolean(mode.rewriteLinks)) {
                            html5Mode.rewriteLinks = mode.rewriteLinks;
                        }
                        return this;
                    } else {
                        return html5Mode;
                    }
                };
                this.$get = [
                    '$rootScope',
                    '$browser',
                    '$sniffer',
                    '$rootElement',
                    '$window',
                    function ($rootScope, $browser, $sniffer, $rootElement, $window) {
                        var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
                        if (html5Mode.enabled) {
                            if (!baseHref && html5Mode.requireBase) {
                                throw $locationMinErr('nobase', '$location in HTML5 mode requires a <base> tag to be present!');
                            }
                            appBase = serverBase(initialUrl) + (baseHref || '/');
                            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                        } else {
                            appBase = stripHash(initialUrl);
                            LocationMode = LocationHashbangUrl;
                        }
                        var appBaseNoFile = stripFile(appBase);
                        $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
                        $location.$$parseLinkUrl(initialUrl, initialUrl);
                        $location.$$state = $browser.state();
                        var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                        function setBrowserUrlWithFallback(url, replace, state) {
                            var oldUrl = $location.url();
                            var oldState = $location.$$state;
                            try {
                                $browser.url(url, replace, state);
                                $location.$$state = $browser.state();
                            } catch (e) {
                                $location.url(oldUrl);
                                $location.$$state = oldState;
                                throw e;
                            }
                        }
                        $rootElement.on('click', function (event) {
                            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
                                return;
                            var elm = jqLite(event.target);
                            while (nodeName_(elm[0]) !== 'a') {
                                if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                                    return;
                            }
                            var absHref = elm.prop('href');
                            var relHref = elm.attr('href') || elm.attr('xlink:href');
                            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
                                absHref = urlResolve(absHref.animVal).href;
                            }
                            if (IGNORE_URI_REGEXP.test(absHref))
                                return;
                            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
                                if ($location.$$parseLinkUrl(absHref, relHref)) {
                                    event.preventDefault();
                                    if ($location.absUrl() != $browser.url()) {
                                        $rootScope.$apply();
                                        $window.angular['ff-684208-preventDefault'] = true;
                                    }
                                }
                            }
                        });
                        if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
                            $browser.url($location.absUrl(), true);
                        }
                        var initializing = true;
                        $browser.onUrlChange(function (newUrl, newState) {
                            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
                                $window.location.href = newUrl;
                                return;
                            }
                            $rootScope.$evalAsync(function () {
                                var oldUrl = $location.absUrl();
                                var oldState = $location.$$state;
                                var defaultPrevented;
                                newUrl = trimEmptyHash(newUrl);
                                $location.$$parse(newUrl);
                                $location.$$state = newState;
                                defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
                                if ($location.absUrl() !== newUrl)
                                    return;
                                if (defaultPrevented) {
                                    $location.$$parse(oldUrl);
                                    $location.$$state = oldState;
                                    setBrowserUrlWithFallback(oldUrl, false, oldState);
                                } else {
                                    initializing = false;
                                    afterLocationChange(oldUrl, oldState);
                                }
                            });
                            if (!$rootScope.$$phase)
                                $rootScope.$digest();
                        });
                        $rootScope.$watch(function $locationWatch() {
                            var oldUrl = trimEmptyHash($browser.url());
                            var newUrl = trimEmptyHash($location.absUrl());
                            var oldState = $browser.state();
                            var currentReplace = $location.$$replace;
                            var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                            if (initializing || urlOrStateChanged) {
                                initializing = false;
                                $rootScope.$evalAsync(function () {
                                    var newUrl = $location.absUrl();
                                    var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                                    if ($location.absUrl() !== newUrl)
                                        return;
                                    if (defaultPrevented) {
                                        $location.$$parse(oldUrl);
                                        $location.$$state = oldState;
                                    } else {
                                        if (urlOrStateChanged) {
                                            setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                                        }
                                        afterLocationChange(oldUrl, oldState);
                                    }
                                });
                            }
                            $location.$$replace = false;
                        });
                        return $location;
                        function afterLocationChange(oldUrl, oldState) {
                            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
                        }
                    }
                ];
            }
            function $LogProvider() {
                var debug = true, self = this;
                this.debugEnabled = function (flag) {
                    if (isDefined(flag)) {
                        debug = flag;
                        return this;
                    } else {
                        return debug;
                    }
                };
                this.$get = [
                    '$window',
                    function ($window) {
                        return {
                            log: consoleLog('log'),
                            info: consoleLog('info'),
                            warn: consoleLog('warn'),
                            error: consoleLog('error'),
                            debug: function () {
                                var fn = consoleLog('debug');
                                return function () {
                                    if (debug) {
                                        fn.apply(self, arguments);
                                    }
                                };
                            }()
                        };
                        function formatError(arg) {
                            if (arg instanceof Error) {
                                if (arg.stack) {
                                    arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
                                } else if (arg.sourceURL) {
                                    arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
                                }
                            }
                            return arg;
                        }
                        function consoleLog(type) {
                            var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                            try {
                                hasApply = !!logFn.apply;
                            } catch (e) {
                            }
                            if (hasApply) {
                                return function () {
                                    var args = [];
                                    forEach(arguments, function (arg) {
                                        args.push(formatError(arg));
                                    });
                                    return logFn.apply(console, args);
                                };
                            }
                            return function (arg1, arg2) {
                                logFn(arg1, arg2 == null ? '' : arg2);
                            };
                        }
                    }
                ];
            }
            var $parseMinErr = minErr('$parse');
            function ensureSafeMemberName(name, fullExpression) {
                if (name === '__defineGetter__' || name === '__defineSetter__' || name === '__lookupGetter__' || name === '__lookupSetter__' || name === '__proto__') {
                    throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
                }
                return name;
            }
            function getStringValue(name, fullExpression) {
                name = name + '';
                if (!isString(name)) {
                    throw $parseMinErr('iseccst', 'Cannot convert object to primitive value! ' + 'Expression: {0}', fullExpression);
                }
                return name;
            }
            function ensureSafeObject(obj, fullExpression) {
                if (obj) {
                    if (obj.constructor === obj) {
                        throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
                    } else if (obj.window === obj) {
                        throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
                    } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                        throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
                    } else if (obj === Object) {
                        throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
                    }
                }
                return obj;
            }
            var CALL = Function.prototype.call;
            var APPLY = Function.prototype.apply;
            var BIND = Function.prototype.bind;
            function ensureSafeFunction(obj, fullExpression) {
                if (obj) {
                    if (obj.constructor === obj) {
                        throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
                    } else if (obj === CALL || obj === APPLY || obj === BIND) {
                        throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
                    }
                }
            }
            function ensureSafeAssignContext(obj, fullExpression) {
                if (obj) {
                    if (obj === 0..constructor || obj === false.constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
                        throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
                    }
                }
            }
            var OPERATORS = createMap();
            forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (operator) {
                OPERATORS[operator] = true;
            });
            var ESCAPE = {
                'n': '\n',
                'f': '\f',
                'r': '\r',
                't': '\t',
                'v': '\x0B',
                '\'': '\'',
                '"': '"'
            };
            var Lexer = function (options) {
                this.options = options;
            };
            Lexer.prototype = {
                constructor: Lexer,
                lex: function (text) {
                    this.text = text;
                    this.index = 0;
                    this.tokens = [];
                    while (this.index < this.text.length) {
                        var ch = this.text.charAt(this.index);
                        if (ch === '"' || ch === '\'') {
                            this.readString(ch);
                        } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
                            this.readNumber();
                        } else if (this.isIdent(ch)) {
                            this.readIdent();
                        } else if (this.is(ch, '(){}[].,;:?')) {
                            this.tokens.push({
                                index: this.index,
                                text: ch
                            });
                            this.index++;
                        } else if (this.isWhitespace(ch)) {
                            this.index++;
                        } else {
                            var ch2 = ch + this.peek();
                            var ch3 = ch2 + this.peek(2);
                            var op1 = OPERATORS[ch];
                            var op2 = OPERATORS[ch2];
                            var op3 = OPERATORS[ch3];
                            if (op1 || op2 || op3) {
                                var token = op3 ? ch3 : op2 ? ch2 : ch;
                                this.tokens.push({
                                    index: this.index,
                                    text: token,
                                    operator: true
                                });
                                this.index += token.length;
                            } else {
                                this.throwError('Unexpected next character ', this.index, this.index + 1);
                            }
                        }
                    }
                    return this.tokens;
                },
                is: function (ch, chars) {
                    return chars.indexOf(ch) !== -1;
                },
                peek: function (i) {
                    var num = i || 1;
                    return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
                },
                isNumber: function (ch) {
                    return '0' <= ch && ch <= '9' && typeof ch === 'string';
                },
                isWhitespace: function (ch) {
                    return ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\x0B' || ch === '\xA0';
                },
                isIdent: function (ch) {
                    return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$';
                },
                isExpOperator: function (ch) {
                    return ch === '-' || ch === '+' || this.isNumber(ch);
                },
                throwError: function (error, start, end) {
                    end = end || this.index;
                    var colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end;
                    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
                },
                readNumber: function () {
                    var number = '';
                    var start = this.index;
                    while (this.index < this.text.length) {
                        var ch = lowercase(this.text.charAt(this.index));
                        if (ch == '.' || this.isNumber(ch)) {
                            number += ch;
                        } else {
                            var peekCh = this.peek();
                            if (ch == 'e' && this.isExpOperator(peekCh)) {
                                number += ch;
                            } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                                number += ch;
                            } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                                this.throwError('Invalid exponent');
                            } else {
                                break;
                            }
                        }
                        this.index++;
                    }
                    this.tokens.push({
                        index: start,
                        text: number,
                        constant: true,
                        value: Number(number)
                    });
                },
                readIdent: function () {
                    var start = this.index;
                    while (this.index < this.text.length) {
                        var ch = this.text.charAt(this.index);
                        if (!(this.isIdent(ch) || this.isNumber(ch))) {
                            break;
                        }
                        this.index++;
                    }
                    this.tokens.push({
                        index: start,
                        text: this.text.slice(start, this.index),
                        identifier: true
                    });
                },
                readString: function (quote) {
                    var start = this.index;
                    this.index++;
                    var string = '';
                    var rawString = quote;
                    var escape = false;
                    while (this.index < this.text.length) {
                        var ch = this.text.charAt(this.index);
                        rawString += ch;
                        if (escape) {
                            if (ch === 'u') {
                                var hex = this.text.substring(this.index + 1, this.index + 5);
                                if (!hex.match(/[\da-f]{4}/i)) {
                                    this.throwError('Invalid unicode escape [\\u' + hex + ']');
                                }
                                this.index += 4;
                                string += String.fromCharCode(parseInt(hex, 16));
                            } else {
                                var rep = ESCAPE[ch];
                                string = string + (rep || ch);
                            }
                            escape = false;
                        } else if (ch === '\\') {
                            escape = true;
                        } else if (ch === quote) {
                            this.index++;
                            this.tokens.push({
                                index: start,
                                text: rawString,
                                constant: true,
                                value: string
                            });
                            return;
                        } else {
                            string += ch;
                        }
                        this.index++;
                    }
                    this.throwError('Unterminated quote', start);
                }
            };
            var AST = function (lexer, options) {
                this.lexer = lexer;
                this.options = options;
            };
            AST.Program = 'Program';
            AST.ExpressionStatement = 'ExpressionStatement';
            AST.AssignmentExpression = 'AssignmentExpression';
            AST.ConditionalExpression = 'ConditionalExpression';
            AST.LogicalExpression = 'LogicalExpression';
            AST.BinaryExpression = 'BinaryExpression';
            AST.UnaryExpression = 'UnaryExpression';
            AST.CallExpression = 'CallExpression';
            AST.MemberExpression = 'MemberExpression';
            AST.Identifier = 'Identifier';
            AST.Literal = 'Literal';
            AST.ArrayExpression = 'ArrayExpression';
            AST.Property = 'Property';
            AST.ObjectExpression = 'ObjectExpression';
            AST.ThisExpression = 'ThisExpression';
            AST.NGValueParameter = 'NGValueParameter';
            AST.prototype = {
                ast: function (text) {
                    this.text = text;
                    this.tokens = this.lexer.lex(text);
                    var value = this.program();
                    if (this.tokens.length !== 0) {
                        this.throwError('is an unexpected token', this.tokens[0]);
                    }
                    return value;
                },
                program: function () {
                    var body = [];
                    while (true) {
                        if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
                            body.push(this.expressionStatement());
                        if (!this.expect(';')) {
                            return {
                                type: AST.Program,
                                body: body
                            };
                        }
                    }
                },
                expressionStatement: function () {
                    return {
                        type: AST.ExpressionStatement,
                        expression: this.filterChain()
                    };
                },
                filterChain: function () {
                    var left = this.expression();
                    var token;
                    while (token = this.expect('|')) {
                        left = this.filter(left);
                    }
                    return left;
                },
                expression: function () {
                    return this.assignment();
                },
                assignment: function () {
                    var result = this.ternary();
                    if (this.expect('=')) {
                        result = {
                            type: AST.AssignmentExpression,
                            left: result,
                            right: this.assignment(),
                            operator: '='
                        };
                    }
                    return result;
                },
                ternary: function () {
                    var test = this.logicalOR();
                    var alternate;
                    var consequent;
                    if (this.expect('?')) {
                        alternate = this.expression();
                        if (this.consume(':')) {
                            consequent = this.expression();
                            return {
                                type: AST.ConditionalExpression,
                                test: test,
                                alternate: alternate,
                                consequent: consequent
                            };
                        }
                    }
                    return test;
                },
                logicalOR: function () {
                    var left = this.logicalAND();
                    while (this.expect('||')) {
                        left = {
                            type: AST.LogicalExpression,
                            operator: '||',
                            left: left,
                            right: this.logicalAND()
                        };
                    }
                    return left;
                },
                logicalAND: function () {
                    var left = this.equality();
                    while (this.expect('&&')) {
                        left = {
                            type: AST.LogicalExpression,
                            operator: '&&',
                            left: left,
                            right: this.equality()
                        };
                    }
                    return left;
                },
                equality: function () {
                    var left = this.relational();
                    var token;
                    while (token = this.expect('==', '!=', '===', '!==')) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.relational()
                        };
                    }
                    return left;
                },
                relational: function () {
                    var left = this.additive();
                    var token;
                    while (token = this.expect('<', '>', '<=', '>=')) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.additive()
                        };
                    }
                    return left;
                },
                additive: function () {
                    var left = this.multiplicative();
                    var token;
                    while (token = this.expect('+', '-')) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.multiplicative()
                        };
                    }
                    return left;
                },
                multiplicative: function () {
                    var left = this.unary();
                    var token;
                    while (token = this.expect('*', '/', '%')) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.unary()
                        };
                    }
                    return left;
                },
                unary: function () {
                    var token;
                    if (token = this.expect('+', '-', '!')) {
                        return {
                            type: AST.UnaryExpression,
                            operator: token.text,
                            prefix: true,
                            argument: this.unary()
                        };
                    } else {
                        return this.primary();
                    }
                },
                primary: function () {
                    var primary;
                    if (this.expect('(')) {
                        primary = this.filterChain();
                        this.consume(')');
                    } else if (this.expect('[')) {
                        primary = this.arrayDeclaration();
                    } else if (this.expect('{')) {
                        primary = this.object();
                    } else if (this.constants.hasOwnProperty(this.peek().text)) {
                        primary = copy(this.constants[this.consume().text]);
                    } else if (this.peek().identifier) {
                        primary = this.identifier();
                    } else if (this.peek().constant) {
                        primary = this.constant();
                    } else {
                        this.throwError('not a primary expression', this.peek());
                    }
                    var next;
                    while (next = this.expect('(', '[', '.')) {
                        if (next.text === '(') {
                            primary = {
                                type: AST.CallExpression,
                                callee: primary,
                                arguments: this.parseArguments()
                            };
                            this.consume(')');
                        } else if (next.text === '[') {
                            primary = {
                                type: AST.MemberExpression,
                                object: primary,
                                property: this.expression(),
                                computed: true
                            };
                            this.consume(']');
                        } else if (next.text === '.') {
                            primary = {
                                type: AST.MemberExpression,
                                object: primary,
                                property: this.identifier(),
                                computed: false
                            };
                        } else {
                            this.throwError('IMPOSSIBLE');
                        }
                    }
                    return primary;
                },
                filter: function (baseExpression) {
                    var args = [baseExpression];
                    var result = {
                        type: AST.CallExpression,
                        callee: this.identifier(),
                        arguments: args,
                        filter: true
                    };
                    while (this.expect(':')) {
                        args.push(this.expression());
                    }
                    return result;
                },
                parseArguments: function () {
                    var args = [];
                    if (this.peekToken().text !== ')') {
                        do {
                            args.push(this.expression());
                        } while (this.expect(','));
                    }
                    return args;
                },
                identifier: function () {
                    var token = this.consume();
                    if (!token.identifier) {
                        this.throwError('is not a valid identifier', token);
                    }
                    return {
                        type: AST.Identifier,
                        name: token.text
                    };
                },
                constant: function () {
                    return {
                        type: AST.Literal,
                        value: this.consume().value
                    };
                },
                arrayDeclaration: function () {
                    var elements = [];
                    if (this.peekToken().text !== ']') {
                        do {
                            if (this.peek(']')) {
                                break;
                            }
                            elements.push(this.expression());
                        } while (this.expect(','));
                    }
                    this.consume(']');
                    return {
                        type: AST.ArrayExpression,
                        elements: elements
                    };
                },
                object: function () {
                    var properties = [], property;
                    if (this.peekToken().text !== '}') {
                        do {
                            if (this.peek('}')) {
                                break;
                            }
                            property = {
                                type: AST.Property,
                                kind: 'init'
                            };
                            if (this.peek().constant) {
                                property.key = this.constant();
                            } else if (this.peek().identifier) {
                                property.key = this.identifier();
                            } else {
                                this.throwError('invalid key', this.peek());
                            }
                            this.consume(':');
                            property.value = this.expression();
                            properties.push(property);
                        } while (this.expect(','));
                    }
                    this.consume('}');
                    return {
                        type: AST.ObjectExpression,
                        properties: properties
                    };
                },
                throwError: function (msg, token) {
                    throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
                },
                consume: function (e1) {
                    if (this.tokens.length === 0) {
                        throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
                    }
                    var token = this.expect(e1);
                    if (!token) {
                        this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
                    }
                    return token;
                },
                peekToken: function () {
                    if (this.tokens.length === 0) {
                        throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
                    }
                    return this.tokens[0];
                },
                peek: function (e1, e2, e3, e4) {
                    return this.peekAhead(0, e1, e2, e3, e4);
                },
                peekAhead: function (i, e1, e2, e3, e4) {
                    if (this.tokens.length > i) {
                        var token = this.tokens[i];
                        var t = token.text;
                        if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                            return token;
                        }
                    }
                    return false;
                },
                expect: function (e1, e2, e3, e4) {
                    var token = this.peek(e1, e2, e3, e4);
                    if (token) {
                        this.tokens.shift();
                        return token;
                    }
                    return false;
                },
                constants: {
                    'true': {
                        type: AST.Literal,
                        value: true
                    },
                    'false': {
                        type: AST.Literal,
                        value: false
                    },
                    'null': {
                        type: AST.Literal,
                        value: null
                    },
                    'undefined': {
                        type: AST.Literal,
                        value: undefined
                    },
                    'this': { type: AST.ThisExpression }
                }
            };
            function ifDefined(v, d) {
                return typeof v !== 'undefined' ? v : d;
            }
            function plusFn(l, r) {
                if (typeof l === 'undefined')
                    return r;
                if (typeof r === 'undefined')
                    return l;
                return l + r;
            }
            function isStateless($filter, filterName) {
                var fn = $filter(filterName);
                return !fn.$stateful;
            }
            function findConstantAndWatchExpressions(ast, $filter) {
                var allConstants;
                var argsToWatch;
                switch (ast.type) {
                case AST.Program:
                    allConstants = true;
                    forEach(ast.body, function (expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter);
                        allConstants = allConstants && expr.expression.constant;
                    });
                    ast.constant = allConstants;
                    break;
                case AST.Literal:
                    ast.constant = true;
                    ast.toWatch = [];
                    break;
                case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter);
                    ast.constant = ast.argument.constant;
                    ast.toWatch = ast.argument.toWatch;
                    break;
                case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter);
                    findConstantAndWatchExpressions(ast.right, $filter);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;
                case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter);
                    findConstantAndWatchExpressions(ast.right, $filter);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter);
                    findConstantAndWatchExpressions(ast.alternate, $filter);
                    findConstantAndWatchExpressions(ast.consequent, $filter);
                    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
                    ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.Identifier:
                    ast.constant = false;
                    ast.toWatch = [ast];
                    break;
                case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter);
                    if (ast.computed) {
                        findConstantAndWatchExpressions(ast.property, $filter);
                    }
                    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
                    ast.toWatch = [ast];
                    break;
                case AST.CallExpression:
                    allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
                    argsToWatch = [];
                    forEach(ast.arguments, function (expr) {
                        findConstantAndWatchExpressions(expr, $filter);
                        allConstants = allConstants && expr.constant;
                        if (!expr.constant) {
                            argsToWatch.push.apply(argsToWatch, expr.toWatch);
                        }
                    });
                    ast.constant = allConstants;
                    ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
                    break;
                case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter);
                    findConstantAndWatchExpressions(ast.right, $filter);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = [ast];
                    break;
                case AST.ArrayExpression:
                    allConstants = true;
                    argsToWatch = [];
                    forEach(ast.elements, function (expr) {
                        findConstantAndWatchExpressions(expr, $filter);
                        allConstants = allConstants && expr.constant;
                        if (!expr.constant) {
                            argsToWatch.push.apply(argsToWatch, expr.toWatch);
                        }
                    });
                    ast.constant = allConstants;
                    ast.toWatch = argsToWatch;
                    break;
                case AST.ObjectExpression:
                    allConstants = true;
                    argsToWatch = [];
                    forEach(ast.properties, function (property) {
                        findConstantAndWatchExpressions(property.value, $filter);
                        allConstants = allConstants && property.value.constant;
                        if (!property.value.constant) {
                            argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                        }
                    });
                    ast.constant = allConstants;
                    ast.toWatch = argsToWatch;
                    break;
                case AST.ThisExpression:
                    ast.constant = false;
                    ast.toWatch = [];
                    break;
                }
            }
            function getInputs(body) {
                if (body.length != 1)
                    return;
                var lastExpression = body[0].expression;
                var candidate = lastExpression.toWatch;
                if (candidate.length !== 1)
                    return candidate;
                return candidate[0] !== lastExpression ? candidate : undefined;
            }
            function isAssignable(ast) {
                return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
            }
            function assignableAST(ast) {
                if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
                    return {
                        type: AST.AssignmentExpression,
                        left: ast.body[0].expression,
                        right: { type: AST.NGValueParameter },
                        operator: '='
                    };
                }
            }
            function isLiteral(ast) {
                return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
            }
            function isConstant(ast) {
                return ast.constant;
            }
            function ASTCompiler(astBuilder, $filter) {
                this.astBuilder = astBuilder;
                this.$filter = $filter;
            }
            ASTCompiler.prototype = {
                compile: function (expression, expensiveChecks) {
                    var self = this;
                    var ast = this.astBuilder.ast(expression);
                    this.state = {
                        nextId: 0,
                        filters: {},
                        expensiveChecks: expensiveChecks,
                        fn: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        assign: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        inputs: []
                    };
                    findConstantAndWatchExpressions(ast, self.$filter);
                    var extra = '';
                    var assignable;
                    this.stage = 'assign';
                    if (assignable = assignableAST(ast)) {
                        this.state.computing = 'assign';
                        var result = this.nextId();
                        this.recurse(assignable, result);
                        this.return_(result);
                        extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
                    }
                    var toWatch = getInputs(ast.body);
                    self.stage = 'inputs';
                    forEach(toWatch, function (watch, key) {
                        var fnKey = 'fn' + key;
                        self.state[fnKey] = {
                            vars: [],
                            body: [],
                            own: {}
                        };
                        self.state.computing = fnKey;
                        var intoId = self.nextId();
                        self.recurse(watch, intoId);
                        self.return_(intoId);
                        self.state.inputs.push(fnKey);
                        watch.watchId = key;
                    });
                    this.state.computing = 'fn';
                    this.stage = 'main';
                    this.recurse(ast);
                    var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
                    var fn = new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
                    this.state = this.stage = undefined;
                    fn.literal = isLiteral(ast);
                    fn.constant = isConstant(ast);
                    return fn;
                },
                USE: 'use',
                STRICT: 'strict',
                watchFns: function () {
                    var result = [];
                    var fns = this.state.inputs;
                    var self = this;
                    forEach(fns, function (name) {
                        result.push('var ' + name + '=' + self.generateFunction(name, 's'));
                    });
                    if (fns.length) {
                        result.push('fn.inputs=[' + fns.join(',') + '];');
                    }
                    return result.join('');
                },
                generateFunction: function (name, params) {
                    return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
                },
                filterPrefix: function () {
                    var parts = [];
                    var self = this;
                    forEach(this.state.filters, function (id, filter) {
                        parts.push(id + '=$filter(' + self.escape(filter) + ')');
                    });
                    if (parts.length)
                        return 'var ' + parts.join(',') + ';';
                    return '';
                },
                varsPrefix: function (section) {
                    return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
                },
                body: function (section) {
                    return this.state[section].body.join('');
                },
                recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var left, right, self = this, args, expression;
                    recursionFn = recursionFn || noop;
                    if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                        intoId = intoId || this.nextId();
                        this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                        return;
                    }
                    switch (ast.type) {
                    case AST.Program:
                        forEach(ast.body, function (expression, pos) {
                            self.recurse(expression.expression, undefined, undefined, function (expr) {
                                right = expr;
                            });
                            if (pos !== ast.body.length - 1) {
                                self.current().body.push(right, ';');
                            } else {
                                self.return_(right);
                            }
                        });
                        break;
                    case AST.Literal:
                        expression = this.escape(ast.value);
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;
                    case AST.UnaryExpression:
                        this.recurse(ast.argument, undefined, undefined, function (expr) {
                            right = expr;
                        });
                        expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;
                    case AST.BinaryExpression:
                        this.recurse(ast.left, undefined, undefined, function (expr) {
                            left = expr;
                        });
                        this.recurse(ast.right, undefined, undefined, function (expr) {
                            right = expr;
                        });
                        if (ast.operator === '+') {
                            expression = this.plus(left, right);
                        } else if (ast.operator === '-') {
                            expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                        } else {
                            expression = '(' + left + ')' + ast.operator + '(' + right + ')';
                        }
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;
                    case AST.LogicalExpression:
                        intoId = intoId || this.nextId();
                        self.recurse(ast.left, intoId);
                        self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                        recursionFn(intoId);
                        break;
                    case AST.ConditionalExpression:
                        intoId = intoId || this.nextId();
                        self.recurse(ast.test, intoId);
                        self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                        recursionFn(intoId);
                        break;
                    case AST.Identifier:
                        intoId = intoId || this.nextId();
                        if (nameId) {
                            nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                            nameId.computed = false;
                            nameId.name = ast.name;
                        }
                        ensureSafeMemberName(ast.name);
                        self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {
                            self.if_(self.stage === 'inputs' || 's', function () {
                                if (create && create !== 1) {
                                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                                }
                                self.assign(intoId, self.nonComputedMember('s', ast.name));
                            });
                        }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
                        if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                            self.addEnsureSafeObject(intoId);
                        }
                        recursionFn(intoId);
                        break;
                    case AST.MemberExpression:
                        left = nameId && (nameId.context = this.nextId()) || this.nextId();
                        intoId = intoId || this.nextId();
                        self.recurse(ast.object, left, undefined, function () {
                            self.if_(self.notNull(left), function () {
                                if (create && create !== 1) {
                                    self.addEnsureSafeAssignContext(left);
                                }
                                if (ast.computed) {
                                    right = self.nextId();
                                    self.recurse(ast.property, right);
                                    self.getStringValue(right);
                                    self.addEnsureSafeMemberName(right);
                                    if (create && create !== 1) {
                                        self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                                    }
                                    expression = self.ensureSafeObject(self.computedMember(left, right));
                                    self.assign(intoId, expression);
                                    if (nameId) {
                                        nameId.computed = true;
                                        nameId.name = right;
                                    }
                                } else {
                                    ensureSafeMemberName(ast.property.name);
                                    if (create && create !== 1) {
                                        self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                                    }
                                    expression = self.nonComputedMember(left, ast.property.name);
                                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                                        expression = self.ensureSafeObject(expression);
                                    }
                                    self.assign(intoId, expression);
                                    if (nameId) {
                                        nameId.computed = false;
                                        nameId.name = ast.property.name;
                                    }
                                }
                            }, function () {
                                self.assign(intoId, 'undefined');
                            });
                            recursionFn(intoId);
                        }, !!create);
                        break;
                    case AST.CallExpression:
                        intoId = intoId || this.nextId();
                        if (ast.filter) {
                            right = self.filter(ast.callee.name);
                            args = [];
                            forEach(ast.arguments, function (expr) {
                                var argument = self.nextId();
                                self.recurse(expr, argument);
                                args.push(argument);
                            });
                            expression = right + '(' + args.join(',') + ')';
                            self.assign(intoId, expression);
                            recursionFn(intoId);
                        } else {
                            right = self.nextId();
                            left = {};
                            args = [];
                            self.recurse(ast.callee, right, left, function () {
                                self.if_(self.notNull(right), function () {
                                    self.addEnsureSafeFunction(right);
                                    forEach(ast.arguments, function (expr) {
                                        self.recurse(expr, self.nextId(), undefined, function (argument) {
                                            args.push(self.ensureSafeObject(argument));
                                        });
                                    });
                                    if (left.name) {
                                        if (!self.state.expensiveChecks) {
                                            self.addEnsureSafeObject(left.context);
                                        }
                                        expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                                    } else {
                                        expression = right + '(' + args.join(',') + ')';
                                    }
                                    expression = self.ensureSafeObject(expression);
                                    self.assign(intoId, expression);
                                }, function () {
                                    self.assign(intoId, 'undefined');
                                });
                                recursionFn(intoId);
                            });
                        }
                        break;
                    case AST.AssignmentExpression:
                        right = this.nextId();
                        left = {};
                        if (!isAssignable(ast.left)) {
                            throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
                        }
                        this.recurse(ast.left, undefined, left, function () {
                            self.if_(self.notNull(left.context), function () {
                                self.recurse(ast.right, right);
                                self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                                self.addEnsureSafeAssignContext(left.context);
                                expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                                self.assign(intoId, expression);
                                recursionFn(intoId || expression);
                            });
                        }, 1);
                        break;
                    case AST.ArrayExpression:
                        args = [];
                        forEach(ast.elements, function (expr) {
                            self.recurse(expr, self.nextId(), undefined, function (argument) {
                                args.push(argument);
                            });
                        });
                        expression = '[' + args.join(',') + ']';
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;
                    case AST.ObjectExpression:
                        args = [];
                        forEach(ast.properties, function (property) {
                            self.recurse(property.value, self.nextId(), undefined, function (expr) {
                                args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : '' + property.key.value) + ':' + expr);
                            });
                        });
                        expression = '{' + args.join(',') + '}';
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;
                    case AST.ThisExpression:
                        this.assign(intoId, 's');
                        recursionFn('s');
                        break;
                    case AST.NGValueParameter:
                        this.assign(intoId, 'v');
                        recursionFn('v');
                        break;
                    }
                },
                getHasOwnProperty: function (element, property) {
                    var key = element + '.' + property;
                    var own = this.current().own;
                    if (!own.hasOwnProperty(key)) {
                        own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
                    }
                    return own[key];
                },
                assign: function (id, value) {
                    if (!id)
                        return;
                    this.current().body.push(id, '=', value, ';');
                    return id;
                },
                filter: function (filterName) {
                    if (!this.state.filters.hasOwnProperty(filterName)) {
                        this.state.filters[filterName] = this.nextId(true);
                    }
                    return this.state.filters[filterName];
                },
                ifDefined: function (id, defaultValue) {
                    return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
                },
                plus: function (left, right) {
                    return 'plus(' + left + ',' + right + ')';
                },
                return_: function (id) {
                    this.current().body.push('return ', id, ';');
                },
                if_: function (test, alternate, consequent) {
                    if (test === true) {
                        alternate();
                    } else {
                        var body = this.current().body;
                        body.push('if(', test, '){');
                        alternate();
                        body.push('}');
                        if (consequent) {
                            body.push('else{');
                            consequent();
                            body.push('}');
                        }
                    }
                },
                not: function (expression) {
                    return '!(' + expression + ')';
                },
                notNull: function (expression) {
                    return expression + '!=null';
                },
                nonComputedMember: function (left, right) {
                    return left + '.' + right;
                },
                computedMember: function (left, right) {
                    return left + '[' + right + ']';
                },
                member: function (left, right, computed) {
                    if (computed)
                        return this.computedMember(left, right);
                    return this.nonComputedMember(left, right);
                },
                addEnsureSafeObject: function (item) {
                    this.current().body.push(this.ensureSafeObject(item), ';');
                },
                addEnsureSafeMemberName: function (item) {
                    this.current().body.push(this.ensureSafeMemberName(item), ';');
                },
                addEnsureSafeFunction: function (item) {
                    this.current().body.push(this.ensureSafeFunction(item), ';');
                },
                addEnsureSafeAssignContext: function (item) {
                    this.current().body.push(this.ensureSafeAssignContext(item), ';');
                },
                ensureSafeObject: function (item) {
                    return 'ensureSafeObject(' + item + ',text)';
                },
                ensureSafeMemberName: function (item) {
                    return 'ensureSafeMemberName(' + item + ',text)';
                },
                ensureSafeFunction: function (item) {
                    return 'ensureSafeFunction(' + item + ',text)';
                },
                getStringValue: function (item) {
                    this.assign(item, 'getStringValue(' + item + ',text)');
                },
                ensureSafeAssignContext: function (item) {
                    return 'ensureSafeAssignContext(' + item + ',text)';
                },
                lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var self = this;
                    return function () {
                        self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
                    };
                },
                lazyAssign: function (id, value) {
                    var self = this;
                    return function () {
                        self.assign(id, value);
                    };
                },
                stringEscapeRegex: /[^ a-zA-Z0-9]/g,
                stringEscapeFn: function (c) {
                    return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
                },
                escape: function (value) {
                    if (isString(value))
                        return '\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\'';
                    if (isNumber(value))
                        return value.toString();
                    if (value === true)
                        return 'true';
                    if (value === false)
                        return 'false';
                    if (value === null)
                        return 'null';
                    if (typeof value === 'undefined')
                        return 'undefined';
                    throw $parseMinErr('esc', 'IMPOSSIBLE');
                },
                nextId: function (skip, init) {
                    var id = 'v' + this.state.nextId++;
                    if (!skip) {
                        this.current().vars.push(id + (init ? '=' + init : ''));
                    }
                    return id;
                },
                current: function () {
                    return this.state[this.state.computing];
                }
            };
            function ASTInterpreter(astBuilder, $filter) {
                this.astBuilder = astBuilder;
                this.$filter = $filter;
            }
            ASTInterpreter.prototype = {
                compile: function (expression, expensiveChecks) {
                    var self = this;
                    var ast = this.astBuilder.ast(expression);
                    this.expression = expression;
                    this.expensiveChecks = expensiveChecks;
                    findConstantAndWatchExpressions(ast, self.$filter);
                    var assignable;
                    var assign;
                    if (assignable = assignableAST(ast)) {
                        assign = this.recurse(assignable);
                    }
                    var toWatch = getInputs(ast.body);
                    var inputs;
                    if (toWatch) {
                        inputs = [];
                        forEach(toWatch, function (watch, key) {
                            var input = self.recurse(watch);
                            watch.input = input;
                            inputs.push(input);
                            watch.watchId = key;
                        });
                    }
                    var expressions = [];
                    forEach(ast.body, function (expression) {
                        expressions.push(self.recurse(expression.expression));
                    });
                    var fn = ast.body.length === 0 ? function () {
                    } : ast.body.length === 1 ? expressions[0] : function (scope, locals) {
                        var lastValue;
                        forEach(expressions, function (exp) {
                            lastValue = exp(scope, locals);
                        });
                        return lastValue;
                    };
                    if (assign) {
                        fn.assign = function (scope, value, locals) {
                            return assign(scope, locals, value);
                        };
                    }
                    if (inputs) {
                        fn.inputs = inputs;
                    }
                    fn.literal = isLiteral(ast);
                    fn.constant = isConstant(ast);
                    return fn;
                },
                recurse: function (ast, context, create) {
                    var left, right, self = this, args, expression;
                    if (ast.input) {
                        return this.inputs(ast.input, ast.watchId);
                    }
                    switch (ast.type) {
                    case AST.Literal:
                        return this.value(ast.value, context);
                    case AST.UnaryExpression:
                        right = this.recurse(ast.argument);
                        return this['unary' + ast.operator](right, context);
                    case AST.BinaryExpression:
                        left = this.recurse(ast.left);
                        right = this.recurse(ast.right);
                        return this['binary' + ast.operator](left, right, context);
                    case AST.LogicalExpression:
                        left = this.recurse(ast.left);
                        right = this.recurse(ast.right);
                        return this['binary' + ast.operator](left, right, context);
                    case AST.ConditionalExpression:
                        return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
                    case AST.Identifier:
                        ensureSafeMemberName(ast.name, self.expression);
                        return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
                    case AST.MemberExpression:
                        left = this.recurse(ast.object, false, !!create);
                        if (!ast.computed) {
                            ensureSafeMemberName(ast.property.name, self.expression);
                            right = ast.property.name;
                        }
                        if (ast.computed)
                            right = this.recurse(ast.property);
                        return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
                    case AST.CallExpression:
                        args = [];
                        forEach(ast.arguments, function (expr) {
                            args.push(self.recurse(expr));
                        });
                        if (ast.filter)
                            right = this.$filter(ast.callee.name);
                        if (!ast.filter)
                            right = this.recurse(ast.callee, true);
                        return ast.filter ? function (scope, locals, assign, inputs) {
                            var values = [];
                            for (var i = 0; i < args.length; ++i) {
                                values.push(args[i](scope, locals, assign, inputs));
                            }
                            var value = right.apply(undefined, values, inputs);
                            return context ? {
                                context: undefined,
                                name: undefined,
                                value: value
                            } : value;
                        } : function (scope, locals, assign, inputs) {
                            var rhs = right(scope, locals, assign, inputs);
                            var value;
                            if (rhs.value != null) {
                                ensureSafeObject(rhs.context, self.expression);
                                ensureSafeFunction(rhs.value, self.expression);
                                var values = [];
                                for (var i = 0; i < args.length; ++i) {
                                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                                }
                                value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                            }
                            return context ? { value: value } : value;
                        };
                    case AST.AssignmentExpression:
                        left = this.recurse(ast.left, true, 1);
                        right = this.recurse(ast.right);
                        return function (scope, locals, assign, inputs) {
                            var lhs = left(scope, locals, assign, inputs);
                            var rhs = right(scope, locals, assign, inputs);
                            ensureSafeObject(lhs.value, self.expression);
                            ensureSafeAssignContext(lhs.context);
                            lhs.context[lhs.name] = rhs;
                            return context ? { value: rhs } : rhs;
                        };
                    case AST.ArrayExpression:
                        args = [];
                        forEach(ast.elements, function (expr) {
                            args.push(self.recurse(expr));
                        });
                        return function (scope, locals, assign, inputs) {
                            var value = [];
                            for (var i = 0; i < args.length; ++i) {
                                value.push(args[i](scope, locals, assign, inputs));
                            }
                            return context ? { value: value } : value;
                        };
                    case AST.ObjectExpression:
                        args = [];
                        forEach(ast.properties, function (property) {
                            args.push({
                                key: property.key.type === AST.Identifier ? property.key.name : '' + property.key.value,
                                value: self.recurse(property.value)
                            });
                        });
                        return function (scope, locals, assign, inputs) {
                            var value = {};
                            for (var i = 0; i < args.length; ++i) {
                                value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                            }
                            return context ? { value: value } : value;
                        };
                    case AST.ThisExpression:
                        return function (scope) {
                            return context ? { value: scope } : scope;
                        };
                    case AST.NGValueParameter:
                        return function (scope, locals, assign, inputs) {
                            return context ? { value: assign } : assign;
                        };
                    }
                },
                'unary+': function (argument, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        if (isDefined(arg)) {
                            arg = +arg;
                        } else {
                            arg = 0;
                        }
                        return context ? { value: arg } : arg;
                    };
                },
                'unary-': function (argument, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        if (isDefined(arg)) {
                            arg = -arg;
                        } else {
                            arg = 0;
                        }
                        return context ? { value: arg } : arg;
                    };
                },
                'unary!': function (argument, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = !argument(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary+': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs = right(scope, locals, assign, inputs);
                        var arg = plusFn(lhs, rhs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary-': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs = right(scope, locals, assign, inputs);
                        var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary*': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary/': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary%': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary===': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary!==': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary==': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary!=': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary<': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary>': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary<=': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary>=': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary&&': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'binary||': function (left, right, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                'ternary?:': function (test, alternate, consequent, context) {
                    return function (scope, locals, assign, inputs) {
                        var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                        return context ? { value: arg } : arg;
                    };
                },
                value: function (value, context) {
                    return function () {
                        return context ? {
                            context: undefined,
                            name: undefined,
                            value: value
                        } : value;
                    };
                },
                identifier: function (name, expensiveChecks, context, create, expression) {
                    return function (scope, locals, assign, inputs) {
                        var base = locals && name in locals ? locals : scope;
                        if (create && create !== 1 && base && !base[name]) {
                            base[name] = {};
                        }
                        var value = base ? base[name] : undefined;
                        if (expensiveChecks) {
                            ensureSafeObject(value, expression);
                        }
                        if (context) {
                            return {
                                context: base,
                                name: name,
                                value: value
                            };
                        } else {
                            return value;
                        }
                    };
                },
                computedMember: function (left, right, context, create, expression) {
                    return function (scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs;
                        var value;
                        if (lhs != null) {
                            rhs = right(scope, locals, assign, inputs);
                            rhs = getStringValue(rhs);
                            ensureSafeMemberName(rhs, expression);
                            if (create && create !== 1) {
                                ensureSafeAssignContext(lhs);
                                if (lhs && !lhs[rhs]) {
                                    lhs[rhs] = {};
                                }
                            }
                            value = lhs[rhs];
                            ensureSafeObject(value, expression);
                        }
                        if (context) {
                            return {
                                context: lhs,
                                name: rhs,
                                value: value
                            };
                        } else {
                            return value;
                        }
                    };
                },
                nonComputedMember: function (left, right, expensiveChecks, context, create, expression) {
                    return function (scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        if (create && create !== 1) {
                            ensureSafeAssignContext(lhs);
                            if (lhs && !lhs[right]) {
                                lhs[right] = {};
                            }
                        }
                        var value = lhs != null ? lhs[right] : undefined;
                        if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
                            ensureSafeObject(value, expression);
                        }
                        if (context) {
                            return {
                                context: lhs,
                                name: right,
                                value: value
                            };
                        } else {
                            return value;
                        }
                    };
                },
                inputs: function (input, watchId) {
                    return function (scope, value, locals, inputs) {
                        if (inputs)
                            return inputs[watchId];
                        return input(scope, value, locals);
                    };
                }
            };
            var Parser = function (lexer, $filter, options) {
                this.lexer = lexer;
                this.$filter = $filter;
                this.options = options;
                this.ast = new AST(this.lexer);
                this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
            };
            Parser.prototype = {
                constructor: Parser,
                parse: function (text) {
                    return this.astCompiler.compile(text, this.options.expensiveChecks);
                }
            };
            function isPossiblyDangerousMemberName(name) {
                return name == 'constructor';
            }
            var objectValueOf = Object.prototype.valueOf;
            function getValueOf(value) {
                return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
            }
            function $ParseProvider() {
                var cacheDefault = createMap();
                var cacheExpensive = createMap();
                this.$get = [
                    '$filter',
                    function ($filter) {
                        var noUnsafeEval = csp().noUnsafeEval;
                        var $parseOptions = {
                                csp: noUnsafeEval,
                                expensiveChecks: false
                            }, $parseOptionsExpensive = {
                                csp: noUnsafeEval,
                                expensiveChecks: true
                            };
                        var runningChecksEnabled = false;
                        $parse.$$runningExpensiveChecks = function () {
                            return runningChecksEnabled;
                        };
                        return $parse;
                        function $parse(exp, interceptorFn, expensiveChecks) {
                            var parsedExpression, oneTime, cacheKey;
                            expensiveChecks = expensiveChecks || runningChecksEnabled;
                            switch (typeof exp) {
                            case 'string':
                                exp = exp.trim();
                                cacheKey = exp;
                                var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                                parsedExpression = cache[cacheKey];
                                if (!parsedExpression) {
                                    if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                                        oneTime = true;
                                        exp = exp.substring(2);
                                    }
                                    var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                                    var lexer = new Lexer(parseOptions);
                                    var parser = new Parser(lexer, $filter, parseOptions);
                                    parsedExpression = parser.parse(exp);
                                    if (parsedExpression.constant) {
                                        parsedExpression.$$watchDelegate = constantWatchDelegate;
                                    } else if (oneTime) {
                                        parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                                    } else if (parsedExpression.inputs) {
                                        parsedExpression.$$watchDelegate = inputsWatchDelegate;
                                    }
                                    if (expensiveChecks) {
                                        parsedExpression = expensiveChecksInterceptor(parsedExpression);
                                    }
                                    cache[cacheKey] = parsedExpression;
                                }
                                return addInterceptor(parsedExpression, interceptorFn);
                            case 'function':
                                return addInterceptor(exp, interceptorFn);
                            default:
                                return addInterceptor(noop, interceptorFn);
                            }
                        }
                        function expensiveChecksInterceptor(fn) {
                            if (!fn)
                                return fn;
                            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
                            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
                            expensiveCheckFn.constant = fn.constant;
                            expensiveCheckFn.literal = fn.literal;
                            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
                                fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
                            }
                            expensiveCheckFn.inputs = fn.inputs;
                            return expensiveCheckFn;
                            function expensiveCheckFn(scope, locals, assign, inputs) {
                                var expensiveCheckOldValue = runningChecksEnabled;
                                runningChecksEnabled = true;
                                try {
                                    return fn(scope, locals, assign, inputs);
                                } finally {
                                    runningChecksEnabled = expensiveCheckOldValue;
                                }
                            }
                        }
                        function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                            if (newValue == null || oldValueOfValue == null) {
                                return newValue === oldValueOfValue;
                            }
                            if (typeof newValue === 'object') {
                                newValue = getValueOf(newValue);
                                if (typeof newValue === 'object') {
                                    return false;
                                }
                            }
                            return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
                        }
                        function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                            var inputExpressions = parsedExpression.inputs;
                            var lastResult;
                            if (inputExpressions.length === 1) {
                                var oldInputValueOf = expressionInputDirtyCheck;
                                inputExpressions = inputExpressions[0];
                                return scope.$watch(function expressionInputWatch(scope) {
                                    var newInputValue = inputExpressions(scope);
                                    if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                                        lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                                        oldInputValueOf = newInputValue && getValueOf(newInputValue);
                                    }
                                    return lastResult;
                                }, listener, objectEquality, prettyPrintExpression);
                            }
                            var oldInputValueOfValues = [];
                            var oldInputValues = [];
                            for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                                oldInputValueOfValues[i] = expressionInputDirtyCheck;
                                oldInputValues[i] = null;
                            }
                            return scope.$watch(function expressionInputsWatch(scope) {
                                var changed = false;
                                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                                    var newInputValue = inputExpressions[i](scope);
                                    if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                                        oldInputValues[i] = newInputValue;
                                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                                    }
                                }
                                if (changed) {
                                    lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                                }
                                return lastResult;
                            }, listener, objectEquality, prettyPrintExpression);
                        }
                        function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                            var unwatch, lastValue;
                            return unwatch = scope.$watch(function oneTimeWatch(scope) {
                                return parsedExpression(scope);
                            }, function oneTimeListener(value, old, scope) {
                                lastValue = value;
                                if (isFunction(listener)) {
                                    listener.apply(this, arguments);
                                }
                                if (isDefined(value)) {
                                    scope.$$postDigest(function () {
                                        if (isDefined(lastValue)) {
                                            unwatch();
                                        }
                                    });
                                }
                            }, objectEquality);
                        }
                        function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                            var unwatch, lastValue;
                            return unwatch = scope.$watch(function oneTimeWatch(scope) {
                                return parsedExpression(scope);
                            }, function oneTimeListener(value, old, scope) {
                                lastValue = value;
                                if (isFunction(listener)) {
                                    listener.call(this, value, old, scope);
                                }
                                if (isAllDefined(value)) {
                                    scope.$$postDigest(function () {
                                        if (isAllDefined(lastValue))
                                            unwatch();
                                    });
                                }
                            }, objectEquality);
                            function isAllDefined(value) {
                                var allDefined = true;
                                forEach(value, function (val) {
                                    if (!isDefined(val))
                                        allDefined = false;
                                });
                                return allDefined;
                            }
                        }
                        function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                            var unwatch;
                            return unwatch = scope.$watch(function constantWatch(scope) {
                                return parsedExpression(scope);
                            }, function constantListener(value, old, scope) {
                                if (isFunction(listener)) {
                                    listener.apply(this, arguments);
                                }
                                unwatch();
                            }, objectEquality);
                        }
                        function addInterceptor(parsedExpression, interceptorFn) {
                            if (!interceptorFn)
                                return parsedExpression;
                            var watchDelegate = parsedExpression.$$watchDelegate;
                            var useInputs = false;
                            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                                var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                                return interceptorFn(value, scope, locals);
                            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                                var value = parsedExpression(scope, locals, assign, inputs);
                                var result = interceptorFn(value, scope, locals);
                                return isDefined(value) ? result : value;
                            };
                            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                                fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                            } else if (!interceptorFn.$stateful) {
                                fn.$$watchDelegate = inputsWatchDelegate;
                                useInputs = !parsedExpression.inputs;
                                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
                            }
                            return fn;
                        }
                    }
                ];
            }
            function $QProvider() {
                this.$get = [
                    '$rootScope',
                    '$exceptionHandler',
                    function ($rootScope, $exceptionHandler) {
                        return qFactory(function (callback) {
                            $rootScope.$evalAsync(callback);
                        }, $exceptionHandler);
                    }
                ];
            }
            function $$QProvider() {
                this.$get = [
                    '$browser',
                    '$exceptionHandler',
                    function ($browser, $exceptionHandler) {
                        return qFactory(function (callback) {
                            $browser.defer(callback);
                        }, $exceptionHandler);
                    }
                ];
            }
            function qFactory(nextTick, exceptionHandler) {
                var $qMinErr = minErr('$q', TypeError);
                function callOnce(self, resolveFn, rejectFn) {
                    var called = false;
                    function wrap(fn) {
                        return function (value) {
                            if (called)
                                return;
                            called = true;
                            fn.call(self, value);
                        };
                    }
                    return [
                        wrap(resolveFn),
                        wrap(rejectFn)
                    ];
                }
                var defer = function () {
                    return new Deferred();
                };
                function Promise() {
                    this.$$state = { status: 0 };
                }
                extend(Promise.prototype, {
                    then: function (onFulfilled, onRejected, progressBack) {
                        if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                            return this;
                        }
                        var result = new Deferred();
                        this.$$state.pending = this.$$state.pending || [];
                        this.$$state.pending.push([
                            result,
                            onFulfilled,
                            onRejected,
                            progressBack
                        ]);
                        if (this.$$state.status > 0)
                            scheduleProcessQueue(this.$$state);
                        return result.promise;
                    },
                    'catch': function (callback) {
                        return this.then(null, callback);
                    },
                    'finally': function (callback, progressBack) {
                        return this.then(function (value) {
                            return handleCallback(value, true, callback);
                        }, function (error) {
                            return handleCallback(error, false, callback);
                        }, progressBack);
                    }
                });
                function simpleBind(context, fn) {
                    return function (value) {
                        fn.call(context, value);
                    };
                }
                function processQueue(state) {
                    var fn, deferred, pending;
                    pending = state.pending;
                    state.processScheduled = false;
                    state.pending = undefined;
                    for (var i = 0, ii = pending.length; i < ii; ++i) {
                        deferred = pending[i][0];
                        fn = pending[i][state.status];
                        try {
                            if (isFunction(fn)) {
                                deferred.resolve(fn(state.value));
                            } else if (state.status === 1) {
                                deferred.resolve(state.value);
                            } else {
                                deferred.reject(state.value);
                            }
                        } catch (e) {
                            deferred.reject(e);
                            exceptionHandler(e);
                        }
                    }
                }
                function scheduleProcessQueue(state) {
                    if (state.processScheduled || !state.pending)
                        return;
                    state.processScheduled = true;
                    nextTick(function () {
                        processQueue(state);
                    });
                }
                function Deferred() {
                    this.promise = new Promise();
                    this.resolve = simpleBind(this, this.resolve);
                    this.reject = simpleBind(this, this.reject);
                    this.notify = simpleBind(this, this.notify);
                }
                extend(Deferred.prototype, {
                    resolve: function (val) {
                        if (this.promise.$$state.status)
                            return;
                        if (val === this.promise) {
                            this.$$reject($qMinErr('qcycle', 'Expected promise to be resolved with value other than itself \'{0}\'', val));
                        } else {
                            this.$$resolve(val);
                        }
                    },
                    $$resolve: function (val) {
                        var then, fns;
                        fns = callOnce(this, this.$$resolve, this.$$reject);
                        try {
                            if (isObject(val) || isFunction(val))
                                then = val && val.then;
                            if (isFunction(then)) {
                                this.promise.$$state.status = -1;
                                then.call(val, fns[0], fns[1], this.notify);
                            } else {
                                this.promise.$$state.value = val;
                                this.promise.$$state.status = 1;
                                scheduleProcessQueue(this.promise.$$state);
                            }
                        } catch (e) {
                            fns[1](e);
                            exceptionHandler(e);
                        }
                    },
                    reject: function (reason) {
                        if (this.promise.$$state.status)
                            return;
                        this.$$reject(reason);
                    },
                    $$reject: function (reason) {
                        this.promise.$$state.value = reason;
                        this.promise.$$state.status = 2;
                        scheduleProcessQueue(this.promise.$$state);
                    },
                    notify: function (progress) {
                        var callbacks = this.promise.$$state.pending;
                        if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                            nextTick(function () {
                                var callback, result;
                                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                    result = callbacks[i][0];
                                    callback = callbacks[i][3];
                                    try {
                                        result.notify(isFunction(callback) ? callback(progress) : progress);
                                    } catch (e) {
                                        exceptionHandler(e);
                                    }
                                }
                            });
                        }
                    }
                });
                var reject = function (reason) {
                    var result = new Deferred();
                    result.reject(reason);
                    return result.promise;
                };
                var makePromise = function makePromise(value, resolved) {
                    var result = new Deferred();
                    if (resolved) {
                        result.resolve(value);
                    } else {
                        result.reject(value);
                    }
                    return result.promise;
                };
                var handleCallback = function handleCallback(value, isResolved, callback) {
                    var callbackOutput = null;
                    try {
                        if (isFunction(callback))
                            callbackOutput = callback();
                    } catch (e) {
                        return makePromise(e, false);
                    }
                    if (isPromiseLike(callbackOutput)) {
                        return callbackOutput.then(function () {
                            return makePromise(value, isResolved);
                        }, function (error) {
                            return makePromise(error, false);
                        });
                    } else {
                        return makePromise(value, isResolved);
                    }
                };
                var when = function (value, callback, errback, progressBack) {
                    var result = new Deferred();
                    result.resolve(value);
                    return result.promise.then(callback, errback, progressBack);
                };
                var resolve = when;
                function all(promises) {
                    var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
                    forEach(promises, function (promise, key) {
                        counter++;
                        when(promise).then(function (value) {
                            if (results.hasOwnProperty(key))
                                return;
                            results[key] = value;
                            if (!--counter)
                                deferred.resolve(results);
                        }, function (reason) {
                            if (results.hasOwnProperty(key))
                                return;
                            deferred.reject(reason);
                        });
                    });
                    if (counter === 0) {
                        deferred.resolve(results);
                    }
                    return deferred.promise;
                }
                var $Q = function Q(resolver) {
                    if (!isFunction(resolver)) {
                        throw $qMinErr('norslvr', 'Expected resolverFn, got \'{0}\'', resolver);
                    }
                    if (!(this instanceof Q)) {
                        return new Q(resolver);
                    }
                    var deferred = new Deferred();
                    function resolveFn(value) {
                        deferred.resolve(value);
                    }
                    function rejectFn(reason) {
                        deferred.reject(reason);
                    }
                    resolver(resolveFn, rejectFn);
                    return deferred.promise;
                };
                $Q.defer = defer;
                $Q.reject = reject;
                $Q.when = when;
                $Q.resolve = resolve;
                $Q.all = all;
                return $Q;
            }
            function $$RAFProvider() {
                this.$get = [
                    '$window',
                    '$timeout',
                    function ($window, $timeout) {
                        var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
                        var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
                        var rafSupported = !!requestAnimationFrame;
                        var raf = rafSupported ? function (fn) {
                            var id = requestAnimationFrame(fn);
                            return function () {
                                cancelAnimationFrame(id);
                            };
                        } : function (fn) {
                            var timer = $timeout(fn, 16.66, false);
                            return function () {
                                $timeout.cancel(timer);
                            };
                        };
                        raf.supported = rafSupported;
                        return raf;
                    }
                ];
            }
            function $RootScopeProvider() {
                var TTL = 10;
                var $rootScopeMinErr = minErr('$rootScope');
                var lastDirtyWatch = null;
                var applyAsyncId = null;
                this.digestTtl = function (value) {
                    if (arguments.length) {
                        TTL = value;
                    }
                    return TTL;
                };
                function createChildScopeClass(parent) {
                    function ChildScope() {
                        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                        this.$$listeners = {};
                        this.$$listenerCount = {};
                        this.$$watchersCount = 0;
                        this.$id = nextUid();
                        this.$$ChildScope = null;
                    }
                    ChildScope.prototype = parent;
                    return ChildScope;
                }
                this.$get = [
                    '$injector',
                    '$exceptionHandler',
                    '$parse',
                    '$browser',
                    function ($injector, $exceptionHandler, $parse, $browser) {
                        function destroyChildScope($event) {
                            $event.currentScope.$$destroyed = true;
                        }
                        function cleanUpScope($scope) {
                            if (msie === 9) {
                                $scope.$$childHead && cleanUpScope($scope.$$childHead);
                                $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
                            }
                            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                        }
                        function Scope() {
                            this.$id = nextUid();
                            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                            this.$root = this;
                            this.$$destroyed = false;
                            this.$$listeners = {};
                            this.$$listenerCount = {};
                            this.$$watchersCount = 0;
                            this.$$isolateBindings = null;
                        }
                        Scope.prototype = {
                            constructor: Scope,
                            $new: function (isolate, parent) {
                                var child;
                                parent = parent || this;
                                if (isolate) {
                                    child = new Scope();
                                    child.$root = this.$root;
                                } else {
                                    if (!this.$$ChildScope) {
                                        this.$$ChildScope = createChildScopeClass(this);
                                    }
                                    child = new this.$$ChildScope();
                                }
                                child.$parent = parent;
                                child.$$prevSibling = parent.$$childTail;
                                if (parent.$$childHead) {
                                    parent.$$childTail.$$nextSibling = child;
                                    parent.$$childTail = child;
                                } else {
                                    parent.$$childHead = parent.$$childTail = child;
                                }
                                if (isolate || parent != this)
                                    child.$on('$destroy', destroyChildScope);
                                return child;
                            },
                            $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {
                                var get = $parse(watchExp);
                                if (get.$$watchDelegate) {
                                    return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                                }
                                var scope = this, array = scope.$$watchers, watcher = {
                                        fn: listener,
                                        last: initWatchVal,
                                        get: get,
                                        exp: prettyPrintExpression || watchExp,
                                        eq: !!objectEquality
                                    };
                                lastDirtyWatch = null;
                                if (!isFunction(listener)) {
                                    watcher.fn = noop;
                                }
                                if (!array) {
                                    array = scope.$$watchers = [];
                                }
                                array.unshift(watcher);
                                incrementWatchersCount(this, 1);
                                return function deregisterWatch() {
                                    if (arrayRemove(array, watcher) >= 0) {
                                        incrementWatchersCount(scope, -1);
                                    }
                                    lastDirtyWatch = null;
                                };
                            },
                            $watchGroup: function (watchExpressions, listener) {
                                var oldValues = new Array(watchExpressions.length);
                                var newValues = new Array(watchExpressions.length);
                                var deregisterFns = [];
                                var self = this;
                                var changeReactionScheduled = false;
                                var firstRun = true;
                                if (!watchExpressions.length) {
                                    var shouldCall = true;
                                    self.$evalAsync(function () {
                                        if (shouldCall)
                                            listener(newValues, newValues, self);
                                    });
                                    return function deregisterWatchGroup() {
                                        shouldCall = false;
                                    };
                                }
                                if (watchExpressions.length === 1) {
                                    return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                                        newValues[0] = value;
                                        oldValues[0] = oldValue;
                                        listener(newValues, value === oldValue ? newValues : oldValues, scope);
                                    });
                                }
                                forEach(watchExpressions, function (expr, i) {
                                    var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                                        newValues[i] = value;
                                        oldValues[i] = oldValue;
                                        if (!changeReactionScheduled) {
                                            changeReactionScheduled = true;
                                            self.$evalAsync(watchGroupAction);
                                        }
                                    });
                                    deregisterFns.push(unwatchFn);
                                });
                                function watchGroupAction() {
                                    changeReactionScheduled = false;
                                    if (firstRun) {
                                        firstRun = false;
                                        listener(newValues, newValues, self);
                                    } else {
                                        listener(newValues, oldValues, self);
                                    }
                                }
                                return function deregisterWatchGroup() {
                                    while (deregisterFns.length) {
                                        deregisterFns.shift()();
                                    }
                                };
                            },
                            $watchCollection: function (obj, listener) {
                                $watchCollectionInterceptor.$stateful = true;
                                var self = this;
                                var newValue;
                                var oldValue;
                                var veryOldValue;
                                var trackVeryOldValue = listener.length > 1;
                                var changeDetected = 0;
                                var changeDetector = $parse(obj, $watchCollectionInterceptor);
                                var internalArray = [];
                                var internalObject = {};
                                var initRun = true;
                                var oldLength = 0;
                                function $watchCollectionInterceptor(_value) {
                                    newValue = _value;
                                    var newLength, key, bothNaN, newItem, oldItem;
                                    if (isUndefined(newValue))
                                        return;
                                    if (!isObject(newValue)) {
                                        if (oldValue !== newValue) {
                                            oldValue = newValue;
                                            changeDetected++;
                                        }
                                    } else if (isArrayLike(newValue)) {
                                        if (oldValue !== internalArray) {
                                            oldValue = internalArray;
                                            oldLength = oldValue.length = 0;
                                            changeDetected++;
                                        }
                                        newLength = newValue.length;
                                        if (oldLength !== newLength) {
                                            changeDetected++;
                                            oldValue.length = oldLength = newLength;
                                        }
                                        for (var i = 0; i < newLength; i++) {
                                            oldItem = oldValue[i];
                                            newItem = newValue[i];
                                            bothNaN = oldItem !== oldItem && newItem !== newItem;
                                            if (!bothNaN && oldItem !== newItem) {
                                                changeDetected++;
                                                oldValue[i] = newItem;
                                            }
                                        }
                                    } else {
                                        if (oldValue !== internalObject) {
                                            oldValue = internalObject = {};
                                            oldLength = 0;
                                            changeDetected++;
                                        }
                                        newLength = 0;
                                        for (key in newValue) {
                                            if (hasOwnProperty.call(newValue, key)) {
                                                newLength++;
                                                newItem = newValue[key];
                                                oldItem = oldValue[key];
                                                if (key in oldValue) {
                                                    bothNaN = oldItem !== oldItem && newItem !== newItem;
                                                    if (!bothNaN && oldItem !== newItem) {
                                                        changeDetected++;
                                                        oldValue[key] = newItem;
                                                    }
                                                } else {
                                                    oldLength++;
                                                    oldValue[key] = newItem;
                                                    changeDetected++;
                                                }
                                            }
                                        }
                                        if (oldLength > newLength) {
                                            changeDetected++;
                                            for (key in oldValue) {
                                                if (!hasOwnProperty.call(newValue, key)) {
                                                    oldLength--;
                                                    delete oldValue[key];
                                                }
                                            }
                                        }
                                    }
                                    return changeDetected;
                                }
                                function $watchCollectionAction() {
                                    if (initRun) {
                                        initRun = false;
                                        listener(newValue, newValue, self);
                                    } else {
                                        listener(newValue, veryOldValue, self);
                                    }
                                    if (trackVeryOldValue) {
                                        if (!isObject(newValue)) {
                                            veryOldValue = newValue;
                                        } else if (isArrayLike(newValue)) {
                                            veryOldValue = new Array(newValue.length);
                                            for (var i = 0; i < newValue.length; i++) {
                                                veryOldValue[i] = newValue[i];
                                            }
                                        } else {
                                            veryOldValue = {};
                                            for (var key in newValue) {
                                                if (hasOwnProperty.call(newValue, key)) {
                                                    veryOldValue[key] = newValue[key];
                                                }
                                            }
                                        }
                                    }
                                }
                                return this.$watch(changeDetector, $watchCollectionAction);
                            },
                            $digest: function () {
                                var watch, value, last, fn, get, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
                                beginPhase('$digest');
                                $browser.$$checkUrlChange();
                                if (this === $rootScope && applyAsyncId !== null) {
                                    $browser.defer.cancel(applyAsyncId);
                                    flushApplyAsync();
                                }
                                lastDirtyWatch = null;
                                do {
                                    dirty = false;
                                    current = target;
                                    while (asyncQueue.length) {
                                        try {
                                            asyncTask = asyncQueue.shift();
                                            asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                                        } catch (e) {
                                            $exceptionHandler(e);
                                        }
                                        lastDirtyWatch = null;
                                    }
                                    traverseScopesLoop:
                                        do {
                                            if (watchers = current.$$watchers) {
                                                length = watchers.length;
                                                while (length--) {
                                                    try {
                                                        watch = watchers[length];
                                                        if (watch) {
                                                            get = watch.get;
                                                            if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last))) {
                                                                dirty = true;
                                                                lastDirtyWatch = watch;
                                                                watch.last = watch.eq ? copy(value, null) : value;
                                                                fn = watch.fn;
                                                                fn(value, last === initWatchVal ? value : last, current);
                                                                if (ttl < 5) {
                                                                    logIdx = 4 - ttl;
                                                                    if (!watchLog[logIdx])
                                                                        watchLog[logIdx] = [];
                                                                    watchLog[logIdx].push({
                                                                        msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                                        newVal: value,
                                                                        oldVal: last
                                                                    });
                                                                }
                                                            } else if (watch === lastDirtyWatch) {
                                                                dirty = false;
                                                                break traverseScopesLoop;
                                                            }
                                                        }
                                                    } catch (e) {
                                                        $exceptionHandler(e);
                                                    }
                                                }
                                            }
                                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                                while (current !== target && !(next = current.$$nextSibling)) {
                                                    current = current.$parent;
                                                }
                                            }
                                        } while (current = next);
                                    if ((dirty || asyncQueue.length) && !ttl--) {
                                        clearPhase();
                                        throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                                    }
                                } while (dirty || asyncQueue.length);
                                clearPhase();
                                while (postDigestQueue.length) {
                                    try {
                                        postDigestQueue.shift()();
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            },
                            $destroy: function () {
                                if (this.$$destroyed)
                                    return;
                                var parent = this.$parent;
                                this.$broadcast('$destroy');
                                this.$$destroyed = true;
                                if (this === $rootScope) {
                                    $browser.$$applicationDestroyed();
                                }
                                incrementWatchersCount(this, -this.$$watchersCount);
                                for (var eventName in this.$$listenerCount) {
                                    decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                                }
                                if (parent && parent.$$childHead == this)
                                    parent.$$childHead = this.$$nextSibling;
                                if (parent && parent.$$childTail == this)
                                    parent.$$childTail = this.$$prevSibling;
                                if (this.$$prevSibling)
                                    this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                                if (this.$$nextSibling)
                                    this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                                this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                                this.$on = this.$watch = this.$watchGroup = function () {
                                    return noop;
                                };
                                this.$$listeners = {};
                                this.$$nextSibling = null;
                                cleanUpScope(this);
                            },
                            $eval: function (expr, locals) {
                                return $parse(expr)(this, locals);
                            },
                            $evalAsync: function (expr, locals) {
                                if (!$rootScope.$$phase && !asyncQueue.length) {
                                    $browser.defer(function () {
                                        if (asyncQueue.length) {
                                            $rootScope.$digest();
                                        }
                                    });
                                }
                                asyncQueue.push({
                                    scope: this,
                                    expression: $parse(expr),
                                    locals: locals
                                });
                            },
                            $$postDigest: function (fn) {
                                postDigestQueue.push(fn);
                            },
                            $apply: function (expr) {
                                try {
                                    beginPhase('$apply');
                                    try {
                                        return this.$eval(expr);
                                    } finally {
                                        clearPhase();
                                    }
                                } catch (e) {
                                    $exceptionHandler(e);
                                } finally {
                                    try {
                                        $rootScope.$digest();
                                    } catch (e) {
                                        $exceptionHandler(e);
                                        throw e;
                                    }
                                }
                            },
                            $applyAsync: function (expr) {
                                var scope = this;
                                expr && applyAsyncQueue.push($applyAsyncExpression);
                                expr = $parse(expr);
                                scheduleApplyAsync();
                                function $applyAsyncExpression() {
                                    scope.$eval(expr);
                                }
                            },
                            $on: function (name, listener) {
                                var namedListeners = this.$$listeners[name];
                                if (!namedListeners) {
                                    this.$$listeners[name] = namedListeners = [];
                                }
                                namedListeners.push(listener);
                                var current = this;
                                do {
                                    if (!current.$$listenerCount[name]) {
                                        current.$$listenerCount[name] = 0;
                                    }
                                    current.$$listenerCount[name]++;
                                } while (current = current.$parent);
                                var self = this;
                                return function () {
                                    var indexOfListener = namedListeners.indexOf(listener);
                                    if (indexOfListener !== -1) {
                                        namedListeners[indexOfListener] = null;
                                        decrementListenerCount(self, 1, name);
                                    }
                                };
                            },
                            $emit: function (name, args) {
                                var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                                        name: name,
                                        targetScope: scope,
                                        stopPropagation: function () {
                                            stopPropagation = true;
                                        },
                                        preventDefault: function () {
                                            event.defaultPrevented = true;
                                        },
                                        defaultPrevented: false
                                    }, listenerArgs = concat([event], arguments, 1), i, length;
                                do {
                                    namedListeners = scope.$$listeners[name] || empty;
                                    event.currentScope = scope;
                                    for (i = 0, length = namedListeners.length; i < length; i++) {
                                        if (!namedListeners[i]) {
                                            namedListeners.splice(i, 1);
                                            i--;
                                            length--;
                                            continue;
                                        }
                                        try {
                                            namedListeners[i].apply(null, listenerArgs);
                                        } catch (e) {
                                            $exceptionHandler(e);
                                        }
                                    }
                                    if (stopPropagation) {
                                        event.currentScope = null;
                                        return event;
                                    }
                                    scope = scope.$parent;
                                } while (scope);
                                event.currentScope = null;
                                return event;
                            },
                            $broadcast: function (name, args) {
                                var target = this, current = target, next = target, event = {
                                        name: name,
                                        targetScope: target,
                                        preventDefault: function () {
                                            event.defaultPrevented = true;
                                        },
                                        defaultPrevented: false
                                    };
                                if (!target.$$listenerCount[name])
                                    return event;
                                var listenerArgs = concat([event], arguments, 1), listeners, i, length;
                                while (current = next) {
                                    event.currentScope = current;
                                    listeners = current.$$listeners[name] || [];
                                    for (i = 0, length = listeners.length; i < length; i++) {
                                        if (!listeners[i]) {
                                            listeners.splice(i, 1);
                                            i--;
                                            length--;
                                            continue;
                                        }
                                        try {
                                            listeners[i].apply(null, listenerArgs);
                                        } catch (e) {
                                            $exceptionHandler(e);
                                        }
                                    }
                                    if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                                        while (current !== target && !(next = current.$$nextSibling)) {
                                            current = current.$parent;
                                        }
                                    }
                                }
                                event.currentScope = null;
                                return event;
                            }
                        };
                        var $rootScope = new Scope();
                        var asyncQueue = $rootScope.$$asyncQueue = [];
                        var postDigestQueue = $rootScope.$$postDigestQueue = [];
                        var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
                        return $rootScope;
                        function beginPhase(phase) {
                            if ($rootScope.$$phase) {
                                throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
                            }
                            $rootScope.$$phase = phase;
                        }
                        function clearPhase() {
                            $rootScope.$$phase = null;
                        }
                        function incrementWatchersCount(current, count) {
                            do {
                                current.$$watchersCount += count;
                            } while (current = current.$parent);
                        }
                        function decrementListenerCount(current, count, name) {
                            do {
                                current.$$listenerCount[name] -= count;
                                if (current.$$listenerCount[name] === 0) {
                                    delete current.$$listenerCount[name];
                                }
                            } while (current = current.$parent);
                        }
                        function initWatchVal() {
                        }
                        function flushApplyAsync() {
                            while (applyAsyncQueue.length) {
                                try {
                                    applyAsyncQueue.shift()();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                            applyAsyncId = null;
                        }
                        function scheduleApplyAsync() {
                            if (applyAsyncId === null) {
                                applyAsyncId = $browser.defer(function () {
                                    $rootScope.$apply(flushApplyAsync);
                                });
                            }
                        }
                    }
                ];
            }
            function $$SanitizeUriProvider() {
                var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
                this.aHrefSanitizationWhitelist = function (regexp) {
                    if (isDefined(regexp)) {
                        aHrefSanitizationWhitelist = regexp;
                        return this;
                    }
                    return aHrefSanitizationWhitelist;
                };
                this.imgSrcSanitizationWhitelist = function (regexp) {
                    if (isDefined(regexp)) {
                        imgSrcSanitizationWhitelist = regexp;
                        return this;
                    }
                    return imgSrcSanitizationWhitelist;
                };
                this.$get = function () {
                    return function sanitizeUri(uri, isImage) {
                        var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                        var normalizedVal;
                        normalizedVal = urlResolve(uri).href;
                        if (normalizedVal !== '' && !normalizedVal.match(regex)) {
                            return 'unsafe:' + normalizedVal;
                        }
                        return uri;
                    };
                };
            }
            var $sceMinErr = minErr('$sce');
            var SCE_CONTEXTS = {
                HTML: 'html',
                CSS: 'css',
                URL: 'url',
                RESOURCE_URL: 'resourceUrl',
                JS: 'js'
            };
            function adjustMatcher(matcher) {
                if (matcher === 'self') {
                    return matcher;
                } else if (isString(matcher)) {
                    if (matcher.indexOf('***') > -1) {
                        throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
                    }
                    matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
                    return new RegExp('^' + matcher + '$');
                } else if (isRegExp(matcher)) {
                    return new RegExp('^' + matcher.source + '$');
                } else {
                    throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
                }
            }
            function adjustMatchers(matchers) {
                var adjustedMatchers = [];
                if (isDefined(matchers)) {
                    forEach(matchers, function (matcher) {
                        adjustedMatchers.push(adjustMatcher(matcher));
                    });
                }
                return adjustedMatchers;
            }
            function $SceDelegateProvider() {
                this.SCE_CONTEXTS = SCE_CONTEXTS;
                var resourceUrlWhitelist = ['self'], resourceUrlBlacklist = [];
                this.resourceUrlWhitelist = function (value) {
                    if (arguments.length) {
                        resourceUrlWhitelist = adjustMatchers(value);
                    }
                    return resourceUrlWhitelist;
                };
                this.resourceUrlBlacklist = function (value) {
                    if (arguments.length) {
                        resourceUrlBlacklist = adjustMatchers(value);
                    }
                    return resourceUrlBlacklist;
                };
                this.$get = [
                    '$injector',
                    function ($injector) {
                        var htmlSanitizer = function htmlSanitizer(html) {
                            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                        };
                        if ($injector.has('$sanitize')) {
                            htmlSanitizer = $injector.get('$sanitize');
                        }
                        function matchUrl(matcher, parsedUrl) {
                            if (matcher === 'self') {
                                return urlIsSameOrigin(parsedUrl);
                            } else {
                                return !!matcher.exec(parsedUrl.href);
                            }
                        }
                        function isResourceUrlAllowedByPolicy(url) {
                            var parsedUrl = urlResolve(url.toString());
                            var i, n, allowed = false;
                            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                                if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                                    allowed = true;
                                    break;
                                }
                            }
                            if (allowed) {
                                for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                                    if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                        allowed = false;
                                        break;
                                    }
                                }
                            }
                            return allowed;
                        }
                        function generateHolderType(Base) {
                            var holderType = function TrustedValueHolderType(trustedValue) {
                                this.$$unwrapTrustedValue = function () {
                                    return trustedValue;
                                };
                            };
                            if (Base) {
                                holderType.prototype = new Base();
                            }
                            holderType.prototype.valueOf = function sceValueOf() {
                                return this.$$unwrapTrustedValue();
                            };
                            holderType.prototype.toString = function sceToString() {
                                return this.$$unwrapTrustedValue().toString();
                            };
                            return holderType;
                        }
                        var trustedValueHolderBase = generateHolderType(), byType = {};
                        byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
                        byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
                        byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
                        byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
                        byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
                        function trustAs(type, trustedValue) {
                            var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                            if (!Constructor) {
                                throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
                            }
                            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
                                return trustedValue;
                            }
                            if (typeof trustedValue !== 'string') {
                                throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
                            }
                            return new Constructor(trustedValue);
                        }
                        function valueOf(maybeTrusted) {
                            if (maybeTrusted instanceof trustedValueHolderBase) {
                                return maybeTrusted.$$unwrapTrustedValue();
                            } else {
                                return maybeTrusted;
                            }
                        }
                        function getTrusted(type, maybeTrusted) {
                            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
                                return maybeTrusted;
                            }
                            var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                            if (constructor && maybeTrusted instanceof constructor) {
                                return maybeTrusted.$$unwrapTrustedValue();
                            }
                            if (type === SCE_CONTEXTS.RESOURCE_URL) {
                                if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                                    return maybeTrusted;
                                } else {
                                    throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
                                }
                            } else if (type === SCE_CONTEXTS.HTML) {
                                return htmlSanitizer(maybeTrusted);
                            }
                            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                        }
                        return {
                            trustAs: trustAs,
                            getTrusted: getTrusted,
                            valueOf: valueOf
                        };
                    }
                ];
            }
            function $SceProvider() {
                var enabled = true;
                this.enabled = function (value) {
                    if (arguments.length) {
                        enabled = !!value;
                    }
                    return enabled;
                };
                this.$get = [
                    '$parse',
                    '$sceDelegate',
                    function ($parse, $sceDelegate) {
                        if (enabled && msie < 8) {
                            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
                        }
                        var sce = shallowCopy(SCE_CONTEXTS);
                        sce.isEnabled = function () {
                            return enabled;
                        };
                        sce.trustAs = $sceDelegate.trustAs;
                        sce.getTrusted = $sceDelegate.getTrusted;
                        sce.valueOf = $sceDelegate.valueOf;
                        if (!enabled) {
                            sce.trustAs = sce.getTrusted = function (type, value) {
                                return value;
                            };
                            sce.valueOf = identity;
                        }
                        sce.parseAs = function sceParseAs(type, expr) {
                            var parsed = $parse(expr);
                            if (parsed.literal && parsed.constant) {
                                return parsed;
                            } else {
                                return $parse(expr, function (value) {
                                    return sce.getTrusted(type, value);
                                });
                            }
                        };
                        var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                        forEach(SCE_CONTEXTS, function (enumValue, name) {
                            var lName = lowercase(name);
                            sce[camelCase('parse_as_' + lName)] = function (expr) {
                                return parse(enumValue, expr);
                            };
                            sce[camelCase('get_trusted_' + lName)] = function (value) {
                                return getTrusted(enumValue, value);
                            };
                            sce[camelCase('trust_as_' + lName)] = function (value) {
                                return trustAs(enumValue, value);
                            };
                        });
                        return sce;
                    }
                ];
            }
            function $SnifferProvider() {
                this.$get = [
                    '$window',
                    '$document',
                    function ($window, $document) {
                        var eventSupport = {}, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
                        if (bodyStyle) {
                            for (var prop in bodyStyle) {
                                if (match = vendorRegex.exec(prop)) {
                                    vendorPrefix = match[0];
                                    vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                                    break;
                                }
                            }
                            if (!vendorPrefix) {
                                vendorPrefix = 'WebkitOpacity' in bodyStyle && 'webkit';
                            }
                            transitions = !!('transition' in bodyStyle || vendorPrefix + 'Transition' in bodyStyle);
                            animations = !!('animation' in bodyStyle || vendorPrefix + 'Animation' in bodyStyle);
                            if (android && (!transitions || !animations)) {
                                transitions = isString(bodyStyle.webkitTransition);
                                animations = isString(bodyStyle.webkitAnimation);
                            }
                        }
                        return {
                            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                            hasEvent: function (event) {
                                if (event === 'input' && msie <= 11)
                                    return false;
                                if (isUndefined(eventSupport[event])) {
                                    var divElm = document.createElement('div');
                                    eventSupport[event] = 'on' + event in divElm;
                                }
                                return eventSupport[event];
                            },
                            csp: csp(),
                            vendorPrefix: vendorPrefix,
                            transitions: transitions,
                            animations: animations,
                            android: android
                        };
                    }
                ];
            }
            var $compileMinErr = minErr('$compile');
            function $TemplateRequestProvider() {
                this.$get = [
                    '$templateCache',
                    '$http',
                    '$q',
                    '$sce',
                    function ($templateCache, $http, $q, $sce) {
                        function handleRequestFn(tpl, ignoreRequestError) {
                            handleRequestFn.totalPendingRequests++;
                            if (!isString(tpl) || !$templateCache.get(tpl)) {
                                tpl = $sce.getTrustedResourceUrl(tpl);
                            }
                            var transformResponse = $http.defaults && $http.defaults.transformResponse;
                            if (isArray(transformResponse)) {
                                transformResponse = transformResponse.filter(function (transformer) {
                                    return transformer !== defaultHttpResponseTransform;
                                });
                            } else if (transformResponse === defaultHttpResponseTransform) {
                                transformResponse = null;
                            }
                            var httpOptions = {
                                cache: $templateCache,
                                transformResponse: transformResponse
                            };
                            return $http.get(tpl, httpOptions)['finally'](function () {
                                handleRequestFn.totalPendingRequests--;
                            }).then(function (response) {
                                $templateCache.put(tpl, response.data);
                                return response.data;
                            }, handleError);
                            function handleError(resp) {
                                if (!ignoreRequestError) {
                                    throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
                                }
                                return $q.reject(resp);
                            }
                        }
                        handleRequestFn.totalPendingRequests = 0;
                        return handleRequestFn;
                    }
                ];
            }
            function $$TestabilityProvider() {
                this.$get = [
                    '$rootScope',
                    '$browser',
                    '$location',
                    function ($rootScope, $browser, $location) {
                        var testability = {};
                        testability.findBindings = function (element, expression, opt_exactMatch) {
                            var bindings = element.getElementsByClassName('ng-binding');
                            var matches = [];
                            forEach(bindings, function (binding) {
                                var dataBinding = angular.element(binding).data('$binding');
                                if (dataBinding) {
                                    forEach(dataBinding, function (bindingName) {
                                        if (opt_exactMatch) {
                                            var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                                            if (matcher.test(bindingName)) {
                                                matches.push(binding);
                                            }
                                        } else {
                                            if (bindingName.indexOf(expression) != -1) {
                                                matches.push(binding);
                                            }
                                        }
                                    });
                                }
                            });
                            return matches;
                        };
                        testability.findModels = function (element, expression, opt_exactMatch) {
                            var prefixes = [
                                'ng-',
                                'data-ng-',
                                'ng\\:'
                            ];
                            for (var p = 0; p < prefixes.length; ++p) {
                                var attributeEquals = opt_exactMatch ? '=' : '*=';
                                var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
                                var elements = element.querySelectorAll(selector);
                                if (elements.length) {
                                    return elements;
                                }
                            }
                        };
                        testability.getLocation = function () {
                            return $location.url();
                        };
                        testability.setLocation = function (url) {
                            if (url !== $location.url()) {
                                $location.url(url);
                                $rootScope.$digest();
                            }
                        };
                        testability.whenStable = function (callback) {
                            $browser.notifyWhenNoOutstandingRequests(callback);
                        };
                        return testability;
                    }
                ];
            }
            function $TimeoutProvider() {
                this.$get = [
                    '$rootScope',
                    '$browser',
                    '$q',
                    '$$q',
                    '$exceptionHandler',
                    function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
                        var deferreds = {};
                        function timeout(fn, delay, invokeApply) {
                            if (!isFunction(fn)) {
                                invokeApply = delay;
                                delay = fn;
                                fn = noop;
                            }
                            var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                            timeoutId = $browser.defer(function () {
                                try {
                                    deferred.resolve(fn.apply(null, args));
                                } catch (e) {
                                    deferred.reject(e);
                                    $exceptionHandler(e);
                                } finally {
                                    delete deferreds[promise.$$timeoutId];
                                }
                                if (!skipApply)
                                    $rootScope.$apply();
                            }, delay);
                            promise.$$timeoutId = timeoutId;
                            deferreds[timeoutId] = deferred;
                            return promise;
                        }
                        timeout.cancel = function (promise) {
                            if (promise && promise.$$timeoutId in deferreds) {
                                deferreds[promise.$$timeoutId].reject('canceled');
                                delete deferreds[promise.$$timeoutId];
                                return $browser.defer.cancel(promise.$$timeoutId);
                            }
                            return false;
                        };
                        return timeout;
                    }
                ];
            }
            var urlParsingNode = document.createElement('a');
            var originUrl = urlResolve(window.location.href);
            function urlResolve(url) {
                var href = url;
                if (msie) {
                    urlParsingNode.setAttribute('href', href);
                    href = urlParsingNode.href;
                }
                urlParsingNode.setAttribute('href', href);
                return {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                    host: urlParsingNode.host,
                    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                    hostname: urlParsingNode.hostname,
                    port: urlParsingNode.port,
                    pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
                };
            }
            function urlIsSameOrigin(requestUrl) {
                var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
                return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
            }
            function $WindowProvider() {
                this.$get = valueFn(window);
            }
            function $$CookieReader($document) {
                var rawDocument = $document[0] || {};
                var lastCookies = {};
                var lastCookieString = '';
                function safeDecodeURIComponent(str) {
                    try {
                        return decodeURIComponent(str);
                    } catch (e) {
                        return str;
                    }
                }
                return function () {
                    var cookieArray, cookie, i, index, name;
                    var currentCookieString = rawDocument.cookie || '';
                    if (currentCookieString !== lastCookieString) {
                        lastCookieString = currentCookieString;
                        cookieArray = lastCookieString.split('; ');
                        lastCookies = {};
                        for (i = 0; i < cookieArray.length; i++) {
                            cookie = cookieArray[i];
                            index = cookie.indexOf('=');
                            if (index > 0) {
                                name = safeDecodeURIComponent(cookie.substring(0, index));
                                if (isUndefined(lastCookies[name])) {
                                    lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                                }
                            }
                        }
                    }
                    return lastCookies;
                };
            }
            $$CookieReader.$inject = ['$document'];
            function $$CookieReaderProvider() {
                this.$get = $$CookieReader;
            }
            $FilterProvider.$inject = ['$provide'];
            function $FilterProvider($provide) {
                var suffix = 'Filter';
                function register(name, factory) {
                    if (isObject(name)) {
                        var filters = {};
                        forEach(name, function (filter, key) {
                            filters[key] = register(key, filter);
                        });
                        return filters;
                    } else {
                        return $provide.factory(name + suffix, factory);
                    }
                }
                this.register = register;
                this.$get = [
                    '$injector',
                    function ($injector) {
                        return function (name) {
                            return $injector.get(name + suffix);
                        };
                    }
                ];
                register('currency', currencyFilter);
                register('date', dateFilter);
                register('filter', filterFilter);
                register('json', jsonFilter);
                register('limitTo', limitToFilter);
                register('lowercase', lowercaseFilter);
                register('number', numberFilter);
                register('orderBy', orderByFilter);
                register('uppercase', uppercaseFilter);
            }
            function filterFilter() {
                return function (array, expression, comparator) {
                    if (!isArrayLike(array)) {
                        if (array == null) {
                            return array;
                        } else {
                            throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
                        }
                    }
                    var expressionType = getTypeForFilter(expression);
                    var predicateFn;
                    var matchAgainstAnyProp;
                    switch (expressionType) {
                    case 'function':
                        predicateFn = expression;
                        break;
                    case 'boolean':
                    case 'null':
                    case 'number':
                    case 'string':
                        matchAgainstAnyProp = true;
                    case 'object':
                        predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                        break;
                    default:
                        return array;
                    }
                    return Array.prototype.filter.call(array, predicateFn);
                };
            }
            function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
                var shouldMatchPrimitives = isObject(expression) && '$' in expression;
                var predicateFn;
                if (comparator === true) {
                    comparator = equals;
                } else if (!isFunction(comparator)) {
                    comparator = function (actual, expected) {
                        if (isUndefined(actual)) {
                            return false;
                        }
                        if (actual === null || expected === null) {
                            return actual === expected;
                        }
                        if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
                            return false;
                        }
                        actual = lowercase('' + actual);
                        expected = lowercase('' + expected);
                        return actual.indexOf(expected) !== -1;
                    };
                }
                predicateFn = function (item) {
                    if (shouldMatchPrimitives && !isObject(item)) {
                        return deepCompare(item, expression.$, comparator, false);
                    }
                    return deepCompare(item, expression, comparator, matchAgainstAnyProp);
                };
                return predicateFn;
            }
            function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
                var actualType = getTypeForFilter(actual);
                var expectedType = getTypeForFilter(expected);
                if (expectedType === 'string' && expected.charAt(0) === '!') {
                    return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
                } else if (isArray(actual)) {
                    return actual.some(function (item) {
                        return deepCompare(item, expected, comparator, matchAgainstAnyProp);
                    });
                }
                switch (actualType) {
                case 'object':
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual) {
                            if (key.charAt(0) !== '$' && deepCompare(actual[key], expected, comparator, true)) {
                                return true;
                            }
                        }
                        return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
                    } else if (expectedType === 'object') {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                                continue;
                            }
                            var matchAnyProperty = key === '$';
                            var actualVal = matchAnyProperty ? actual : actual[key];
                            if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                                return false;
                            }
                        }
                        return true;
                    } else {
                        return comparator(actual, expected);
                    }
                    break;
                case 'function':
                    return false;
                default:
                    return comparator(actual, expected);
                }
            }
            function getTypeForFilter(val) {
                return val === null ? 'null' : typeof val;
            }
            var MAX_DIGITS = 22;
            var DECIMAL_SEP = '.';
            var ZERO_CHAR = '0';
            currencyFilter.$inject = ['$locale'];
            function currencyFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function (amount, currencySymbol, fractionSize) {
                    if (isUndefined(currencySymbol)) {
                        currencySymbol = formats.CURRENCY_SYM;
                    }
                    if (isUndefined(fractionSize)) {
                        fractionSize = formats.PATTERNS[1].maxFrac;
                    }
                    return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
                };
            }
            numberFilter.$inject = ['$locale'];
            function numberFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function (number, fractionSize) {
                    return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
                };
            }
            function parse(numStr) {
                var exponent = 0, digits, numberOfIntegerDigits;
                var i, j, zeros;
                if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
                    numStr = numStr.replace(DECIMAL_SEP, '');
                }
                if ((i = numStr.search(/e/i)) > 0) {
                    if (numberOfIntegerDigits < 0)
                        numberOfIntegerDigits = i;
                    numberOfIntegerDigits += +numStr.slice(i + 1);
                    numStr = numStr.substring(0, i);
                } else if (numberOfIntegerDigits < 0) {
                    numberOfIntegerDigits = numStr.length;
                }
                for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {
                }
                if (i == (zeros = numStr.length)) {
                    digits = [0];
                    numberOfIntegerDigits = 1;
                } else {
                    zeros--;
                    while (numStr.charAt(zeros) == ZERO_CHAR)
                        zeros--;
                    numberOfIntegerDigits -= i;
                    digits = [];
                    for (j = 0; i <= zeros; i++, j++) {
                        digits[j] = +numStr.charAt(i);
                    }
                }
                if (numberOfIntegerDigits > MAX_DIGITS) {
                    digits = digits.splice(0, MAX_DIGITS - 1);
                    exponent = numberOfIntegerDigits - 1;
                    numberOfIntegerDigits = 1;
                }
                return {
                    d: digits,
                    e: exponent,
                    i: numberOfIntegerDigits
                };
            }
            function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
                var digits = parsedNumber.d;
                var fractionLen = digits.length - parsedNumber.i;
                fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
                var roundAt = fractionSize + parsedNumber.i;
                var digit = digits[roundAt];
                if (roundAt > 0) {
                    digits.splice(roundAt);
                } else {
                    parsedNumber.i = 1;
                    digits.length = roundAt = fractionSize + 1;
                    for (var i = 0; i < roundAt; i++)
                        digits[i] = 0;
                }
                if (digit >= 5)
                    digits[roundAt - 1]++;
                for (; fractionLen < fractionSize; fractionLen++)
                    digits.push(0);
                var carry = digits.reduceRight(function (carry, d, i, digits) {
                    d = d + carry;
                    digits[i] = d % 10;
                    return Math.floor(d / 10);
                }, 0);
                if (carry) {
                    digits.unshift(carry);
                    parsedNumber.i++;
                }
            }
            function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
                if (!(isString(number) || isNumber(number)) || isNaN(number))
                    return '';
                var isInfinity = !isFinite(number);
                var isZero = false;
                var numStr = Math.abs(number) + '', formattedText = '', parsedNumber;
                if (isInfinity) {
                    formattedText = '\u221E';
                } else {
                    parsedNumber = parse(numStr);
                    roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                    var digits = parsedNumber.d;
                    var integerLen = parsedNumber.i;
                    var exponent = parsedNumber.e;
                    var decimals = [];
                    isZero = digits.reduce(function (isZero, d) {
                        return isZero && !d;
                    }, true);
                    while (integerLen < 0) {
                        digits.unshift(0);
                        integerLen++;
                    }
                    if (integerLen > 0) {
                        decimals = digits.splice(integerLen);
                    } else {
                        decimals = digits;
                        digits = [0];
                    }
                    var groups = [];
                    if (digits.length > pattern.lgSize) {
                        groups.unshift(digits.splice(-pattern.lgSize).join(''));
                    }
                    while (digits.length > pattern.gSize) {
                        groups.unshift(digits.splice(-pattern.gSize).join(''));
                    }
                    if (digits.length) {
                        groups.unshift(digits.join(''));
                    }
                    formattedText = groups.join(groupSep);
                    if (decimals.length) {
                        formattedText += decimalSep + decimals.join('');
                    }
                    if (exponent) {
                        formattedText += 'e+' + exponent;
                    }
                }
                if (number < 0 && !isZero) {
                    return pattern.negPre + formattedText + pattern.negSuf;
                } else {
                    return pattern.posPre + formattedText + pattern.posSuf;
                }
            }
            function padNumber(num, digits, trim) {
                var neg = '';
                if (num < 0) {
                    neg = '-';
                    num = -num;
                }
                num = '' + num;
                while (num.length < digits)
                    num = ZERO_CHAR + num;
                if (trim) {
                    num = num.substr(num.length - digits);
                }
                return neg + num;
            }
            function dateGetter(name, size, offset, trim) {
                offset = offset || 0;
                return function (date) {
                    var value = date['get' + name]();
                    if (offset > 0 || value > -offset) {
                        value += offset;
                    }
                    if (value === 0 && offset == -12)
                        value = 12;
                    return padNumber(value, size, trim);
                };
            }
            function dateStrGetter(name, shortForm) {
                return function (date, formats) {
                    var value = date['get' + name]();
                    var get = uppercase(shortForm ? 'SHORT' + name : name);
                    return formats[get][value];
                };
            }
            function timeZoneGetter(date, formats, offset) {
                var zone = -1 * offset;
                var paddedZone = zone >= 0 ? '+' : '';
                paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
                return paddedZone;
            }
            function getFirstThursdayOfYear(year) {
                var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
                return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
            }
            function getThursdayThisWeek(datetime) {
                return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
            }
            function weekGetter(size) {
                return function (date) {
                    var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
                    var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 604800000);
                    return padNumber(result, size);
                };
            }
            function ampmGetter(date, formats) {
                return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
            }
            function eraGetter(date, formats) {
                return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
            }
            function longEraGetter(date, formats) {
                return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
            }
            var DATE_FORMATS = {
                yyyy: dateGetter('FullYear', 4),
                yy: dateGetter('FullYear', 2, 0, true),
                y: dateGetter('FullYear', 1),
                MMMM: dateStrGetter('Month'),
                MMM: dateStrGetter('Month', true),
                MM: dateGetter('Month', 2, 1),
                M: dateGetter('Month', 1, 1),
                dd: dateGetter('Date', 2),
                d: dateGetter('Date', 1),
                HH: dateGetter('Hours', 2),
                H: dateGetter('Hours', 1),
                hh: dateGetter('Hours', 2, -12),
                h: dateGetter('Hours', 1, -12),
                mm: dateGetter('Minutes', 2),
                m: dateGetter('Minutes', 1),
                ss: dateGetter('Seconds', 2),
                s: dateGetter('Seconds', 1),
                sss: dateGetter('Milliseconds', 3),
                EEEE: dateStrGetter('Day'),
                EEE: dateStrGetter('Day', true),
                a: ampmGetter,
                Z: timeZoneGetter,
                ww: weekGetter(2),
                w: weekGetter(1),
                G: eraGetter,
                GG: eraGetter,
                GGG: eraGetter,
                GGGG: longEraGetter
            };
            var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
            dateFilter.$inject = ['$locale'];
            function dateFilter($locale) {
                var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                function jsonStringToDate(string) {
                    var match;
                    if (match = string.match(R_ISO8601_STR)) {
                        var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                        if (match[9]) {
                            tzHour = toInt(match[9] + match[10]);
                            tzMin = toInt(match[9] + match[11]);
                        }
                        dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                        var h = toInt(match[4] || 0) - tzHour;
                        var m = toInt(match[5] || 0) - tzMin;
                        var s = toInt(match[6] || 0);
                        var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
                        timeSetter.call(date, h, m, s, ms);
                        return date;
                    }
                    return string;
                }
                return function (date, format, timezone) {
                    var text = '', parts = [], fn, match;
                    format = format || 'mediumDate';
                    format = $locale.DATETIME_FORMATS[format] || format;
                    if (isString(date)) {
                        date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
                    }
                    if (isNumber(date)) {
                        date = new Date(date);
                    }
                    if (!isDate(date) || !isFinite(date.getTime())) {
                        return date;
                    }
                    while (format) {
                        match = DATE_FORMATS_SPLIT.exec(format);
                        if (match) {
                            parts = concat(parts, match, 1);
                            format = parts.pop();
                        } else {
                            parts.push(format);
                            format = null;
                        }
                    }
                    var dateTimezoneOffset = date.getTimezoneOffset();
                    if (timezone) {
                        dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                        date = convertTimezoneToLocal(date, timezone, true);
                    }
                    forEach(parts, function (value) {
                        fn = DATE_FORMATS[value];
                        text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === '\'\'' ? '\'' : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
                    });
                    return text;
                };
            }
            function jsonFilter() {
                return function (object, spacing) {
                    if (isUndefined(spacing)) {
                        spacing = 2;
                    }
                    return toJson(object, spacing);
                };
            }
            var lowercaseFilter = valueFn(lowercase);
            var uppercaseFilter = valueFn(uppercase);
            function limitToFilter() {
                return function (input, limit, begin) {
                    if (Math.abs(Number(limit)) === Infinity) {
                        limit = Number(limit);
                    } else {
                        limit = toInt(limit);
                    }
                    if (isNaN(limit))
                        return input;
                    if (isNumber(input))
                        input = input.toString();
                    if (!isArray(input) && !isString(input))
                        return input;
                    begin = !begin || isNaN(begin) ? 0 : toInt(begin);
                    begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
                    if (limit >= 0) {
                        return input.slice(begin, begin + limit);
                    } else {
                        if (begin === 0) {
                            return input.slice(limit, input.length);
                        } else {
                            return input.slice(Math.max(0, begin + limit), begin);
                        }
                    }
                };
            }
            orderByFilter.$inject = ['$parse'];
            function orderByFilter($parse) {
                return function (array, sortPredicate, reverseOrder) {
                    if (!isArrayLike(array))
                        return array;
                    if (!isArray(sortPredicate)) {
                        sortPredicate = [sortPredicate];
                    }
                    if (sortPredicate.length === 0) {
                        sortPredicate = ['+'];
                    }
                    var predicates = processPredicates(sortPredicate, reverseOrder);
                    predicates.push({
                        get: function () {
                            return {};
                        },
                        descending: reverseOrder ? -1 : 1
                    });
                    var compareValues = Array.prototype.map.call(array, getComparisonObject);
                    compareValues.sort(doComparison);
                    array = compareValues.map(function (item) {
                        return item.value;
                    });
                    return array;
                    function getComparisonObject(value, index) {
                        return {
                            value: value,
                            predicateValues: predicates.map(function (predicate) {
                                return getPredicateValue(predicate.get(value), index);
                            })
                        };
                    }
                    function doComparison(v1, v2) {
                        var result = 0;
                        for (var index = 0, length = predicates.length; index < length; ++index) {
                            result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
                            if (result)
                                break;
                        }
                        return result;
                    }
                };
                function processPredicates(sortPredicate, reverseOrder) {
                    reverseOrder = reverseOrder ? -1 : 1;
                    return sortPredicate.map(function (predicate) {
                        var descending = 1, get = identity;
                        if (isFunction(predicate)) {
                            get = predicate;
                        } else if (isString(predicate)) {
                            if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
                                descending = predicate.charAt(0) == '-' ? -1 : 1;
                                predicate = predicate.substring(1);
                            }
                            if (predicate !== '') {
                                get = $parse(predicate);
                                if (get.constant) {
                                    var key = get();
                                    get = function (value) {
                                        return value[key];
                                    };
                                }
                            }
                        }
                        return {
                            get: get,
                            descending: descending * reverseOrder
                        };
                    });
                }
                function isPrimitive(value) {
                    switch (typeof value) {
                    case 'number':
                    case 'boolean':
                    case 'string':
                        return true;
                    default:
                        return false;
                    }
                }
                function objectValue(value, index) {
                    if (typeof value.valueOf === 'function') {
                        value = value.valueOf();
                        if (isPrimitive(value))
                            return value;
                    }
                    if (hasCustomToString(value)) {
                        value = value.toString();
                        if (isPrimitive(value))
                            return value;
                    }
                    return index;
                }
                function getPredicateValue(value, index) {
                    var type = typeof value;
                    if (value === null) {
                        type = 'string';
                        value = 'null';
                    } else if (type === 'string') {
                        value = value.toLowerCase();
                    } else if (type === 'object') {
                        value = objectValue(value, index);
                    }
                    return {
                        value: value,
                        type: type
                    };
                }
                function compare(v1, v2) {
                    var result = 0;
                    if (v1.type === v2.type) {
                        if (v1.value !== v2.value) {
                            result = v1.value < v2.value ? -1 : 1;
                        }
                    } else {
                        result = v1.type < v2.type ? -1 : 1;
                    }
                    return result;
                }
            }
            function ngDirective(directive) {
                if (isFunction(directive)) {
                    directive = { link: directive };
                }
                directive.restrict = directive.restrict || 'AC';
                return valueFn(directive);
            }
            var htmlAnchorDirective = valueFn({
                restrict: 'E',
                compile: function (element, attr) {
                    if (!attr.href && !attr.xlinkHref) {
                        return function (scope, element) {
                            if (element[0].nodeName.toLowerCase() !== 'a')
                                return;
                            var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
                            element.on('click', function (event) {
                                if (!element.attr(href)) {
                                    event.preventDefault();
                                }
                            });
                        };
                    }
                }
            });
            var ngAttributeAliasDirectives = {};
            forEach(BOOLEAN_ATTR, function (propName, attrName) {
                if (propName == 'multiple')
                    return;
                function defaultLinkFn(scope, element, attr) {
                    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                        attr.$set(attrName, !!value);
                    });
                }
                var normalized = directiveNormalize('ng-' + attrName);
                var linkFn = defaultLinkFn;
                if (propName === 'checked') {
                    linkFn = function (scope, element, attr) {
                        if (attr.ngModel !== attr[normalized]) {
                            defaultLinkFn(scope, element, attr);
                        }
                    };
                }
                ngAttributeAliasDirectives[normalized] = function () {
                    return {
                        restrict: 'A',
                        priority: 100,
                        link: linkFn
                    };
                };
            });
            forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
                ngAttributeAliasDirectives[ngAttr] = function () {
                    return {
                        priority: 100,
                        link: function (scope, element, attr) {
                            if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) == '/') {
                                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                                if (match) {
                                    attr.$set('ngPattern', new RegExp(match[1], match[2]));
                                    return;
                                }
                            }
                            scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                                attr.$set(ngAttr, value);
                            });
                        }
                    };
                };
            });
            forEach([
                'src',
                'srcset',
                'href'
            ], function (attrName) {
                var normalized = directiveNormalize('ng-' + attrName);
                ngAttributeAliasDirectives[normalized] = function () {
                    return {
                        priority: 99,
                        link: function (scope, element, attr) {
                            var propName = attrName, name = attrName;
                            if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                                name = 'xlinkHref';
                                attr.$attr[name] = 'xlink:href';
                                propName = null;
                            }
                            attr.$observe(normalized, function (value) {
                                if (!value) {
                                    if (attrName === 'href') {
                                        attr.$set(name, null);
                                    }
                                    return;
                                }
                                attr.$set(name, value);
                                if (msie && propName)
                                    element.prop(propName, attr[name]);
                            });
                        }
                    };
                };
            });
            var nullFormCtrl = {
                    $addControl: noop,
                    $$renameControl: nullFormRenameControl,
                    $removeControl: noop,
                    $setValidity: noop,
                    $setDirty: noop,
                    $setPristine: noop,
                    $setSubmitted: noop
                }, SUBMITTED_CLASS = 'ng-submitted';
            function nullFormRenameControl(control, name) {
                control.$name = name;
            }
            FormController.$inject = [
                '$element',
                '$attrs',
                '$scope',
                '$animate',
                '$interpolate'
            ];
            function FormController(element, attrs, $scope, $animate, $interpolate) {
                var form = this, controls = [];
                form.$error = {};
                form.$$success = {};
                form.$pending = undefined;
                form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
                form.$dirty = false;
                form.$pristine = true;
                form.$valid = true;
                form.$invalid = false;
                form.$submitted = false;
                form.$$parentForm = nullFormCtrl;
                form.$rollbackViewValue = function () {
                    forEach(controls, function (control) {
                        control.$rollbackViewValue();
                    });
                };
                form.$commitViewValue = function () {
                    forEach(controls, function (control) {
                        control.$commitViewValue();
                    });
                };
                form.$addControl = function (control) {
                    assertNotHasOwnProperty(control.$name, 'input');
                    controls.push(control);
                    if (control.$name) {
                        form[control.$name] = control;
                    }
                    control.$$parentForm = form;
                };
                form.$$renameControl = function (control, newName) {
                    var oldName = control.$name;
                    if (form[oldName] === control) {
                        delete form[oldName];
                    }
                    form[newName] = control;
                    control.$name = newName;
                };
                form.$removeControl = function (control) {
                    if (control.$name && form[control.$name] === control) {
                        delete form[control.$name];
                    }
                    forEach(form.$pending, function (value, name) {
                        form.$setValidity(name, null, control);
                    });
                    forEach(form.$error, function (value, name) {
                        form.$setValidity(name, null, control);
                    });
                    forEach(form.$$success, function (value, name) {
                        form.$setValidity(name, null, control);
                    });
                    arrayRemove(controls, control);
                    control.$$parentForm = nullFormCtrl;
                };
                addSetValidityMethod({
                    ctrl: this,
                    $element: element,
                    set: function (object, property, controller) {
                        var list = object[property];
                        if (!list) {
                            object[property] = [controller];
                        } else {
                            var index = list.indexOf(controller);
                            if (index === -1) {
                                list.push(controller);
                            }
                        }
                    },
                    unset: function (object, property, controller) {
                        var list = object[property];
                        if (!list) {
                            return;
                        }
                        arrayRemove(list, controller);
                        if (list.length === 0) {
                            delete object[property];
                        }
                    },
                    $animate: $animate
                });
                form.$setDirty = function () {
                    $animate.removeClass(element, PRISTINE_CLASS);
                    $animate.addClass(element, DIRTY_CLASS);
                    form.$dirty = true;
                    form.$pristine = false;
                    form.$$parentForm.$setDirty();
                };
                form.$setPristine = function () {
                    $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
                    form.$dirty = false;
                    form.$pristine = true;
                    form.$submitted = false;
                    forEach(controls, function (control) {
                        control.$setPristine();
                    });
                };
                form.$setUntouched = function () {
                    forEach(controls, function (control) {
                        control.$setUntouched();
                    });
                };
                form.$setSubmitted = function () {
                    $animate.addClass(element, SUBMITTED_CLASS);
                    form.$submitted = true;
                    form.$$parentForm.$setSubmitted();
                };
            }
            var formDirectiveFactory = function (isNgForm) {
                return [
                    '$timeout',
                    '$parse',
                    function ($timeout, $parse) {
                        var formDirective = {
                            name: 'form',
                            restrict: isNgForm ? 'EAC' : 'E',
                            require: [
                                'form',
                                '^^?form'
                            ],
                            controller: FormController,
                            compile: function ngFormCompile(formElement, attr) {
                                formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                                var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false;
                                return {
                                    pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                                        var controller = ctrls[0];
                                        if (!('action' in attr)) {
                                            var handleFormSubmission = function (event) {
                                                scope.$apply(function () {
                                                    controller.$commitViewValue();
                                                    controller.$setSubmitted();
                                                });
                                                event.preventDefault();
                                            };
                                            addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                                            formElement.on('$destroy', function () {
                                                $timeout(function () {
                                                    removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                                                }, 0, false);
                                            });
                                        }
                                        var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                                        parentFormCtrl.$addControl(controller);
                                        var setter = nameAttr ? getSetter(controller.$name) : noop;
                                        if (nameAttr) {
                                            setter(scope, controller);
                                            attr.$observe(nameAttr, function (newValue) {
                                                if (controller.$name === newValue)
                                                    return;
                                                setter(scope, undefined);
                                                controller.$$parentForm.$$renameControl(controller, newValue);
                                                setter = getSetter(controller.$name);
                                                setter(scope, controller);
                                            });
                                        }
                                        formElement.on('$destroy', function () {
                                            controller.$$parentForm.$removeControl(controller);
                                            setter(scope, undefined);
                                            extend(controller, nullFormCtrl);
                                        });
                                    }
                                };
                            }
                        };
                        return formDirective;
                        function getSetter(expression) {
                            if (expression === '') {
                                return $parse('this[""]').assign;
                            }
                            return $parse(expression).assign || noop;
                        }
                    }
                ];
            };
            var formDirective = formDirectiveFactory();
            var ngFormDirective = formDirectiveFactory(true);
            var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
            var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
            var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
            var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
            var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
            var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
            var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
            var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
            var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
            var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
            var PARTIAL_VALIDATION_TYPES = createMap();
            forEach('date,datetime-local,month,time,week'.split(','), function (type) {
                PARTIAL_VALIDATION_TYPES[type] = true;
            });
            var inputType = {
                'text': textInputType,
                'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, [
                    'yyyy',
                    'MM',
                    'dd'
                ]), 'yyyy-MM-dd'),
                'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [
                    'yyyy',
                    'MM',
                    'dd',
                    'HH',
                    'mm',
                    'ss',
                    'sss'
                ]), 'yyyy-MM-ddTHH:mm:ss.sss'),
                'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, [
                    'HH',
                    'mm',
                    'ss',
                    'sss'
                ]), 'HH:mm:ss.sss'),
                'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
                'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, [
                    'yyyy',
                    'MM'
                ]), 'yyyy-MM'),
                'number': numberInputType,
                'url': urlInputType,
                'email': emailInputType,
                'radio': radioInputType,
                'checkbox': checkboxInputType,
                'hidden': noop,
                'button': noop,
                'submit': noop,
                'reset': noop,
                'file': noop
            };
            function stringBasedInputType(ctrl) {
                ctrl.$formatters.push(function (value) {
                    return ctrl.$isEmpty(value) ? value : value.toString();
                });
            }
            function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                stringBasedInputType(ctrl);
            }
            function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                var type = lowercase(element[0].type);
                if (!$sniffer.android) {
                    var composing = false;
                    element.on('compositionstart', function (data) {
                        composing = true;
                    });
                    element.on('compositionend', function () {
                        composing = false;
                        listener();
                    });
                }
                var timeout;
                var listener = function (ev) {
                    if (timeout) {
                        $browser.defer.cancel(timeout);
                        timeout = null;
                    }
                    if (composing)
                        return;
                    var value = element.val(), event = ev && ev.type;
                    if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
                        value = trim(value);
                    }
                    if (ctrl.$viewValue !== value || value === '' && ctrl.$$hasNativeValidators) {
                        ctrl.$setViewValue(value, event);
                    }
                };
                if ($sniffer.hasEvent('input')) {
                    element.on('input', listener);
                } else {
                    var deferListener = function (ev, input, origValue) {
                        if (!timeout) {
                            timeout = $browser.defer(function () {
                                timeout = null;
                                if (!input || input.value !== origValue) {
                                    listener(ev);
                                }
                            });
                        }
                    };
                    element.on('keydown', function (event) {
                        var key = event.keyCode;
                        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
                            return;
                        deferListener(event, this, this.value);
                    });
                    if ($sniffer.hasEvent('paste')) {
                        element.on('paste cut', deferListener);
                    }
                }
                element.on('change', listener);
                if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
                    element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
                        if (!timeout) {
                            var validity = this[VALIDITY_STATE_PROPERTY];
                            var origBadInput = validity.badInput;
                            var origTypeMismatch = validity.typeMismatch;
                            timeout = $browser.defer(function () {
                                timeout = null;
                                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                                    listener(ev);
                                }
                            });
                        }
                    });
                }
                ctrl.$render = function () {
                    var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
                    if (element.val() !== value) {
                        element.val(value);
                    }
                };
            }
            function weekParser(isoWeek, existingDate) {
                if (isDate(isoWeek)) {
                    return isoWeek;
                }
                if (isString(isoWeek)) {
                    WEEK_REGEXP.lastIndex = 0;
                    var parts = WEEK_REGEXP.exec(isoWeek);
                    if (parts) {
                        var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                        if (existingDate) {
                            hours = existingDate.getHours();
                            minutes = existingDate.getMinutes();
                            seconds = existingDate.getSeconds();
                            milliseconds = existingDate.getMilliseconds();
                        }
                        return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                    }
                }
                return NaN;
            }
            function createDateParser(regexp, mapping) {
                return function (iso, date) {
                    var parts, map;
                    if (isDate(iso)) {
                        return iso;
                    }
                    if (isString(iso)) {
                        if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
                            iso = iso.substring(1, iso.length - 1);
                        }
                        if (ISO_DATE_REGEXP.test(iso)) {
                            return new Date(iso);
                        }
                        regexp.lastIndex = 0;
                        parts = regexp.exec(iso);
                        if (parts) {
                            parts.shift();
                            if (date) {
                                map = {
                                    yyyy: date.getFullYear(),
                                    MM: date.getMonth() + 1,
                                    dd: date.getDate(),
                                    HH: date.getHours(),
                                    mm: date.getMinutes(),
                                    ss: date.getSeconds(),
                                    sss: date.getMilliseconds() / 1000
                                };
                            } else {
                                map = {
                                    yyyy: 1970,
                                    MM: 1,
                                    dd: 1,
                                    HH: 0,
                                    mm: 0,
                                    ss: 0,
                                    sss: 0
                                };
                            }
                            forEach(parts, function (part, index) {
                                if (index < mapping.length) {
                                    map[mapping[index]] = +part;
                                }
                            });
                            return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
                        }
                    }
                    return NaN;
                };
            }
            function createDateInputType(type, regexp, parseDate, format) {
                return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
                    badInputChecker(scope, element, attr, ctrl);
                    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                    var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
                    var previousDate;
                    ctrl.$$parserName = type;
                    ctrl.$parsers.push(function (value) {
                        if (ctrl.$isEmpty(value))
                            return null;
                        if (regexp.test(value)) {
                            var parsedDate = parseDate(value, previousDate);
                            if (timezone) {
                                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                            }
                            return parsedDate;
                        }
                        return undefined;
                    });
                    ctrl.$formatters.push(function (value) {
                        if (value && !isDate(value)) {
                            throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
                        }
                        if (isValidDate(value)) {
                            previousDate = value;
                            if (previousDate && timezone) {
                                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                            }
                            return $filter('date')(value, format, timezone);
                        } else {
                            previousDate = null;
                            return '';
                        }
                    });
                    if (isDefined(attr.min) || attr.ngMin) {
                        var minVal;
                        ctrl.$validators.min = function (value) {
                            return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                        };
                        attr.$observe('min', function (val) {
                            minVal = parseObservedDateValue(val);
                            ctrl.$validate();
                        });
                    }
                    if (isDefined(attr.max) || attr.ngMax) {
                        var maxVal;
                        ctrl.$validators.max = function (value) {
                            return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                        };
                        attr.$observe('max', function (val) {
                            maxVal = parseObservedDateValue(val);
                            ctrl.$validate();
                        });
                    }
                    function isValidDate(value) {
                        return value && !(value.getTime && value.getTime() !== value.getTime());
                    }
                    function parseObservedDateValue(val) {
                        return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
                    }
                };
            }
            function badInputChecker(scope, element, attr, ctrl) {
                var node = element[0];
                var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
                if (nativeValidation) {
                    ctrl.$parsers.push(function (value) {
                        var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                        return validity.badInput && !validity.typeMismatch ? undefined : value;
                    });
                }
            }
            function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                badInputChecker(scope, element, attr, ctrl);
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                ctrl.$$parserName = 'number';
                ctrl.$parsers.push(function (value) {
                    if (ctrl.$isEmpty(value))
                        return null;
                    if (NUMBER_REGEXP.test(value))
                        return parseFloat(value);
                    return undefined;
                });
                ctrl.$formatters.push(function (value) {
                    if (!ctrl.$isEmpty(value)) {
                        if (!isNumber(value)) {
                            throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
                        }
                        value = value.toString();
                    }
                    return value;
                });
                if (isDefined(attr.min) || attr.ngMin) {
                    var minVal;
                    ctrl.$validators.min = function (value) {
                        return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
                    };
                    attr.$observe('min', function (val) {
                        if (isDefined(val) && !isNumber(val)) {
                            val = parseFloat(val, 10);
                        }
                        minVal = isNumber(val) && !isNaN(val) ? val : undefined;
                        ctrl.$validate();
                    });
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal;
                    ctrl.$validators.max = function (value) {
                        return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
                    };
                    attr.$observe('max', function (val) {
                        if (isDefined(val) && !isNumber(val)) {
                            val = parseFloat(val, 10);
                        }
                        maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
                        ctrl.$validate();
                    });
                }
            }
            function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                stringBasedInputType(ctrl);
                ctrl.$$parserName = 'url';
                ctrl.$validators.url = function (modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
                };
            }
            function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                stringBasedInputType(ctrl);
                ctrl.$$parserName = 'email';
                ctrl.$validators.email = function (modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
                };
            }
            function radioInputType(scope, element, attr, ctrl) {
                if (isUndefined(attr.name)) {
                    element.attr('name', nextUid());
                }
                var listener = function (ev) {
                    if (element[0].checked) {
                        ctrl.$setViewValue(attr.value, ev && ev.type);
                    }
                };
                element.on('click', listener);
                ctrl.$render = function () {
                    var value = attr.value;
                    element[0].checked = value == ctrl.$viewValue;
                };
                attr.$observe('value', ctrl.$render);
            }
            function parseConstantExpr($parse, context, name, expression, fallback) {
                var parseFn;
                if (isDefined(expression)) {
                    parseFn = $parse(expression);
                    if (!parseFn.constant) {
                        throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
                    }
                    return parseFn(context);
                }
                return fallback;
            }
            function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
                var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
                var listener = function (ev) {
                    ctrl.$setViewValue(element[0].checked, ev && ev.type);
                };
                element.on('click', listener);
                ctrl.$render = function () {
                    element[0].checked = ctrl.$viewValue;
                };
                ctrl.$isEmpty = function (value) {
                    return value === false;
                };
                ctrl.$formatters.push(function (value) {
                    return equals(value, trueValue);
                });
                ctrl.$parsers.push(function (value) {
                    return value ? trueValue : falseValue;
                });
            }
            var inputDirective = [
                '$browser',
                '$sniffer',
                '$filter',
                '$parse',
                function ($browser, $sniffer, $filter, $parse) {
                    return {
                        restrict: 'E',
                        require: ['?ngModel'],
                        link: {
                            pre: function (scope, element, attr, ctrls) {
                                if (ctrls[0]) {
                                    (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                                }
                            }
                        }
                    };
                }
            ];
            var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
            var ngValueDirective = function () {
                return {
                    restrict: 'A',
                    priority: 100,
                    compile: function (tpl, tplAttr) {
                        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                            return function ngValueConstantLink(scope, elm, attr) {
                                attr.$set('value', scope.$eval(attr.ngValue));
                            };
                        } else {
                            return function ngValueLink(scope, elm, attr) {
                                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                                    attr.$set('value', value);
                                });
                            };
                        }
                    }
                };
            };
            var ngBindDirective = [
                '$compile',
                function ($compile) {
                    return {
                        restrict: 'AC',
                        compile: function ngBindCompile(templateElement) {
                            $compile.$$addBindingClass(templateElement);
                            return function ngBindLink(scope, element, attr) {
                                $compile.$$addBindingInfo(element, attr.ngBind);
                                element = element[0];
                                scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                                    element.textContent = isUndefined(value) ? '' : value;
                                });
                            };
                        }
                    };
                }
            ];
            var ngBindTemplateDirective = [
                '$interpolate',
                '$compile',
                function ($interpolate, $compile) {
                    return {
                        compile: function ngBindTemplateCompile(templateElement) {
                            $compile.$$addBindingClass(templateElement);
                            return function ngBindTemplateLink(scope, element, attr) {
                                var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                                $compile.$$addBindingInfo(element, interpolateFn.expressions);
                                element = element[0];
                                attr.$observe('ngBindTemplate', function (value) {
                                    element.textContent = isUndefined(value) ? '' : value;
                                });
                            };
                        }
                    };
                }
            ];
            var ngBindHtmlDirective = [
                '$sce',
                '$parse',
                '$compile',
                function ($sce, $parse, $compile) {
                    return {
                        restrict: 'A',
                        compile: function ngBindHtmlCompile(tElement, tAttrs) {
                            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
                                return (value || '').toString();
                            });
                            $compile.$$addBindingClass(tElement);
                            return function ngBindHtmlLink(scope, element, attr) {
                                $compile.$$addBindingInfo(element, attr.ngBindHtml);
                                scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                                    element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
                                });
                            };
                        }
                    };
                }
            ];
            var ngChangeDirective = valueFn({
                restrict: 'A',
                require: 'ngModel',
                link: function (scope, element, attr, ctrl) {
                    ctrl.$viewChangeListeners.push(function () {
                        scope.$eval(attr.ngChange);
                    });
                }
            });
            function classDirective(name, selector) {
                name = 'ngClass' + name;
                return [
                    '$animate',
                    function ($animate) {
                        return {
                            restrict: 'AC',
                            link: function (scope, element, attr) {
                                var oldVal;
                                scope.$watch(attr[name], ngClassWatchAction, true);
                                attr.$observe('class', function (value) {
                                    ngClassWatchAction(scope.$eval(attr[name]));
                                });
                                if (name !== 'ngClass') {
                                    scope.$watch('$index', function ($index, old$index) {
                                        var mod = $index & 1;
                                        if (mod !== (old$index & 1)) {
                                            var classes = arrayClasses(scope.$eval(attr[name]));
                                            mod === selector ? addClasses(classes) : removeClasses(classes);
                                        }
                                    });
                                }
                                function addClasses(classes) {
                                    var newClasses = digestClassCounts(classes, 1);
                                    attr.$addClass(newClasses);
                                }
                                function removeClasses(classes) {
                                    var newClasses = digestClassCounts(classes, -1);
                                    attr.$removeClass(newClasses);
                                }
                                function digestClassCounts(classes, count) {
                                    var classCounts = element.data('$classCounts') || createMap();
                                    var classesToUpdate = [];
                                    forEach(classes, function (className) {
                                        if (count > 0 || classCounts[className]) {
                                            classCounts[className] = (classCounts[className] || 0) + count;
                                            if (classCounts[className] === +(count > 0)) {
                                                classesToUpdate.push(className);
                                            }
                                        }
                                    });
                                    element.data('$classCounts', classCounts);
                                    return classesToUpdate.join(' ');
                                }
                                function updateClasses(oldClasses, newClasses) {
                                    var toAdd = arrayDifference(newClasses, oldClasses);
                                    var toRemove = arrayDifference(oldClasses, newClasses);
                                    toAdd = digestClassCounts(toAdd, 1);
                                    toRemove = digestClassCounts(toRemove, -1);
                                    if (toAdd && toAdd.length) {
                                        $animate.addClass(element, toAdd);
                                    }
                                    if (toRemove && toRemove.length) {
                                        $animate.removeClass(element, toRemove);
                                    }
                                }
                                function ngClassWatchAction(newVal) {
                                    if (selector === true || scope.$index % 2 === selector) {
                                        var newClasses = arrayClasses(newVal || []);
                                        if (!oldVal) {
                                            addClasses(newClasses);
                                        } else if (!equals(newVal, oldVal)) {
                                            var oldClasses = arrayClasses(oldVal);
                                            updateClasses(oldClasses, newClasses);
                                        }
                                    }
                                    oldVal = shallowCopy(newVal);
                                }
                            }
                        };
                        function arrayDifference(tokens1, tokens2) {
                            var values = [];
                            outer:
                                for (var i = 0; i < tokens1.length; i++) {
                                    var token = tokens1[i];
                                    for (var j = 0; j < tokens2.length; j++) {
                                        if (token == tokens2[j])
                                            continue outer;
                                    }
                                    values.push(token);
                                }
                            return values;
                        }
                        function arrayClasses(classVal) {
                            var classes = [];
                            if (isArray(classVal)) {
                                forEach(classVal, function (v) {
                                    classes = classes.concat(arrayClasses(v));
                                });
                                return classes;
                            } else if (isString(classVal)) {
                                return classVal.split(' ');
                            } else if (isObject(classVal)) {
                                forEach(classVal, function (v, k) {
                                    if (v) {
                                        classes = classes.concat(k.split(' '));
                                    }
                                });
                                return classes;
                            }
                            return classVal;
                        }
                    }
                ];
            }
            var ngClassDirective = classDirective('', true);
            var ngClassOddDirective = classDirective('Odd', 0);
            var ngClassEvenDirective = classDirective('Even', 1);
            var ngCloakDirective = ngDirective({
                compile: function (element, attr) {
                    attr.$set('ngCloak', undefined);
                    element.removeClass('ng-cloak');
                }
            });
            var ngControllerDirective = [function () {
                    return {
                        restrict: 'A',
                        scope: true,
                        controller: '@',
                        priority: 500
                    };
                }];
            var ngEventDirectives = {};
            var forceAsyncEvents = {
                'blur': true,
                'focus': true
            };
            forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function (eventName) {
                var directiveName = directiveNormalize('ng-' + eventName);
                ngEventDirectives[directiveName] = [
                    '$parse',
                    '$rootScope',
                    function ($parse, $rootScope) {
                        return {
                            restrict: 'A',
                            compile: function ($element, attr) {
                                var fn = $parse(attr[directiveName], null, true);
                                return function ngEventHandler(scope, element) {
                                    element.on(eventName, function (event) {
                                        var callback = function () {
                                            fn(scope, { $event: event });
                                        };
                                        if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                            scope.$evalAsync(callback);
                                        } else {
                                            scope.$apply(callback);
                                        }
                                    });
                                };
                            }
                        };
                    }
                ];
            });
            var ngIfDirective = [
                '$animate',
                function ($animate) {
                    return {
                        multiElement: true,
                        transclude: 'element',
                        priority: 600,
                        terminal: true,
                        restrict: 'A',
                        $$tlb: true,
                        link: function ($scope, $element, $attr, ctrl, $transclude) {
                            var block, childScope, previousElements;
                            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                                if (value) {
                                    if (!childScope) {
                                        $transclude(function (clone, newScope) {
                                            childScope = newScope;
                                            clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                                            block = { clone: clone };
                                            $animate.enter(clone, $element.parent(), $element);
                                        });
                                    }
                                } else {
                                    if (previousElements) {
                                        previousElements.remove();
                                        previousElements = null;
                                    }
                                    if (childScope) {
                                        childScope.$destroy();
                                        childScope = null;
                                    }
                                    if (block) {
                                        previousElements = getBlockNodes(block.clone);
                                        $animate.leave(previousElements).then(function () {
                                            previousElements = null;
                                        });
                                        block = null;
                                    }
                                }
                            });
                        }
                    };
                }
            ];
            var ngIncludeDirective = [
                '$templateRequest',
                '$anchorScroll',
                '$animate',
                function ($templateRequest, $anchorScroll, $animate) {
                    return {
                        restrict: 'ECA',
                        priority: 400,
                        terminal: true,
                        transclude: 'element',
                        controller: angular.noop,
                        compile: function (element, attr) {
                            var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
                            return function (scope, $element, $attr, ctrl, $transclude) {
                                var changeCounter = 0, currentScope, previousElement, currentElement;
                                var cleanupLastIncludeContent = function () {
                                    if (previousElement) {
                                        previousElement.remove();
                                        previousElement = null;
                                    }
                                    if (currentScope) {
                                        currentScope.$destroy();
                                        currentScope = null;
                                    }
                                    if (currentElement) {
                                        $animate.leave(currentElement).then(function () {
                                            previousElement = null;
                                        });
                                        previousElement = currentElement;
                                        currentElement = null;
                                    }
                                };
                                scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                                    var afterAnimation = function () {
                                        if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                            $anchorScroll();
                                        }
                                    };
                                    var thisChangeId = ++changeCounter;
                                    if (src) {
                                        $templateRequest(src, true).then(function (response) {
                                            if (scope.$$destroyed)
                                                return;
                                            if (thisChangeId !== changeCounter)
                                                return;
                                            var newScope = scope.$new();
                                            ctrl.template = response;
                                            var clone = $transclude(newScope, function (clone) {
                                                cleanupLastIncludeContent();
                                                $animate.enter(clone, null, $element).then(afterAnimation);
                                            });
                                            currentScope = newScope;
                                            currentElement = clone;
                                            currentScope.$emit('$includeContentLoaded', src);
                                            scope.$eval(onloadExp);
                                        }, function () {
                                            if (scope.$$destroyed)
                                                return;
                                            if (thisChangeId === changeCounter) {
                                                cleanupLastIncludeContent();
                                                scope.$emit('$includeContentError', src);
                                            }
                                        });
                                        scope.$emit('$includeContentRequested', src);
                                    } else {
                                        cleanupLastIncludeContent();
                                        ctrl.template = null;
                                    }
                                });
                            };
                        }
                    };
                }
            ];
            var ngIncludeFillContentDirective = [
                '$compile',
                function ($compile) {
                    return {
                        restrict: 'ECA',
                        priority: -400,
                        require: 'ngInclude',
                        link: function (scope, $element, $attr, ctrl) {
                            if (/SVG/.test($element[0].toString())) {
                                $element.empty();
                                $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                                    $element.append(clone);
                                }, { futureParentElement: $element });
                                return;
                            }
                            $element.html(ctrl.template);
                            $compile($element.contents())(scope);
                        }
                    };
                }
            ];
            var ngInitDirective = ngDirective({
                priority: 450,
                compile: function () {
                    return {
                        pre: function (scope, element, attrs) {
                            scope.$eval(attrs.ngInit);
                        }
                    };
                }
            });
            var ngListDirective = function () {
                return {
                    restrict: 'A',
                    priority: 100,
                    require: 'ngModel',
                    link: function (scope, element, attr, ctrl) {
                        var ngList = element.attr(attr.$attr.ngList) || ', ';
                        var trimValues = attr.ngTrim !== 'false';
                        var separator = trimValues ? trim(ngList) : ngList;
                        var parse = function (viewValue) {
                            if (isUndefined(viewValue))
                                return;
                            var list = [];
                            if (viewValue) {
                                forEach(viewValue.split(separator), function (value) {
                                    if (value)
                                        list.push(trimValues ? trim(value) : value);
                                });
                            }
                            return list;
                        };
                        ctrl.$parsers.push(parse);
                        ctrl.$formatters.push(function (value) {
                            if (isArray(value)) {
                                return value.join(ngList);
                            }
                            return undefined;
                        });
                        ctrl.$isEmpty = function (value) {
                            return !value || !value.length;
                        };
                    }
                };
            };
            var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty', UNTOUCHED_CLASS = 'ng-untouched', TOUCHED_CLASS = 'ng-touched', PENDING_CLASS = 'ng-pending';
            var ngModelMinErr = minErr('ngModel');
            var NgModelController = [
                '$scope',
                '$exceptionHandler',
                '$attrs',
                '$element',
                '$parse',
                '$animate',
                '$timeout',
                '$rootScope',
                '$q',
                '$interpolate',
                function ($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
                    this.$viewValue = Number.NaN;
                    this.$modelValue = Number.NaN;
                    this.$$rawModelValue = undefined;
                    this.$validators = {};
                    this.$asyncValidators = {};
                    this.$parsers = [];
                    this.$formatters = [];
                    this.$viewChangeListeners = [];
                    this.$untouched = true;
                    this.$touched = false;
                    this.$pristine = true;
                    this.$dirty = false;
                    this.$valid = true;
                    this.$invalid = false;
                    this.$error = {};
                    this.$$success = {};
                    this.$pending = undefined;
                    this.$name = $interpolate($attr.name || '', false)($scope);
                    this.$$parentForm = nullFormCtrl;
                    var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, parserValid, ctrl = this;
                    this.$$setOptions = function (options) {
                        ctrl.$options = options;
                        if (options && options.getterSetter) {
                            var invokeModelGetter = $parse($attr.ngModel + '()'), invokeModelSetter = $parse($attr.ngModel + '($$$p)');
                            ngModelGet = function ($scope) {
                                var modelValue = parsedNgModel($scope);
                                if (isFunction(modelValue)) {
                                    modelValue = invokeModelGetter($scope);
                                }
                                return modelValue;
                            };
                            ngModelSet = function ($scope, newValue) {
                                if (isFunction(parsedNgModel($scope))) {
                                    invokeModelSetter($scope, { $$$p: ctrl.$modelValue });
                                } else {
                                    parsedNgModelAssign($scope, ctrl.$modelValue);
                                }
                            };
                        } else if (!parsedNgModel.assign) {
                            throw ngModelMinErr('nonassign', 'Expression \'{0}\' is non-assignable. Element: {1}', $attr.ngModel, startingTag($element));
                        }
                    };
                    this.$render = noop;
                    this.$isEmpty = function (value) {
                        return isUndefined(value) || value === '' || value === null || value !== value;
                    };
                    var currentValidationRunId = 0;
                    addSetValidityMethod({
                        ctrl: this,
                        $element: $element,
                        set: function (object, property) {
                            object[property] = true;
                        },
                        unset: function (object, property) {
                            delete object[property];
                        },
                        $animate: $animate
                    });
                    this.$setPristine = function () {
                        ctrl.$dirty = false;
                        ctrl.$pristine = true;
                        $animate.removeClass($element, DIRTY_CLASS);
                        $animate.addClass($element, PRISTINE_CLASS);
                    };
                    this.$setDirty = function () {
                        ctrl.$dirty = true;
                        ctrl.$pristine = false;
                        $animate.removeClass($element, PRISTINE_CLASS);
                        $animate.addClass($element, DIRTY_CLASS);
                        ctrl.$$parentForm.$setDirty();
                    };
                    this.$setUntouched = function () {
                        ctrl.$touched = false;
                        ctrl.$untouched = true;
                        $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
                    };
                    this.$setTouched = function () {
                        ctrl.$touched = true;
                        ctrl.$untouched = false;
                        $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
                    };
                    this.$rollbackViewValue = function () {
                        $timeout.cancel(pendingDebounce);
                        ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
                        ctrl.$render();
                    };
                    this.$validate = function () {
                        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                            return;
                        }
                        var viewValue = ctrl.$$lastCommittedViewValue;
                        var modelValue = ctrl.$$rawModelValue;
                        var prevValid = ctrl.$valid;
                        var prevModelValue = ctrl.$modelValue;
                        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                        ctrl.$$runValidators(modelValue, viewValue, function (allValid) {
                            if (!allowInvalid && prevValid !== allValid) {
                                ctrl.$modelValue = allValid ? modelValue : undefined;
                                if (ctrl.$modelValue !== prevModelValue) {
                                    ctrl.$$writeModelToScope();
                                }
                            }
                        });
                    };
                    this.$$runValidators = function (modelValue, viewValue, doneCallback) {
                        currentValidationRunId++;
                        var localValidationRunId = currentValidationRunId;
                        if (!processParseErrors()) {
                            validationDone(false);
                            return;
                        }
                        if (!processSyncValidators()) {
                            validationDone(false);
                            return;
                        }
                        processAsyncValidators();
                        function processParseErrors() {
                            var errorKey = ctrl.$$parserName || 'parse';
                            if (isUndefined(parserValid)) {
                                setValidity(errorKey, null);
                            } else {
                                if (!parserValid) {
                                    forEach(ctrl.$validators, function (v, name) {
                                        setValidity(name, null);
                                    });
                                    forEach(ctrl.$asyncValidators, function (v, name) {
                                        setValidity(name, null);
                                    });
                                }
                                setValidity(errorKey, parserValid);
                                return parserValid;
                            }
                            return true;
                        }
                        function processSyncValidators() {
                            var syncValidatorsValid = true;
                            forEach(ctrl.$validators, function (validator, name) {
                                var result = validator(modelValue, viewValue);
                                syncValidatorsValid = syncValidatorsValid && result;
                                setValidity(name, result);
                            });
                            if (!syncValidatorsValid) {
                                forEach(ctrl.$asyncValidators, function (v, name) {
                                    setValidity(name, null);
                                });
                                return false;
                            }
                            return true;
                        }
                        function processAsyncValidators() {
                            var validatorPromises = [];
                            var allValid = true;
                            forEach(ctrl.$asyncValidators, function (validator, name) {
                                var promise = validator(modelValue, viewValue);
                                if (!isPromiseLike(promise)) {
                                    throw ngModelMinErr('nopromise', 'Expected asynchronous validator to return a promise but got \'{0}\' instead.', promise);
                                }
                                setValidity(name, undefined);
                                validatorPromises.push(promise.then(function () {
                                    setValidity(name, true);
                                }, function (error) {
                                    allValid = false;
                                    setValidity(name, false);
                                }));
                            });
                            if (!validatorPromises.length) {
                                validationDone(true);
                            } else {
                                $q.all(validatorPromises).then(function () {
                                    validationDone(allValid);
                                }, noop);
                            }
                        }
                        function setValidity(name, isValid) {
                            if (localValidationRunId === currentValidationRunId) {
                                ctrl.$setValidity(name, isValid);
                            }
                        }
                        function validationDone(allValid) {
                            if (localValidationRunId === currentValidationRunId) {
                                doneCallback(allValid);
                            }
                        }
                    };
                    this.$commitViewValue = function () {
                        var viewValue = ctrl.$viewValue;
                        $timeout.cancel(pendingDebounce);
                        if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
                            return;
                        }
                        ctrl.$$lastCommittedViewValue = viewValue;
                        if (ctrl.$pristine) {
                            this.$setDirty();
                        }
                        this.$$parseAndValidate();
                    };
                    this.$$parseAndValidate = function () {
                        var viewValue = ctrl.$$lastCommittedViewValue;
                        var modelValue = viewValue;
                        parserValid = isUndefined(modelValue) ? undefined : true;
                        if (parserValid) {
                            for (var i = 0; i < ctrl.$parsers.length; i++) {
                                modelValue = ctrl.$parsers[i](modelValue);
                                if (isUndefined(modelValue)) {
                                    parserValid = false;
                                    break;
                                }
                            }
                        }
                        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                            ctrl.$modelValue = ngModelGet($scope);
                        }
                        var prevModelValue = ctrl.$modelValue;
                        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                        ctrl.$$rawModelValue = modelValue;
                        if (allowInvalid) {
                            ctrl.$modelValue = modelValue;
                            writeToModelIfNeeded();
                        }
                        ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function (allValid) {
                            if (!allowInvalid) {
                                ctrl.$modelValue = allValid ? modelValue : undefined;
                                writeToModelIfNeeded();
                            }
                        });
                        function writeToModelIfNeeded() {
                            if (ctrl.$modelValue !== prevModelValue) {
                                ctrl.$$writeModelToScope();
                            }
                        }
                    };
                    this.$$writeModelToScope = function () {
                        ngModelSet($scope, ctrl.$modelValue);
                        forEach(ctrl.$viewChangeListeners, function (listener) {
                            try {
                                listener();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                    };
                    this.$setViewValue = function (value, trigger) {
                        ctrl.$viewValue = value;
                        if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                            ctrl.$$debounceViewValueCommit(trigger);
                        }
                    };
                    this.$$debounceViewValueCommit = function (trigger) {
                        var debounceDelay = 0, options = ctrl.$options, debounce;
                        if (options && isDefined(options.debounce)) {
                            debounce = options.debounce;
                            if (isNumber(debounce)) {
                                debounceDelay = debounce;
                            } else if (isNumber(debounce[trigger])) {
                                debounceDelay = debounce[trigger];
                            } else if (isNumber(debounce['default'])) {
                                debounceDelay = debounce['default'];
                            }
                        }
                        $timeout.cancel(pendingDebounce);
                        if (debounceDelay) {
                            pendingDebounce = $timeout(function () {
                                ctrl.$commitViewValue();
                            }, debounceDelay);
                        } else if ($rootScope.$$phase) {
                            ctrl.$commitViewValue();
                        } else {
                            $scope.$apply(function () {
                                ctrl.$commitViewValue();
                            });
                        }
                    };
                    $scope.$watch(function ngModelWatch() {
                        var modelValue = ngModelGet($scope);
                        if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                            parserValid = undefined;
                            var formatters = ctrl.$formatters, idx = formatters.length;
                            var viewValue = modelValue;
                            while (idx--) {
                                viewValue = formatters[idx](viewValue);
                            }
                            if (ctrl.$viewValue !== viewValue) {
                                ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                                ctrl.$render();
                                ctrl.$$runValidators(modelValue, viewValue, noop);
                            }
                        }
                        return modelValue;
                    });
                }
            ];
            var ngModelDirective = [
                '$rootScope',
                function ($rootScope) {
                    return {
                        restrict: 'A',
                        require: [
                            'ngModel',
                            '^?form',
                            '^?ngModelOptions'
                        ],
                        controller: NgModelController,
                        priority: 1,
                        compile: function ngModelCompile(element) {
                            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                            return {
                                pre: function ngModelPreLink(scope, element, attr, ctrls) {
                                    var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                                    modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                                    formCtrl.$addControl(modelCtrl);
                                    attr.$observe('name', function (newValue) {
                                        if (modelCtrl.$name !== newValue) {
                                            modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                                        }
                                    });
                                    scope.$on('$destroy', function () {
                                        modelCtrl.$$parentForm.$removeControl(modelCtrl);
                                    });
                                },
                                post: function ngModelPostLink(scope, element, attr, ctrls) {
                                    var modelCtrl = ctrls[0];
                                    if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                                        element.on(modelCtrl.$options.updateOn, function (ev) {
                                            modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                                        });
                                    }
                                    element.on('blur', function (ev) {
                                        if (modelCtrl.$touched)
                                            return;
                                        if ($rootScope.$$phase) {
                                            scope.$evalAsync(modelCtrl.$setTouched);
                                        } else {
                                            scope.$apply(modelCtrl.$setTouched);
                                        }
                                    });
                                }
                            };
                        }
                    };
                }
            ];
            var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
            var ngModelOptionsDirective = function () {
                return {
                    restrict: 'A',
                    controller: [
                        '$scope',
                        '$attrs',
                        function ($scope, $attrs) {
                            var that = this;
                            this.$options = copy($scope.$eval($attrs.ngModelOptions));
                            if (isDefined(this.$options.updateOn)) {
                                this.$options.updateOnDefault = false;
                                this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function () {
                                    that.$options.updateOnDefault = true;
                                    return ' ';
                                }));
                            } else {
                                this.$options.updateOnDefault = true;
                            }
                        }
                    ]
                };
            };
            function addSetValidityMethod(context) {
                var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, $animate = context.$animate;
                classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
                ctrl.$setValidity = setValidity;
                function setValidity(validationErrorKey, state, controller) {
                    if (isUndefined(state)) {
                        createAndSet('$pending', validationErrorKey, controller);
                    } else {
                        unsetAndCleanup('$pending', validationErrorKey, controller);
                    }
                    if (!isBoolean(state)) {
                        unset(ctrl.$error, validationErrorKey, controller);
                        unset(ctrl.$$success, validationErrorKey, controller);
                    } else {
                        if (state) {
                            unset(ctrl.$error, validationErrorKey, controller);
                            set(ctrl.$$success, validationErrorKey, controller);
                        } else {
                            set(ctrl.$error, validationErrorKey, controller);
                            unset(ctrl.$$success, validationErrorKey, controller);
                        }
                    }
                    if (ctrl.$pending) {
                        cachedToggleClass(PENDING_CLASS, true);
                        ctrl.$valid = ctrl.$invalid = undefined;
                        toggleValidationCss('', null);
                    } else {
                        cachedToggleClass(PENDING_CLASS, false);
                        ctrl.$valid = isObjectEmpty(ctrl.$error);
                        ctrl.$invalid = !ctrl.$valid;
                        toggleValidationCss('', ctrl.$valid);
                    }
                    var combinedState;
                    if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                        combinedState = undefined;
                    } else if (ctrl.$error[validationErrorKey]) {
                        combinedState = false;
                    } else if (ctrl.$$success[validationErrorKey]) {
                        combinedState = true;
                    } else {
                        combinedState = null;
                    }
                    toggleValidationCss(validationErrorKey, combinedState);
                    ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
                }
                function createAndSet(name, value, controller) {
                    if (!ctrl[name]) {
                        ctrl[name] = {};
                    }
                    set(ctrl[name], value, controller);
                }
                function unsetAndCleanup(name, value, controller) {
                    if (ctrl[name]) {
                        unset(ctrl[name], value, controller);
                    }
                    if (isObjectEmpty(ctrl[name])) {
                        ctrl[name] = undefined;
                    }
                }
                function cachedToggleClass(className, switchValue) {
                    if (switchValue && !classCache[className]) {
                        $animate.addClass($element, className);
                        classCache[className] = true;
                    } else if (!switchValue && classCache[className]) {
                        $animate.removeClass($element, className);
                        classCache[className] = false;
                    }
                }
                function toggleValidationCss(validationErrorKey, isValid) {
                    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
                    cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
                    cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
                }
            }
            function isObjectEmpty(obj) {
                if (obj) {
                    for (var prop in obj) {
                        if (obj.hasOwnProperty(prop)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            var ngNonBindableDirective = ngDirective({
                terminal: true,
                priority: 1000
            });
            var ngOptionsMinErr = minErr('ngOptions');
            var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
            var ngOptionsDirective = [
                '$compile',
                '$parse',
                function ($compile, $parse) {
                    function parseOptionsExpression(optionsExp, selectElement, scope) {
                        var match = optionsExp.match(NG_OPTIONS_REGEXP);
                        if (!match) {
                            throw ngOptionsMinErr('iexp', 'Expected expression in form of ' + '\'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'{0}\'. Element: {1}', optionsExp, startingTag(selectElement));
                        }
                        var valueName = match[5] || match[7];
                        var keyName = match[6];
                        var selectAs = / as /.test(match[0]) && match[1];
                        var trackBy = match[9];
                        var valueFn = $parse(match[2] ? match[1] : valueName);
                        var selectAsFn = selectAs && $parse(selectAs);
                        var viewValueFn = selectAsFn || valueFn;
                        var trackByFn = trackBy && $parse(trackBy);
                        var getTrackByValueFn = trackBy ? function (value, locals) {
                            return trackByFn(scope, locals);
                        } : function getHashOfValue(value) {
                            return hashKey(value);
                        };
                        var getTrackByValue = function (value, key) {
                            return getTrackByValueFn(value, getLocals(value, key));
                        };
                        var displayFn = $parse(match[2] || match[1]);
                        var groupByFn = $parse(match[3] || '');
                        var disableWhenFn = $parse(match[4] || '');
                        var valuesFn = $parse(match[8]);
                        var locals = {};
                        var getLocals = keyName ? function (value, key) {
                            locals[keyName] = key;
                            locals[valueName] = value;
                            return locals;
                        } : function (value) {
                            locals[valueName] = value;
                            return locals;
                        };
                        function Option(selectValue, viewValue, label, group, disabled) {
                            this.selectValue = selectValue;
                            this.viewValue = viewValue;
                            this.label = label;
                            this.group = group;
                            this.disabled = disabled;
                        }
                        function getOptionValuesKeys(optionValues) {
                            var optionValuesKeys;
                            if (!keyName && isArrayLike(optionValues)) {
                                optionValuesKeys = optionValues;
                            } else {
                                optionValuesKeys = [];
                                for (var itemKey in optionValues) {
                                    if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                                        optionValuesKeys.push(itemKey);
                                    }
                                }
                            }
                            return optionValuesKeys;
                        }
                        return {
                            trackBy: trackBy,
                            getTrackByValue: getTrackByValue,
                            getWatchables: $parse(valuesFn, function (optionValues) {
                                var watchedArray = [];
                                optionValues = optionValues || [];
                                var optionValuesKeys = getOptionValuesKeys(optionValues);
                                var optionValuesLength = optionValuesKeys.length;
                                for (var index = 0; index < optionValuesLength; index++) {
                                    var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                    var value = optionValues[key];
                                    var locals = getLocals(optionValues[key], key);
                                    var selectValue = getTrackByValueFn(optionValues[key], locals);
                                    watchedArray.push(selectValue);
                                    if (match[2] || match[1]) {
                                        var label = displayFn(scope, locals);
                                        watchedArray.push(label);
                                    }
                                    if (match[4]) {
                                        var disableWhen = disableWhenFn(scope, locals);
                                        watchedArray.push(disableWhen);
                                    }
                                }
                                return watchedArray;
                            }),
                            getOptions: function () {
                                var optionItems = [];
                                var selectValueMap = {};
                                var optionValues = valuesFn(scope) || [];
                                var optionValuesKeys = getOptionValuesKeys(optionValues);
                                var optionValuesLength = optionValuesKeys.length;
                                for (var index = 0; index < optionValuesLength; index++) {
                                    var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                    var value = optionValues[key];
                                    var locals = getLocals(value, key);
                                    var viewValue = viewValueFn(scope, locals);
                                    var selectValue = getTrackByValueFn(viewValue, locals);
                                    var label = displayFn(scope, locals);
                                    var group = groupByFn(scope, locals);
                                    var disabled = disableWhenFn(scope, locals);
                                    var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                                    optionItems.push(optionItem);
                                    selectValueMap[selectValue] = optionItem;
                                }
                                return {
                                    items: optionItems,
                                    selectValueMap: selectValueMap,
                                    getOptionFromViewValue: function (value) {
                                        return selectValueMap[getTrackByValue(value)];
                                    },
                                    getViewValueFromOption: function (option) {
                                        return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                                    }
                                };
                            }
                        };
                    }
                    var optionTemplate = document.createElement('option'), optGroupTemplate = document.createElement('optgroup');
                    function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                        var ngModelCtrl = ctrls[1];
                        if (!ngModelCtrl)
                            return;
                        var selectCtrl = ctrls[0];
                        var multiple = attr.multiple;
                        var emptyOption;
                        for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                            if (children[i].value === '') {
                                emptyOption = children.eq(i);
                                break;
                            }
                        }
                        var providedEmptyOption = !!emptyOption;
                        var unknownOption = jqLite(optionTemplate.cloneNode(false));
                        unknownOption.val('?');
                        var options;
                        var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
                        var renderEmptyOption = function () {
                            if (!providedEmptyOption) {
                                selectElement.prepend(emptyOption);
                            }
                            selectElement.val('');
                            emptyOption.prop('selected', true);
                            emptyOption.attr('selected', true);
                        };
                        var removeEmptyOption = function () {
                            if (!providedEmptyOption) {
                                emptyOption.remove();
                            }
                        };
                        var renderUnknownOption = function () {
                            selectElement.prepend(unknownOption);
                            selectElement.val('?');
                            unknownOption.prop('selected', true);
                            unknownOption.attr('selected', true);
                        };
                        var removeUnknownOption = function () {
                            unknownOption.remove();
                        };
                        if (!multiple) {
                            selectCtrl.writeValue = function writeNgOptionsValue(value) {
                                var option = options.getOptionFromViewValue(value);
                                if (option && !option.disabled) {
                                    if (selectElement[0].value !== option.selectValue) {
                                        removeUnknownOption();
                                        removeEmptyOption();
                                        selectElement[0].value = option.selectValue;
                                        option.element.selected = true;
                                    }
                                    option.element.setAttribute('selected', 'selected');
                                } else {
                                    if (value === null || providedEmptyOption) {
                                        removeUnknownOption();
                                        renderEmptyOption();
                                    } else {
                                        removeEmptyOption();
                                        renderUnknownOption();
                                    }
                                }
                            };
                            selectCtrl.readValue = function readNgOptionsValue() {
                                var selectedOption = options.selectValueMap[selectElement.val()];
                                if (selectedOption && !selectedOption.disabled) {
                                    removeEmptyOption();
                                    removeUnknownOption();
                                    return options.getViewValueFromOption(selectedOption);
                                }
                                return null;
                            };
                            if (ngOptions.trackBy) {
                                scope.$watch(function () {
                                    return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                                }, function () {
                                    ngModelCtrl.$render();
                                });
                            }
                        } else {
                            ngModelCtrl.$isEmpty = function (value) {
                                return !value || value.length === 0;
                            };
                            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                                options.items.forEach(function (option) {
                                    option.element.selected = false;
                                });
                                if (value) {
                                    value.forEach(function (item) {
                                        var option = options.getOptionFromViewValue(item);
                                        if (option && !option.disabled)
                                            option.element.selected = true;
                                    });
                                }
                            };
                            selectCtrl.readValue = function readNgOptionsMultiple() {
                                var selectedValues = selectElement.val() || [], selections = [];
                                forEach(selectedValues, function (value) {
                                    var option = options.selectValueMap[value];
                                    if (option && !option.disabled)
                                        selections.push(options.getViewValueFromOption(option));
                                });
                                return selections;
                            };
                            if (ngOptions.trackBy) {
                                scope.$watchCollection(function () {
                                    if (isArray(ngModelCtrl.$viewValue)) {
                                        return ngModelCtrl.$viewValue.map(function (value) {
                                            return ngOptions.getTrackByValue(value);
                                        });
                                    }
                                }, function () {
                                    ngModelCtrl.$render();
                                });
                            }
                        }
                        if (providedEmptyOption) {
                            emptyOption.remove();
                            $compile(emptyOption)(scope);
                            emptyOption.removeClass('ng-scope');
                        } else {
                            emptyOption = jqLite(optionTemplate.cloneNode(false));
                        }
                        updateOptions();
                        scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                        function updateOptionElement(option, element) {
                            option.element = element;
                            element.disabled = option.disabled;
                            if (option.label !== element.label) {
                                element.label = option.label;
                                element.textContent = option.label;
                            }
                            if (option.value !== element.value)
                                element.value = option.selectValue;
                        }
                        function addOrReuseElement(parent, current, type, templateElement) {
                            var element;
                            if (current && lowercase(current.nodeName) === type) {
                                element = current;
                            } else {
                                element = templateElement.cloneNode(false);
                                if (!current) {
                                    parent.appendChild(element);
                                } else {
                                    parent.insertBefore(element, current);
                                }
                            }
                            return element;
                        }
                        function removeExcessElements(current) {
                            var next;
                            while (current) {
                                next = current.nextSibling;
                                jqLiteRemove(current);
                                current = next;
                            }
                        }
                        function skipEmptyAndUnknownOptions(current) {
                            var emptyOption_ = emptyOption && emptyOption[0];
                            var unknownOption_ = unknownOption && unknownOption[0];
                            if (emptyOption_ || unknownOption_) {
                                while (current && (current === emptyOption_ || current === unknownOption_ || current.nodeType === NODE_TYPE_COMMENT || nodeName_(current) === 'option' && current.value === '')) {
                                    current = current.nextSibling;
                                }
                            }
                            return current;
                        }
                        function updateOptions() {
                            var previousValue = options && selectCtrl.readValue();
                            options = ngOptions.getOptions();
                            var groupMap = {};
                            var currentElement = selectElement[0].firstChild;
                            if (providedEmptyOption) {
                                selectElement.prepend(emptyOption);
                            }
                            currentElement = skipEmptyAndUnknownOptions(currentElement);
                            options.items.forEach(function updateOption(option) {
                                var group;
                                var groupElement;
                                var optionElement;
                                if (option.group) {
                                    group = groupMap[option.group];
                                    if (!group) {
                                        groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                                        currentElement = groupElement.nextSibling;
                                        groupElement.label = option.group;
                                        group = groupMap[option.group] = {
                                            groupElement: groupElement,
                                            currentOptionElement: groupElement.firstChild
                                        };
                                    }
                                    optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                                    updateOptionElement(option, optionElement);
                                    group.currentOptionElement = optionElement.nextSibling;
                                } else {
                                    optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                                    updateOptionElement(option, optionElement);
                                    currentElement = optionElement.nextSibling;
                                }
                            });
                            Object.keys(groupMap).forEach(function (key) {
                                removeExcessElements(groupMap[key].currentOptionElement);
                            });
                            removeExcessElements(currentElement);
                            ngModelCtrl.$render();
                            if (!ngModelCtrl.$isEmpty(previousValue)) {
                                var nextValue = selectCtrl.readValue();
                                var isNotPrimitive = ngOptions.trackBy || multiple;
                                if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                                    ngModelCtrl.$setViewValue(nextValue);
                                    ngModelCtrl.$render();
                                }
                            }
                        }
                    }
                    return {
                        restrict: 'A',
                        terminal: true,
                        require: [
                            'select',
                            '?ngModel'
                        ],
                        link: {
                            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                                ctrls[0].registerOption = noop;
                            },
                            post: ngOptionsPostLink
                        }
                    };
                }
            ];
            var ngPluralizeDirective = [
                '$locale',
                '$interpolate',
                '$log',
                function ($locale, $interpolate, $log) {
                    var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
                    return {
                        link: function (scope, element, attr) {
                            var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol, watchRemover = angular.noop, lastCount;
                            forEach(attr, function (expression, attributeName) {
                                var tmpMatch = IS_WHEN.exec(attributeName);
                                if (tmpMatch) {
                                    var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                                    whens[whenKey] = element.attr(attr.$attr[attributeName]);
                                }
                            });
                            forEach(whens, function (expression, key) {
                                whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                            });
                            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                                var count = parseFloat(newVal);
                                var countIsNaN = isNaN(count);
                                if (!countIsNaN && !(count in whens)) {
                                    count = $locale.pluralCat(count - offset);
                                }
                                if (count !== lastCount && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                                    watchRemover();
                                    var whenExpFn = whensExpFns[count];
                                    if (isUndefined(whenExpFn)) {
                                        if (newVal != null) {
                                            $log.debug('ngPluralize: no rule defined for \'' + count + '\' in ' + whenExp);
                                        }
                                        watchRemover = noop;
                                        updateElementText();
                                    } else {
                                        watchRemover = scope.$watch(whenExpFn, updateElementText);
                                    }
                                    lastCount = count;
                                }
                            });
                            function updateElementText(newText) {
                                element.text(newText || '');
                            }
                        }
                    };
                }
            ];
            var ngRepeatDirective = [
                '$parse',
                '$animate',
                function ($parse, $animate) {
                    var NG_REMOVED = '$$NG_REMOVED';
                    var ngRepeatMinErr = minErr('ngRepeat');
                    var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                        scope[valueIdentifier] = value;
                        if (keyIdentifier)
                            scope[keyIdentifier] = key;
                        scope.$index = index;
                        scope.$first = index === 0;
                        scope.$last = index === arrayLength - 1;
                        scope.$middle = !(scope.$first || scope.$last);
                        scope.$odd = !(scope.$even = (index & 1) === 0);
                    };
                    var getBlockStart = function (block) {
                        return block.clone[0];
                    };
                    var getBlockEnd = function (block) {
                        return block.clone[block.clone.length - 1];
                    };
                    return {
                        restrict: 'A',
                        multiElement: true,
                        transclude: 'element',
                        priority: 1000,
                        terminal: true,
                        $$tlb: true,
                        compile: function ngRepeatCompile($element, $attr) {
                            var expression = $attr.ngRepeat;
                            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
                            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                            if (!match) {
                                throw ngRepeatMinErr('iexp', 'Expected expression in form of \'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.', expression);
                            }
                            var lhs = match[1];
                            var rhs = match[2];
                            var aliasAs = match[3];
                            var trackByExp = match[4];
                            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                            if (!match) {
                                throw ngRepeatMinErr('iidexp', '\'_item_\' in \'_item_ in _collection_\' should be an identifier or \'(_key_, _value_)\' expression, but got \'{0}\'.', lhs);
                            }
                            var valueIdentifier = match[3] || match[1];
                            var keyIdentifier = match[2];
                            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                                throw ngRepeatMinErr('badident', 'alias \'{0}\' is invalid --- must be a valid JS identifier which is not a reserved name.', aliasAs);
                            }
                            var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                            var hashFnLocals = { $id: hashKey };
                            if (trackByExp) {
                                trackByExpGetter = $parse(trackByExp);
                            } else {
                                trackByIdArrayFn = function (key, value) {
                                    return hashKey(value);
                                };
                                trackByIdObjFn = function (key) {
                                    return key;
                                };
                            }
                            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                                if (trackByExpGetter) {
                                    trackByIdExpFn = function (key, value, index) {
                                        if (keyIdentifier)
                                            hashFnLocals[keyIdentifier] = key;
                                        hashFnLocals[valueIdentifier] = value;
                                        hashFnLocals.$index = index;
                                        return trackByExpGetter($scope, hashFnLocals);
                                    };
                                }
                                var lastBlockMap = createMap();
                                $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                                    var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                                    if (aliasAs) {
                                        $scope[aliasAs] = collection;
                                    }
                                    if (isArrayLike(collection)) {
                                        collectionKeys = collection;
                                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                    } else {
                                        trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                                        collectionKeys = [];
                                        for (var itemKey in collection) {
                                            if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                                                collectionKeys.push(itemKey);
                                            }
                                        }
                                    }
                                    collectionLength = collectionKeys.length;
                                    nextBlockOrder = new Array(collectionLength);
                                    for (index = 0; index < collectionLength; index++) {
                                        key = collection === collectionKeys ? index : collectionKeys[index];
                                        value = collection[key];
                                        trackById = trackByIdFn(key, value, index);
                                        if (lastBlockMap[trackById]) {
                                            block = lastBlockMap[trackById];
                                            delete lastBlockMap[trackById];
                                            nextBlockMap[trackById] = block;
                                            nextBlockOrder[index] = block;
                                        } else if (nextBlockMap[trackById]) {
                                            forEach(nextBlockOrder, function (block) {
                                                if (block && block.scope)
                                                    lastBlockMap[block.id] = block;
                                            });
                                            throw ngRepeatMinErr('dupes', 'Duplicates in a repeater are not allowed. Use \'track by\' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}', expression, trackById, value);
                                        } else {
                                            nextBlockOrder[index] = {
                                                id: trackById,
                                                scope: undefined,
                                                clone: undefined
                                            };
                                            nextBlockMap[trackById] = true;
                                        }
                                    }
                                    for (var blockKey in lastBlockMap) {
                                        block = lastBlockMap[blockKey];
                                        elementsToRemove = getBlockNodes(block.clone);
                                        $animate.leave(elementsToRemove);
                                        if (elementsToRemove[0].parentNode) {
                                            for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                                elementsToRemove[index][NG_REMOVED] = true;
                                            }
                                        }
                                        block.scope.$destroy();
                                    }
                                    for (index = 0; index < collectionLength; index++) {
                                        key = collection === collectionKeys ? index : collectionKeys[index];
                                        value = collection[key];
                                        block = nextBlockOrder[index];
                                        if (block.scope) {
                                            nextNode = previousNode;
                                            do {
                                                nextNode = nextNode.nextSibling;
                                            } while (nextNode && nextNode[NG_REMOVED]);
                                            if (getBlockStart(block) != nextNode) {
                                                $animate.move(getBlockNodes(block.clone), null, previousNode);
                                            }
                                            previousNode = getBlockEnd(block);
                                            updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                        } else {
                                            $transclude(function ngRepeatTransclude(clone, scope) {
                                                block.scope = scope;
                                                var endNode = ngRepeatEndComment.cloneNode(false);
                                                clone[clone.length++] = endNode;
                                                $animate.enter(clone, null, previousNode);
                                                previousNode = endNode;
                                                block.clone = clone;
                                                nextBlockMap[block.id] = block;
                                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                            });
                                        }
                                    }
                                    lastBlockMap = nextBlockMap;
                                });
                            };
                        }
                    };
                }
            ];
            var NG_HIDE_CLASS = 'ng-hide';
            var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
            var ngShowDirective = [
                '$animate',
                function ($animate) {
                    return {
                        restrict: 'A',
                        multiElement: true,
                        link: function (scope, element, attr) {
                            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                                $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                            });
                        }
                    };
                }
            ];
            var ngHideDirective = [
                '$animate',
                function ($animate) {
                    return {
                        restrict: 'A',
                        multiElement: true,
                        link: function (scope, element, attr) {
                            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                                $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                            });
                        }
                    };
                }
            ];
            var ngStyleDirective = ngDirective(function (scope, element, attr) {
                scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
                    if (oldStyles && newStyles !== oldStyles) {
                        forEach(oldStyles, function (val, style) {
                            element.css(style, '');
                        });
                    }
                    if (newStyles)
                        element.css(newStyles);
                }, true);
            });
            var ngSwitchDirective = [
                '$animate',
                function ($animate) {
                    return {
                        require: 'ngSwitch',
                        controller: [
                            '$scope',
                            function ngSwitchController() {
                                this.cases = {};
                            }
                        ],
                        link: function (scope, element, attr, ngSwitchController) {
                            var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                            var spliceFactory = function (array, index) {
                                return function () {
                                    array.splice(index, 1);
                                };
                            };
                            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                                var i, ii;
                                for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                                    $animate.cancel(previousLeaveAnimations[i]);
                                }
                                previousLeaveAnimations.length = 0;
                                for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                    var selected = getBlockNodes(selectedElements[i].clone);
                                    selectedScopes[i].$destroy();
                                    var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                                    promise.then(spliceFactory(previousLeaveAnimations, i));
                                }
                                selectedElements.length = 0;
                                selectedScopes.length = 0;
                                if (selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?']) {
                                    forEach(selectedTranscludes, function (selectedTransclude) {
                                        selectedTransclude.transclude(function (caseElement, selectedScope) {
                                            selectedScopes.push(selectedScope);
                                            var anchor = selectedTransclude.element;
                                            caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                                            var block = { clone: caseElement };
                                            selectedElements.push(block);
                                            $animate.enter(caseElement, anchor.parent(), anchor);
                                        });
                                    });
                                }
                            });
                        }
                    };
                }
            ];
            var ngSwitchWhenDirective = ngDirective({
                transclude: 'element',
                priority: 1200,
                require: '^ngSwitch',
                multiElement: true,
                link: function (scope, element, attrs, ctrl, $transclude) {
                    ctrl.cases['!' + attrs.ngSwitchWhen] = ctrl.cases['!' + attrs.ngSwitchWhen] || [];
                    ctrl.cases['!' + attrs.ngSwitchWhen].push({
                        transclude: $transclude,
                        element: element
                    });
                }
            });
            var ngSwitchDefaultDirective = ngDirective({
                transclude: 'element',
                priority: 1200,
                require: '^ngSwitch',
                multiElement: true,
                link: function (scope, element, attr, ctrl, $transclude) {
                    ctrl.cases['?'] = ctrl.cases['?'] || [];
                    ctrl.cases['?'].push({
                        transclude: $transclude,
                        element: element
                    });
                }
            });
            var ngTranscludeDirective = ngDirective({
                restrict: 'EAC',
                link: function ($scope, $element, $attrs, controller, $transclude) {
                    if (!$transclude) {
                        throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
                    }
                    $transclude(function (clone) {
                        $element.empty();
                        $element.append(clone);
                    });
                }
            });
            var scriptDirective = [
                '$templateCache',
                function ($templateCache) {
                    return {
                        restrict: 'E',
                        terminal: true,
                        compile: function (element, attr) {
                            if (attr.type == 'text/ng-template') {
                                var templateUrl = attr.id, text = element[0].text;
                                $templateCache.put(templateUrl, text);
                            }
                        }
                    };
                }
            ];
            var noopNgModelController = {
                $setViewValue: noop,
                $render: noop
            };
            function chromeHack(optionElement) {
                if (optionElement[0].hasAttribute('selected')) {
                    optionElement[0].selected = true;
                }
            }
            var SelectController = [
                '$element',
                '$scope',
                '$attrs',
                function ($element, $scope, $attrs) {
                    var self = this, optionsMap = new HashMap();
                    self.ngModelCtrl = noopNgModelController;
                    self.unknownOption = jqLite(document.createElement('option'));
                    self.renderUnknownOption = function (val) {
                        var unknownVal = '? ' + hashKey(val) + ' ?';
                        self.unknownOption.val(unknownVal);
                        $element.prepend(self.unknownOption);
                        $element.val(unknownVal);
                    };
                    $scope.$on('$destroy', function () {
                        self.renderUnknownOption = noop;
                    });
                    self.removeUnknownOption = function () {
                        if (self.unknownOption.parent())
                            self.unknownOption.remove();
                    };
                    self.readValue = function readSingleValue() {
                        self.removeUnknownOption();
                        return $element.val();
                    };
                    self.writeValue = function writeSingleValue(value) {
                        if (self.hasOption(value)) {
                            self.removeUnknownOption();
                            $element.val(value);
                            if (value === '')
                                self.emptyOption.prop('selected', true);
                        } else {
                            if (value == null && self.emptyOption) {
                                self.removeUnknownOption();
                                $element.val('');
                            } else {
                                self.renderUnknownOption(value);
                            }
                        }
                    };
                    self.addOption = function (value, element) {
                        if (element[0].nodeType === NODE_TYPE_COMMENT)
                            return;
                        assertNotHasOwnProperty(value, '"option value"');
                        if (value === '') {
                            self.emptyOption = element;
                        }
                        var count = optionsMap.get(value) || 0;
                        optionsMap.put(value, count + 1);
                        self.ngModelCtrl.$render();
                        chromeHack(element);
                    };
                    self.removeOption = function (value) {
                        var count = optionsMap.get(value);
                        if (count) {
                            if (count === 1) {
                                optionsMap.remove(value);
                                if (value === '') {
                                    self.emptyOption = undefined;
                                }
                            } else {
                                optionsMap.put(value, count - 1);
                            }
                        }
                    };
                    self.hasOption = function (value) {
                        return !!optionsMap.get(value);
                    };
                    self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                        if (interpolateValueFn) {
                            var oldVal;
                            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
                                if (isDefined(oldVal)) {
                                    self.removeOption(oldVal);
                                }
                                oldVal = newVal;
                                self.addOption(newVal, optionElement);
                            });
                        } else if (interpolateTextFn) {
                            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                                optionAttrs.$set('value', newVal);
                                if (oldVal !== newVal) {
                                    self.removeOption(oldVal);
                                }
                                self.addOption(newVal, optionElement);
                            });
                        } else {
                            self.addOption(optionAttrs.value, optionElement);
                        }
                        optionElement.on('$destroy', function () {
                            self.removeOption(optionAttrs.value);
                            self.ngModelCtrl.$render();
                        });
                    };
                }
            ];
            var selectDirective = function () {
                return {
                    restrict: 'E',
                    require: [
                        'select',
                        '?ngModel'
                    ],
                    controller: SelectController,
                    priority: 1,
                    link: {
                        pre: selectPreLink,
                        post: selectPostLink
                    }
                };
                function selectPreLink(scope, element, attr, ctrls) {
                    var ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl)
                        return;
                    var selectCtrl = ctrls[0];
                    selectCtrl.ngModelCtrl = ngModelCtrl;
                    element.on('change', function () {
                        scope.$apply(function () {
                            ngModelCtrl.$setViewValue(selectCtrl.readValue());
                        });
                    });
                    if (attr.multiple) {
                        selectCtrl.readValue = function readMultipleValue() {
                            var array = [];
                            forEach(element.find('option'), function (option) {
                                if (option.selected) {
                                    array.push(option.value);
                                }
                            });
                            return array;
                        };
                        selectCtrl.writeValue = function writeMultipleValue(value) {
                            var items = new HashMap(value);
                            forEach(element.find('option'), function (option) {
                                option.selected = isDefined(items.get(option.value));
                            });
                        };
                        var lastView, lastViewRef = NaN;
                        scope.$watch(function selectMultipleWatch() {
                            if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                                lastView = shallowCopy(ngModelCtrl.$viewValue);
                                ngModelCtrl.$render();
                            }
                            lastViewRef = ngModelCtrl.$viewValue;
                        });
                        ngModelCtrl.$isEmpty = function (value) {
                            return !value || value.length === 0;
                        };
                    }
                }
                function selectPostLink(scope, element, attrs, ctrls) {
                    var ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl)
                        return;
                    var selectCtrl = ctrls[0];
                    ngModelCtrl.$render = function () {
                        selectCtrl.writeValue(ngModelCtrl.$viewValue);
                    };
                }
            };
            var optionDirective = [
                '$interpolate',
                function ($interpolate) {
                    return {
                        restrict: 'E',
                        priority: 100,
                        compile: function (element, attr) {
                            if (isDefined(attr.value)) {
                                var interpolateValueFn = $interpolate(attr.value, true);
                            } else {
                                var interpolateTextFn = $interpolate(element.text(), true);
                                if (!interpolateTextFn) {
                                    attr.$set('value', element.text());
                                }
                            }
                            return function (scope, element, attr) {
                                var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                                if (selectCtrl) {
                                    selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                                }
                            };
                        }
                    };
                }
            ];
            var styleDirective = valueFn({
                restrict: 'E',
                terminal: false
            });
            var requiredDirective = function () {
                return {
                    restrict: 'A',
                    require: '?ngModel',
                    link: function (scope, elm, attr, ctrl) {
                        if (!ctrl)
                            return;
                        attr.required = true;
                        ctrl.$validators.required = function (modelValue, viewValue) {
                            return !attr.required || !ctrl.$isEmpty(viewValue);
                        };
                        attr.$observe('required', function () {
                            ctrl.$validate();
                        });
                    }
                };
            };
            var patternDirective = function () {
                return {
                    restrict: 'A',
                    require: '?ngModel',
                    link: function (scope, elm, attr, ctrl) {
                        if (!ctrl)
                            return;
                        var regexp, patternExp = attr.ngPattern || attr.pattern;
                        attr.$observe('pattern', function (regex) {
                            if (isString(regex) && regex.length > 0) {
                                regex = new RegExp('^' + regex + '$');
                            }
                            if (regex && !regex.test) {
                                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
                            }
                            regexp = regex || undefined;
                            ctrl.$validate();
                        });
                        ctrl.$validators.pattern = function (modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                        };
                    }
                };
            };
            var maxlengthDirective = function () {
                return {
                    restrict: 'A',
                    require: '?ngModel',
                    link: function (scope, elm, attr, ctrl) {
                        if (!ctrl)
                            return;
                        var maxlength = -1;
                        attr.$observe('maxlength', function (value) {
                            var intVal = toInt(value);
                            maxlength = isNaN(intVal) ? -1 : intVal;
                            ctrl.$validate();
                        });
                        ctrl.$validators.maxlength = function (modelValue, viewValue) {
                            return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                        };
                    }
                };
            };
            var minlengthDirective = function () {
                return {
                    restrict: 'A',
                    require: '?ngModel',
                    link: function (scope, elm, attr, ctrl) {
                        if (!ctrl)
                            return;
                        var minlength = 0;
                        attr.$observe('minlength', function (value) {
                            minlength = toInt(value) || 0;
                            ctrl.$validate();
                        });
                        ctrl.$validators.minlength = function (modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                        };
                    }
                };
            };
            if (window.angular.bootstrap) {
                if (window.console) {
                    console.log('WARNING: Tried to load angular more than once.');
                }
                return;
            }
            bindJQuery();
            publishExternalAPI(angular);
            angular.module('ngLocale', [], [
                '$provide',
                function ($provide) {
                    var PLURAL_CATEGORY = {
                        ZERO: 'zero',
                        ONE: 'one',
                        TWO: 'two',
                        FEW: 'few',
                        MANY: 'many',
                        OTHER: 'other'
                    };
                    function getDecimals(n) {
                        n = n + '';
                        var i = n.indexOf('.');
                        return i == -1 ? 0 : n.length - i - 1;
                    }
                    function getVF(n, opt_precision) {
                        var v = opt_precision;
                        if (undefined === v) {
                            v = Math.min(getDecimals(n), 3);
                        }
                        var base = Math.pow(10, v);
                        var f = (n * base | 0) % base;
                        return {
                            v: v,
                            f: f
                        };
                    }
                    $provide.value('$locale', {
                        'DATETIME_FORMATS': {
                            'AMPMS': [
                                'AM',
                                'PM'
                            ],
                            'DAY': [
                                'Sunday',
                                'Monday',
                                'Tuesday',
                                'Wednesday',
                                'Thursday',
                                'Friday',
                                'Saturday'
                            ],
                            'ERANAMES': [
                                'Before Christ',
                                'Anno Domini'
                            ],
                            'ERAS': [
                                'BC',
                                'AD'
                            ],
                            'FIRSTDAYOFWEEK': 6,
                            'MONTH': [
                                'January',
                                'February',
                                'March',
                                'April',
                                'May',
                                'June',
                                'July',
                                'August',
                                'September',
                                'October',
                                'November',
                                'December'
                            ],
                            'SHORTDAY': [
                                'Sun',
                                'Mon',
                                'Tue',
                                'Wed',
                                'Thu',
                                'Fri',
                                'Sat'
                            ],
                            'SHORTMONTH': [
                                'Jan',
                                'Feb',
                                'Mar',
                                'Apr',
                                'May',
                                'Jun',
                                'Jul',
                                'Aug',
                                'Sep',
                                'Oct',
                                'Nov',
                                'Dec'
                            ],
                            'STANDALONEMONTH': [
                                'January',
                                'February',
                                'March',
                                'April',
                                'May',
                                'June',
                                'July',
                                'August',
                                'September',
                                'October',
                                'November',
                                'December'
                            ],
                            'WEEKENDRANGE': [
                                5,
                                6
                            ],
                            'fullDate': 'EEEE, MMMM d, y',
                            'longDate': 'MMMM d, y',
                            'medium': 'MMM d, y h:mm:ss a',
                            'mediumDate': 'MMM d, y',
                            'mediumTime': 'h:mm:ss a',
                            'short': 'M/d/yy h:mm a',
                            'shortDate': 'M/d/yy',
                            'shortTime': 'h:mm a'
                        },
                        'NUMBER_FORMATS': {
                            'CURRENCY_SYM': '$',
                            'DECIMAL_SEP': '.',
                            'GROUP_SEP': ',',
                            'PATTERNS': [
                                {
                                    'gSize': 3,
                                    'lgSize': 3,
                                    'maxFrac': 3,
                                    'minFrac': 0,
                                    'minInt': 1,
                                    'negPre': '-',
                                    'negSuf': '',
                                    'posPre': '',
                                    'posSuf': ''
                                },
                                {
                                    'gSize': 3,
                                    'lgSize': 3,
                                    'maxFrac': 2,
                                    'minFrac': 2,
                                    'minInt': 1,
                                    'negPre': '-\xA4',
                                    'negSuf': '',
                                    'posPre': '\xA4',
                                    'posSuf': ''
                                }
                            ]
                        },
                        'id': 'en-us',
                        'localeID': 'en_US',
                        'pluralCat': function (n, opt_precision) {
                            var i = n | 0;
                            var vf = getVF(n, opt_precision);
                            if (i == 1 && vf.v == 0) {
                                return PLURAL_CATEGORY.ONE;
                            }
                            return PLURAL_CATEGORY.OTHER;
                        }
                    });
                }
            ]);
            jqLite(document).ready(function () {
                angularInit(document, bootstrap);
            });
        }(window, document));
        !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
    }(function () {
        return this;
    }()));
});
/*angular@1.4.10#index*/
define('angular@1.4.10#index', function (require, exports, module) {
    require('./angular');
    module.exports = angular;
});
/*lodash@4.11.1#lodash*/
;
(function () {
    var undefined;
    var VERSION = '4.11.1';
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = 'Expected a function';
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    var PLACEHOLDER = '__lodash_placeholder__';
    var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, FLIP_FLAG = 512;
    var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
    var HOT_COUNT = 150, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';
    var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
    var reBasicWord = /[a-zA-Z0-9]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reHasHexPrefix = /^0x/i;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23', rsComboSymbolsRange = '\\u20d0-\\u20f0', rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;
    var rsApos = '[\'\u2019]', rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
    var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')', rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [
            rsNonAstral,
            rsRegional,
            rsSurrPair
        ].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [
            rsDingbat,
            rsRegional,
            rsSurrPair
        ].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [
            rsNonAstral + rsCombo + '?',
            rsCombo,
            rsRegional,
            rsSurrPair,
            rsAstral
        ].join('|') + ')';
    var reApos = RegExp(rsApos, 'g');
    var reComboMark = RegExp(rsCombo, 'g');
    var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    var reComplexWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [
            rsBreak,
            rsUpper,
            '$'
        ].join('|') + ')',
        rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [
            rsBreak,
            rsUpper + rsLowerMisc,
            '$'
        ].join('|') + ')',
        rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
        rsUpper + '+' + rsOptUpperContr,
        rsDigits,
        rsEmoji
    ].join('|'), 'g');
    var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
    var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
        'Array',
        'Buffer',
        'DataView',
        'Date',
        'Error',
        'Float32Array',
        'Float64Array',
        'Function',
        'Int8Array',
        'Int16Array',
        'Int32Array',
        'Map',
        'Math',
        'Object',
        'Promise',
        'Reflect',
        'RegExp',
        'Set',
        'String',
        'Symbol',
        'TypeError',
        'Uint8Array',
        'Uint8ClampedArray',
        'Uint16Array',
        'Uint32Array',
        'WeakMap',
        '_',
        'clearTimeout',
        'isFinite',
        'parseInt',
        'setTimeout'
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
        '': 'A',
        '': 'A',
        '': 'A',
        '': 'A',
        '': 'A',
        '': 'A',
        '': 'a',
        '': 'a',
        '': 'a',
        '': 'a',
        '': 'a',
        '': 'a',
        '': 'C',
        '': 'c',
        '': 'D',
        '': 'd',
        '': 'E',
        '': 'E',
        '': 'E',
        '': 'E',
        '': 'e',
        '': 'e',
        '': 'e',
        '': 'e',
        '': 'I',
        '': 'I',
        '': 'I',
        '': 'I',
        '': 'i',
        '': 'i',
        '': 'i',
        '': 'i',
        '': 'N',
        '': 'n',
        '': 'O',
        '': 'O',
        '': 'O',
        '': 'O',
        '': 'O',
        '': 'O',
        '': 'o',
        '': 'o',
        '': 'o',
        '': 'o',
        '': 'o',
        '': 'o',
        '': 'U',
        '': 'U',
        '': 'U',
        '': 'U',
        '': 'u',
        '': 'u',
        '': 'u',
        '': 'u',
        '': 'Y',
        '': 'y',
        '': 'y',
        '': 'Ae',
        '': 'ae',
        '': 'Th',
        '': 'th',
        '': 'ss'
    };
    var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;',
        '`': '&#96;'
    };
    var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': '\'',
        '&#96;': '`'
    };
    var objectTypes = {
        'function': true,
        'object': true
    };
    var stringEscapes = {
        '\\': '\\',
        '\'': '\'',
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : undefined;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType ? module : undefined;
    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : undefined;
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();
    function addMapEntry(map, pair) {
        map.set(pair[0], pair[1]);
        return map;
    }
    function addSetEntry(set, value) {
        set.add(value);
        return set;
    }
    function apply(func, thisArg, args) {
        var length = args.length;
        switch (length) {
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array.length;
        while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
    }
    function arrayConcat(array, other) {
        var index = -1, length = array.length, othIndex = -1, othLength = other.length, result = Array(length + othLength);
        while (++index < length) {
            result[index] = array[index];
        }
        while (++othIndex < othLength) {
            result[index++] = other[othIndex];
        }
        return result;
    }
    function arrayEach(array, iteratee) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
                break;
            }
        }
        return array;
    }
    function arrayEachRight(array, iteratee) {
        var length = array.length;
        while (length--) {
            if (iteratee(array[length], length, array) === false) {
                break;
            }
        }
        return array;
    }
    function arrayEvery(array, predicate) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (!predicate(array[index], index, array)) {
                return false;
            }
        }
        return true;
    }
    function arrayFilter(array, predicate) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
                result[resIndex++] = value;
            }
        }
        return result;
    }
    function arrayIncludes(array, value) {
        return !!array.length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (comparator(value, array[index])) {
                return true;
            }
        }
        return false;
    }
    function arrayMap(array, iteratee) {
        var index = -1, length = array.length, result = Array(length);
        while (++index < length) {
            result[index] = iteratee(array[index], index, array);
        }
        return result;
    }
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array.length;
        if (initAccum && length) {
            accumulator = array[++index];
        }
        while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array.length;
        if (initAccum && length) {
            accumulator = array[--length];
        }
        while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
    }
    function arraySome(array, predicate) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return true;
            }
        }
        return false;
    }
    function baseExtremum(array, iteratee, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
            var value = array[index], current = iteratee(value);
            if (current != null && (computed === undefined ? current === current : comparator(current, computed))) {
                var computed = current, result = value;
            }
        }
        return result;
    }
    function baseFind(collection, predicate, eachFunc, retKey) {
        var result;
        eachFunc(collection, function (value, key, collection) {
            if (predicate(value, key, collection)) {
                result = retKey ? key : value;
                return false;
            }
        });
        return result;
    }
    function baseFindIndex(array, predicate, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
                return index;
            }
        }
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
            return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
            if (comparator(array[index], value)) {
                return index;
            }
        }
        return -1;
    }
    function baseMean(array, iteratee) {
        var length = array ? array.length : 0;
        return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function (value, index, collection) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
    }
    function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
            array[length] = array[length].value;
        }
        return array;
    }
    function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined) {
                result = result === undefined ? current : result + current;
            }
        }
        return result;
    }
    function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }
    function baseToPairs(object, props) {
        return arrayMap(props, function (key) {
            return [
                key,
                object[key]
            ];
        });
    }
    function baseUnary(func) {
        return function (value) {
            return func(value);
        };
    }
    function baseValues(object, props) {
        return arrayMap(props, function (key) {
            return object[key];
        });
    }
    function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
    }
    function checkGlobal(value) {
        return value && value.Object === Object ? value : null;
    }
    function compareAscending(value, other) {
        if (value !== other) {
            var valIsNull = value === null, valIsUndef = value === undefined, valIsReflexive = value === value;
            var othIsNull = other === null, othIsUndef = other === undefined, othIsReflexive = other === other;
            if (value > other && !othIsNull || !valIsReflexive || valIsNull && !othIsUndef && othIsReflexive || valIsUndef && othIsReflexive) {
                return 1;
            }
            if (value < other && !valIsNull || !othIsReflexive || othIsNull && !valIsUndef && valIsReflexive || othIsUndef && valIsReflexive) {
                return -1;
            }
        }
        return 0;
    }
    function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
            var result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
                if (index >= ordersLength) {
                    return result;
                }
                var order = orders[index];
                return result * (order == 'desc' ? -1 : 1);
            }
        }
        return object.index - other.index;
    }
    function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
            if (array[length] === placeholder) {
                result++;
            }
        }
        return result;
    }
    function createMathOperation(operator) {
        return function (value, other) {
            var result;
            if (value === undefined && other === undefined) {
                return 0;
            }
            if (value !== undefined) {
                result = value;
            }
            if (other !== undefined) {
                result = result === undefined ? other : operator(result, other);
            }
            return result;
        };
    }
    function deburrLetter(letter) {
        return deburredLetters[letter];
    }
    function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
    }
    function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
    }
    function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
        while (fromRight ? index-- : ++index < length) {
            var other = array[index];
            if (other !== other) {
                return index;
            }
        }
        return -1;
    }
    function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != 'function') {
            try {
                result = !!(value + '');
            } catch (e) {
            }
        }
        return result;
    }
    function isIndex(value, length) {
        value = typeof value == 'number' || reIsUint.test(value) ? +value : -1;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return value > -1 && value % 1 == 0 && value < length;
    }
    function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
            result.push(data.value);
        }
        return result;
    }
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function (value, key) {
            result[++index] = [
                key,
                value
            ];
        });
        return result;
    }
    function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
                array[index] = PLACEHOLDER;
                result[resIndex++] = index;
            }
        }
        return result;
    }
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function (value) {
            result[++index] = value;
        });
        return result;
    }
    function stringSize(string) {
        if (!(string && reHasComplexSymbol.test(string))) {
            return string.length;
        }
        var result = reComplexSymbol.lastIndex = 0;
        while (reComplexSymbol.test(string)) {
            result++;
        }
        return result;
    }
    function stringToArray(string) {
        return string.match(reComplexSymbol);
    }
    function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
    }
    function runInContext(context) {
        context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
        var Date = context.Date, Error = context.Error, Math = context.Math, RegExp = context.RegExp, TypeError = context.TypeError;
        var arrayProto = context.Array.prototype, objectProto = context.Object.prototype, stringProto = context.String.prototype;
        var funcToString = context.Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objectCtorString = funcToString.call(Object);
        var objectToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var Buffer = moduleExports ? context.Buffer : undefined, Reflect = context.Reflect, Symbol = context.Symbol, Uint8Array = context.Uint8Array, clearTimeout = context.clearTimeout, enumerate = Reflect ? Reflect.enumerate : undefined, getOwnPropertySymbols = Object.getOwnPropertySymbols, iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined, objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, setTimeout = context.setTimeout, splice = arrayProto.splice;
        var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetPrototype = Object.getPrototypeOf, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = Object.keys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReplace = stringProto.replace, nativeReverse = arrayProto.reverse, nativeSplit = stringProto.split;
        var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create');
        var metaMap = WeakMap && new WeakMap();
        var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) {
                    return value;
                }
                if (hasOwnProperty.call(value, '__wrapped__')) {
                    return wrapperClone(value);
                }
            }
            return new LodashWrapper(value);
        }
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined;
        }
        lodash.templateSettings = {
            'escape': reEscape,
            'evaluate': reEvaluate,
            'interpolate': reInterpolate,
            'variable': '',
            'imports': { '_': lodash }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
        }
        function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result;
        }
        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1;
                result.__filtered__ = true;
            } else {
                result = this.clone();
                result.__dir__ *= -1;
            }
            return result;
        }
        function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || arrLength < LARGE_ARRAY_SIZE || arrLength == length && takeCount == length) {
                return baseWrapperValue(array, this.__actions__);
            }
            var result = [];
            outer:
                while (length-- && resIndex < takeCount) {
                    index += dir;
                    var iterIndex = -1, value = array[index];
                    while (++iterIndex < iterLength) {
                        var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                        if (type == LAZY_MAP_FLAG) {
                            value = computed;
                        } else if (!computed) {
                            if (type == LAZY_FILTER_FLAG) {
                                continue outer;
                            } else {
                                break outer;
                            }
                        }
                    }
                    result[resIndex++] = value;
                }
            return result;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash() {
        }
        function hashDelete(hash, key) {
            return hashHas(hash, key) && delete hash[key];
        }
        function hashGet(hash, key) {
            if (nativeCreate) {
                var result = hash[key];
                return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
        }
        function hashHas(hash, key) {
            return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
        }
        function hashSet(hash, key, value) {
            hash[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
        }
        Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
        function MapCache(values) {
            var index = -1, length = values ? values.length : 0;
            this.clear();
            while (++index < length) {
                var entry = values[index];
                this.set(entry[0], entry[1]);
            }
        }
        function mapClear() {
            this.__data__ = {
                'hash': new Hash(),
                'map': Map ? new Map() : [],
                'string': new Hash()
            };
        }
        function mapDelete(key) {
            var data = this.__data__;
            if (isKeyable(key)) {
                return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
            }
            return Map ? data.map['delete'](key) : assocDelete(data.map, key);
        }
        function mapGet(key) {
            var data = this.__data__;
            if (isKeyable(key)) {
                return hashGet(typeof key == 'string' ? data.string : data.hash, key);
            }
            return Map ? data.map.get(key) : assocGet(data.map, key);
        }
        function mapHas(key) {
            var data = this.__data__;
            if (isKeyable(key)) {
                return hashHas(typeof key == 'string' ? data.string : data.hash, key);
            }
            return Map ? data.map.has(key) : assocHas(data.map, key);
        }
        function mapSet(key, value) {
            var data = this.__data__;
            if (isKeyable(key)) {
                hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
            } else if (Map) {
                data.map.set(key, value);
            } else {
                assocSet(data.map, key, value);
            }
            return this;
        }
        MapCache.prototype.clear = mapClear;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        function SetCache(values) {
            var index = -1, length = values ? values.length : 0;
            this.__data__ = new MapCache();
            while (++index < length) {
                this.push(values[index]);
            }
        }
        function cacheHas(cache, value) {
            var map = cache.__data__;
            if (isKeyable(value)) {
                var data = map.__data__, hash = typeof value == 'string' ? data.string : data.hash;
                return hash[value] === HASH_UNDEFINED;
            }
            return map.has(value);
        }
        function cachePush(value) {
            var map = this.__data__;
            if (isKeyable(value)) {
                var data = map.__data__, hash = typeof value == 'string' ? data.string : data.hash;
                hash[value] = HASH_UNDEFINED;
            } else {
                map.set(value, HASH_UNDEFINED);
            }
        }
        SetCache.prototype.push = cachePush;
        function Stack(values) {
            var index = -1, length = values ? values.length : 0;
            this.clear();
            while (++index < length) {
                var entry = values[index];
                this.set(entry[0], entry[1]);
            }
        }
        function stackClear() {
            this.__data__ = {
                'array': [],
                'map': null
            };
        }
        function stackDelete(key) {
            var data = this.__data__, array = data.array;
            return array ? assocDelete(array, key) : data.map['delete'](key);
        }
        function stackGet(key) {
            var data = this.__data__, array = data.array;
            return array ? assocGet(array, key) : data.map.get(key);
        }
        function stackHas(key) {
            var data = this.__data__, array = data.array;
            return array ? assocHas(array, key) : data.map.has(key);
        }
        function stackSet(key, value) {
            var data = this.__data__, array = data.array;
            if (array) {
                if (array.length < LARGE_ARRAY_SIZE - 1) {
                    assocSet(array, key, value);
                } else {
                    data.array = null;
                    data.map = new MapCache(array);
                }
            }
            var map = data.map;
            if (map) {
                map.set(key, value);
            }
            return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function assocDelete(array, key) {
            var index = assocIndexOf(array, key);
            if (index < 0) {
                return false;
            }
            var lastIndex = array.length - 1;
            if (index == lastIndex) {
                array.pop();
            } else {
                splice.call(array, index, 1);
            }
            return true;
        }
        function assocGet(array, key) {
            var index = assocIndexOf(array, key);
            return index < 0 ? undefined : array[index][1];
        }
        function assocHas(array, key) {
            return assocIndexOf(array, key) > -1;
        }
        function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
                if (eq(array[length][0], key)) {
                    return length;
                }
            }
            return -1;
        }
        function assocSet(array, key, value) {
            var index = assocIndexOf(array, key);
            if (index < 0) {
                array.push([
                    key,
                    value
                ]);
            } else {
                array[index][1] = value;
            }
        }
        function assignInDefaults(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                return srcValue;
            }
            return objValue;
        }
        function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || typeof key == 'number' && value === undefined && !(key in object)) {
                object[key] = value;
            }
        }
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
                object[key] = value;
            }
        }
        function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function (value, key, collection) {
                setter(accumulator, value, iteratee(value), collection);
            });
            return accumulator;
        }
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        function baseAt(object, paths) {
            var index = -1, isNil = object == null, length = paths.length, result = Array(length);
            while (++index < length) {
                result[index] = isNil ? undefined : get(object, paths[index]);
            }
            return result;
        }
        function baseClamp(number, lower, upper) {
            if (number === number) {
                if (upper !== undefined) {
                    number = number <= upper ? number : upper;
                }
                if (lower !== undefined) {
                    number = number >= lower ? number : lower;
                }
            }
            return number;
        }
        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== undefined) {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return copyArray(value, result);
                }
            } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                }
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    if (isHostObject(value)) {
                        return object ? value : {};
                    }
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return copySymbols(value, baseAssign(result, value));
                    }
                } else {
                    if (!cloneableTags[tag]) {
                        return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
                return stacked;
            }
            stack.set(value, result);
            if (!isArr) {
                var props = isFull ? getAllKeys(value) : keys(value);
            }
            arrayEach(props || value, function (subValue, key) {
                if (props) {
                    key = subValue;
                    subValue = value[key];
                }
                assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
            });
            return result;
        }
        function baseConforms(source) {
            var props = keys(source), length = props.length;
            return function (object) {
                if (object == null) {
                    return !length;
                }
                var index = length;
                while (index--) {
                    var key = props[index], predicate = source[key], value = object[key];
                    if (value === undefined && !(key in Object(object)) || !predicate(value)) {
                        return false;
                    }
                }
                return true;
            };
        }
        function baseCreate(proto) {
            return isObject(proto) ? objectCreate(proto) : {};
        }
        function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function () {
                func.apply(undefined, args);
            }, wait);
        }
        function baseDifference(array, values, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
            if (!length) {
                return result;
            }
            if (iteratee) {
                values = arrayMap(values, baseUnary(iteratee));
            }
            if (comparator) {
                includes = arrayIncludesWith;
                isCommon = false;
            } else if (values.length >= LARGE_ARRAY_SIZE) {
                includes = cacheHas;
                isCommon = false;
                values = new SetCache(values);
            }
            outer:
                while (++index < length) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    if (isCommon && computed === computed) {
                        var valuesIndex = valuesLength;
                        while (valuesIndex--) {
                            if (values[valuesIndex] === computed) {
                                continue outer;
                            }
                        }
                        result.push(value);
                    } else if (!includes(values, computed, comparator)) {
                        result.push(value);
                    }
                }
            return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }
        function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end === undefined || end > length ? length : toInteger(end);
            if (end < 0) {
                end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
                array[start++] = value;
            }
            return array;
        }
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
                if (predicate(value, index, collection)) {
                    result.push(value);
                }
            });
            return result;
        }
        function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while (++index < length) {
                var value = array[index];
                if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                        baseFlatten(value, depth - 1, predicate, isStrict, result);
                    } else {
                        arrayPush(result, value);
                    }
                } else if (!isStrict) {
                    result[result.length] = value;
                }
            }
            return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
            return arrayFilter(props, function (key) {
                return isFunction(object[key]);
            });
        }
        function baseGet(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = 0, length = path.length;
            while (object != null && index < length) {
                object = object[path[index++]];
            }
            return index && index == length ? object : undefined;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseHas(object, key) {
            return hasOwnProperty.call(object, key) || typeof object == 'object' && key in object && getPrototype(object) === null;
        }
        function baseHasIn(object, key) {
            return key in Object(object);
        }
        function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
            while (othIndex--) {
                var array = arrays[othIndex];
                if (othIndex && iteratee) {
                    array = arrayMap(array, baseUnary(iteratee));
                }
                maxLength = nativeMin(array.length, maxLength);
                caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
                while (++index < length && result.length < maxLength) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                        othIndex = othLength;
                        while (--othIndex) {
                            var cache = caches[othIndex];
                            if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                                continue outer;
                            }
                        }
                        if (seen) {
                            seen.push(computed);
                        }
                        result.push(value);
                    }
                }
            return result;
        }
        function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function (value, key, object) {
                setter(accumulator, iteratee(value), key, object);
            });
            return accumulator;
        }
        function baseInvoke(object, path, args) {
            if (!isKey(path, object)) {
                path = castPath(path);
                object = parent(object, path);
                path = last(path);
            }
            var func = object == null ? object : object[path];
            return func == null ? undefined : apply(func, object, args);
        }
        function baseIsEqual(value, other, customizer, bitmask, stack) {
            if (value === other) {
                return true;
            }
            if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
            if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag;
            }
            if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag;
            }
            var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
            if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
            }
            if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
                }
            }
            if (!isSameTag) {
                return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
        }
        function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
                return !length;
            }
            object = Object(object);
            while (index--) {
                var data = matchData[index];
                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                }
            }
            while (++index < length) {
                data = matchData[index];
                var key = data[0], objValue = object[key], srcValue = data[1];
                if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                        return false;
                    }
                } else {
                    var stack = new Stack();
                    if (customizer) {
                        var result = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function baseIteratee(value) {
            if (typeof value == 'function') {
                return value;
            }
            if (value == null) {
                return identity;
            }
            if (typeof value == 'object') {
                return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
        }
        function baseKeys(object) {
            return nativeKeys(Object(object));
        }
        function baseKeysIn(object) {
            object = object == null ? object : Object(object);
            var result = [];
            for (var key in object) {
                result.push(key);
            }
            return result;
        }
        if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
            baseKeysIn = function (object) {
                return iteratorToArray(enumerate(object));
            };
        }
        function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            });
            return result;
        }
        function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function (object) {
                return object === source || baseIsMatch(object, source, matchData);
            };
        }
        function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(path, srcValue);
            }
            return function (object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
            };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
                return;
            }
            if (!(isArray(source) || isTypedArray(source))) {
                var props = keysIn(source);
            }
            arrayEach(props || source, function (srcValue, key) {
                if (props) {
                    key = srcValue;
                    srcValue = source[key];
                }
                if (isObject(srcValue)) {
                    stack || (stack = new Stack());
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                } else {
                    var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;
                    if (newValue === undefined) {
                        newValue = srcValue;
                    }
                    assignMergeValue(object, key, newValue);
                }
            });
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
            if (stacked) {
                assignMergeValue(object, key, stacked);
                return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
                newValue = srcValue;
                if (isArray(srcValue) || isTypedArray(srcValue)) {
                    if (isArray(objValue)) {
                        newValue = objValue;
                    } else if (isArrayLikeObject(objValue)) {
                        newValue = copyArray(objValue);
                    } else {
                        isCommon = false;
                        newValue = baseClone(srcValue, true);
                    }
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    if (isArguments(objValue)) {
                        newValue = toPlainObject(objValue);
                    } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
                        isCommon = false;
                        newValue = baseClone(srcValue, true);
                    } else {
                        newValue = objValue;
                    }
                } else {
                    isCommon = false;
                }
            }
            stack.set(srcValue, newValue);
            if (isCommon) {
                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            }
            stack['delete'](srcValue);
            assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
            var length = array.length;
            if (!length) {
                return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined;
        }
        function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
            var result = baseMap(collection, function (value, key, collection) {
                var criteria = arrayMap(iteratees, function (iteratee) {
                    return iteratee(value);
                });
                return {
                    'criteria': criteria,
                    'index': ++index,
                    'value': value
                };
            });
            return baseSortBy(result, function (object, other) {
                return compareMultiple(object, other, orders);
            });
        }
        function basePick(object, props) {
            object = Object(object);
            return arrayReduce(props, function (result, key) {
                if (key in object) {
                    result[key] = object[key];
                }
                return result;
            }, {});
        }
        function basePickBy(object, predicate) {
            var index = -1, props = getAllKeysIn(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index], value = object[key];
                if (predicate(value, key)) {
                    result[key] = value;
                }
            }
            return result;
        }
        function baseProperty(key) {
            return function (object) {
                return object == null ? undefined : object[key];
            };
        }
        function basePropertyDeep(path) {
            return function (object) {
                return baseGet(object, path);
            };
        }
        function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
            if (iteratee) {
                seen = arrayMap(array, baseUnary(iteratee));
            }
            while (++index < length) {
                var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                    if (seen !== array) {
                        splice.call(seen, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                }
            }
            return array;
        }
        function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
                var index = indexes[length];
                if (lastIndex == length || index != previous) {
                    var previous = index;
                    if (isIndex(index)) {
                        splice.call(array, index, 1);
                    } else if (!isKey(index, array)) {
                        var path = castPath(index), object = parent(array, path);
                        if (object != null) {
                            delete object[last(path)];
                        }
                    } else {
                        delete array[index];
                    }
                }
            }
            return array;
        }
        function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
            while (length--) {
                result[fromRight ? length : ++index] = start;
                start += step;
            }
            return result;
        }
        function baseRepeat(string, n) {
            var result = '';
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                return result;
            }
            do {
                if (n % 2) {
                    result += string;
                }
                n = nativeFloor(n / 2);
                if (n) {
                    string += string;
                }
            } while (n);
            return result;
        }
        function baseSet(object, path, value, customizer) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
                var key = path[index];
                if (isObject(nested)) {
                    var newValue = value;
                    if (index != lastIndex) {
                        var objValue = nested[key];
                        newValue = customizer ? customizer(objValue, key, nested) : undefined;
                        if (newValue === undefined) {
                            newValue = objValue == null ? isIndex(path[index + 1]) ? [] : {} : objValue;
                        }
                    }
                    assignValue(nested, key, newValue);
                }
                nested = nested[key];
            }
            return object;
        }
        var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
        };
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
                result[index] = array[index + start];
            }
            return result;
        }
        function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function (value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }
        function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array ? array.length : low;
            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if ((retHighest ? computed <= value : computed < value) && computed !== null) {
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }
                return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsNull = value === null, valIsUndef = value === undefined;
            while (low < high) {
                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), isDef = computed !== undefined, isReflexive = computed === computed;
                if (valIsNaN) {
                    var setLow = isReflexive || retHighest;
                } else if (valIsNull) {
                    setLow = isReflexive && isDef && (retHighest || computed != null);
                } else if (valIsUndef) {
                    setLow = isReflexive && (retHighest || isDef);
                } else if (computed == null) {
                    setLow = false;
                } else {
                    setLow = retHighest ? computed <= value : computed < value;
                }
                if (setLow) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array) {
            return baseSortedUniqBy(array);
        }
        function baseSortedUniqBy(array, iteratee) {
            var index = 0, length = array.length, value = array[0], computed = iteratee ? iteratee(value) : value, seen = computed, resIndex = 1, result = [value];
            while (++index < length) {
                value = array[index], computed = iteratee ? iteratee(value) : value;
                if (!eq(computed, seen)) {
                    seen = computed;
                    result[resIndex++] = value;
                }
            }
            return result;
        }
        function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
            if (comparator) {
                isCommon = false;
                includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
                var set = iteratee ? null : createSet(array);
                if (set) {
                    return setToArray(set);
                }
                isCommon = false;
                includes = cacheHas;
                seen = new SetCache();
            } else {
                seen = iteratee ? [] : result;
            }
            outer:
                while (++index < length) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    if (isCommon && computed === computed) {
                        var seenIndex = seen.length;
                        while (seenIndex--) {
                            if (seen[seenIndex] === computed) {
                                continue outer;
                            }
                        }
                        if (iteratee) {
                            seen.push(computed);
                        }
                        result.push(value);
                    } else if (!includes(seen, computed, comparator)) {
                        if (seen !== result) {
                            seen.push(computed);
                        }
                        result.push(value);
                    }
                }
            return result;
        }
        function baseUnset(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);
            object = parent(object, path);
            var key = last(path);
            return object != null && has(object, key) ? delete object[key] : true;
        }
        function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
                result = result.value();
            }
            return arrayReduce(actions, function (result, action) {
                return action.func.apply(action.thisArg, arrayPush([result], action.args));
            }, result);
        }
        function baseXor(arrays, iteratee, comparator) {
            var index = -1, length = arrays.length;
            while (++index < length) {
                var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
            }
            return result && result.length ? baseUniq(result, iteratee, comparator) : [];
        }
        function baseZipObject(props, values, assignFunc) {
            var index = -1, length = props.length, valsLength = values.length, result = {};
            while (++index < length) {
                var value = index < valsLength ? values[index] : undefined;
                assignFunc(result, props[index], value);
            }
            return result;
        }
        function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
            return typeof value == 'function' ? value : identity;
        }
        function castPath(value) {
            return isArray(value) ? value : stringToPath(value);
        }
        function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
        }
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
                return buffer.slice();
            }
            var result = new buffer.constructor(buffer.length);
            buffer.copy(result);
            return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
        }
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
            return arrayReduce(array, addMapEntry, new map.constructor());
        }
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
            return arrayReduce(array, addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
                if (isUncurried || argsIndex < argsLength) {
                    result[holders[argsIndex]] = args[argsIndex];
                }
            }
            while (rangeLength--) {
                result[leftIndex++] = args[argsIndex++];
            }
            return result;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
                result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
                result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
                if (isUncurried || argsIndex < argsLength) {
                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                }
            }
            return result;
        }
        function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }
        function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];
                assignValue(object, key, newValue);
            }
            return object;
        }
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        function createAggregator(setter, initializer) {
            return function (collection, iteratee) {
                var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                return func(collection, setter, getIteratee(iteratee), accumulator);
            };
        }
        function createAssigner(assigner) {
            return rest(function (object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                customizer = typeof customizer == 'function' ? (length--, customizer) : undefined;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                }
                object = Object(object);
                while (++index < length) {
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, index, customizer);
                    }
                }
                return object;
            });
        }
        function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
                if (collection == null) {
                    return collection;
                }
                if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee);
                }
                var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                        break;
                    }
                }
                return collection;
            };
        }
        function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                    }
                }
                return object;
            };
        }
        function createBaseWrapper(func, bitmask, thisArg) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
        }
        function createCaseFirst(methodName) {
            return function (string) {
                string = toString(string);
                var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined;
                var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
                return chr[methodName]() + trailing;
            };
        }
        function createCompounder(callback) {
            return function (string) {
                return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
            };
        }
        function createCtorWrapper(Ctor) {
            return function () {
                var args = arguments;
                switch (args.length) {
                case 0:
                    return new Ctor();
                case 1:
                    return new Ctor(args[0]);
                case 2:
                    return new Ctor(args[0], args[1]);
                case 3:
                    return new Ctor(args[0], args[1], args[2]);
                case 4:
                    return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                }
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
            };
        }
        function createCurryWrapper(func, bitmask, arity) {
            var Ctor = createCtorWrapper(func);
            function wrapper() {
                var length = arguments.length, args = Array(length), index = length, placeholder = getPlaceholder(wrapper);
                while (index--) {
                    args[index] = arguments[index];
                }
                var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                length -= holders.length;
                if (length < arity) {
                    return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                }
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return apply(fn, this, args);
            }
            return wrapper;
        }
        function createFlow(fromRight) {
            return rest(function (funcs) {
                funcs = baseFlatten(funcs, 1);
                var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                if (fromRight) {
                    funcs.reverse();
                }
                while (index--) {
                    var func = funcs[index];
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                        var wrapper = new LodashWrapper([], true);
                    }
                }
                index = wrapper ? index : length;
                while (++index < length) {
                    func = funcs[index];
                    var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;
                    if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                }
                return function () {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                        return wrapper.plant(value).value();
                    }
                    var index = 0, result = length ? funcs[index].apply(this, args) : value;
                    while (++index < length) {
                        result = funcs[index].call(this, result);
                    }
                    return result;
                };
            });
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? undefined : createCtorWrapper(func);
            function wrapper() {
                var length = arguments.length, index = length, args = Array(length);
                while (index--) {
                    args[index] = arguments[index];
                }
                if (isCurried) {
                    var placeholder = getPlaceholder(wrapper), holdersCount = countHolders(args, placeholder);
                }
                if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                }
                if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                }
                length -= holdersCount;
                if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                }
                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                length = args.length;
                if (argPos) {
                    args = reorder(args, argPos);
                } else if (isFlip && length > 1) {
                    args.reverse();
                }
                if (isAry && ary < length) {
                    args.length = ary;
                }
                if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtorWrapper(fn);
                }
                return fn.apply(thisBinding, args);
            }
            return wrapper;
        }
        function createInverter(setter, toIteratee) {
            return function (object, iteratee) {
                return baseInverter(object, setter, toIteratee(iteratee), {});
            };
        }
        function createOver(arrayFunc) {
            return rest(function (iteratees) {
                iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? arrayMap(iteratees[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee()));
                return rest(function (args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function (iteratee) {
                        return apply(iteratee, thisArg, args);
                    });
                });
            });
        }
        function createPadding(length, chars) {
            chars = chars === undefined ? ' ' : chars + '';
            var charsLength = chars.length;
            if (charsLength < 2) {
                return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                }
                while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                }
                return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
        }
        function createRange(fromRight) {
            return function (start, end, step) {
                if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                    end = step = undefined;
                }
                start = toNumber(start);
                start = start === start ? start : 0;
                if (end === undefined) {
                    end = start;
                    start = 0;
                } else {
                    end = toNumber(end) || 0;
                }
                step = step === undefined ? start < end ? 1 : -1 : toNumber(step) || 0;
                return baseRange(start, end, step, fromRight);
            };
        }
        function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
            if (!(bitmask & CURRY_BOUND_FLAG)) {
                bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [
                func,
                bitmask,
                thisArg,
                newPartials,
                newHolders,
                newPartialsRight,
                newHoldersRight,
                argPos,
                ary,
                arity
            ];
            var result = wrapFunc.apply(undefined, newData);
            if (isLaziable(func)) {
                setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
        }
        function createRound(methodName) {
            var func = Math[methodName];
            return function (number, precision) {
                number = toNumber(number);
                precision = toInteger(precision);
                if (precision) {
                    var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
                    pair = (toString(value) + 'e').split('e');
                    return +(pair[0] + 'e' + (+pair[1] - precision));
                }
                return func(number);
            };
        }
        var createSet = !(Set && new Set([
            1,
            2
        ]).size === 2) ? noop : function (values) {
            return new Set(values);
        };
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = undefined;
            }
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func);
            var newData = [
                func,
                bitmask,
                thisArg,
                partials,
                holders,
                partialsRight,
                holdersRight,
                argPos,
                ary,
                arity
            ];
            if (data) {
                mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
                bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == BIND_FLAG) {
                var result = createBaseWrapper(func, bitmask, thisArg);
            } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
                result = createCurryWrapper(func, bitmask, arity);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
                result = createPartialWrapper(func, bitmask, thisArg, partials);
            } else {
                result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
            var index = -1, isPartial = bitmask & PARTIAL_COMPARE_FLAG, isUnordered = bitmask & UNORDERED_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                return false;
            }
            var stacked = stack.get(array);
            if (stacked) {
                return stacked == other;
            }
            var result = true;
            stack.set(array, other);
            while (++index < arrLength) {
                var arrValue = array[index], othValue = other[index];
                if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                }
                if (compared !== undefined) {
                    if (compared) {
                        continue;
                    }
                    result = false;
                    break;
                }
                if (isUnordered) {
                    if (!arraySome(other, function (othValue) {
                            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack);
                        })) {
                        result = false;
                        break;
                    }
                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                    result = false;
                    break;
                }
            }
            stack['delete'](array);
            return result;
        }
        function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
            switch (tag) {
            case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                    return false;
                }
                object = object.buffer;
                other = other.buffer;
            case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                    return false;
                }
                return true;
            case boolTag:
            case dateTag:
                return +object == +other;
            case errorTag:
                return object.name == other.name && object.message == other.message;
            case numberTag:
                return object != +object ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
                return object == other + '';
            case mapTag:
                var convert = mapToArray;
            case setTag:
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                    return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                    return stacked == other;
                }
                bitmask |= UNORDERED_COMPARE_FLAG;
                stack.set(object, other);
                return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
            case symbolTag:
                if (symbolValueOf) {
                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
        }
        function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
                return false;
            }
            var index = objLength;
            while (index--) {
                var key = objProps[index];
                if (!(isPartial ? key in other : baseHas(other, key))) {
                    return false;
                }
            }
            var stacked = stack.get(object);
            if (stacked) {
                return stacked == other;
            }
            var result = true;
            stack.set(object, other);
            var skipCtor = isPartial;
            while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key], othValue = other[key];
                if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                }
                if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
                    result = false;
                    break;
                }
                skipCtor || (skipCtor = key == 'constructor');
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    result = false;
                }
            }
            stack['delete'](object);
            return result;
        }
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
        };
        function getFuncName(func) {
            var result = func.name + '', array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
            while (length--) {
                var data = array[length], otherFunc = data.func;
                if (otherFunc == null || otherFunc == func) {
                    return data.name;
                }
            }
            return result;
        }
        function getIteratee() {
            var result = lodash.iteratee || iteratee;
            result = result === iteratee ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        var getLength = baseProperty('length');
        function getMatchData(object) {
            var result = toPairs(object), length = result.length;
            while (length--) {
                result[length][2] = isStrictComparable(result[length][1]);
            }
            return result;
        }
        function getNative(object, key) {
            var value = object[key];
            return isNative(value) ? value : undefined;
        }
        function getPlaceholder(func) {
            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
            return object.placeholder;
        }
        function getPrototype(value) {
            return nativeGetPrototype(Object(value));
        }
        function getSymbols(object) {
            return getOwnPropertySymbols(Object(object));
        }
        if (!getOwnPropertySymbols) {
            getSymbols = function () {
                return [];
            };
        }
        var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function (object) {
            var result = [];
            while (object) {
                arrayPush(result, getSymbols(object));
                object = getPrototype(object);
            }
            return result;
        };
        function getTag(value) {
            return objectToString.call(value);
        }
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function (value) {
                var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                    switch (ctorString) {
                    case dataViewCtorString:
                        return dataViewTag;
                    case mapCtorString:
                        return mapTag;
                    case promiseCtorString:
                        return promiseTag;
                    case setCtorString:
                        return setTag;
                    case weakMapCtorString:
                        return weakMapTag;
                    }
                }
                return result;
            };
        }
        function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
                var data = transforms[index], size = data.size;
                switch (data.type) {
                case 'drop':
                    start += size;
                    break;
                case 'dropRight':
                    end -= size;
                    break;
                case 'take':
                    end = nativeMin(end, start + size);
                    break;
                case 'takeRight':
                    start = nativeMax(start, end - size);
                    break;
                }
            }
            return {
                'start': start,
                'end': end
            };
        }
        function hasPath(object, path, hasFunc) {
            path = isKey(path, object) ? [path] : castPath(path);
            var result, index = -1, length = path.length;
            while (++index < length) {
                var key = path[index];
                if (!(result = object != null && hasFunc(object, key))) {
                    break;
                }
                object = object[key];
            }
            if (result) {
                return result;
            }
            var length = object ? object.length : 0;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object));
        }
        function initCloneArray(array) {
            var length = array.length, result = array.constructor(length);
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
            case arrayBufferTag:
                return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
                return new Ctor(+object);
            case dataViewTag:
                return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
                return cloneTypedArray(object, isDeep);
            case mapTag:
                return cloneMap(object, isDeep, cloneFunc);
            case numberTag:
            case stringTag:
                return new Ctor(object);
            case regexpTag:
                return cloneRegExp(object);
            case setTag:
                return cloneSet(object, isDeep, cloneFunc);
            case symbolTag:
                return cloneSymbol(object);
            }
        }
        function indexKeys(object) {
            var length = object ? object.length : undefined;
            if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) {
                return baseTimes(length, String);
            }
            return null;
        }
        function isFlattenable(value) {
            return isArrayLikeObject(value) && (isArray(value) || isArguments(value));
        }
        function isFlattenableIteratee(value) {
            return isArray(value) && !(value.length == 2 && !isFunction(value[0]));
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
                return eq(object[index], value);
            }
            return false;
        }
        function isKey(value, object) {
            var type = typeof value;
            if (type == 'number' || type == 'symbol') {
                return true;
            }
            return !isArray(value) && (isSymbol(value) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object));
        }
        function isKeyable(value) {
            var type = typeof value;
            return type == 'number' || type == 'boolean' || type == 'string' && value != '__proto__' || value == null;
        }
        function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                return false;
            }
            if (func === other) {
                return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
        }
        function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
        }
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
            return function (object) {
                if (object == null) {
                    return false;
                }
                return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
        }
        function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
            var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && source[7].length <= source[8] && bitmask == CURRY_FLAG;
            if (!(isCommon || isCombo)) {
                return data;
            }
            if (srcBitmask & BIND_FLAG) {
                data[2] = source[2];
                newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
                data[7] = value;
            }
            if (srcBitmask & ARY_FLAG) {
                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
                data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
        }
        function mergeDefaults(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
                baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
            }
            return objValue;
        }
        function parent(object, path) {
            return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        var setData = function () {
            var count = 0, lastCalled = 0;
            return function (key, value) {
                var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return key;
                    }
                } else {
                    count = 0;
                }
                return baseSetData(key, value);
            };
        }();
        var stringToPath = memoize(function (string) {
            var result = [];
            toString(string).replace(rePropName, function (match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
            });
            return result;
        });
        function toKey(key) {
            return typeof key == 'string' || isSymbol(key) ? key : key + '';
        }
        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                } catch (e) {
                }
                try {
                    return func + '';
                } catch (e) {
                }
            }
            return '';
        }
        function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
                return wrapper.clone();
            }
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ = copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result;
        }
        function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
                size = 1;
            } else {
                size = nativeMax(toInteger(size), 0);
            }
            var length = array ? array.length : 0;
            if (!length || size < 1) {
                return [];
            }
            var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
            while (index < length) {
                result[resIndex++] = baseSlice(array, index, index += size);
            }
            return result;
        }
        function compact(array) {
            var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result[resIndex++] = value;
                }
            }
            return result;
        }
        function concat() {
            var length = arguments.length, array = castArray(arguments[0]);
            if (length < 2) {
                return length ? copyArray(array) : [];
            }
            var args = Array(length - 1);
            while (length--) {
                args[length - 1] = arguments[length];
            }
            return arrayConcat(array, baseFlatten(args, 1));
        }
        var difference = rest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = rest(function (array, values) {
            var iteratee = last(values);
            if (isArrayLikeObject(iteratee)) {
                iteratee = undefined;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee)) : [];
        });
        var differenceWith = rest(function (array, values) {
            var comparator = last(values);
            if (isArrayLikeObject(comparator)) {
                comparator = undefined;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
        });
        function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                start = 0;
                end = length;
            }
            return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate) {
            return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3)) : -1;
        }
        function findLastIndex(array, predicate) {
            return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3), true) : -1;
        }
        function flatten(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
            var index = -1, length = pairs ? pairs.length : 0, result = {};
            while (++index < length) {
                var pair = pairs[index];
                result[pair[0]] = pair[1];
            }
            return result;
        }
        function head(array) {
            return array && array.length ? array[0] : undefined;
        }
        function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            fromIndex = toInteger(fromIndex);
            if (fromIndex < 0) {
                fromIndex = nativeMax(length + fromIndex, 0);
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array) {
            return dropRight(array, 1);
        }
        var intersection = rest(function (arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = rest(function (arrays) {
            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee === last(mapped)) {
                iteratee = undefined;
            } else {
                mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee)) : [];
        });
        var intersectionWith = rest(function (arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (comparator === last(mapped)) {
                comparator = undefined;
            } else {
                mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
        });
        function join(array, separator) {
            return array ? nativeJoin.call(array, separator) : '';
        }
        function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            var index = length;
            if (fromIndex !== undefined) {
                index = toInteger(fromIndex);
                index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;
            }
            if (value !== value) {
                return indexOfNaN(array, index, true);
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
        }
        var pull = rest(pullAll);
        function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
        }
        function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee)) : array;
        }
        function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
        }
        var pullAt = rest(function (array, indexes) {
            indexes = arrayMap(baseFlatten(indexes, 1), String);
            var result = baseAt(array, indexes);
            basePullAt(array, indexes.sort(compareAscending));
            return result;
        });
        function remove(array, predicate) {
            var result = [];
            if (!(array && array.length)) {
                return result;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                }
            }
            basePullAt(array, indexes);
            return result;
        }
        function reverse(array) {
            return array ? nativeReverse.call(array) : array;
        }
        function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                start = 0;
                end = length;
            } else {
                start = start == null ? 0 : toInteger(start);
                end = end === undefined ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee));
        }
        function sortedIndexOf(array, value) {
            var length = array ? array.length : 0;
            if (length) {
                var index = baseSortedIndex(array, value);
                if (index < length && eq(array[index], value)) {
                    return index;
                }
            }
            return -1;
        }
        function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
        }
        function sortedLastIndexOf(array, value) {
            var length = array ? array.length : 0;
            if (length) {
                var index = baseSortedIndex(array, value, true) - 1;
                if (eq(array[index], value)) {
                    return index;
                }
            }
            return -1;
        }
        function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniqBy(array, getIteratee(iteratee)) : [];
        }
        function tail(array) {
            return drop(array, 1);
        }
        function take(array, n, guard) {
            if (!(array && array.length)) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = rest(function (arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = rest(function (arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) {
                iteratee = undefined;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee));
        });
        var unionWith = rest(function (arrays) {
            var comparator = last(arrays);
            if (isArrayLikeObject(comparator)) {
                comparator = undefined;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
        });
        function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee)) : [];
        }
        function uniqWith(array, comparator) {
            return array && array.length ? baseUniq(array, undefined, comparator) : [];
        }
        function unzip(array) {
            if (!(array && array.length)) {
                return [];
            }
            var length = 0;
            array = arrayFilter(array, function (group) {
                if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                }
            });
            return baseTimes(length, function (index) {
                return arrayMap(array, baseProperty(index));
            });
        }
        function unzipWith(array, iteratee) {
            if (!(array && array.length)) {
                return [];
            }
            var result = unzip(array);
            if (iteratee == null) {
                return result;
            }
            return arrayMap(result, function (group) {
                return apply(iteratee, undefined, group);
            });
        }
        var without = rest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
        });
        var xor = rest(function (arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = rest(function (arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) {
                iteratee = undefined;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
        });
        var xorWith = rest(function (arrays) {
            var comparator = last(arrays);
            if (isArrayLikeObject(comparator)) {
                comparator = undefined;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });
        var zip = rest(unzip);
        function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
        }
        function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
        }
        var zipWith = rest(function (arrays) {
            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee);
        });
        function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        function thru(value, interceptor) {
            return interceptor(value);
        }
        var wrapperAt = rest(function (paths) {
            paths = baseFlatten(paths, 1);
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) {
                    return baseAt(object, paths);
                };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
                'func': thru,
                'args': [interceptor],
                'thisArg': undefined
            });
            return new LodashWrapper(value, this.__chain__).thru(function (array) {
                if (length && !array.length) {
                    array.push(undefined);
                }
                return array;
            });
        });
        function wrapperChain() {
            return chain(this);
        }
        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
            if (this.__values__ === undefined) {
                this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
            return {
                'done': done,
                'value': value
            };
        }
        function wrapperToIterator() {
            return this;
        }
        function wrapperPlant(value) {
            var result, parent = this;
            while (parent instanceof baseLodash) {
                var clone = wrapperClone(parent);
                clone.__index__ = 0;
                clone.__values__ = undefined;
                if (result) {
                    previous.__wrapped__ = clone;
                } else {
                    result = clone;
                }
                var previous = clone;
                parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
        }
        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                var wrapped = value;
                if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                }
                wrapped = wrapped.reverse();
                wrapped.__actions__.push({
                    'func': thru,
                    'args': [reverse],
                    'thisArg': undefined
                });
                return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
        }
        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
        });
        function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
                predicate = undefined;
            }
            return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
        }
        function find(collection, predicate) {
            predicate = getIteratee(predicate, 3);
            if (isArray(collection)) {
                var index = baseFindIndex(collection, predicate);
                return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, baseEach);
        }
        function findLast(collection, predicate) {
            predicate = getIteratee(predicate, 3);
            if (isArray(collection)) {
                var index = baseFindIndex(collection, predicate, true);
                return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, baseEachRight);
        }
        function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
        }
        function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
        }
        function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee), depth);
        }
        function forEach(collection, iteratee) {
            return typeof iteratee == 'function' && isArray(collection) ? arrayEach(collection, iteratee) : baseEach(collection, getIteratee(iteratee));
        }
        function forEachRight(collection, iteratee) {
            return typeof iteratee == 'function' && isArray(collection) ? arrayEachRight(collection, iteratee) : baseEachRight(collection, getIteratee(iteratee));
        }
        var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                result[key] = [value];
            }
        });
        function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
                fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = rest(function (collection, path, args) {
            var index = -1, isFunc = typeof path == 'function', isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value) {
                var func = isFunc ? path : isProp && value != null ? value[path] : undefined;
                result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
            });
            return result;
        });
        var keyBy = createAggregator(function (result, value, key) {
            result[key] = value;
        });
        function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
                return [];
            }
            if (!isArray(iteratees)) {
                iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined : orders;
            if (!isArray(orders)) {
                orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function () {
            return [
                [],
                []
            ];
        });
        function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getIteratee(predicate, 3);
            return func(collection, function (value, index, collection) {
                return !predicate(value, index, collection);
            });
        }
        function sample(collection) {
            var array = isArrayLike(collection) ? collection : values(collection), length = array.length;
            return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
        }
        function sampleSize(collection, n, guard) {
            var index = -1, result = toArray(collection), length = result.length, lastIndex = length - 1;
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
                n = 1;
            } else {
                n = baseClamp(toInteger(n), 0, length);
            }
            while (++index < n) {
                var rand = baseRandom(index, lastIndex), value = result[rand];
                result[rand] = result[index];
                result[index] = value;
            }
            result.length = n;
            return result;
        }
        function shuffle(collection) {
            return sampleSize(collection, MAX_ARRAY_LENGTH);
        }
        function size(collection) {
            if (collection == null) {
                return 0;
            }
            if (isArrayLike(collection)) {
                var result = collection.length;
                return result && isString(collection) ? stringSize(collection) : result;
            }
            if (isObjectLike(collection)) {
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                    return collection.size;
                }
            }
            return keys(collection).length;
        }
        function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
                predicate = undefined;
            }
            return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = rest(function (collection, iteratees) {
            if (collection == null) {
                return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                iteratees = [iteratees[0]];
            }
            iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? iteratees[0] : baseFlatten(iteratees, 1, isFlattenableIteratee);
            return baseOrderBy(collection, iteratees, []);
        });
        var now = Date.now;
        function after(n, func) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function () {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function ary(func, n, guard) {
            n = guard ? undefined : n;
            n = func && n == null ? func.length : n;
            return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
            var result;
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function () {
                if (--n > 0) {
                    result = func.apply(this, arguments);
                }
                if (n <= 1) {
                    func = undefined;
                }
                return result;
            };
        }
        var bind = rest(function (func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getPlaceholder(bind));
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = rest(function (object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getPlaceholder(bindKey));
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result;
        }
        function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result;
        }
        function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime = 0, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
                leading = !!options.leading;
                maxing = 'maxWait' in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = undefined;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }
            function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return !lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = now();
                if (shouldInvoke(time)) {
                    return trailingEdge(time);
                }
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                clearTimeout(timerId);
                timerId = undefined;
                if (trailing && lastArgs) {
                    return invokeFunc(time);
                }
                lastArgs = lastThis = undefined;
                return result;
            }
            function cancel() {
                if (timerId !== undefined) {
                    clearTimeout(timerId);
                }
                lastCallTime = lastInvokeTime = 0;
                lastArgs = lastThis = timerId = undefined;
            }
            function flush() {
                return timerId === undefined ? result : trailingEdge(now());
            }
            function debounced() {
                var time = now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === undefined) {
                        return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === undefined) {
                    timerId = setTimeout(timerExpired, wait);
                }
                return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
        }
        var defer = rest(function (func, args) {
            return baseDelay(func, 1, args);
        });
        var delay = rest(function (func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
            return createWrapper(func, FLIP_FLAG);
        }
        function memoize(func, resolver) {
            if (typeof func != 'function' || resolver && typeof resolver != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function () {
                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                if (cache.has(key)) {
                    return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result);
                return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
            if (typeof predicate != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function () {
                return !predicate.apply(this, arguments);
            };
        }
        function once(func) {
            return before(2, func);
        }
        var overArgs = rest(function (func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return rest(function (args) {
                var index = -1, length = nativeMin(args.length, funcsLength);
                while (++index < length) {
                    args[index] = transforms[index].call(this, args[index]);
                }
                return apply(func, this, args);
            });
        });
        var partial = rest(function (func, partials) {
            var holders = replaceHolders(partials, getPlaceholder(partial));
            return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
        });
        var partialRight = rest(function (func, partials) {
            var holders = replaceHolders(partials, getPlaceholder(partialRight));
            return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });
        var rearg = rest(function (func, indexes) {
            return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
        });
        function rest(func, start) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? func.length - 1 : toInteger(start), 0);
            return function () {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                while (++index < length) {
                    array[index] = args[start + index];
                }
                switch (start) {
                case 0:
                    return func.call(this, array);
                case 1:
                    return func.call(this, args[0], array);
                case 2:
                    return func.call(this, args[0], args[1], array);
                }
                var otherArgs = Array(start + 1);
                index = -1;
                while (++index < start) {
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = array;
                return apply(func, this, otherArgs);
            };
        }
        function spread(func, start) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
            return rest(function (args) {
                var array = args[start], otherArgs = castSlice(args, 0, start);
                if (array) {
                    arrayPush(otherArgs, array);
                }
                return apply(func, this, otherArgs);
            });
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
                leading = 'leading' in options ? !!options.leading : leading;
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
                'leading': leading,
                'maxWait': wait,
                'trailing': trailing
            });
        }
        function unary(func) {
            return ary(func, 1);
        }
        function wrap(value, wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return partial(wrapper, value);
        }
        function castArray() {
            if (!arguments.length) {
                return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
        }
        function clone(value) {
            return baseClone(value, false, true);
        }
        function cloneWith(value, customizer) {
            return baseClone(value, false, true, customizer);
        }
        function cloneDeep(value) {
            return baseClone(value, true, true);
        }
        function cloneDeepWith(value, customizer) {
            return baseClone(value, true, true, customizer);
        }
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        function gt(value, other) {
            return value > other;
        }
        function gte(value, other) {
            return value >= other;
        }
        function isArguments(value) {
            return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
        }
        var isArray = Array.isArray;
        function isArrayBuffer(value) {
            return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
        }
        function isArrayLike(value) {
            return value != null && isLength(getLength(value)) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
        }
        var isBuffer = !Buffer ? constant(false) : function (value) {
            return value instanceof Buffer;
        };
        function isDate(value) {
            return isObjectLike(value) && objectToString.call(value) == dateTag;
        }
        function isElement(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
            if (isArrayLike(value) && (isArray(value) || isString(value) || isFunction(value.splice) || isArguments(value) || isBuffer(value))) {
                return !value.length;
            }
            if (isObjectLike(value)) {
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                    return !value.size;
                }
            }
            for (var key in value) {
                if (hasOwnProperty.call(value, key)) {
                    return false;
                }
            }
            return !(nonEnumShadows && keys(value).length);
        }
        function isEqual(value, other) {
            return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
            if (!isObjectLike(value)) {
                return false;
            }
            return objectToString.call(value) == errorTag || typeof value.message == 'string' && typeof value.name == 'string';
        }
        function isFinite(value) {
            return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
        }
        function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value);
        }
        function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
        }
        function isObjectLike(value) {
            return !!value && typeof value == 'object';
        }
        function isMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
        }
        function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNative(value) {
            if (!isObject(value)) {
                return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        function isNull(value) {
            return value === null;
        }
        function isNil(value) {
            return value == null;
        }
        function isNumber(value) {
            return typeof value == 'number' || isObjectLike(value) && objectToString.call(value) == numberTag;
        }
        function isPlainObject(value) {
            if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
                return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
                return true;
            }
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        function isRegExp(value) {
            return isObject(value) && objectToString.call(value) == regexpTag;
        }
        function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        function isSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
        }
        function isString(value) {
            return typeof value == 'string' || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
        }
        function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
        }
        function isUndefined(value) {
            return value === undefined;
        }
        function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
            return isObjectLike(value) && objectToString.call(value) == weakSetTag;
        }
        function lt(value, other) {
            return value < other;
        }
        function lte(value, other) {
            return value <= other;
        }
        function toArray(value) {
            if (!value) {
                return [];
            }
            if (isArrayLike(value)) {
                return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (iteratorSymbol && value[iteratorSymbol]) {
                return iteratorToArray(value[iteratorSymbol]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
        }
        function toInteger(value) {
            if (!value) {
                return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
                var sign = value < 0 ? -1 : 1;
                return sign * MAX_INTEGER;
            }
            var remainder = value % 1;
            return value === value ? remainder ? value - remainder : value : 0;
        }
        function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
            if (typeof value == 'number') {
                return value;
            }
            if (isSymbol(value)) {
                return NAN;
            }
            if (isObject(value)) {
                var other = isFunction(value.valueOf) ? value.valueOf() : value;
                value = isObject(other) ? other + '' : other;
            }
            if (typeof value != 'string') {
                return value === 0 ? value : +value;
            }
            value = value.replace(reTrim, '');
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
            return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
            return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        }
        function toString(value) {
            if (typeof value == 'string') {
                return value;
            }
            if (value == null) {
                return '';
            }
            if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }
        var assign = createAssigner(function (object, source) {
            if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keys(source), object);
                return;
            }
            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    assignValue(object, key, source[key]);
                }
            }
        });
        var assignIn = createAssigner(function (object, source) {
            if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keysIn(source), object);
                return;
            }
            for (var key in source) {
                assignValue(object, key, source[key]);
            }
        });
        var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
        });
        var at = rest(function (object, paths) {
            return baseAt(object, baseFlatten(paths, 1));
        });
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? baseAssign(result, properties) : result;
        }
        var defaults = rest(function (args) {
            args.push(undefined, assignInDefaults);
            return apply(assignInWith, undefined, args);
        });
        var defaultsDeep = rest(function (args) {
            args.push(undefined, mergeDefaults);
            return apply(mergeWith, undefined, args);
        });
        function findKey(object, predicate) {
            return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);
        }
        function findLastKey(object, predicate) {
            return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);
        }
        function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, getIteratee(iteratee), keysIn);
        }
        function forInRight(object, iteratee) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee), keysIn);
        }
        function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee));
        }
        function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee));
        }
        function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function (result, value, key) {
            result[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function (result, value, key) {
            if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
            } else {
                result[value] = [key];
            }
        }, getIteratee);
        var invoke = rest(baseInvoke);
        function keys(object) {
            var isProto = isPrototype(object);
            if (!(isProto || isArrayLike(object))) {
                return baseKeys(object);
            }
            var indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
            for (var key in object) {
                if (baseHas(object, key) && !(skipIndexes && (key == 'length' || isIndex(key, length))) && !(isProto && key == 'constructor')) {
                    result.push(key);
                }
            }
            return result;
        }
        function keysIn(object) {
            var index = -1, isProto = isPrototype(object), props = baseKeysIn(object), propsLength = props.length, indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
            while (++index < propsLength) {
                var key = props[index];
                if (!(skipIndexes && (key == 'length' || isIndex(key, length))) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }
        function mapKeys(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
                result[iteratee(value, key, object)] = value;
            });
            return result;
        }
        function mapValues(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
                result[key] = iteratee(value, key, object);
            });
            return result;
        }
        var merge = createAssigner(function (object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
        });
        var omit = rest(function (object, props) {
            if (object == null) {
                return {};
            }
            props = arrayMap(baseFlatten(props, 1), toKey);
            return basePick(object, baseDifference(getAllKeysIn(object), props));
        });
        function omitBy(object, predicate) {
            predicate = getIteratee(predicate);
            return basePickBy(object, function (value, key) {
                return !predicate(value, key);
            });
        }
        var pick = rest(function (object, props) {
            return object == null ? {} : basePick(object, baseFlatten(props, 1));
        });
        function pickBy(object, predicate) {
            return object == null ? {} : basePickBy(object, getIteratee(predicate));
        }
        function result(object, path, defaultValue) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = -1, length = path.length;
            if (!length) {
                object = undefined;
                length = 1;
            }
            while (++index < length) {
                var value = object == null ? undefined : object[path[index]];
                if (value === undefined) {
                    index = length;
                    value = defaultValue;
                }
                object = isFunction(value) ? value.call(object) : value;
            }
            return object;
        }
        function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseSet(object, path, value, customizer);
        }
        function toPairs(object) {
            return baseToPairs(object, keys(object));
        }
        function toPairsIn(object) {
            return baseToPairs(object, keysIn(object));
        }
        function transform(object, iteratee, accumulator) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getIteratee(iteratee, 4);
            if (accumulator == null) {
                if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) {
                        accumulator = isArray(object) ? new Ctor() : [];
                    } else {
                        accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                    }
                } else {
                    accumulator = {};
                }
            }
            (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                return iteratee(accumulator, value, index, object);
            });
            return accumulator;
        }
        function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
            return object ? baseValues(object, keys(object)) : [];
        }
        function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
            if (upper === undefined) {
                upper = lower;
                lower = undefined;
            }
            if (upper !== undefined) {
                upper = toNumber(upper);
                upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined) {
                lower = toNumber(lower);
                lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
            start = toNumber(start) || 0;
            if (end === undefined) {
                end = start;
                start = 0;
            } else {
                end = toNumber(end) || 0;
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                upper = floating = undefined;
            }
            if (floating === undefined) {
                if (typeof upper == 'boolean') {
                    floating = upper;
                    upper = undefined;
                } else if (typeof lower == 'boolean') {
                    floating = lower;
                    lower = undefined;
                }
            }
            if (lower === undefined && upper === undefined) {
                lower = 0;
                upper = 1;
            } else {
                lower = toNumber(lower) || 0;
                if (upper === undefined) {
                    upper = lower;
                    lower = 0;
                } else {
                    upper = toNumber(upper) || 0;
                }
            }
            if (lower > upper) {
                var temp = lower;
                lower = upper;
                upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
                var rand = nativeRandom();
                return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
            }
            return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
            string = toString(string);
            target = typeof target == 'string' ? target : target + '';
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            position -= target.length;
            return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
        }
        var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
        });
        var lowerCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst('toLowerCase');
        function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
                return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt(string, radix, guard) {
            if (guard || radix == null) {
                radix = 0;
            } else if (radix) {
                radix = +radix;
            }
            string = toString(string).replace(reTrim, '');
            return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
                n = 1;
            } else {
                n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
        }
        function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
        }
        var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
        });
        function split(string, separator, limit) {
            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                separator = limit = undefined;
            }
            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
                return [];
            }
            string = toString(string);
            if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
                separator += '';
                if (separator == '' && reHasComplexSymbol.test(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                }
            }
            return nativeSplit.call(string, separator, limit);
        }
        var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + upperFirst(word);
        });
        function startsWith(string, target, position) {
            string = toString(string);
            position = baseClamp(toInteger(position), 0, string.length);
            return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
                options = undefined;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, assignInDefaults);
            var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
            var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    isEscaping = true;
                    source += '\' +\n__e(' + escapeValue + ') +\n\'';
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += '\';\n' + evaluateValue + ';\n__p += \'';
                }
                if (interpolateValue) {
                    source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                }
                index = offset + match.length;
                return match;
            });
            source += '\';\n';
            var variable = options.variable;
            if (!variable) {
                source = 'with (obj) {\n' + source + '\n}\n';
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
            source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + 'var __t, __p = \'\'' + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
            var result = attempt(function () {
                return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            });
            result.source = source;
            if (isError(result)) {
                throw result;
            }
            return result;
        }
        function toLower(value) {
            return toString(value).toLowerCase();
        }
        function toUpper(value) {
            return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
            string = toString(string);
            if (!string) {
                return string;
            }
            if (guard || chars === undefined) {
                return string.replace(reTrim, '');
            }
            if (!(chars += '')) {
                return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join('');
        }
        function trimEnd(string, chars, guard) {
            string = toString(string);
            if (!string) {
                return string;
            }
            if (guard || chars === undefined) {
                return string.replace(reTrimEnd, '');
            }
            if (!(chars += '')) {
                return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join('');
        }
        function trimStart(string, chars, guard) {
            string = toString(string);
            if (!string) {
                return string;
            }
            if (guard || chars === undefined) {
                return string.replace(reTrimStart, '');
            }
            if (!(chars += '')) {
                return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join('');
        }
        function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
                var separator = 'separator' in options ? options.separator : separator;
                length = 'length' in options ? toInteger(options.length) : length;
                omission = 'omission' in options ? toString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (reHasComplexSymbol.test(string)) {
                var strSymbols = stringToArray(string);
                strLength = strSymbols.length;
            }
            if (length >= strLength) {
                return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
                return omission;
            }
            var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
            if (separator === undefined) {
                return result + omission;
            }
            if (strSymbols) {
                end += result.length - end;
            }
            if (isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, substring = result;
                    if (!separator.global) {
                        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                        var newEnd = match.index;
                    }
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                }
            } else if (string.indexOf(separator, end) != end) {
                var index = result.lastIndexOf(separator);
                if (index > -1) {
                    result = result.slice(0, index);
                }
            }
            return result + omission;
        }
        function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toUpperCase();
        });
        var upperFirst = createCaseFirst('toUpperCase');
        function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;
            if (pattern === undefined) {
                pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
            }
            return string.match(pattern) || [];
        }
        var attempt = rest(function (func, args) {
            try {
                return apply(func, undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        });
        var bindAll = rest(function (object, methodNames) {
            arrayEach(baseFlatten(methodNames, 1), function (key) {
                object[key] = bind(object[key], object);
            });
            return object;
        });
        function cond(pairs) {
            var length = pairs ? pairs.length : 0, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function (pair) {
                if (typeof pair[1] != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
                return [
                    toIteratee(pair[0]),
                    pair[1]
                ];
            });
            return rest(function (args) {
                var index = -1;
                while (++index < length) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) {
                        return apply(pair[1], this, args);
                    }
                }
            });
        }
        function conforms(source) {
            return baseConforms(baseClone(source, true));
        }
        function constant(value) {
            return function () {
                return value;
            };
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
            return value;
        }
        function iteratee(func) {
            return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
        }
        function matches(source) {
            return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = rest(function (path, args) {
            return function (object) {
                return baseInvoke(object, path, args);
            };
        });
        var methodOf = rest(function (object, args) {
            return function (path) {
                return baseInvoke(object, path, args);
            };
        });
        function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                options = source;
                source = object;
                object = this;
                methodNames = baseFunctions(source, keys(source));
            }
            var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function (methodName) {
                var func = source[methodName];
                object[methodName] = func;
                if (isFunc) {
                    object.prototype[methodName] = function () {
                        var chainAll = this.__chain__;
                        if (chain || chainAll) {
                            var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                            actions.push({
                                'func': func,
                                'args': arguments,
                                'thisArg': object
                            });
                            result.__chain__ = chainAll;
                            return result;
                        }
                        return func.apply(object, arrayPush([this.value()], arguments));
                    };
                }
            });
            return object;
        }
        function noConflict() {
            if (root._ === this) {
                root._ = oldDash;
            }
            return this;
        }
        function noop() {
        }
        function nthArg(n) {
            n = toInteger(n);
            return rest(function (args) {
                return baseNth(args, n);
            });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
            return function (path) {
                return object == null ? undefined : baseGet(object, path);
            };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function times(n, iteratee) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
                return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);
            while (++index < n) {
                iteratee(index);
            }
            return result;
        }
        function toPath(value) {
            if (isArray(value)) {
                return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(value));
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
        }
        var add = createMathOperation(function (augend, addend) {
            return augend + addend;
        });
        var ceil = createRound('ceil');
        var divide = createMathOperation(function (dividend, divisor) {
            return dividend / divisor;
        });
        var floor = createRound('floor');
        function max(array) {
            return array && array.length ? baseExtremum(array, identity, gt) : undefined;
        }
        function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee), gt) : undefined;
        }
        function mean(array) {
            return baseMean(array, identity);
        }
        function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee));
        }
        function min(array) {
            return array && array.length ? baseExtremum(array, identity, lt) : undefined;
        }
        function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee), lt) : undefined;
        }
        var multiply = createMathOperation(function (multiplier, multiplicand) {
            return multiplier * multiplicand;
        });
        var round = createRound('round');
        var subtract = createMathOperation(function (minuend, subtrahend) {
            return minuend - subtrahend;
        });
        function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.deburr = deburr;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
                if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), { 'chain': false });
        lodash.VERSION = VERSION;
        arrayEach([
            'bind',
            'bindKey',
            'curry',
            'curryRight',
            'partial',
            'partialRight'
        ], function (methodName) {
            lodash[methodName].placeholder = lodash;
        });
        arrayEach([
            'drop',
            'take'
        ], function (methodName, index) {
            LazyWrapper.prototype[methodName] = function (n) {
                var filtered = this.__filtered__;
                if (filtered && !index) {
                    return new LazyWrapper(this);
                }
                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                var result = this.clone();
                if (filtered) {
                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                } else {
                    result.__views__.push({
                        'size': nativeMin(n, MAX_ARRAY_LENGTH),
                        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                    });
                }
                return result;
            };
            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                return this.reverse()[methodName](n).reverse();
            };
        });
        arrayEach([
            'filter',
            'map',
            'takeWhile'
        ], function (methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function (iteratee) {
                var result = this.clone();
                result.__iteratees__.push({
                    'iteratee': getIteratee(iteratee, 3),
                    'type': type
                });
                result.__filtered__ = result.__filtered__ || isFilter;
                return result;
            };
        });
        arrayEach([
            'head',
            'last'
        ], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');
            LazyWrapper.prototype[methodName] = function () {
                return this[takeName](1).value()[0];
            };
        });
        arrayEach([
            'initial',
            'tail'
        ], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');
            LazyWrapper.prototype[methodName] = function () {
                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
        });
        LazyWrapper.prototype.compact = function () {
            return this.filter(identity);
        };
        LazyWrapper.prototype.find = function (predicate) {
            return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function (predicate) {
            return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = rest(function (path, args) {
            if (typeof path == 'function') {
                return new LazyWrapper(this);
            }
            return this.map(function (value) {
                return baseInvoke(value, path, args);
            });
        });
        LazyWrapper.prototype.reject = function (predicate) {
            predicate = getIteratee(predicate, 3);
            return this.filter(function (value) {
                return !predicate(value);
            });
        };
        LazyWrapper.prototype.slice = function (start, end) {
            start = toInteger(start);
            var result = this;
            if (result.__filtered__ && (start > 0 || end < 0)) {
                return new LazyWrapper(result);
            }
            if (start < 0) {
                result = result.takeRight(-start);
            } else if (start) {
                result = result.drop(start);
            }
            if (end !== undefined) {
                end = toInteger(end);
                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
        };
        LazyWrapper.prototype.takeRightWhile = function (predicate) {
            return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function () {
            return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
                return;
            }
            lodash.prototype[methodName] = function () {
                var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                var interceptor = function (value) {
                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                    return isTaker && chainAll ? result[0] : result;
                };
                if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                    isLazy = useLazy = false;
                }
                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    result.__actions__.push({
                        'func': thru,
                        'args': [interceptor],
                        'thisArg': undefined
                    });
                    return new LodashWrapper(result, chainAll);
                }
                if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                }
                result = this.thru(interceptor);
                return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
            };
        });
        arrayEach([
            'pop',
            'push',
            'shift',
            'sort',
            'splice',
            'unshift'
        ], function (methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function () {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                }
                return this[chainName](function (value) {
                    return func.apply(isArray(value) ? value : [], args);
                });
            };
        });
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name + '', names = realNames[key] || (realNames[key] = []);
                names.push({
                    'name': methodName,
                    'func': lodashFunc
                });
            }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
                'name': 'wrapper',
                'func': undefined
            }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        if (iteratorSymbol) {
            lodash.prototype[iteratorSymbol] = wrapperToIterator;
        }
        return lodash;
    }
    var _ = runInContext();
    (freeWindow || freeSelf || {})._ = _;
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('lodash@4.11.1#lodash', function () {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        }
        freeExports._ = _;
    } else {
        root._ = _;
    }
}.call(this));
/*mui@0.0.0#mui*/
define('mui@0.0.0#mui', [
    'angular',
    'lodash'
], function (ng, _) {
    'use strict';
    function mui(ng) {
        var _self = {};
        _self.providerMap = {
            service: 'service',
            factory: 'factory',
            directive: 'directive',
            provider: 'provider',
            controller: 'controller',
            filter: 'filter',
            value: 'value',
            constant: 'constant',
            animation: 'animation',
            config: 'config',
            run: 'run',
            decorator: 'decorator'
        };
        function MevError(msg) {
            this.msg = msg;
        }
        _self.inferProvider = function inferProvider(func) {
            if (typeof func !== 'function')
                throw new MevError('Compnent with name \'' + func.name + '\' is not a function, but is ' + typeof func);
            var provider = func.provider || func.$provider;
            func.provider = provider;
            if (provider !== 'config' && provider !== 'run' && !func.$name)
                throw new MevError('Compnent name not specified for func ' + func.name);
            if (provider) {
                if (!_self.providerMap[provider.toLowerCase()]) {
                    throw new MevError('Invalid angular provider \'' + provider + '\'');
                }
                return provider.toLowerCase();
            }
            for (var curProvider in _self.providerMap) {
                if (_self.providerMap.hasOwnProperty(curProvider)) {
                    if (func.$name.toLowerCase().indexOf(curProvider) > -1)
                        provider = curProvider;
                }
            }
            if (!provider)
                throw new MevError('Could not infer provider for component: ' + JSON.stringify(func));
            func.provider = provider.toLowerCase();
            return func.provider;
        };
        _self.selectNgModules = function (deps) {
            return deps.filter(function (dep) {
                if ((dep instanceof String || typeof dep === 'string') && dep.charAt(0) !== '<')
                    return true;
                if (Array.isArray(dep.requires) && typeof dep.provider === 'function')
                    return true;
            }).map(function (dep) {
                if (dep instanceof String || typeof dep === 'string')
                    return dep;
                else
                    return dep.name;
            });
        };
        _self.formatComponentName = function (func) {
            var name = func.$name;
            if (!func.$provider) {
                if (name.toLowerCase().indexOf(func.provider, this.length - func.provider.length) !== -1) {
                    name = name.substring(0, name.length - func.provider.length);
                }
            }
            if (func.provider === 'directive')
                name = name.substr(0, 1).toLowerCase() + name.substr(1);
            func.$name = name;
            return name;
        };
        _self.register = function (func) {
            var provider = _self.inferProvider(func);
            if (provider === 'config' || provider === 'run')
                return this[provider](func);
            else {
                var name = _self.formatComponentName(func);
                return this[provider](name, func);
            }
        };
        _self.registerAll = function (components) {
            var result;
            for (var i = 0; i < components.length; i++) {
                try {
                    result = this.mevRegister(components[i]);
                    console.debug('registerAll - regitered', components[i].$name);
                } catch (e) {
                    if (e instanceof MevError)
                        console.debug('registerAll - skipping component ', e);
                    else
                        throw e;
                }
            }
            return result ? result : this;
        };
        _self._module = ng.module;
        ng.module = function (name, deps, args) {
            if (typeof deps === 'undefined')
                return _self._module(name);
            var modules = [];
            if (Array.isArray(deps)) {
                modules = modules.concat(_self.selectNgModules(deps));
            } else if (typeof deps.length !== 'undefined') {
                deps = Array.prototype.slice.call(deps);
                modules = modules.concat(_self.selectNgModules(deps));
            }
            if (args) {
                var aArgs = Array.prototype.slice.call(args);
                modules = modules.concat(_self.selectNgModules(aArgs));
            }
            modules = _.uniq(modules);
            var module = _self._module(name, modules);
            console.info('registered module ' + module.name + ' with ' + modules.length + ' dependencies ', modules);
            module.mevRegister = _self.register.bind(module);
            module.mevRegisterAll = _self.registerAll.bind(module);
            if (args) {
                module.mevRegisterAll(args);
            }
            return module;
        };
        return ng;
    }
    return mui(ng);
});
/*angular-animate@1.5.0#angular-animate*/
define('angular-animate@1.5.0#angular-animate', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/**\n * @license AngularJS v1.5.0\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {\'use strict\';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar copy        = angular.copy;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = \'-add\';\nvar REMOVE_CLASS_SUFFIX = \'-remove\';\nvar EVENT_CLASS_PREFIX = \'ng-\';\nvar ACTIVE_CLASS_SUFFIX = \'-active\';\nvar PREPARE_CLASS_SUFFIX = \'-prepare\';\n\nvar NG_ANIMATE_CLASSNAME = \'ng-animate\';\nvar NG_ANIMATE_CHILDREN_DATA = \'$$ngAnimateChildren\';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = \'\', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn\'t implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = \'-webkit-\';\n  TRANSITION_PROP = \'WebkitTransition\';\n  TRANSITIONEND_EVENT = \'webkitTransitionEnd transitionend\';\n} else {\n  TRANSITION_PROP = \'transition\';\n  TRANSITIONEND_EVENT = \'transitionend\';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = \'-webkit-\';\n  ANIMATION_PROP = \'WebkitAnimation\';\n  ANIMATIONEND_EVENT = \'webkitAnimationEnd animationend\';\n} else {\n  ANIMATION_PROP = \'animation\';\n  ANIMATIONEND_EVENT = \'animationend\';\n}\n\nvar DURATION_KEY = \'Duration\';\nvar PROPERTY_KEY = \'Property\';\nvar DELAY_KEY = \'Delay\';\nvar TIMING_KEY = \'TimingFunction\';\nvar ANIMATION_ITERATION_COUNT_KEY = \'IterationCount\';\nvar ANIMATION_PLAYSTATE_KEY = \'PlayState\';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nvar ngMinErr = angular.$$minErr(\'ng\');\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr(\'areq\', "Argument \'{0}\' is {1}", (name || \'?\'), (reason || "required"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return \'\';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(\' \');\n  if (isArray(b)) b = b.join(\' \');\n  return a + \' \' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = \'\';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? \' \' : \'\';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it\'s important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  var target = oldAnimation.options || {};\n  var newOptions = newAnimation.options || {};\n\n  var toAdd = (target.addClass || \'\') + \' \' + (newOptions.addClass || \'\');\n  var toRemove = (target.removeClass || \'\') + \' \' + (newOptions.removeClass || \'\');\n  var classes = resolveElementClasses(element.attr(\'class\'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: \'\',\n    removeClass: \'\'\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = \'addClass\';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = \'removeClass\';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += \' \';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(\' \');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = \'\';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn\'t kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? \'-\' + duration + \'s\' : \'\';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? \'paused\' : \'\';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + \' \' + b;\n}\n\nvar $$rAFSchedulerFactory = [\'$$rAF\', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children\'s parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module="ngAnimateChildren" name="ngAnimateChildren" deps="angular-animate.js" animations="true">\n     <file name="index.html">\n       <div ng-controller="mainController as main">\n         <label>Show container? <input type="checkbox" ng-model="main.enterElement" /></label>\n         <label>Animate children? <input type="checkbox" ng-model="main.animateChildren" /></label>\n         <hr>\n         <div ng-animate-children="{{main.animateChildren}}">\n           <div ng-if="main.enterElement" class="container">\n             List of items:\n             <div ng-repeat="item in [0, 1, 2, 3]" class="item">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name="animations.css">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name="script.js">\n      angular.module(\'ngAnimateChildren\', [\'ngAnimate\'])\n        .controller(\'mainController\', function() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>\n */\nvar $$AnimateChildrenDirective = [\'$interpolate\', function($interpolate) {\n  return {\n    link: function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (angular.isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData($interpolate(val)(scope));\n        attrs.$observe(\'ngAnimateChildren\', setData);\n      }\n\n      function setData(value) {\n        value = value === \'on\' || value === \'true\';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      }\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = \'$$animateCss\';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if="onOff" class="fold-animation">\n *   This element will go BOOM\n * </div>\n * <button ng-click="onOff=true">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation(\'.fold-animation\', [\'$animateCss\', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:\'0px\' },\n *         to: { height:height + \'px\' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation(\'.fold-animation\', [\'$animateCss\', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: \'red large-text pulse-twice\',\n *         easing: \'ease-out\',\n *         from: { height:\'0px\' },\n *         to: { height:height + \'px\' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we\'re adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:\'red\' },\n *   to: { background:\'blue\' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it\'s always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + \'s\'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + \'s\'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === \'-\' || c === \'+\' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for negative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it\'s always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == \'s\') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + \'s\';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += \' linear all\';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// "OR" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = [\'$animateProvider\', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = [\'$window\', \'$$jqLite\', \'$$AnimateRunner\', \'$timeout\',\n               \'$$forceReflow\', \'$sniffer\', \'$$rAFScheduler\', \'$$animateQueue\',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = "$$ngAnimateParentKey";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + \'-\' + node.getAttribute(\'class\') + \'-\' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === \'infinite\') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we\'re keeping an internal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, \'-stagger\');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, initialOptions) {\n      // all of the animation functions should create\n      // a copy of the options data, however, if a\n      // parent service has already created a copy then\n      // we should stick to using that\n      var options = initialOptions || {};\n      if (!options.$$prepared) {\n        options = prepareAnimationOptions(copy(options));\n      }\n\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$$animateQueue.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var temporaryStyles = [];\n      var classes = element.attr(\'class\');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n      var startTime;\n      var events = [];\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(\' \')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = \'\';\n      var addRemoveClassName = \'\';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += \' \';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(\' \').trim();\n      var fullClassName = classes + \' \' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || \'\').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class\' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it\'s thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == \'all\';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle;\n        if (typeof options.delay !== "boolean") {\n          delayStyle = parseFloat(options.delay);\n          // number in options.delay means we have to recalculate the delay for the closing timeout\n          maxDelay = Math.max(delayStyle, 0);\n        }\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don\'t have access to pause/resume the animation\n          // since it hasn\'t run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn\'t close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = \'\';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        if (events && events.length) {\n          // Remove the transitionend / animationend listener(s)\n          element.off(events.join(\' \'), onAnimationProgress);\n        }\n\n        //Cancel the fallback closing timeout and remove the timer data\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n        if (animationTimerData) {\n          $timeout.cancel(animationTimerData[0].timer);\n          element.removeData(ANIMATE_TIMER_KEY);\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function onAnimationProgress(event) {\n        event.stopPropagation();\n        var ev = event.originalEvent || event;\n\n        // we now always use `Date.now()` due to the recent changes with\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n        var timeStamp = ev.$manualTimeStamp || Date.now();\n\n        /* Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation */\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n        /* $manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don\'t, then a timeStamp is automatically created for them.\n         * We\'re checking to see if the timeStamp surpasses the expected delay,\n         * but we\'re using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early */\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n          // we set this flag to ensure that if the transition is paused then, when resumed,\n          // the animation will automatically close itself since transitions cannot be paused.\n          animationCompleted = true;\n          close();\n        }\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intentional stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + \' \' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          if (events.length) {\n            element.on(events.join(\' \'), onAnimationProgress);\n          }\n\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = [\'$$animationProvider\', function($$animationProvider) {\n  $$animationProvider.drivers.push(\'$$animateCssDriver\');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = \'ng-animate-shim\';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = \'ng-anchor\';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = \'ng-anchor-out\';\n  var NG_IN_ANCHOR_CLASS_NAME = \'ng-anchor-in\';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = [\'$animateCss\', \'$rootScope\', \'$$AnimateRunner\', \'$rootElement\', \'$sniffer\', \'$$jqLite\', \'$document\',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragment case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, \'\');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(\' \');\n      if (isString(b)) b = b.split(\' \');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(\' \');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn\'t return\n        // all the keys for the coords object when iterated\n        forEach([\'width\',\'height\',\'top\',\'left\'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case \'top\':\n              value += bodyNode.scrollTop;\n              break;\n            case \'left\':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + \'px\';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr(\'class\') || \'\';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + \' \' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + \' \' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor[\'out\'];\n        var inElement = anchor[\'in\'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === \'leave\') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = [\'$animateProvider\', function($animateProvider) {\n  this.$get = [\'$injector\', \'$$AnimateRunner\', \'$$jqLite\',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, \'enter\');\n    return function(element, event, classes, options) {\n      var animationClosed = false;\n\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element\'s className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr(\'class\') || \'\';\n        if (options.addClass) {\n          classes += \' \' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += \' \' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don\'t return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == \'leave\') {\n          beforeFn = \'leave\';\n          afterFn = \'afterLeave\'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = \'before\' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== \'enter\' && event !== \'move\') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      function close() {\n        animationClosed = true;\n        applyOptions();\n        applyAnimationStyles(element, options);\n      }\n\n      var runner;\n\n      return {\n        $$willAnimate: true,\n        end: function() {\n          if (runner) {\n            runner.end();\n          } else {\n            close();\n            runner = new $$AnimateRunner();\n            runner.complete(true);\n          }\n          return runner;\n        },\n        start: function() {\n          if (runner) {\n            return runner;\n          }\n\n          runner = new $$AnimateRunner();\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          runner.setHost({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            close(success);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case \'animate\':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case \'setClass\':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case \'addClass\':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case \'removeClass\':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === \'beforeSetClass\') {\n            a = groupEventedAnimations(element, \'removeClass\', options, animations, \'beforeRemoveClass\');\n            b = groupEventedAnimations(element, \'addClass\', options, animations, \'beforeAddClass\');\n          } else if (fnName === \'setClass\') {\n            a = groupEventedAnimations(element, \'removeClass\', options, animations, \'removeClass\');\n            b = groupEventedAnimations(element, \'addClass\', options, animations, \'addClass\');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(\' \');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = [\'$$animationProvider\', function($$animationProvider) {\n  $$animationProvider.drivers.push(\'$$animateJsDriver\');\n  this.$get = [\'$$animateJs\', \'$$AnimateRunner\', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = \'data-ng-animate\';\nvar NG_ANIMATE_PIN_DATA = \'$ngAnimatePin\';\nvar $$AnimateQueueProvider = [\'$animateProvider\', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n  var ONE_SPACE = \' \';\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function makeTruthyCssClassMap(classString) {\n    if (!classString) {\n      return null;\n    }\n\n    var keys = classString.split(ONE_SPACE);\n    var map = Object.create(null);\n\n    forEach(keys, function(key) {\n      map[key] = true;\n    });\n    return map;\n  }\n\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n      return newClassString.split(ONE_SPACE).some(function(className) {\n        return currentClassMap[className];\n      });\n    }\n  }\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(animation, and) {\n    var a = (animation.addClass || \'\').length > 0;\n    var b = (animation.removeClass || \'\').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == \'leave\' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don\'t even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nA = newAnimation.addClass;\n    var nR = newAnimation.removeClass;\n    var cA = currentAnimation.addClass;\n    var cR = currentAnimation.removeClass;\n\n    // early detection to save the global CPU shortage :)\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n      return false;\n    }\n\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n  });\n\n  this.$get = [\'$$rAF\', \'$rootScope\', \'$rootElement\', \'$document\', \'$$HashMap\',\n               \'$$animation\', \'$$AnimateRunner\', \'$templateRequest\', \'$$jqLite\', \'$$forceReflow\',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it\'s important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationDetails(element, animation) {\n      return mergeAnimationDetails(element, animation, {});\n    }\n\n    // IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.\n    var contains = Node.prototype.contains || function(arg) {\n      // jshint bitwise: false\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n      // jshint bitwise: true\n    };\n\n    function findCallbacks(parent, element, event) {\n      var targetNode = getDomNode(element);\n      var targetParentNode = getDomNode(parent);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (contains.call(entry.node, targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === \'leave\' && contains.call(entry.node, targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), \'element\', \'not an element\');\n        assertArg(isElement(parentElement), \'parentElement\', \'not an element\');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              disabledElementsLookup.put(node, !bool);\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, initialOptions) {\n      // we always make a copy of the options since\n      // there should never be any side effects on\n      // the input data when running `$animateCss`.\n      var options = copy(initialOptions);\n\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(\' \');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(\' \');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(\' \');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = [\'enter\', \'move\', \'leave\'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      // Animations are also disabled if the document is currently hidden (page is not visible\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n      var skipAnimations = !animationsEnabled || $document[0].hidden || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        addClass: options.addClass,\n        removeClass: options.removeClass,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed(\'skip\', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n            return existingAnimation.runner;\n          }\n        }\n        var cancelAnimationFlag = isAllowed(\'cancel\', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn\'t started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed(\'join\', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationDetails(element, newAnimation);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationDetails(element, newAnimation);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === \'animate\' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === \'animate\'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it\'s the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn\'t allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won\'t read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n            ? \'setClass\'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, \'close\', {});\n        });\n\n        // this will update the runner\'s flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, \'start\', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parent, element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don\'t know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll(\'[\' + NG_ANIMATE_ATTR_NAME + \']\');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        if (animationDetails) {\n          switch (state) {\n            case RUNNING_STATE:\n              animationDetails.runner.end();\n              /* falls through */\n            case PRE_DIGEST_STATE:\n              activeAnimationsLookup.remove(child);\n              break;\n          }\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    /**\n     * This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren\'t explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement\n     */\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === \'HTML\';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn\'t want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can\'t allow any animations to take place\n        // but if a parent animation is class-based then that\'s ok\n        if (!parentAnimationDetected) {\n          var parentElementDisabled = disabledElementsLookup.get(parentNode);\n\n          if (parentElementDisabled === true && elementDisabled !== false) {\n            // disable animations if the user hasn\'t explicitly enabled animations on the\n            // current element\n            elementDisabled = true;\n            // element is disabled via parent element, no need to check anything else\n            break;\n          } else if (parentElementDisabled === false) {\n            elementDisabled = false;\n          }\n          parentAnimationDetected = details.structural;\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be a part of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        if (bodyElementDetected && rootElementDetected) {\n          // If both body and root have been found, any other checks are pointless,\n          // as no animation data should live outside the application\n          break;\n        }\n\n        if (!rootElementDetected) {\n          // If no rootElement is detected, check if the parentElement is pinned to another element\n          parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n          if (parentHost) {\n            // The pin target element becomes the next parent element\n            parentElement = parentHost;\n            continue;\n          }\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimationProvider = [\'$animateProvider\', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = \'ng-animate-ref\';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = \'$$animationRunner\';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = [\'$$jqLite\', \'$rootScope\', \'$injector\', \'$$AnimateRunner\', \'$$HashMap\', \'$$rAFScheduler\',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = [\'enter\', \'move\', \'leave\'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver\'s end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr(\'class\'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += \' \' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var prepareClassName;\n      if (isStructural) {\n        prepareClassName = \'ng-\' + event + PREPARE_CLASS_SUFFIX;\n        $$jqLite.addClass(element, prepareClassName);\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on(\'$destroy\', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can\'t animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it\'s important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = \'[\' + NG_ANIMATE_REF_ATTR + \']\';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = [\'enter\', \'move\'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? \'to\' : \'from\';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can\'t have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effectively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            \'out\': from.element, \'in\': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(\' \');\n        b = b.split(\' \');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === \'ng-\') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(\' \');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n        if (prepareClassName) {\n          $$jqLite.removeClass(element, prepareClassName);\n          prepareClassName = null;\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== \'leave\' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off(\'$destroy\', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @example\n * <example name="ngAnimateSwap-directive" module="ngAnimateSwapExample"\n *          deps="angular-animate.js"\n *          animations="true" fixBase="true">\n *   <file name="index.html">\n *     <div class="container" ng-controller="AppCtrl">\n *       <div ng-animate-swap="number" class="cell swap-animation" ng-class="colorClass(number)">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name="script.js">\n *     angular.module(\'ngAnimateSwapExample\', [\'ngAnimate\'])\n *       .controller(\'AppCtrl\', [\'$scope\', \'$interval\', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = [\'red\',\'blue\',\'green\',\'yellow\',\'orange\'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name="animations.css">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>\n */\nvar ngAnimateSwapDirective = [\'$animate\', \'$rootScope\', function($animate, $rootScope) {\n  return {\n    restrict: \'A\',\n    transclude: \'element\',\n    terminal: true,\n    priority: 600, // we use 600 here to ensure that the directive is caught before others\n    link: function(scope, $element, attrs, ctrl, $transclude) {\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs[\'for\'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n    }\n  };\n}];\n\n/* global angularAnimateModule: true,\n\n   ngAnimateSwapDirective,\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components="ngAnimate"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are "animation aware":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if="bool" class="fade">\n *    Fade me in out\n * </div>\n * <button ng-click="bool=true">Fade In!</button>\n * <button ng-click="bool=false">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what\'s going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show="bool" class="fade">\n *   Show and hide me\n * </div>\n * <button ng-click="bool=true">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class="{on:onOff}" class="highlight">\n *   Highlight this box\n * </div>\n * <button ng-click="onOff=!onOff">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class="{red: myProp}">\n *   <div ng-class="{blue: myProp}">\n *     <div class="message" ng-if="myProp"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let\'s see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat="item in items" class="slide">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let\'s use that class to define an animation that we\'ll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation(\'.slide\', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class="color" class="colorful">\n *   this box is moody\n * </div>\n * <button ng-click="color=\'red\'">Change to red</button>\n * <button ng-click="color=\'blue\'">Change to blue</button>\n * <button ng-click="color=\'green\'">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation(\'.colorful\', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if="bool" class="slide">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation(\'.slide\', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation(\'.slide\', [\'$animateCss\', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: \'enter\',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don\'t need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation(\'.slide\', [\'$animateCss\', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: \'enter\',\n *         structural: true,\n *         addClass: \'maroon-setting\',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what\'s possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let\'s say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class="view-animation">\n * </div>\n *\n * <!-- home.html -->\n * <a href="#/banner-page">\n *   <img src="./banner.jpg" class="banner" ng-animate-ref="banner">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src="./banner.jpg" class="banner" ng-animate-ref="banner">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn\'t be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module="anchoringExample"\n           name="anchoringExample"\n           id="anchoringExample"\n           deps="angular-animate.js;angular-route.js"\n           animations="true">\n    <file name="index.html">\n      <a href="#/">Home</a>\n      <hr />\n      <div class="view-container">\n        <div ng-view class="view"></div>\n      </div>\n    </file>\n    <file name="script.js">\n      angular.module(\'anchoringExample\', [\'ngAnimate\', \'ngRoute\'])\n        .config([\'$routeProvider\', function($routeProvider) {\n          $routeProvider.when(\'/\', {\n            templateUrl: \'home.html\',\n            controller: \'HomeController as home\'\n          });\n          $routeProvider.when(\'/profile/:id\', {\n            templateUrl: \'profile.html\',\n            controller: \'ProfileController as profile\'\n          });\n        }])\n        .run([\'$rootScope\', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: "Miss Beulah Roob" },\n            { id:2, title: "Trent Morissette" },\n            { id:3, title: "Miss Ava Pouros" },\n            { id:4, title: "Rod Pouros" },\n            { id:5, title: "Abdul Rice" },\n            { id:6, title: "Laurie Rutherford Sr." },\n            { id:7, title: "Nakia McLaughlin" },\n            { id:8, title: "Jordon Blanda DVM" },\n            { id:9, title: "Rhoda Hand" },\n            { id:10, title: "Alexandrea Sauer" }\n          ];\n        }])\n        .controller(\'HomeController\', [function() {\n          //empty\n        }])\n        .controller(\'ProfileController\', [\'$rootScope\', \'$routeParams\', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name="home.html">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class="record"\n         ng-href="#/profile/{{ record.id }}"\n         ng-animate-ref="{{ record.id }}"\n         ng-repeat="record in records">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name="profile.html">\n      <div class="profile record" ng-animate-ref="{{ profile.id }}">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name="animations.css">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we\'ve explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let\'s\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active="onOrOff">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive(\'greetingBox\', [\'$animate\', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe(\'active\', function(value) {\n *       value ? $animate.addClass(element, \'on\') : $animate.removeClass(element, \'on\');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what\'s\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let\'s say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller(\'HomePageController\', [\'$animate\', function($animate) {\n *   $animate.on(\'enter\', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module(\'ngAnimate\', [])\n  .directive(\'ngAnimateSwap\', ngAnimateSwapDirective)\n\n  .directive(\'ngAnimateChildren\', $$AnimateChildrenDirective)\n  .factory(\'$$rAFScheduler\', $$rAFSchedulerFactory)\n\n  .provider(\'$$animateQueue\', $$AnimateQueueProvider)\n  .provider(\'$$animation\', $$AnimationProvider)\n\n  .provider(\'$animateCss\', $AnimateCssProvider)\n  .provider(\'$$animateCssDriver\', $$AnimateCssDriverProvider)\n\n  .provider(\'$$animateJs\', $$AnimateJsProvider)\n  .provider(\'$$animateJsDriver\', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*angular-animate@1.5.0#index*/
define('angular-animate@1.5.0#index', function (require, exports, module) {
    require('./angular-animate');
    module.exports = 'ngAnimate';
});
/*angular-ui-router@0.3.1#release/angular-ui-router*/
define('angular-ui-router@0.3.1#release/angular-ui-router', function (require, exports, module) {
    (function (global) {
        if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {
            module.exports = 'ui.router';
        }
        (function (window, angular, undefined) {
            'use strict';
            var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, toJson = angular.toJson;
            function inherit(parent, extra) {
                return extend(new (extend(function () {
                }, { prototype: parent }))(), extra);
            }
            function merge(dst) {
                forEach(arguments, function (obj) {
                    if (obj !== dst) {
                        forEach(obj, function (value, key) {
                            if (!dst.hasOwnProperty(key))
                                dst[key] = value;
                        });
                    }
                });
                return dst;
            }
            function ancestors(first, second) {
                var path = [];
                for (var n in first.path) {
                    if (first.path[n] !== second.path[n])
                        break;
                    path.push(first.path[n]);
                }
                return path;
            }
            function objectKeys(object) {
                if (Object.keys) {
                    return Object.keys(object);
                }
                var result = [];
                forEach(object, function (val, key) {
                    result.push(key);
                });
                return result;
            }
            function indexOf(array, value) {
                if (Array.prototype.indexOf) {
                    return array.indexOf(value, Number(arguments[2]) || 0);
                }
                var len = array.length >>> 0, from = Number(arguments[2]) || 0;
                from = from < 0 ? Math.ceil(from) : Math.floor(from);
                if (from < 0)
                    from += len;
                for (; from < len; from++) {
                    if (from in array && array[from] === value)
                        return from;
                }
                return -1;
            }
            function inheritParams(currentParams, newParams, $current, $to) {
                var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
                for (var i in parents) {
                    if (!parents[i] || !parents[i].params)
                        continue;
                    parentParams = objectKeys(parents[i].params);
                    if (!parentParams.length)
                        continue;
                    for (var j in parentParams) {
                        if (indexOf(inheritList, parentParams[j]) >= 0)
                            continue;
                        inheritList.push(parentParams[j]);
                        inherited[parentParams[j]] = currentParams[parentParams[j]];
                    }
                }
                return extend({}, inherited, newParams);
            }
            function equalForKeys(a, b, keys) {
                if (!keys) {
                    keys = [];
                    for (var n in a)
                        keys.push(n);
                }
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    if (a[k] != b[k])
                        return false;
                }
                return true;
            }
            function filterByKeys(keys, values) {
                var filtered = {};
                forEach(keys, function (name) {
                    filtered[name] = values[name];
                });
                return filtered;
            }
            function indexBy(array, propName) {
                var result = {};
                forEach(array, function (item) {
                    result[item[propName]] = item;
                });
                return result;
            }
            function pick(obj) {
                var copy = {};
                var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
                forEach(keys, function (key) {
                    if (key in obj)
                        copy[key] = obj[key];
                });
                return copy;
            }
            function omit(obj) {
                var copy = {};
                var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
                for (var key in obj) {
                    if (indexOf(keys, key) == -1)
                        copy[key] = obj[key];
                }
                return copy;
            }
            function pluck(collection, key) {
                var result = isArray(collection) ? [] : {};
                forEach(collection, function (val, i) {
                    result[i] = isFunction(key) ? key(val) : val[key];
                });
                return result;
            }
            function filter(collection, callback) {
                var array = isArray(collection);
                var result = array ? [] : {};
                forEach(collection, function (val, i) {
                    if (callback(val, i)) {
                        result[array ? result.length : i] = val;
                    }
                });
                return result;
            }
            function map(collection, callback) {
                var result = isArray(collection) ? [] : {};
                forEach(collection, function (val, i) {
                    result[i] = callback(val, i);
                });
                return result;
            }
            angular.module('ui.router.util', ['ng']);
            angular.module('ui.router.router', ['ui.router.util']);
            angular.module('ui.router.state', [
                'ui.router.router',
                'ui.router.util'
            ]);
            angular.module('ui.router', ['ui.router.state']);
            angular.module('ui.router.compat', ['ui.router']);
            $Resolve.$inject = [
                '$q',
                '$injector'
            ];
            function $Resolve($q, $injector) {
                var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
                        $$promises: NOTHING,
                        $$values: NOTHING
                    });
                this.study = function (invocables) {
                    if (!isObject(invocables))
                        throw new Error('\'invocables\' must be an object');
                    var invocableKeys = objectKeys(invocables || {});
                    var plan = [], cycle = [], visited = {};
                    function visit(value, key) {
                        if (visited[key] === VISIT_DONE)
                            return;
                        cycle.push(key);
                        if (visited[key] === VISIT_IN_PROGRESS) {
                            cycle.splice(0, indexOf(cycle, key));
                            throw new Error('Cyclic dependency: ' + cycle.join(' -> '));
                        }
                        visited[key] = VISIT_IN_PROGRESS;
                        if (isString(value)) {
                            plan.push(key, [function () {
                                    return $injector.get(value);
                                }], NO_DEPENDENCIES);
                        } else {
                            var params = $injector.annotate(value);
                            forEach(params, function (param) {
                                if (param !== key && invocables.hasOwnProperty(param))
                                    visit(invocables[param], param);
                            });
                            plan.push(key, value, params);
                        }
                        cycle.pop();
                        visited[key] = VISIT_DONE;
                    }
                    forEach(invocables, visit);
                    invocables = cycle = visited = null;
                    function isResolve(value) {
                        return isObject(value) && value.then && value.$$promises;
                    }
                    return function (locals, parent, self) {
                        if (isResolve(locals) && self === undefined) {
                            self = parent;
                            parent = locals;
                            locals = null;
                        }
                        if (!locals)
                            locals = NO_LOCALS;
                        else if (!isObject(locals)) {
                            throw new Error('\'locals\' must be an object');
                        }
                        if (!parent)
                            parent = NO_PARENT;
                        else if (!isResolve(parent)) {
                            throw new Error('\'parent\' must be a promise returned by $resolve.resolve()');
                        }
                        var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = false;
                        function done() {
                            if (!--wait) {
                                if (!merged)
                                    merge(values, parent.$$values);
                                result.$$values = values;
                                result.$$promises = result.$$promises || true;
                                delete result.$$inheritedValues;
                                resolution.resolve(values);
                            }
                        }
                        function fail(reason) {
                            result.$$failure = reason;
                            resolution.reject(reason);
                        }
                        if (isDefined(parent.$$failure)) {
                            fail(parent.$$failure);
                            return result;
                        }
                        if (parent.$$inheritedValues) {
                            merge(values, omit(parent.$$inheritedValues, invocableKeys));
                        }
                        extend(promises, parent.$$promises);
                        if (parent.$$values) {
                            merged = merge(values, omit(parent.$$values, invocableKeys));
                            result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                            done();
                        } else {
                            if (parent.$$inheritedValues) {
                                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                            }
                            parent.then(done, fail);
                        }
                        for (var i = 0, ii = plan.length; i < ii; i += 3) {
                            if (locals.hasOwnProperty(plan[i]))
                                done();
                            else
                                invoke(plan[i], plan[i + 1], plan[i + 2]);
                        }
                        function invoke(key, invocable, params) {
                            var invocation = $q.defer(), waitParams = 0;
                            function onfailure(reason) {
                                invocation.reject(reason);
                                fail(reason);
                            }
                            forEach(params, function (dep) {
                                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                                    waitParams++;
                                    promises[dep].then(function (result) {
                                        values[dep] = result;
                                        if (!--waitParams)
                                            proceed();
                                    }, onfailure);
                                }
                            });
                            if (!waitParams)
                                proceed();
                            function proceed() {
                                if (isDefined(result.$$failure))
                                    return;
                                try {
                                    invocation.resolve($injector.invoke(invocable, self, values));
                                    invocation.promise.then(function (result) {
                                        values[key] = result;
                                        done();
                                    }, onfailure);
                                } catch (e) {
                                    onfailure(e);
                                }
                            }
                            promises[key] = invocation.promise;
                        }
                        return result;
                    };
                };
                this.resolve = function (invocables, locals, parent, self) {
                    return this.study(invocables)(locals, parent, self);
                };
            }
            angular.module('ui.router.util').service('$resolve', $Resolve);
            $TemplateFactory.$inject = [
                '$http',
                '$templateCache',
                '$injector'
            ];
            function $TemplateFactory($http, $templateCache, $injector) {
                this.fromConfig = function (config, params, locals) {
                    return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
                };
                this.fromString = function (template, params) {
                    return isFunction(template) ? template(params) : template;
                };
                this.fromUrl = function (url, params) {
                    if (isFunction(url))
                        url = url(params);
                    if (url == null)
                        return null;
                    else
                        return $http.get(url, {
                            cache: $templateCache,
                            headers: { Accept: 'text/html' }
                        }).then(function (response) {
                            return response.data;
                        });
                };
                this.fromProvider = function (provider, params, locals) {
                    return $injector.invoke(provider, null, locals || { params: params });
                };
            }
            angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
            var $$UMFP;
            function UrlMatcher(pattern, config, parentMatcher) {
                config = extend({ params: {} }, isObject(config) ? config : {});
                var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = '^', last = 0, m, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
                function addParameter(id, type, config, location) {
                    paramNames.push(id);
                    if (parentParams[id])
                        return parentParams[id];
                    if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id))
                        throw new Error('Invalid parameter name \'' + id + '\' in pattern \'' + pattern + '\'');
                    if (params[id])
                        throw new Error('Duplicate parameter name \'' + id + '\' in pattern \'' + pattern + '\'');
                    params[id] = new $$UMFP.Param(id, type, config, location);
                    return params[id];
                }
                function quoteRegExp(string, pattern, squash, optional) {
                    var surroundPattern = [
                            '',
                            ''
                        ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, '\\$&');
                    if (!pattern)
                        return result;
                    switch (squash) {
                    case false:
                        surroundPattern = [
                            '(',
                            ')' + (optional ? '?' : '')
                        ];
                        break;
                    case true:
                        result = result.replace(/\/$/, '');
                        surroundPattern = [
                            '(?:/(',
                            ')|/)?'
                        ];
                        break;
                    default:
                        surroundPattern = [
                            '(' + squash + '|',
                            ')?'
                        ];
                        break;
                    }
                    return result + surroundPattern[0] + pattern + surroundPattern[1];
                }
                this.source = pattern;
                function matchDetails(m, isSearch) {
                    var id, regexp, segment, type, cfg, arrayMode;
                    id = m[2] || m[3];
                    cfg = config.params[id];
                    segment = pattern.substring(last, m.index);
                    regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
                    if (regexp) {
                        type = $$UMFP.type(regexp) || inherit($$UMFP.type('string'), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });
                    }
                    return {
                        id: id,
                        regexp: regexp,
                        segment: segment,
                        type: type,
                        cfg: cfg
                    };
                }
                var p, param, segment;
                while (m = placeholder.exec(pattern)) {
                    p = matchDetails(m, false);
                    if (p.segment.indexOf('?') >= 0)
                        break;
                    param = addParameter(p.id, p.type, p.cfg, 'path');
                    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
                    segments.push(p.segment);
                    last = placeholder.lastIndex;
                }
                segment = pattern.substring(last);
                var i = segment.indexOf('?');
                if (i >= 0) {
                    var search = this.sourceSearch = segment.substring(i);
                    segment = segment.substring(0, i);
                    this.sourcePath = pattern.substring(0, last + i);
                    if (search.length > 0) {
                        last = 0;
                        while (m = searchPlaceholder.exec(search)) {
                            p = matchDetails(m, true);
                            param = addParameter(p.id, p.type, p.cfg, 'search');
                            last = placeholder.lastIndex;
                        }
                    }
                } else {
                    this.sourcePath = pattern;
                    this.sourceSearch = '';
                }
                compiled += quoteRegExp(segment) + (config.strict === false ? '/?' : '') + '$';
                segments.push(segment);
                this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
                this.prefix = segments[0];
                this.$$paramNames = paramNames;
            }
            UrlMatcher.prototype.concat = function (pattern, config) {
                var defaultConfig = {
                    caseInsensitive: $$UMFP.caseInsensitive(),
                    strict: $$UMFP.strictMode(),
                    squash: $$UMFP.defaultSquashPolicy()
                };
                return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
            };
            UrlMatcher.prototype.toString = function () {
                return this.source;
            };
            UrlMatcher.prototype.exec = function (path, searchParams) {
                var m = this.regexp.exec(path);
                if (!m)
                    return null;
                searchParams = searchParams || {};
                var paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {}, i, j, cfg, paramName;
                if (nPath !== m.length - 1)
                    throw new Error('Unbalanced capture group in route \'' + this.source + '\'');
                function decodePathArray(string) {
                    function reverseString(str) {
                        return str.split('').reverse().join('');
                    }
                    function unquoteDashes(str) {
                        return str.replace(/\\-/g, '-');
                    }
                    var split = reverseString(string).split(/-(?!\\)/);
                    var allReversed = map(split, reverseString);
                    return map(allReversed, unquoteDashes).reverse();
                }
                var param, paramVal;
                for (i = 0; i < nPath; i++) {
                    paramName = paramNames[i];
                    param = this.params[paramName];
                    paramVal = m[i + 1];
                    for (j = 0; j < param.replace.length; j++) {
                        if (param.replace[j].from === paramVal)
                            paramVal = param.replace[j].to;
                    }
                    if (paramVal && param.array === true)
                        paramVal = decodePathArray(paramVal);
                    if (isDefined(paramVal))
                        paramVal = param.type.decode(paramVal);
                    values[paramName] = param.value(paramVal);
                }
                for (; i < nTotal; i++) {
                    paramName = paramNames[i];
                    values[paramName] = this.params[paramName].value(searchParams[paramName]);
                    param = this.params[paramName];
                    paramVal = searchParams[paramName];
                    for (j = 0; j < param.replace.length; j++) {
                        if (param.replace[j].from === paramVal)
                            paramVal = param.replace[j].to;
                    }
                    if (isDefined(paramVal))
                        paramVal = param.type.decode(paramVal);
                    values[paramName] = param.value(paramVal);
                }
                return values;
            };
            UrlMatcher.prototype.parameters = function (param) {
                if (!isDefined(param))
                    return this.$$paramNames;
                return this.params[param] || null;
            };
            UrlMatcher.prototype.validates = function (params) {
                return this.params.$$validates(params);
            };
            UrlMatcher.prototype.format = function (values) {
                values = values || {};
                var segments = this.segments, params = this.parameters(), paramset = this.params;
                if (!this.validates(values))
                    return null;
                var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
                function encodeDashes(str) {
                    return encodeURIComponent(str).replace(/-/g, function (c) {
                        return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
                    });
                }
                for (i = 0; i < nTotal; i++) {
                    var isPathParam = i < nPath;
                    var name = params[i], param = paramset[name], value = param.value(values[name]);
                    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
                    var squash = isDefaultValue ? param.squash : false;
                    var encoded = param.type.encode(value);
                    if (isPathParam) {
                        var nextSegment = segments[i + 1];
                        var isFinalPathParam = i + 1 === nPath;
                        if (squash === false) {
                            if (encoded != null) {
                                if (isArray(encoded)) {
                                    result += map(encoded, encodeDashes).join('-');
                                } else {
                                    result += encodeURIComponent(encoded);
                                }
                            }
                            result += nextSegment;
                        } else if (squash === true) {
                            var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                            result += nextSegment.match(capture)[1];
                        } else if (isString(squash)) {
                            result += squash + nextSegment;
                        }
                        if (isFinalPathParam && param.squash === true && result.slice(-1) === '/')
                            result = result.slice(0, -1);
                    } else {
                        if (encoded == null || isDefaultValue && squash !== false)
                            continue;
                        if (!isArray(encoded))
                            encoded = [encoded];
                        if (encoded.length === 0)
                            continue;
                        encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
                        result += (search ? '&' : '?') + (name + '=' + encoded);
                        search = true;
                    }
                }
                return result;
            };
            function Type(config) {
                extend(this, config);
            }
            Type.prototype.is = function (val, key) {
                return true;
            };
            Type.prototype.encode = function (val, key) {
                return val;
            };
            Type.prototype.decode = function (val, key) {
                return val;
            };
            Type.prototype.equals = function (a, b) {
                return a == b;
            };
            Type.prototype.$subPattern = function () {
                var sub = this.pattern.toString();
                return sub.substr(1, sub.length - 2);
            };
            Type.prototype.pattern = /.*/;
            Type.prototype.toString = function () {
                return '{Type:' + this.name + '}';
            };
            Type.prototype.$normalize = function (val) {
                return this.is(val) ? val : this.decode(val);
            };
            Type.prototype.$asArray = function (mode, isSearch) {
                if (!mode)
                    return this;
                if (mode === 'auto' && !isSearch)
                    throw new Error('\'auto\' array mode is for query parameters only');
                function ArrayType(type, mode) {
                    function bindTo(type, callbackName) {
                        return function () {
                            return type[callbackName].apply(type, arguments);
                        };
                    }
                    function arrayWrap(val) {
                        return isArray(val) ? val : isDefined(val) ? [val] : [];
                    }
                    function arrayUnwrap(val) {
                        switch (val.length) {
                        case 0:
                            return undefined;
                        case 1:
                            return mode === 'auto' ? val[0] : val;
                        default:
                            return val;
                        }
                    }
                    function falsey(val) {
                        return !val;
                    }
                    function arrayHandler(callback, allTruthyMode) {
                        return function handleArray(val) {
                            if (isArray(val) && val.length === 0)
                                return val;
                            val = arrayWrap(val);
                            var result = map(val, callback);
                            if (allTruthyMode === true)
                                return filter(result, falsey).length === 0;
                            return arrayUnwrap(result);
                        };
                    }
                    function arrayEqualsHandler(callback) {
                        return function handleArray(val1, val2) {
                            var left = arrayWrap(val1), right = arrayWrap(val2);
                            if (left.length !== right.length)
                                return false;
                            for (var i = 0; i < left.length; i++) {
                                if (!callback(left[i], right[i]))
                                    return false;
                            }
                            return true;
                        };
                    }
                    this.encode = arrayHandler(bindTo(type, 'encode'));
                    this.decode = arrayHandler(bindTo(type, 'decode'));
                    this.is = arrayHandler(bindTo(type, 'is'), true);
                    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
                    this.pattern = type.pattern;
                    this.$normalize = arrayHandler(bindTo(type, '$normalize'));
                    this.name = type.name;
                    this.$arrayMode = mode;
                }
                return new ArrayType(this, mode);
            };
            function $UrlMatcherFactory() {
                $$UMFP = this;
                var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;
                function valToString(val) {
                    return val != null ? val.toString().replace(/~/g, '~~').replace(/\//g, '~2F') : val;
                }
                function valFromString(val) {
                    return val != null ? val.toString().replace(/~2F/g, '/').replace(/~~/g, '~') : val;
                }
                var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
                        'string': {
                            encode: valToString,
                            decode: valFromString,
                            is: function (val) {
                                return val == null || !isDefined(val) || typeof val === 'string';
                            },
                            pattern: /[^\/]*/
                        },
                        'int': {
                            encode: valToString,
                            decode: function (val) {
                                return parseInt(val, 10);
                            },
                            is: function (val) {
                                return isDefined(val) && this.decode(val.toString()) === val;
                            },
                            pattern: /\d+/
                        },
                        'bool': {
                            encode: function (val) {
                                return val ? 1 : 0;
                            },
                            decode: function (val) {
                                return parseInt(val, 10) !== 0;
                            },
                            is: function (val) {
                                return val === true || val === false;
                            },
                            pattern: /0|1/
                        },
                        'date': {
                            encode: function (val) {
                                if (!this.is(val))
                                    return undefined;
                                return [
                                    val.getFullYear(),
                                    ('0' + (val.getMonth() + 1)).slice(-2),
                                    ('0' + val.getDate()).slice(-2)
                                ].join('-');
                            },
                            decode: function (val) {
                                if (this.is(val))
                                    return val;
                                var match = this.capture.exec(val);
                                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                            },
                            is: function (val) {
                                return val instanceof Date && !isNaN(val.valueOf());
                            },
                            equals: function (a, b) {
                                return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                            },
                            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
                        },
                        'json': {
                            encode: angular.toJson,
                            decode: angular.fromJson,
                            is: angular.isObject,
                            equals: angular.equals,
                            pattern: /[^\/]*/
                        },
                        'any': {
                            encode: angular.identity,
                            decode: angular.identity,
                            equals: angular.equals,
                            pattern: /.*/
                        }
                    };
                function getDefaultConfig() {
                    return {
                        strict: isStrictMode,
                        caseInsensitive: isCaseInsensitive
                    };
                }
                function isInjectable(value) {
                    return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
                }
                $UrlMatcherFactory.$$getDefaultValue = function (config) {
                    if (!isInjectable(config.value))
                        return config.value;
                    if (!injector)
                        throw new Error('Injectable functions cannot be called at configuration time');
                    return injector.invoke(config.value);
                };
                this.caseInsensitive = function (value) {
                    if (isDefined(value))
                        isCaseInsensitive = value;
                    return isCaseInsensitive;
                };
                this.strictMode = function (value) {
                    if (isDefined(value))
                        isStrictMode = value;
                    return isStrictMode;
                };
                this.defaultSquashPolicy = function (value) {
                    if (!isDefined(value))
                        return defaultSquashPolicy;
                    if (value !== true && value !== false && !isString(value))
                        throw new Error('Invalid squash policy: ' + value + '. Valid policies: false, true, arbitrary-string');
                    defaultSquashPolicy = value;
                    return value;
                };
                this.compile = function (pattern, config) {
                    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
                };
                this.isMatcher = function (o) {
                    if (!isObject(o))
                        return false;
                    var result = true;
                    forEach(UrlMatcher.prototype, function (val, name) {
                        if (isFunction(val)) {
                            result = result && (isDefined(o[name]) && isFunction(o[name]));
                        }
                    });
                    return result;
                };
                this.type = function (name, definition, definitionFn) {
                    if (!isDefined(definition))
                        return $types[name];
                    if ($types.hasOwnProperty(name))
                        throw new Error('A type named \'' + name + '\' has already been defined.');
                    $types[name] = new Type(extend({ name: name }, definition));
                    if (definitionFn) {
                        typeQueue.push({
                            name: name,
                            def: definitionFn
                        });
                        if (!enqueue)
                            flushTypeQueue();
                    }
                    return this;
                };
                function flushTypeQueue() {
                    while (typeQueue.length) {
                        var type = typeQueue.shift();
                        if (type.pattern)
                            throw new Error('You cannot override a type\'s .pattern at runtime.');
                        angular.extend($types[type.name], injector.invoke(type.def));
                    }
                }
                forEach(defaultTypes, function (type, name) {
                    $types[name] = new Type(extend({ name: name }, type));
                });
                $types = inherit($types, {});
                this.$get = [
                    '$injector',
                    function ($injector) {
                        injector = $injector;
                        enqueue = false;
                        flushTypeQueue();
                        forEach(defaultTypes, function (type, name) {
                            if (!$types[name])
                                $types[name] = new Type(type);
                        });
                        return this;
                    }
                ];
                this.Param = function Param(id, type, config, location) {
                    var self = this;
                    config = unwrapShorthand(config);
                    type = getType(config, type, location);
                    var arrayMode = getArrayMode();
                    type = arrayMode ? type.$asArray(arrayMode, location === 'search') : type;
                    if (type.name === 'string' && !arrayMode && location === 'path' && config.value === undefined)
                        config.value = '';
                    var isOptional = config.value !== undefined;
                    var squash = getSquashPolicy(config, isOptional);
                    var replace = getReplace(config, arrayMode, isOptional, squash);
                    function unwrapShorthand(config) {
                        var keys = isObject(config) ? objectKeys(config) : [];
                        var isShorthand = indexOf(keys, 'value') === -1 && indexOf(keys, 'type') === -1 && indexOf(keys, 'squash') === -1 && indexOf(keys, 'array') === -1;
                        if (isShorthand)
                            config = { value: config };
                        config.$$fn = isInjectable(config.value) ? config.value : function () {
                            return config.value;
                        };
                        return config;
                    }
                    function getType(config, urlType, location) {
                        if (config.type && urlType)
                            throw new Error('Param \'' + id + '\' has two type configurations.');
                        if (urlType)
                            return urlType;
                        if (!config.type)
                            return location === 'config' ? $types.any : $types.string;
                        if (angular.isString(config.type))
                            return $types[config.type];
                        if (config.type instanceof Type)
                            return config.type;
                        return new Type(config.type);
                    }
                    function getArrayMode() {
                        var arrayDefaults = { array: location === 'search' ? 'auto' : false };
                        var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
                        return extend(arrayDefaults, arrayParamNomenclature, config).array;
                    }
                    function getSquashPolicy(config, isOptional) {
                        var squash = config.squash;
                        if (!isOptional || squash === false)
                            return false;
                        if (!isDefined(squash) || squash == null)
                            return defaultSquashPolicy;
                        if (squash === true || isString(squash))
                            return squash;
                        throw new Error('Invalid squash policy: \'' + squash + '\'. Valid policies: false, true, or arbitrary string');
                    }
                    function getReplace(config, arrayMode, isOptional, squash) {
                        var replace, configuredKeys, defaultPolicy = [
                                {
                                    from: '',
                                    to: isOptional || arrayMode ? undefined : ''
                                },
                                {
                                    from: null,
                                    to: isOptional || arrayMode ? undefined : ''
                                }
                            ];
                        replace = isArray(config.replace) ? config.replace : [];
                        if (isString(squash))
                            replace.push({
                                from: squash,
                                to: undefined
                            });
                        configuredKeys = map(replace, function (item) {
                            return item.from;
                        });
                        return filter(defaultPolicy, function (item) {
                            return indexOf(configuredKeys, item.from) === -1;
                        }).concat(replace);
                    }
                    function $$getDefaultValue() {
                        if (!injector)
                            throw new Error('Injectable functions cannot be called at configuration time');
                        var defaultValue = injector.invoke(config.$$fn);
                        if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
                            throw new Error('Default value (' + defaultValue + ') for parameter \'' + self.id + '\' is not an instance of Type (' + self.type.name + ')');
                        return defaultValue;
                    }
                    function $value(value) {
                        function hasReplaceVal(val) {
                            return function (obj) {
                                return obj.from === val;
                            };
                        }
                        function $replace(value) {
                            var replacement = map(filter(self.replace, hasReplaceVal(value)), function (obj) {
                                return obj.to;
                            });
                            return replacement.length ? replacement[0] : value;
                        }
                        value = $replace(value);
                        return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
                    }
                    function toString() {
                        return '{Param:' + id + ' ' + type + ' squash: \'' + squash + '\' optional: ' + isOptional + '}';
                    }
                    extend(this, {
                        id: id,
                        type: type,
                        location: location,
                        array: arrayMode,
                        squash: squash,
                        replace: replace,
                        isOptional: isOptional,
                        value: $value,
                        dynamic: undefined,
                        config: config,
                        toString: toString
                    });
                };
                function ParamSet(params) {
                    extend(this, params || {});
                }
                ParamSet.prototype = {
                    $$new: function () {
                        return inherit(this, extend(new ParamSet(), { $$parent: this }));
                    },
                    $$keys: function () {
                        var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype);
                        while (parent) {
                            chain.push(parent);
                            parent = parent.$$parent;
                        }
                        chain.reverse();
                        forEach(chain, function (paramset) {
                            forEach(objectKeys(paramset), function (key) {
                                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                                    keys.push(key);
                            });
                        });
                        return keys;
                    },
                    $$values: function (paramValues) {
                        var values = {}, self = this;
                        forEach(self.$$keys(), function (key) {
                            values[key] = self[key].value(paramValues && paramValues[key]);
                        });
                        return values;
                    },
                    $$equals: function (paramValues1, paramValues2) {
                        var equal = true, self = this;
                        forEach(self.$$keys(), function (key) {
                            var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                            if (!self[key].type.equals(left, right))
                                equal = false;
                        });
                        return equal;
                    },
                    $$validates: function $$validate(paramValues) {
                        var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
                        for (i = 0; i < keys.length; i++) {
                            param = this[keys[i]];
                            rawVal = paramValues[keys[i]];
                            if ((rawVal === undefined || rawVal === null) && param.isOptional)
                                break;
                            normalized = param.type.$normalize(rawVal);
                            if (!param.type.is(normalized))
                                return false;
                            encoded = param.type.encode(normalized);
                            if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                                return false;
                        }
                        return true;
                    },
                    $$parent: undefined
                };
                this.ParamSet = ParamSet;
            }
            angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
            angular.module('ui.router.util').run([
                '$urlMatcherFactory',
                function ($urlMatcherFactory) {
                }
            ]);
            $UrlRouterProvider.$inject = [
                '$locationProvider',
                '$urlMatcherFactoryProvider'
            ];
            function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
                var rules = [], otherwise = null, interceptDeferred = false, listener;
                function regExpPrefix(re) {
                    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
                    return prefix != null ? prefix[1].replace(/\\(.)/g, '$1') : '';
                }
                function interpolate(pattern, match) {
                    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
                        return match[what === '$' ? 0 : Number(what)];
                    });
                }
                this.rule = function (rule) {
                    if (!isFunction(rule))
                        throw new Error('\'rule\' must be a function');
                    rules.push(rule);
                    return this;
                };
                this.otherwise = function (rule) {
                    if (isString(rule)) {
                        var redirect = rule;
                        rule = function () {
                            return redirect;
                        };
                    } else if (!isFunction(rule))
                        throw new Error('\'rule\' must be a function');
                    otherwise = rule;
                    return this;
                };
                function handleIfMatch($injector, handler, match) {
                    if (!match)
                        return false;
                    var result = $injector.invoke(handler, handler, { $match: match });
                    return isDefined(result) ? result : true;
                }
                this.when = function (what, handler) {
                    var redirect, handlerIsString = isString(handler);
                    if (isString(what))
                        what = $urlMatcherFactory.compile(what);
                    if (!handlerIsString && !isFunction(handler) && !isArray(handler))
                        throw new Error('invalid \'handler\' in when()');
                    var strategies = {
                        matcher: function (what, handler) {
                            if (handlerIsString) {
                                redirect = $urlMatcherFactory.compile(handler);
                                handler = [
                                    '$match',
                                    function ($match) {
                                        return redirect.format($match);
                                    }
                                ];
                            }
                            return extend(function ($injector, $location) {
                                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                            }, { prefix: isString(what.prefix) ? what.prefix : '' });
                        },
                        regex: function (what, handler) {
                            if (what.global || what.sticky)
                                throw new Error('when() RegExp must not be global or sticky');
                            if (handlerIsString) {
                                redirect = handler;
                                handler = [
                                    '$match',
                                    function ($match) {
                                        return interpolate(redirect, $match);
                                    }
                                ];
                            }
                            return extend(function ($injector, $location) {
                                return handleIfMatch($injector, handler, what.exec($location.path()));
                            }, { prefix: regExpPrefix(what) });
                        }
                    };
                    var check = {
                        matcher: $urlMatcherFactory.isMatcher(what),
                        regex: what instanceof RegExp
                    };
                    for (var n in check) {
                        if (check[n])
                            return this.rule(strategies[n](what, handler));
                    }
                    throw new Error('invalid \'what\' in when()');
                };
                this.deferIntercept = function (defer) {
                    if (defer === undefined)
                        defer = true;
                    interceptDeferred = defer;
                };
                this.$get = $get;
                $get.$inject = [
                    '$location',
                    '$rootScope',
                    '$injector',
                    '$browser',
                    '$sniffer'
                ];
                function $get($location, $rootScope, $injector, $browser, $sniffer) {
                    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;
                    function appendBasePath(url, isHtml5, absolute) {
                        if (baseHref === '/')
                            return url;
                        if (isHtml5)
                            return baseHref.slice(0, -1) + url;
                        if (absolute)
                            return baseHref.slice(1) + url;
                        return url;
                    }
                    function update(evt) {
                        if (evt && evt.defaultPrevented)
                            return;
                        var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                        lastPushedUrl = undefined;
                        function check(rule) {
                            var handled = rule($injector, $location);
                            if (!handled)
                                return false;
                            if (isString(handled))
                                $location.replace().url(handled);
                            return true;
                        }
                        var n = rules.length, i;
                        for (i = 0; i < n; i++) {
                            if (check(rules[i]))
                                return;
                        }
                        if (otherwise)
                            check(otherwise);
                    }
                    function listen() {
                        listener = listener || $rootScope.$on('$locationChangeSuccess', update);
                        return listener;
                    }
                    if (!interceptDeferred)
                        listen();
                    return {
                        sync: function () {
                            update();
                        },
                        listen: function () {
                            return listen();
                        },
                        update: function (read) {
                            if (read) {
                                location = $location.url();
                                return;
                            }
                            if ($location.url() === location)
                                return;
                            $location.url(location);
                            $location.replace();
                        },
                        push: function (urlMatcher, params, options) {
                            var url = urlMatcher.format(params || {});
                            if (url !== null && params && params['#']) {
                                url += '#' + params['#'];
                            }
                            $location.url(url);
                            lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                            if (options && options.replace)
                                $location.replace();
                        },
                        href: function (urlMatcher, params, options) {
                            if (!urlMatcher.validates(params))
                                return null;
                            var isHtml5 = $locationProvider.html5Mode();
                            if (angular.isObject(isHtml5)) {
                                isHtml5 = isHtml5.enabled;
                            }
                            isHtml5 = isHtml5 && $sniffer.history;
                            var url = urlMatcher.format(params);
                            options = options || {};
                            if (!isHtml5 && url !== null) {
                                url = '#' + $locationProvider.hashPrefix() + url;
                            }
                            if (url !== null && params && params['#']) {
                                url += '#' + params['#'];
                            }
                            url = appendBasePath(url, isHtml5, options.absolute);
                            if (!options.absolute || !url) {
                                return url;
                            }
                            var slash = !isHtml5 && url ? '/' : '', port = $location.port();
                            port = port === 80 || port === 443 ? '' : ':' + port;
                            return [
                                $location.protocol(),
                                '://',
                                $location.host(),
                                port,
                                slash,
                                url
                            ].join('');
                        }
                    };
                }
            }
            angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
            $StateProvider.$inject = [
                '$urlRouterProvider',
                '$urlMatcherFactoryProvider'
            ];
            function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
                var root, states = {}, $state, queue = {}, abstractKey = 'abstract';
                var stateBuilder = {
                    parent: function (state) {
                        if (isDefined(state.parent) && state.parent)
                            return findState(state.parent);
                        var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                        return compositeName ? findState(compositeName[1]) : root;
                    },
                    data: function (state) {
                        if (state.parent && state.parent.data) {
                            state.data = state.self.data = inherit(state.parent.data, state.data);
                        }
                        return state.data;
                    },
                    url: function (state) {
                        var url = state.url, config = { params: state.params || {} };
                        if (isString(url)) {
                            if (url.charAt(0) == '^')
                                return $urlMatcherFactory.compile(url.substring(1), config);
                            return (state.parent.navigable || root).url.concat(url, config);
                        }
                        if (!url || $urlMatcherFactory.isMatcher(url))
                            return url;
                        throw new Error('Invalid url \'' + url + '\' in state \'' + state + '\'');
                    },
                    navigable: function (state) {
                        return state.url ? state : state.parent ? state.parent.navigable : null;
                    },
                    ownParams: function (state) {
                        var params = state.url && state.url.params || new $$UMFP.ParamSet();
                        forEach(state.params || {}, function (config, id) {
                            if (!params[id])
                                params[id] = new $$UMFP.Param(id, null, config, 'config');
                        });
                        return params;
                    },
                    params: function (state) {
                        var ownParams = pick(state.ownParams, state.ownParams.$$keys());
                        return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
                    },
                    views: function (state) {
                        var views = {};
                        forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
                            if (name.indexOf('@') < 0)
                                name += '@' + state.parent.name;
                            view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';
                            views[name] = view;
                        });
                        return views;
                    },
                    path: function (state) {
                        return state.parent ? state.parent.path.concat(state) : [];
                    },
                    includes: function (state) {
                        var includes = state.parent ? extend({}, state.parent.includes) : {};
                        includes[state.name] = true;
                        return includes;
                    },
                    $delegates: {}
                };
                function isRelative(stateName) {
                    return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;
                }
                function findState(stateOrName, base) {
                    if (!stateOrName)
                        return undefined;
                    var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
                    if (path) {
                        if (!base)
                            throw new Error('No reference point given for path \'' + name + '\'');
                        base = findState(base);
                        var rel = name.split('.'), i = 0, pathLength = rel.length, current = base;
                        for (; i < pathLength; i++) {
                            if (rel[i] === '' && i === 0) {
                                current = base;
                                continue;
                            }
                            if (rel[i] === '^') {
                                if (!current.parent)
                                    throw new Error('Path \'' + name + '\' not valid for state \'' + base.name + '\'');
                                current = current.parent;
                                continue;
                            }
                            break;
                        }
                        rel = rel.slice(i).join('.');
                        name = current.name + (current.name && rel ? '.' : '') + rel;
                    }
                    var state = states[name];
                    if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                        return state;
                    }
                    return undefined;
                }
                function queueState(parentName, state) {
                    if (!queue[parentName]) {
                        queue[parentName] = [];
                    }
                    queue[parentName].push(state);
                }
                function flushQueuedChildren(parentName) {
                    var queued = queue[parentName] || [];
                    while (queued.length) {
                        registerState(queued.shift());
                    }
                }
                function registerState(state) {
                    state = inherit(state, {
                        self: state,
                        resolve: state.resolve || {},
                        toString: function () {
                            return this.name;
                        }
                    });
                    var name = state.name;
                    if (!isString(name) || name.indexOf('@') >= 0)
                        throw new Error('State must have a valid name');
                    if (states.hasOwnProperty(name))
                        throw new Error('State \'' + name + '\' is already defined');
                    var parentName = name.indexOf('.') !== -1 ? name.substring(0, name.lastIndexOf('.')) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : '';
                    if (parentName && !states[parentName]) {
                        return queueState(parentName, state.self);
                    }
                    for (var key in stateBuilder) {
                        if (isFunction(stateBuilder[key]))
                            state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
                    }
                    states[name] = state;
                    if (!state[abstractKey] && state.url) {
                        $urlRouterProvider.when(state.url, [
                            '$match',
                            '$stateParams',
                            function ($match, $stateParams) {
                                if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                                    $state.transitionTo(state, $match, {
                                        inherit: true,
                                        location: false
                                    });
                                }
                            }
                        ]);
                    }
                    flushQueuedChildren(name);
                    return state;
                }
                function isGlob(text) {
                    return text.indexOf('*') > -1;
                }
                function doesStateMatchGlob(glob) {
                    var globSegments = glob.split('.'), segments = $state.$current.name.split('.');
                    for (var i = 0, l = globSegments.length; i < l; i++) {
                        if (globSegments[i] === '*') {
                            segments[i] = '*';
                        }
                    }
                    if (globSegments[0] === '**') {
                        segments = segments.slice(indexOf(segments, globSegments[1]));
                        segments.unshift('**');
                    }
                    if (globSegments[globSegments.length - 1] === '**') {
                        segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                        segments.push('**');
                    }
                    if (globSegments.length != segments.length) {
                        return false;
                    }
                    return segments.join('') === globSegments.join('');
                }
                root = registerState({
                    name: '',
                    url: '^',
                    views: null,
                    'abstract': true
                });
                root.navigable = null;
                this.decorator = decorator;
                function decorator(name, func) {
                    if (isString(name) && !isDefined(func)) {
                        return stateBuilder[name];
                    }
                    if (!isFunction(func) || !isString(name)) {
                        return this;
                    }
                    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                        stateBuilder.$delegates[name] = stateBuilder[name];
                    }
                    stateBuilder[name] = func;
                    return this;
                }
                this.state = state;
                function state(name, definition) {
                    if (isObject(name))
                        definition = name;
                    else
                        definition.name = name;
                    registerState(definition);
                    return this;
                }
                this.$get = $get;
                $get.$inject = [
                    '$rootScope',
                    '$q',
                    '$view',
                    '$injector',
                    '$resolve',
                    '$stateParams',
                    '$urlRouter',
                    '$location',
                    '$urlMatcherFactory'
                ];
                function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
                    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
                    var TransitionPrevented = $q.reject(new Error('transition prevented'));
                    var TransitionAborted = $q.reject(new Error('transition aborted'));
                    var TransitionFailed = $q.reject(new Error('transition failed'));
                    function handleRedirect(redirect, state, params, options) {
                        var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
                        if (evt.defaultPrevented) {
                            $urlRouter.update();
                            return TransitionAborted;
                        }
                        if (!evt.retry) {
                            return null;
                        }
                        if (options.$retry) {
                            $urlRouter.update();
                            return TransitionFailed;
                        }
                        var retryTransition = $state.transition = $q.when(evt.retry);
                        retryTransition.then(function () {
                            if (retryTransition !== $state.transition)
                                return TransitionSuperseded;
                            redirect.options.$retry = true;
                            return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                        }, function () {
                            return TransitionAborted;
                        });
                        $urlRouter.update();
                        return retryTransition;
                    }
                    root.locals = {
                        resolve: null,
                        globals: { $stateParams: {} }
                    };
                    $state = {
                        params: {},
                        current: root.self,
                        $current: root,
                        transition: null
                    };
                    $state.reload = function reload(state) {
                        return $state.transitionTo($state.current, $stateParams, {
                            reload: state || true,
                            inherit: false,
                            notify: true
                        });
                    };
                    $state.go = function go(to, params, options) {
                        return $state.transitionTo(to, params, extend({
                            inherit: true,
                            relative: $state.$current
                        }, options));
                    };
                    $state.transitionTo = function transitionTo(to, toParams, options) {
                        toParams = toParams || {};
                        options = extend({
                            location: true,
                            inherit: false,
                            relative: null,
                            notify: true,
                            reload: false,
                            $retry: false
                        }, options || {});
                        var from = $state.$current, fromParams = $state.params, fromPath = from.path;
                        var evt, toState = findState(to, options.relative);
                        var hash = toParams['#'];
                        if (!isDefined(toState)) {
                            var redirect = {
                                to: to,
                                toParams: toParams,
                                options: options
                            };
                            var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                            if (redirectResult) {
                                return redirectResult;
                            }
                            to = redirect.to;
                            toParams = redirect.toParams;
                            options = redirect.options;
                            toState = findState(to, options.relative);
                            if (!isDefined(toState)) {
                                if (!options.relative)
                                    throw new Error('No such state \'' + to + '\'');
                                throw new Error('Could not resolve \'' + to + '\' from state \'' + options.relative + '\'');
                            }
                        }
                        if (toState[abstractKey])
                            throw new Error('Cannot transition to abstract state \'' + to + '\'');
                        if (options.inherit)
                            toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                        if (!toState.params.$$validates(toParams))
                            return TransitionFailed;
                        toParams = toState.params.$$values(toParams);
                        to = toState;
                        var toPath = to.path;
                        var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                        if (!options.reload) {
                            while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                                locals = toLocals[keep] = state.locals;
                                keep++;
                                state = toPath[keep];
                            }
                        } else if (isString(options.reload) || isObject(options.reload)) {
                            if (isObject(options.reload) && !options.reload.name) {
                                throw new Error('Invalid reload state object');
                            }
                            var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
                            if (options.reload && !reloadState) {
                                throw new Error('No such reload state \'' + (isString(options.reload) ? options.reload : options.reload.name) + '\'');
                            }
                            while (state && state === fromPath[keep] && state !== reloadState) {
                                locals = toLocals[keep] = state.locals;
                                keep++;
                                state = toPath[keep];
                            }
                        }
                        if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
                            if (hash)
                                toParams['#'] = hash;
                            $state.params = toParams;
                            copy($state.params, $stateParams);
                            copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
                            if (options.location && to.navigable && to.navigable.url) {
                                $urlRouter.push(to.navigable.url, toParams, {
                                    $$avoidResync: true,
                                    replace: options.location === 'replace'
                                });
                                $urlRouter.update(true);
                            }
                            $state.transition = null;
                            return $q.when($state.current);
                        }
                        toParams = filterByKeys(to.params.$$keys(), toParams || {});
                        if (hash)
                            toParams['#'] = hash;
                        if (options.notify) {
                            if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
                                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                                if ($state.transition == null)
                                    $urlRouter.update();
                                return TransitionPrevented;
                            }
                        }
                        var resolved = $q.when(locals);
                        for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                            locals = toLocals[l] = inherit(locals);
                            resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                        }
                        var transition = $state.transition = resolved.then(function () {
                            var l, entering, exiting;
                            if ($state.transition !== transition)
                                return TransitionSuperseded;
                            for (l = fromPath.length - 1; l >= keep; l--) {
                                exiting = fromPath[l];
                                if (exiting.self.onExit) {
                                    $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                                }
                                exiting.locals = null;
                            }
                            for (l = keep; l < toPath.length; l++) {
                                entering = toPath[l];
                                entering.locals = toLocals[l];
                                if (entering.self.onEnter) {
                                    $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                                }
                            }
                            if ($state.transition !== transition)
                                return TransitionSuperseded;
                            $state.$current = to;
                            $state.current = to.self;
                            $state.params = toParams;
                            copy($state.params, $stateParams);
                            $state.transition = null;
                            if (options.location && to.navigable) {
                                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                                    $$avoidResync: true,
                                    replace: options.location === 'replace'
                                });
                            }
                            if (options.notify) {
                                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
                            }
                            $urlRouter.update(true);
                            return $state.current;
                        }).then(null, function (error) {
                            if ($state.transition !== transition)
                                return TransitionSuperseded;
                            $state.transition = null;
                            evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
                            if (!evt.defaultPrevented) {
                                $urlRouter.update();
                            }
                            return $q.reject(error);
                        });
                        return transition;
                    };
                    $state.is = function is(stateOrName, params, options) {
                        options = extend({ relative: $state.$current }, options || {});
                        var state = findState(stateOrName, options.relative);
                        if (!isDefined(state)) {
                            return undefined;
                        }
                        if ($state.$current !== state) {
                            return false;
                        }
                        return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
                    };
                    $state.includes = function includes(stateOrName, params, options) {
                        options = extend({ relative: $state.$current }, options || {});
                        if (isString(stateOrName) && isGlob(stateOrName)) {
                            if (!doesStateMatchGlob(stateOrName)) {
                                return false;
                            }
                            stateOrName = $state.$current.name;
                        }
                        var state = findState(stateOrName, options.relative);
                        if (!isDefined(state)) {
                            return undefined;
                        }
                        if (!isDefined($state.$current.includes[state.name])) {
                            return false;
                        }
                        return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
                    };
                    $state.href = function href(stateOrName, params, options) {
                        options = extend({
                            lossy: true,
                            inherit: true,
                            absolute: false,
                            relative: $state.$current
                        }, options || {});
                        var state = findState(stateOrName, options.relative);
                        if (!isDefined(state))
                            return null;
                        if (options.inherit)
                            params = inheritParams($stateParams, params || {}, $state.$current, state);
                        var nav = state && options.lossy ? state.navigable : state;
                        if (!nav || nav.url === undefined || nav.url === null) {
                            return null;
                        }
                        return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), { absolute: options.absolute });
                    };
                    $state.get = function (stateOrName, context) {
                        if (arguments.length === 0)
                            return map(objectKeys(states), function (name) {
                                return states[name].self;
                            });
                        var state = findState(stateOrName, context || $state.$current);
                        return state && state.self ? state.self : null;
                    };
                    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                        var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
                        var locals = { $stateParams: $stateParams };
                        dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                        var promises = [dst.resolve.then(function (globals) {
                                dst.globals = globals;
                            })];
                        if (inherited)
                            promises.push(inherited);
                        function resolveViews() {
                            var viewsPromises = [];
                            forEach(state.views, function (view, name) {
                                var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                                injectables.$template = [function () {
                                        return $view.load(name, {
                                            view: view,
                                            locals: dst.globals,
                                            params: $stateParams,
                                            notify: options.notify
                                        }) || '';
                                    }];
                                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
                                    if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                        var injectLocals = angular.extend({}, injectables, dst.globals);
                                        result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                                    } else {
                                        result.$$controller = view.controller;
                                    }
                                    result.$$state = state;
                                    result.$$controllerAs = view.controllerAs;
                                    result.$$resolveAs = view.resolveAs;
                                    dst[name] = result;
                                }));
                            });
                            return $q.all(viewsPromises).then(function () {
                                return dst.globals;
                            });
                        }
                        return $q.all(promises).then(resolveViews).then(function (values) {
                            return dst;
                        });
                    }
                    return $state;
                }
                function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
                    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                        function notSearchParam(key) {
                            return fromAndToState.params[key].location != 'search';
                        }
                        var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
                        var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
                        var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                        return nonQueryParamSet.$$equals(fromParams, toParams);
                    }
                    if (!options.reload && to === from && (locals === from.locals || to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams))) {
                        return true;
                    }
                }
            }
            angular.module('ui.router.state').factory('$stateParams', function () {
                return {};
            }).constant('$state.runtime', { autoinject: true }).provider('$state', $StateProvider).run([
                '$injector',
                function ($injector) {
                    if ($injector.get('$state.runtime').autoinject) {
                        $injector.get('$state');
                    }
                }
            ]);
            $ViewProvider.$inject = [];
            function $ViewProvider() {
                this.$get = $get;
                $get.$inject = [
                    '$rootScope',
                    '$templateFactory'
                ];
                function $get($rootScope, $templateFactory) {
                    return {
                        load: function load(name, options) {
                            var result, defaults = {
                                    template: null,
                                    controller: null,
                                    view: null,
                                    locals: null,
                                    notify: true,
                                    async: true,
                                    params: {}
                                };
                            options = extend(defaults, options);
                            if (options.view) {
                                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                            }
                            return result;
                        }
                    };
                }
            }
            angular.module('ui.router.state').provider('$view', $ViewProvider);
            function $ViewScrollProvider() {
                var useAnchorScroll = false;
                this.useAnchorScroll = function () {
                    useAnchorScroll = true;
                };
                this.$get = [
                    '$anchorScroll',
                    '$timeout',
                    function ($anchorScroll, $timeout) {
                        if (useAnchorScroll) {
                            return $anchorScroll;
                        }
                        return function ($element) {
                            return $timeout(function () {
                                $element[0].scrollIntoView();
                            }, 0, false);
                        };
                    }
                ];
            }
            angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
            $ViewDirective.$inject = [
                '$state',
                '$injector',
                '$uiViewScroll',
                '$interpolate',
                '$q'
            ];
            function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {
                function getService() {
                    return $injector.has ? function (service) {
                        return $injector.has(service) ? $injector.get(service) : null;
                    } : function (service) {
                        try {
                            return $injector.get(service);
                        } catch (e) {
                            return null;
                        }
                    };
                }
                var service = getService(), $animator = service('$animator'), $animate = service('$animate');
                function getRenderer(attrs, scope) {
                    var statics = function () {
                        return {
                            enter: function (element, target, cb) {
                                target.after(element);
                                cb();
                            },
                            leave: function (element, cb) {
                                element.remove();
                                cb();
                            }
                        };
                    };
                    if ($animate) {
                        return {
                            enter: function (element, target, cb) {
                                if (angular.version.minor > 2) {
                                    $animate.enter(element, null, target).then(cb);
                                } else {
                                    $animate.enter(element, null, target, cb);
                                }
                            },
                            leave: function (element, cb) {
                                if (angular.version.minor > 2) {
                                    $animate.leave(element).then(cb);
                                } else {
                                    $animate.leave(element, cb);
                                }
                            }
                        };
                    }
                    if ($animator) {
                        var animate = $animator && $animator(scope, attrs);
                        return {
                            enter: function (element, target, cb) {
                                animate.enter(element, null, target);
                                cb();
                            },
                            leave: function (element, cb) {
                                animate.leave(element);
                                cb();
                            }
                        };
                    }
                    return statics();
                }
                var directive = {
                    restrict: 'ECA',
                    terminal: true,
                    priority: 400,
                    transclude: 'element',
                    compile: function (tElement, tAttrs, $transclude) {
                        return function (scope, $element, attrs) {
                            var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || '', autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope), inherited = $element.inheritedData('$uiView');
                            scope.$on('$stateChangeSuccess', function () {
                                updateView(false);
                            });
                            updateView(true);
                            function cleanupLastView() {
                                if (previousEl) {
                                    previousEl.remove();
                                    previousEl = null;
                                }
                                if (currentScope) {
                                    currentScope.$destroy();
                                    currentScope = null;
                                }
                                if (currentEl) {
                                    var $uiViewData = currentEl.data('$uiViewAnim');
                                    renderer.leave(currentEl, function () {
                                        $uiViewData.$$animLeave.resolve();
                                        previousEl = null;
                                    });
                                    previousEl = currentEl;
                                    currentEl = null;
                                }
                            }
                            function updateView(firstTime) {
                                var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                                if (!firstTime && previousLocals === latestLocals)
                                    return;
                                newScope = scope.$new();
                                latestLocals = $state.$current.locals[name];
                                newScope.$emit('$viewContentLoading', name);
                                var clone = $transclude(newScope, function (clone) {
                                    var animEnter = $q.defer(), animLeave = $q.defer();
                                    var viewAnimData = {
                                        $animEnter: animEnter.promise,
                                        $animLeave: animLeave.promise,
                                        $$animLeave: animLeave
                                    };
                                    clone.data('$uiViewAnim', viewAnimData);
                                    renderer.enter(clone, $element, function onUiViewEnter() {
                                        animEnter.resolve();
                                        if (currentScope) {
                                            currentScope.$emit('$viewContentAnimationEnded');
                                        }
                                        if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                            $uiViewScroll(clone);
                                        }
                                    });
                                    cleanupLastView();
                                });
                                currentEl = clone;
                                currentScope = newScope;
                                currentScope.$emit('$viewContentLoaded', name);
                                currentScope.$eval(onloadExp);
                            }
                        };
                    }
                };
                return directive;
            }
            $ViewDirectiveFill.$inject = [
                '$compile',
                '$controller',
                '$state',
                '$interpolate'
            ];
            function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
                return {
                    restrict: 'ECA',
                    priority: -400,
                    compile: function (tElement) {
                        var initial = tElement.html();
                        return function (scope, $element, attrs) {
                            var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                            if (!locals) {
                                return;
                            }
                            $element.data('$uiView', {
                                name: name,
                                state: locals.$$state
                            });
                            $element.html(locals.$template ? locals.$template : initial);
                            var resolveData = angular.extend({}, locals);
                            scope[locals.$$resolveAs] = resolveData;
                            var link = $compile($element.contents());
                            if (locals.$$controller) {
                                locals.$scope = scope;
                                locals.$element = $element;
                                var controller = $controller(locals.$$controller, locals);
                                if (locals.$$controllerAs) {
                                    scope[locals.$$controllerAs] = controller;
                                    scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;
                                }
                                if (isFunction(controller.$onInit))
                                    controller.$onInit();
                                $element.data('$ngControllerController', controller);
                                $element.children().data('$ngControllerController', controller);
                            }
                            link(scope);
                        };
                    }
                };
            }
            function getUiViewName(scope, attrs, element, $interpolate) {
                var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
                var uiViewCreatedBy = element.inheritedData('$uiView');
                return name.indexOf('@') >= 0 ? name : name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : '');
            }
            angular.module('ui.router.state').directive('uiView', $ViewDirective);
            angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
            function parseStateRef(ref, current) {
                var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
                if (preparsed)
                    ref = current + '(' + preparsed[1] + ')';
                parsed = ref.replace(/\n/g, ' ').match(/^([^(]+?)\s*(\((.*)\))?$/);
                if (!parsed || parsed.length !== 4)
                    throw new Error('Invalid state ref \'' + ref + '\'');
                return {
                    state: parsed[1],
                    paramExpr: parsed[3] || null
                };
            }
            function stateContext(el) {
                var stateData = el.parent().inheritedData('$uiView');
                if (stateData && stateData.state && stateData.state.name) {
                    return stateData.state;
                }
            }
            function getTypeInfo(el) {
                var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
                var isForm = el[0].nodeName === 'FORM';
                return {
                    attr: isForm ? 'action' : isSvg ? 'xlink:href' : 'href',
                    isAnchor: el.prop('tagName').toUpperCase() === 'A',
                    clickable: !isForm
                };
            }
            function clickHook(el, $state, $timeout, type, current) {
                return function (e) {
                    var button = e.which || e.button, target = current();
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
                        var transition = $timeout(function () {
                            $state.go(target.state, target.params, target.options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
                        e.preventDefault = function () {
                            if (ignorePreventDefaultCount-- <= 0)
                                $timeout.cancel(transition);
                        };
                    }
                };
            }
            function defaultOpts(el, $state) {
                return {
                    relative: stateContext(el) || $state.$current,
                    inherit: true
                };
            }
            $StateRefDirective.$inject = [
                '$state',
                '$timeout'
            ];
            function $StateRefDirective($state, $timeout) {
                return {
                    restrict: 'A',
                    require: [
                        '?^uiSrefActive',
                        '?^uiSrefActiveEq'
                    ],
                    link: function (scope, element, attrs, uiSrefActive) {
                        var ref = parseStateRef(attrs.uiSref, $state.current.name);
                        var def = {
                            state: ref.state,
                            href: null,
                            params: null
                        };
                        var type = getTypeInfo(element);
                        var active = uiSrefActive[1] || uiSrefActive[0];
                        var unlinkInfoFn = null;
                        var hookFn;
                        def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
                        var update = function (val) {
                            if (val)
                                def.params = angular.copy(val);
                            def.href = $state.href(ref.state, def.params, def.options);
                            if (unlinkInfoFn)
                                unlinkInfoFn();
                            if (active)
                                unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);
                            if (def.href !== null)
                                attrs.$set(type.attr, def.href);
                        };
                        if (ref.paramExpr) {
                            scope.$watch(ref.paramExpr, function (val) {
                                if (val !== def.params)
                                    update(val);
                            }, true);
                            def.params = angular.copy(scope.$eval(ref.paramExpr));
                        }
                        update();
                        if (!type.clickable)
                            return;
                        hookFn = clickHook(element, $state, $timeout, type, function () {
                            return def;
                        });
                        element.bind('click', hookFn);
                        scope.$on('$destroy', function () {
                            element.unbind('click', hookFn);
                        });
                    }
                };
            }
            $StateRefDynamicDirective.$inject = [
                '$state',
                '$timeout'
            ];
            function $StateRefDynamicDirective($state, $timeout) {
                return {
                    restrict: 'A',
                    require: [
                        '?^uiSrefActive',
                        '?^uiSrefActiveEq'
                    ],
                    link: function (scope, element, attrs, uiSrefActive) {
                        var type = getTypeInfo(element);
                        var active = uiSrefActive[1] || uiSrefActive[0];
                        var group = [
                            attrs.uiState,
                            attrs.uiStateParams || null,
                            attrs.uiStateOpts || null
                        ];
                        var watch = '[' + group.map(function (val) {
                            return val || 'null';
                        }).join(', ') + ']';
                        var def = {
                            state: null,
                            params: null,
                            options: null,
                            href: null
                        };
                        var unlinkInfoFn = null;
                        var hookFn;
                        function runStateRefLink(group) {
                            def.state = group[0];
                            def.params = group[1];
                            def.options = group[2];
                            def.href = $state.href(def.state, def.params, def.options);
                            if (unlinkInfoFn)
                                unlinkInfoFn();
                            if (active)
                                unlinkInfoFn = active.$$addStateInfo(def.state, def.params);
                            if (def.href)
                                attrs.$set(type.attr, def.href);
                        }
                        scope.$watch(watch, runStateRefLink, true);
                        runStateRefLink(scope.$eval(watch));
                        if (!type.clickable)
                            return;
                        hookFn = clickHook(element, $state, $timeout, type, function () {
                            return def;
                        });
                        element.bind('click', hookFn);
                        scope.$on('$destroy', function () {
                            element.unbind('click', hookFn);
                        });
                    }
                };
            }
            $StateRefActiveDirective.$inject = [
                '$state',
                '$stateParams',
                '$interpolate'
            ];
            function $StateRefActiveDirective($state, $stateParams, $interpolate) {
                return {
                    restrict: 'A',
                    controller: [
                        '$scope',
                        '$element',
                        '$attrs',
                        '$timeout',
                        function ($scope, $element, $attrs, $timeout) {
                            var states = [], activeClasses = {}, activeEqClass, uiSrefActive;
                            activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
                            try {
                                uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                            } catch (e) {
                            }
                            uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
                            if (isObject(uiSrefActive)) {
                                forEach(uiSrefActive, function (stateOrName, activeClass) {
                                    if (isString(stateOrName)) {
                                        var ref = parseStateRef(stateOrName, $state.current.name);
                                        addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                                    }
                                });
                            }
                            this.$$addStateInfo = function (newState, newParams) {
                                if (isObject(uiSrefActive) && states.length > 0) {
                                    return;
                                }
                                var deregister = addState(newState, newParams, uiSrefActive);
                                update();
                                return deregister;
                            };
                            $scope.$on('$stateChangeSuccess', update);
                            function addState(stateName, stateParams, activeClass) {
                                var state = $state.get(stateName, stateContext($element));
                                var stateHash = createStateHash(stateName, stateParams);
                                var stateInfo = {
                                    state: state || { name: stateName },
                                    params: stateParams,
                                    hash: stateHash
                                };
                                states.push(stateInfo);
                                activeClasses[stateHash] = activeClass;
                                return function removeState() {
                                    var idx = states.indexOf(stateInfo);
                                    if (idx !== -1)
                                        states.splice(idx, 1);
                                };
                            }
                            function createStateHash(state, params) {
                                if (!isString(state)) {
                                    throw new Error('state should be a string');
                                }
                                if (isObject(params)) {
                                    return state + toJson(params);
                                }
                                params = $scope.$eval(params);
                                if (isObject(params)) {
                                    return state + toJson(params);
                                }
                                return state;
                            }
                            function update() {
                                for (var i = 0; i < states.length; i++) {
                                    if (anyMatch(states[i].state, states[i].params)) {
                                        addClass($element, activeClasses[states[i].hash]);
                                    } else {
                                        removeClass($element, activeClasses[states[i].hash]);
                                    }
                                    if (exactMatch(states[i].state, states[i].params)) {
                                        addClass($element, activeEqClass);
                                    } else {
                                        removeClass($element, activeEqClass);
                                    }
                                }
                            }
                            function addClass(el, className) {
                                $timeout(function () {
                                    el.addClass(className);
                                });
                            }
                            function removeClass(el, className) {
                                el.removeClass(className);
                            }
                            function anyMatch(state, params) {
                                return $state.includes(state.name, params);
                            }
                            function exactMatch(state, params) {
                                return $state.is(state.name, params);
                            }
                            update();
                        }
                    ]
                };
            }
            angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective).directive('uiState', $StateRefDynamicDirective);
            $IsStateFilter.$inject = ['$state'];
            function $IsStateFilter($state) {
                var isFilter = function (state, params) {
                    return $state.is(state, params);
                };
                isFilter.$stateful = true;
                return isFilter;
            }
            $IncludedByStateFilter.$inject = ['$state'];
            function $IncludedByStateFilter($state) {
                var includesFilter = function (state, params, options) {
                    return $state.includes(state, params, options);
                };
                includesFilter.$stateful = true;
                return includesFilter;
            }
            angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
        }(window, window.angular));
    }(function () {
        return this;
    }()));
});
/*bootstrap@3.3.6#js/transition.js*/
define('bootstrap@3.3.6#js/transition.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: transition.js v3.3.6\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement(\'bootstrap\')\n\n    var transEndEventNames = {\n      WebkitTransition : \'webkitTransitionEnd\',\n      MozTransition    : \'transitionend\',\n      OTransition      : \'oTransitionEnd otransitionend\',\n      transition       : \'transitionend\'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one(\'bsTransitionEnd\', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/alert.js*/
define('bootstrap@3.3.6#js/alert.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: alert.js v3.3.6\n * http://getbootstrap.com/javascript/#alerts\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // ALERT CLASS DEFINITION\n  // ======================\n\n  var dismiss = \'[data-dismiss="alert"]\'\n  var Alert   = function (el) {\n    $(el).on(\'click\', dismiss, this.close)\n  }\n\n  Alert.VERSION = \'3.3.6\'\n\n  Alert.TRANSITION_DURATION = 150\n\n  Alert.prototype.close = function (e) {\n    var $this    = $(this)\n    var selector = $this.attr(\'data-target\')\n\n    if (!selector) {\n      selector = $this.attr(\'href\')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, \'\') // strip for ie7\n    }\n\n    var $parent = $(selector)\n\n    if (e) e.preventDefault()\n\n    if (!$parent.length) {\n      $parent = $this.closest(\'.alert\')\n    }\n\n    $parent.trigger(e = $.Event(\'close.bs.alert\'))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent.removeClass(\'in\')\n\n    function removeElement() {\n      // detach from parent, fire event then clean up data\n      $parent.detach().trigger(\'closed.bs.alert\').remove()\n    }\n\n    $.support.transition && $parent.hasClass(\'fade\') ?\n      $parent\n        .one(\'bsTransitionEnd\', removeElement)\n        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\n      removeElement()\n  }\n\n\n  // ALERT PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data(\'bs.alert\')\n\n      if (!data) $this.data(\'bs.alert\', (data = new Alert(this)))\n      if (typeof option == \'string\') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.alert\n\n  $.fn.alert             = Plugin\n  $.fn.alert.Constructor = Alert\n\n\n  // ALERT NO CONFLICT\n  // =================\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old\n    return this\n  }\n\n\n  // ALERT DATA-API\n  // ==============\n\n  $(document).on(\'click.bs.alert.data-api\', dismiss, Alert.prototype.close)\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/button.js*/
define('bootstrap@3.3.6#js/button.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: button.js v3.3.6\n * http://getbootstrap.com/javascript/#buttons\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // BUTTON PUBLIC CLASS DEFINITION\n  // ==============================\n\n  var Button = function (element, options) {\n    this.$element  = $(element)\n    this.options   = $.extend({}, Button.DEFAULTS, options)\n    this.isLoading = false\n  }\n\n  Button.VERSION  = \'3.3.6\'\n\n  Button.DEFAULTS = {\n    loadingText: \'loading...\'\n  }\n\n  Button.prototype.setState = function (state) {\n    var d    = \'disabled\'\n    var $el  = this.$element\n    var val  = $el.is(\'input\') ? \'val\' : \'html\'\n    var data = $el.data()\n\n    state += \'Text\'\n\n    if (data.resetText == null) $el.data(\'resetText\', $el[val]())\n\n    // push to event loop to allow forms to submit\n    setTimeout($.proxy(function () {\n      $el[val](data[state] == null ? this.options[state] : data[state])\n\n      if (state == \'loadingText\') {\n        this.isLoading = true\n        $el.addClass(d).attr(d, d)\n      } else if (this.isLoading) {\n        this.isLoading = false\n        $el.removeClass(d).removeAttr(d)\n      }\n    }, this), 0)\n  }\n\n  Button.prototype.toggle = function () {\n    var changed = true\n    var $parent = this.$element.closest(\'[data-toggle="buttons"]\')\n\n    if ($parent.length) {\n      var $input = this.$element.find(\'input\')\n      if ($input.prop(\'type\') == \'radio\') {\n        if ($input.prop(\'checked\')) changed = false\n        $parent.find(\'.active\').removeClass(\'active\')\n        this.$element.addClass(\'active\')\n      } else if ($input.prop(\'type\') == \'checkbox\') {\n        if (($input.prop(\'checked\')) !== this.$element.hasClass(\'active\')) changed = false\n        this.$element.toggleClass(\'active\')\n      }\n      $input.prop(\'checked\', this.$element.hasClass(\'active\'))\n      if (changed) $input.trigger(\'change\')\n    } else {\n      this.$element.attr(\'aria-pressed\', !this.$element.hasClass(\'active\'))\n      this.$element.toggleClass(\'active\')\n    }\n  }\n\n\n  // BUTTON PLUGIN DEFINITION\n  // ========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.button\')\n      var options = typeof option == \'object\' && option\n\n      if (!data) $this.data(\'bs.button\', (data = new Button(this, options)))\n\n      if (option == \'toggle\') data.toggle()\n      else if (option) data.setState(option)\n    })\n  }\n\n  var old = $.fn.button\n\n  $.fn.button             = Plugin\n  $.fn.button.Constructor = Button\n\n\n  // BUTTON NO CONFLICT\n  // ==================\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old\n    return this\n  }\n\n\n  // BUTTON DATA-API\n  // ===============\n\n  $(document)\n    .on(\'click.bs.button.data-api\', \'[data-toggle^="button"]\', function (e) {\n      var $btn = $(e.target)\n      if (!$btn.hasClass(\'btn\')) $btn = $btn.closest(\'.btn\')\n      Plugin.call($btn, \'toggle\')\n      if (!($(e.target).is(\'input[type="radio"]\') || $(e.target).is(\'input[type="checkbox"]\'))) e.preventDefault()\n    })\n    .on(\'focus.bs.button.data-api blur.bs.button.data-api\', \'[data-toggle^="button"]\', function (e) {\n      $(e.target).closest(\'.btn\').toggleClass(\'focus\', /^focus(in)?$/.test(e.type))\n    })\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/carousel.js*/
define('bootstrap@3.3.6#js/carousel.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: carousel.js v3.3.6\n * http://getbootstrap.com/javascript/#carousel\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // CAROUSEL CLASS DEFINITION\n  // =========================\n\n  var Carousel = function (element, options) {\n    this.$element    = $(element)\n    this.$indicators = this.$element.find(\'.carousel-indicators\')\n    this.options     = options\n    this.paused      = null\n    this.sliding     = null\n    this.interval    = null\n    this.$active     = null\n    this.$items      = null\n\n    this.options.keyboard && this.$element.on(\'keydown.bs.carousel\', $.proxy(this.keydown, this))\n\n    this.options.pause == \'hover\' && !(\'ontouchstart\' in document.documentElement) && this.$element\n      .on(\'mouseenter.bs.carousel\', $.proxy(this.pause, this))\n      .on(\'mouseleave.bs.carousel\', $.proxy(this.cycle, this))\n  }\n\n  Carousel.VERSION  = \'3.3.6\'\n\n  Carousel.TRANSITION_DURATION = 600\n\n  Carousel.DEFAULTS = {\n    interval: 5000,\n    pause: \'hover\',\n    wrap: true,\n    keyboard: true\n  }\n\n  Carousel.prototype.keydown = function (e) {\n    if (/input|textarea/i.test(e.target.tagName)) return\n    switch (e.which) {\n      case 37: this.prev(); break\n      case 39: this.next(); break\n      default: return\n    }\n\n    e.preventDefault()\n  }\n\n  Carousel.prototype.cycle = function (e) {\n    e || (this.paused = false)\n\n    this.interval && clearInterval(this.interval)\n\n    this.options.interval\n      && !this.paused\n      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\n\n    return this\n  }\n\n  Carousel.prototype.getItemIndex = function (item) {\n    this.$items = item.parent().children(\'.item\')\n    return this.$items.index(item || this.$active)\n  }\n\n  Carousel.prototype.getItemForDirection = function (direction, active) {\n    var activeIndex = this.getItemIndex(active)\n    var willWrap = (direction == \'prev\' && activeIndex === 0)\n                || (direction == \'next\' && activeIndex == (this.$items.length - 1))\n    if (willWrap && !this.options.wrap) return active\n    var delta = direction == \'prev\' ? -1 : 1\n    var itemIndex = (activeIndex + delta) % this.$items.length\n    return this.$items.eq(itemIndex)\n  }\n\n  Carousel.prototype.to = function (pos) {\n    var that        = this\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find(\'.item.active\'))\n\n    if (pos > (this.$items.length - 1) || pos < 0) return\n\n    if (this.sliding)       return this.$element.one(\'slid.bs.carousel\', function () { that.to(pos) }) // yes, "slid"\n    if (activeIndex == pos) return this.pause().cycle()\n\n    return this.slide(pos > activeIndex ? \'next\' : \'prev\', this.$items.eq(pos))\n  }\n\n  Carousel.prototype.pause = function (e) {\n    e || (this.paused = true)\n\n    if (this.$element.find(\'.next, .prev\').length && $.support.transition) {\n      this.$element.trigger($.support.transition.end)\n      this.cycle(true)\n    }\n\n    this.interval = clearInterval(this.interval)\n\n    return this\n  }\n\n  Carousel.prototype.next = function () {\n    if (this.sliding) return\n    return this.slide(\'next\')\n  }\n\n  Carousel.prototype.prev = function () {\n    if (this.sliding) return\n    return this.slide(\'prev\')\n  }\n\n  Carousel.prototype.slide = function (type, next) {\n    var $active   = this.$element.find(\'.item.active\')\n    var $next     = next || this.getItemForDirection(type, $active)\n    var isCycling = this.interval\n    var direction = type == \'next\' ? \'left\' : \'right\'\n    var that      = this\n\n    if ($next.hasClass(\'active\')) return (this.sliding = false)\n\n    var relatedTarget = $next[0]\n    var slideEvent = $.Event(\'slide.bs.carousel\', {\n      relatedTarget: relatedTarget,\n      direction: direction\n    })\n    this.$element.trigger(slideEvent)\n    if (slideEvent.isDefaultPrevented()) return\n\n    this.sliding = true\n\n    isCycling && this.pause()\n\n    if (this.$indicators.length) {\n      this.$indicators.find(\'.active\').removeClass(\'active\')\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\n      $nextIndicator && $nextIndicator.addClass(\'active\')\n    }\n\n    var slidEvent = $.Event(\'slid.bs.carousel\', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"\n    if ($.support.transition && this.$element.hasClass(\'slide\')) {\n      $next.addClass(type)\n      $next[0].offsetWidth // force reflow\n      $active.addClass(direction)\n      $next.addClass(direction)\n      $active\n        .one(\'bsTransitionEnd\', function () {\n          $next.removeClass([type, direction].join(\' \')).addClass(\'active\')\n          $active.removeClass([\'active\', direction].join(\' \'))\n          that.sliding = false\n          setTimeout(function () {\n            that.$element.trigger(slidEvent)\n          }, 0)\n        })\n        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\n    } else {\n      $active.removeClass(\'active\')\n      $next.addClass(\'active\')\n      this.sliding = false\n      this.$element.trigger(slidEvent)\n    }\n\n    isCycling && this.cycle()\n\n    return this\n  }\n\n\n  // CAROUSEL PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.carousel\')\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == \'object\' && option)\n      var action  = typeof option == \'string\' ? option : options.slide\n\n      if (!data) $this.data(\'bs.carousel\', (data = new Carousel(this, options)))\n      if (typeof option == \'number\') data.to(option)\n      else if (action) data[action]()\n      else if (options.interval) data.pause().cycle()\n    })\n  }\n\n  var old = $.fn.carousel\n\n  $.fn.carousel             = Plugin\n  $.fn.carousel.Constructor = Carousel\n\n\n  // CAROUSEL NO CONFLICT\n  // ====================\n\n  $.fn.carousel.noConflict = function () {\n    $.fn.carousel = old\n    return this\n  }\n\n\n  // CAROUSEL DATA-API\n  // =================\n\n  var clickHandler = function (e) {\n    var href\n    var $this   = $(this)\n    var $target = $($this.attr(\'data-target\') || (href = $this.attr(\'href\')) && href.replace(/.*(?=#[^\\s]+$)/, \'\')) // strip for ie7\n    if (!$target.hasClass(\'carousel\')) return\n    var options = $.extend({}, $target.data(), $this.data())\n    var slideIndex = $this.attr(\'data-slide-to\')\n    if (slideIndex) options.interval = false\n\n    Plugin.call($target, options)\n\n    if (slideIndex) {\n      $target.data(\'bs.carousel\').to(slideIndex)\n    }\n\n    e.preventDefault()\n  }\n\n  $(document)\n    .on(\'click.bs.carousel.data-api\', \'[data-slide]\', clickHandler)\n    .on(\'click.bs.carousel.data-api\', \'[data-slide-to]\', clickHandler)\n\n  $(window).on(\'load\', function () {\n    $(\'[data-ride="carousel"]\').each(function () {\n      var $carousel = $(this)\n      Plugin.call($carousel, $carousel.data())\n    })\n  })\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/collapse.js*/
define('bootstrap@3.3.6#js/collapse.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: collapse.js v3.3.6\n * http://getbootstrap.com/javascript/#collapse\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // COLLAPSE PUBLIC CLASS DEFINITION\n  // ================================\n\n  var Collapse = function (element, options) {\n    this.$element      = $(element)\n    this.options       = $.extend({}, Collapse.DEFAULTS, options)\n    this.$trigger      = $(\'[data-toggle="collapse"][href="#\' + element.id + \'"],\' +\n                           \'[data-toggle="collapse"][data-target="#\' + element.id + \'"]\')\n    this.transitioning = null\n\n    if (this.options.parent) {\n      this.$parent = this.getParent()\n    } else {\n      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\n    }\n\n    if (this.options.toggle) this.toggle()\n  }\n\n  Collapse.VERSION  = \'3.3.6\'\n\n  Collapse.TRANSITION_DURATION = 350\n\n  Collapse.DEFAULTS = {\n    toggle: true\n  }\n\n  Collapse.prototype.dimension = function () {\n    var hasWidth = this.$element.hasClass(\'width\')\n    return hasWidth ? \'width\' : \'height\'\n  }\n\n  Collapse.prototype.show = function () {\n    if (this.transitioning || this.$element.hasClass(\'in\')) return\n\n    var activesData\n    var actives = this.$parent && this.$parent.children(\'.panel\').children(\'.in, .collapsing\')\n\n    if (actives && actives.length) {\n      activesData = actives.data(\'bs.collapse\')\n      if (activesData && activesData.transitioning) return\n    }\n\n    var startEvent = $.Event(\'show.bs.collapse\')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    if (actives && actives.length) {\n      Plugin.call(actives, \'hide\')\n      activesData || actives.data(\'bs.collapse\', null)\n    }\n\n    var dimension = this.dimension()\n\n    this.$element\n      .removeClass(\'collapse\')\n      .addClass(\'collapsing\')[dimension](0)\n      .attr(\'aria-expanded\', true)\n\n    this.$trigger\n      .removeClass(\'collapsed\')\n      .attr(\'aria-expanded\', true)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.$element\n        .removeClass(\'collapsing\')\n        .addClass(\'collapse in\')[dimension](\'\')\n      this.transitioning = 0\n      this.$element\n        .trigger(\'shown.bs.collapse\')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    var scrollSize = $.camelCase([\'scroll\', dimension].join(\'-\'))\n\n    this.$element\n      .one(\'bsTransitionEnd\', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\n  }\n\n  Collapse.prototype.hide = function () {\n    if (this.transitioning || !this.$element.hasClass(\'in\')) return\n\n    var startEvent = $.Event(\'hide.bs.collapse\')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    var dimension = this.dimension()\n\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\n\n    this.$element\n      .addClass(\'collapsing\')\n      .removeClass(\'collapse in\')\n      .attr(\'aria-expanded\', false)\n\n    this.$trigger\n      .addClass(\'collapsed\')\n      .attr(\'aria-expanded\', false)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.transitioning = 0\n      this.$element\n        .removeClass(\'collapsing\')\n        .addClass(\'collapse\')\n        .trigger(\'hidden.bs.collapse\')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    this.$element\n      [dimension](0)\n      .one(\'bsTransitionEnd\', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\n  }\n\n  Collapse.prototype.toggle = function () {\n    this[this.$element.hasClass(\'in\') ? \'hide\' : \'show\']()\n  }\n\n  Collapse.prototype.getParent = function () {\n    return $(this.options.parent)\n      .find(\'[data-toggle="collapse"][data-parent="\' + this.options.parent + \'"]\')\n      .each($.proxy(function (i, element) {\n        var $element = $(element)\n        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\n      }, this))\n      .end()\n  }\n\n  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\n    var isOpen = $element.hasClass(\'in\')\n\n    $element.attr(\'aria-expanded\', isOpen)\n    $trigger\n      .toggleClass(\'collapsed\', !isOpen)\n      .attr(\'aria-expanded\', isOpen)\n  }\n\n  function getTargetFromTrigger($trigger) {\n    var href\n    var target = $trigger.attr(\'data-target\')\n      || (href = $trigger.attr(\'href\')) && href.replace(/.*(?=#[^\\s]+$)/, \'\') // strip for ie7\n\n    return $(target)\n  }\n\n\n  // COLLAPSE PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.collapse\')\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == \'object\' && option)\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\n      if (!data) $this.data(\'bs.collapse\', (data = new Collapse(this, options)))\n      if (typeof option == \'string\') data[option]()\n    })\n  }\n\n  var old = $.fn.collapse\n\n  $.fn.collapse             = Plugin\n  $.fn.collapse.Constructor = Collapse\n\n\n  // COLLAPSE NO CONFLICT\n  // ====================\n\n  $.fn.collapse.noConflict = function () {\n    $.fn.collapse = old\n    return this\n  }\n\n\n  // COLLAPSE DATA-API\n  // =================\n\n  $(document).on(\'click.bs.collapse.data-api\', \'[data-toggle="collapse"]\', function (e) {\n    var $this   = $(this)\n\n    if (!$this.attr(\'data-target\')) e.preventDefault()\n\n    var $target = getTargetFromTrigger($this)\n    var data    = $target.data(\'bs.collapse\')\n    var option  = data ? \'toggle\' : $this.data()\n\n    Plugin.call($target, option)\n  })\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/dropdown.js*/
define('bootstrap@3.3.6#js/dropdown.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: dropdown.js v3.3.6\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = \'.dropdown-backdrop\'\n  var toggle   = \'[data-toggle="dropdown"]\'\n  var Dropdown = function (element) {\n    $(element).on(\'click.bs.dropdown\', this.toggle)\n  }\n\n  Dropdown.VERSION = \'3.3.6\'\n\n  function getParent($this) {\n    var selector = $this.attr(\'data-target\')\n\n    if (!selector) {\n      selector = $this.attr(\'href\')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, \'\') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass(\'open\')) return\n\n      if (e && e.type == \'click\' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\n\n      $parent.trigger(e = $.Event(\'hide.bs.dropdown\', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr(\'aria-expanded\', \'false\')\n      $parent.removeClass(\'open\').trigger($.Event(\'hidden.bs.dropdown\', relatedTarget))\n    })\n  }\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is(\'.disabled, :disabled\')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass(\'open\')\n\n    clearMenus()\n\n    if (!isActive) {\n      if (\'ontouchstart\' in document.documentElement && !$parent.closest(\'.navbar-nav\').length) {\n        // if mobile we use a backdrop because click events don\'t delegate\n        $(document.createElement(\'div\'))\n          .addClass(\'dropdown-backdrop\')\n          .insertAfter($(this))\n          .on(\'click\', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event(\'show.bs.dropdown\', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger(\'focus\')\n        .attr(\'aria-expanded\', \'true\')\n\n      $parent\n        .toggleClass(\'open\')\n        .trigger($.Event(\'shown.bs.dropdown\', relatedTarget))\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is(\'.disabled, :disabled\')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass(\'open\')\n\n    if (!isActive && e.which != 27 || isActive && e.which == 27) {\n      if (e.which == 27) $parent.find(toggle).trigger(\'focus\')\n      return $this.trigger(\'click\')\n    }\n\n    var desc = \' li:not(.disabled):visible a\'\n    var $items = $parent.find(\'.dropdown-menu\' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--         // up\n    if (e.which == 40 && index < $items.length - 1) index++         // down\n    if (!~index)                                    index = 0\n\n    $items.eq(index).trigger(\'focus\')\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data(\'bs.dropdown\')\n\n      if (!data) $this.data(\'bs.dropdown\', (data = new Dropdown(this)))\n      if (typeof option == \'string\') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on(\'click.bs.dropdown.data-api\', clearMenus)\n    .on(\'click.bs.dropdown.data-api\', \'.dropdown form\', function (e) { e.stopPropagation() })\n    .on(\'click.bs.dropdown.data-api\', toggle, Dropdown.prototype.toggle)\n    .on(\'keydown.bs.dropdown.data-api\', toggle, Dropdown.prototype.keydown)\n    .on(\'keydown.bs.dropdown.data-api\', \'.dropdown-menu\', Dropdown.prototype.keydown)\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/modal.js*/
define('bootstrap@3.3.6#js/modal.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: modal.js v3.3.6\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  var Modal = function (element, options) {\n    this.options             = options\n    this.$body               = $(document.body)\n    this.$element            = $(element)\n    this.$dialog             = this.$element.find(\'.modal-dialog\')\n    this.$backdrop           = null\n    this.isShown             = null\n    this.originalBodyPad     = null\n    this.scrollbarWidth      = 0\n    this.ignoreBackdropClick = false\n\n    if (this.options.remote) {\n      this.$element\n        .find(\'.modal-content\')\n        .load(this.options.remote, $.proxy(function () {\n          this.$element.trigger(\'loaded.bs.modal\')\n        }, this))\n    }\n  }\n\n  Modal.VERSION  = \'3.3.6\'\n\n  Modal.TRANSITION_DURATION = 300\n  Modal.BACKDROP_TRANSITION_DURATION = 150\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  }\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\n  }\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this\n    var e    = $.Event(\'show.bs.modal\', { relatedTarget: _relatedTarget })\n\n    this.$element.trigger(e)\n\n    if (this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = true\n\n    this.checkScrollbar()\n    this.setScrollbar()\n    this.$body.addClass(\'modal-open\')\n\n    this.escape()\n    this.resize()\n\n    this.$element.on(\'click.dismiss.bs.modal\', \'[data-dismiss="modal"]\', $.proxy(this.hide, this))\n\n    this.$dialog.on(\'mousedown.dismiss.bs.modal\', function () {\n      that.$element.one(\'mouseup.dismiss.bs.modal\', function (e) {\n        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\n      })\n    })\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass(\'fade\')\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body) // don\'t move modals dom position\n      }\n\n      that.$element\n        .show()\n        .scrollTop(0)\n\n      that.adjustDialog()\n\n      if (transition) {\n        that.$element[0].offsetWidth // force reflow\n      }\n\n      that.$element.addClass(\'in\')\n\n      that.enforceFocus()\n\n      var e = $.Event(\'shown.bs.modal\', { relatedTarget: _relatedTarget })\n\n      transition ?\n        that.$dialog // wait for modal to slide in\n          .one(\'bsTransitionEnd\', function () {\n            that.$element.trigger(\'focus\').trigger(e)\n          })\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n        that.$element.trigger(\'focus\').trigger(e)\n    })\n  }\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault()\n\n    e = $.Event(\'hide.bs.modal\')\n\n    this.$element.trigger(e)\n\n    if (!this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = false\n\n    this.escape()\n    this.resize()\n\n    $(document).off(\'focusin.bs.modal\')\n\n    this.$element\n      .removeClass(\'in\')\n      .off(\'click.dismiss.bs.modal\')\n      .off(\'mouseup.dismiss.bs.modal\')\n\n    this.$dialog.off(\'mousedown.dismiss.bs.modal\')\n\n    $.support.transition && this.$element.hasClass(\'fade\') ?\n      this.$element\n        .one(\'bsTransitionEnd\', $.proxy(this.hideModal, this))\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n      this.hideModal()\n  }\n\n  Modal.prototype.enforceFocus = function () {\n    $(document)\n      .off(\'focusin.bs.modal\') // guard against infinite focus loop\n      .on(\'focusin.bs.modal\', $.proxy(function (e) {\n        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {\n          this.$element.trigger(\'focus\')\n        }\n      }, this))\n  }\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on(\'keydown.dismiss.bs.modal\', $.proxy(function (e) {\n        e.which == 27 && this.hide()\n      }, this))\n    } else if (!this.isShown) {\n      this.$element.off(\'keydown.dismiss.bs.modal\')\n    }\n  }\n\n  Modal.prototype.resize = function () {\n    if (this.isShown) {\n      $(window).on(\'resize.bs.modal\', $.proxy(this.handleUpdate, this))\n    } else {\n      $(window).off(\'resize.bs.modal\')\n    }\n  }\n\n  Modal.prototype.hideModal = function () {\n    var that = this\n    this.$element.hide()\n    this.backdrop(function () {\n      that.$body.removeClass(\'modal-open\')\n      that.resetAdjustments()\n      that.resetScrollbar()\n      that.$element.trigger(\'hidden.bs.modal\')\n    })\n  }\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this\n    var animate = this.$element.hasClass(\'fade\') ? \'fade\' : \'\'\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $(document.createElement(\'div\'))\n        .addClass(\'modal-backdrop \' + animate)\n        .appendTo(this.$body)\n\n      this.$element.on(\'click.dismiss.bs.modal\', $.proxy(function (e) {\n        if (this.ignoreBackdropClick) {\n          this.ignoreBackdropClick = false\n          return\n        }\n        if (e.target !== e.currentTarget) return\n        this.options.backdrop == \'static\'\n          ? this.$element[0].focus()\n          : this.hide()\n      }, this))\n\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n      this.$backdrop.addClass(\'in\')\n\n      if (!callback) return\n\n      doAnimate ?\n        this.$backdrop\n          .one(\'bsTransitionEnd\', callback)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callback()\n\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass(\'in\')\n\n      var callbackRemove = function () {\n        that.removeBackdrop()\n        callback && callback()\n      }\n      $.support.transition && this.$element.hasClass(\'fade\') ?\n        this.$backdrop\n          .one(\'bsTransitionEnd\', callbackRemove)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callbackRemove()\n\n    } else if (callback) {\n      callback()\n    }\n  }\n\n  // these following methods are used to handle overflowing modals\n\n  Modal.prototype.handleUpdate = function () {\n    this.adjustDialog()\n  }\n\n  Modal.prototype.adjustDialog = function () {\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\n\n    this.$element.css({\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : \'\',\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : \'\'\n    })\n  }\n\n  Modal.prototype.resetAdjustments = function () {\n    this.$element.css({\n      paddingLeft: \'\',\n      paddingRight: \'\'\n    })\n  }\n\n  Modal.prototype.checkScrollbar = function () {\n    var fullWindowWidth = window.innerWidth\n    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n      var documentElementRect = document.documentElement.getBoundingClientRect()\n      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\n    }\n    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth\n    this.scrollbarWidth = this.measureScrollbar()\n  }\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt((this.$body.css(\'padding-right\') || 0), 10)\n    this.originalBodyPad = document.body.style.paddingRight || \'\'\n    if (this.bodyIsOverflowing) this.$body.css(\'padding-right\', bodyPad + this.scrollbarWidth)\n  }\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css(\'padding-right\', this.originalBodyPad)\n  }\n\n  Modal.prototype.measureScrollbar = function () { // thx walsh\n    var scrollDiv = document.createElement(\'div\')\n    scrollDiv.className = \'modal-scrollbar-measure\'\n    this.$body.append(scrollDiv)\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n    this.$body[0].removeChild(scrollDiv)\n    return scrollbarWidth\n  }\n\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.modal\')\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == \'object\' && option)\n\n      if (!data) $this.data(\'bs.modal\', (data = new Modal(this, options)))\n      if (typeof option == \'string\') data[option](_relatedTarget)\n      else if (options.show) data.show(_relatedTarget)\n    })\n  }\n\n  var old = $.fn.modal\n\n  $.fn.modal             = Plugin\n  $.fn.modal.Constructor = Modal\n\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on(\'click.bs.modal.data-api\', \'[data-toggle="modal"]\', function (e) {\n    var $this   = $(this)\n    var href    = $this.attr(\'href\')\n    var $target = $($this.attr(\'data-target\') || (href && href.replace(/.*(?=#[^\\s]+$)/, \'\'))) // strip for ie7\n    var option  = $target.data(\'bs.modal\') ? \'toggle\' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\n\n    if ($this.is(\'a\')) e.preventDefault()\n\n    $target.one(\'show.bs.modal\', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\n      $target.one(\'hidden.bs.modal\', function () {\n        $this.is(\':visible\') && $this.trigger(\'focus\')\n      })\n    })\n    Plugin.call($target, option, this)\n  })\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/tooltip.js*/
define('bootstrap@3.3.6#js/tooltip.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: tooltip.js v3.3.6\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Tooltip = function (element, options) {\n    this.type       = null\n    this.options    = null\n    this.enabled    = null\n    this.timeout    = null\n    this.hoverState = null\n    this.$element   = null\n    this.inState    = null\n\n    this.init(\'tooltip\', element, options)\n  }\n\n  Tooltip.VERSION  = \'3.3.6\'\n\n  Tooltip.TRANSITION_DURATION = 150\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: \'top\',\n    selector: false,\n    template: \'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>\',\n    trigger: \'hover focus\',\n    title: \'\',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: \'body\',\n      padding: 0\n    }\n  }\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled   = true\n    this.type      = type\n    this.$element  = $(element)\n    this.options   = this.getOptions(options)\n    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))\n    this.inState   = { click: false, hover: false, focus: false }\n\n    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\n      throw new Error(\'`selector` option must be specified when initializing \' + this.type + \' on the window.document object!\')\n    }\n\n    var triggers = this.options.trigger.split(\' \')\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i]\n\n      if (trigger == \'click\') {\n        this.$element.on(\'click.\' + this.type, this.options.selector, $.proxy(this.toggle, this))\n      } else if (trigger != \'manual\') {\n        var eventIn  = trigger == \'hover\' ? \'mouseenter\' : \'focusin\'\n        var eventOut = trigger == \'hover\' ? \'mouseleave\' : \'focusout\'\n\n        this.$element.on(eventIn  + \'.\' + this.type, this.options.selector, $.proxy(this.enter, this))\n        this.$element.on(eventOut + \'.\' + this.type, this.options.selector, $.proxy(this.leave, this))\n      }\n    }\n\n    this.options.selector ?\n      (this._options = $.extend({}, this.options, { trigger: \'manual\', selector: \'\' })) :\n      this.fixTitle()\n  }\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS\n  }\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\n\n    if (options.delay && typeof options.delay == \'number\') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      }\n    }\n\n    return options\n  }\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options  = {}\n    var defaults = this.getDefaults()\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value\n    })\n\n    return options\n  }\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data(\'bs.\' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data(\'bs.\' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == \'focusin\' ? \'focus\' : \'hover\'] = true\n    }\n\n    if (self.tip().hasClass(\'in\') || self.hoverState == \'in\') {\n      self.hoverState = \'in\'\n      return\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = \'in\'\n\n    if (!self.options.delay || !self.options.delay.show) return self.show()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == \'in\') self.show()\n    }, self.options.delay.show)\n  }\n\n  Tooltip.prototype.isInStateTrue = function () {\n    for (var key in this.inState) {\n      if (this.inState[key]) return true\n    }\n\n    return false\n  }\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data(\'bs.\' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data(\'bs.\' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == \'focusout\' ? \'focus\' : \'hover\'] = false\n    }\n\n    if (self.isInStateTrue()) return\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = \'out\'\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == \'out\') self.hide()\n    }, self.options.delay.hide)\n  }\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event(\'show.bs.\' + this.type)\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e)\n\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n      if (e.isDefaultPrevented() || !inDom) return\n      var that = this\n\n      var $tip = this.tip()\n\n      var tipId = this.getUID(this.type)\n\n      this.setContent()\n      $tip.attr(\'id\', tipId)\n      this.$element.attr(\'aria-describedby\', tipId)\n\n      if (this.options.animation) $tip.addClass(\'fade\')\n\n      var placement = typeof this.options.placement == \'function\' ?\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\n        this.options.placement\n\n      var autoToken = /\\s?auto?\\s?/i\n      var autoPlace = autoToken.test(placement)\n      if (autoPlace) placement = placement.replace(autoToken, \'\') || \'top\'\n\n      $tip\n        .detach()\n        .css({ top: 0, left: 0, display: \'block\' })\n        .addClass(placement)\n        .data(\'bs.\' + this.type, this)\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\n      this.$element.trigger(\'inserted.bs.\' + this.type)\n\n      var pos          = this.getPosition()\n      var actualWidth  = $tip[0].offsetWidth\n      var actualHeight = $tip[0].offsetHeight\n\n      if (autoPlace) {\n        var orgPlacement = placement\n        var viewportDim = this.getPosition(this.$viewport)\n\n        placement = placement == \'bottom\' && pos.bottom + actualHeight > viewportDim.bottom ? \'top\'    :\n                    placement == \'top\'    && pos.top    - actualHeight < viewportDim.top    ? \'bottom\' :\n                    placement == \'right\'  && pos.right  + actualWidth  > viewportDim.width  ? \'left\'   :\n                    placement == \'left\'   && pos.left   - actualWidth  < viewportDim.left   ? \'right\'  :\n                    placement\n\n        $tip\n          .removeClass(orgPlacement)\n          .addClass(placement)\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\n\n      this.applyPlacement(calculatedOffset, placement)\n\n      var complete = function () {\n        var prevHoverState = that.hoverState\n        that.$element.trigger(\'shown.bs.\' + that.type)\n        that.hoverState = null\n\n        if (prevHoverState == \'out\') that.leave(that)\n      }\n\n      $.support.transition && this.$tip.hasClass(\'fade\') ?\n        $tip\n          .one(\'bsTransitionEnd\', complete)\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n        complete()\n    }\n  }\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip   = this.tip()\n    var width  = $tip[0].offsetWidth\n    var height = $tip[0].offsetHeight\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css(\'margin-top\'), 10)\n    var marginLeft = parseInt($tip.css(\'margin-left\'), 10)\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop))  marginTop  = 0\n    if (isNaN(marginLeft)) marginLeft = 0\n\n    offset.top  += marginTop\n    offset.left += marginLeft\n\n    // $.fn.offset doesn\'t round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function (props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        })\n      }\n    }, offset), 0)\n\n    $tip.addClass(\'in\')\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth  = $tip[0].offsetWidth\n    var actualHeight = $tip[0].offsetHeight\n\n    if (placement == \'top\' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\n\n    if (delta.left) offset.left += delta.left\n    else offset.top += delta.top\n\n    var isVertical          = /top|bottom/.test(placement)\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\n    var arrowOffsetPosition = isVertical ? \'offsetWidth\' : \'offsetHeight\'\n\n    $tip.offset(offset)\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\n  }\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\n    this.arrow()\n      .css(isVertical ? \'left\' : \'top\', 50 * (1 - delta / dimension) + \'%\')\n      .css(isVertical ? \'top\' : \'left\', \'\')\n  }\n\n  Tooltip.prototype.setContent = function () {\n    var $tip  = this.tip()\n    var title = this.getTitle()\n\n    $tip.find(\'.tooltip-inner\')[this.options.html ? \'html\' : \'text\'](title)\n    $tip.removeClass(\'fade in top bottom left right\')\n  }\n\n  Tooltip.prototype.hide = function (callback) {\n    var that = this\n    var $tip = $(this.$tip)\n    var e    = $.Event(\'hide.bs.\' + this.type)\n\n    function complete() {\n      if (that.hoverState != \'in\') $tip.detach()\n      that.$element\n        .removeAttr(\'aria-describedby\')\n        .trigger(\'hidden.bs.\' + that.type)\n      callback && callback()\n    }\n\n    this.$element.trigger(e)\n\n    if (e.isDefaultPrevented()) return\n\n    $tip.removeClass(\'in\')\n\n    $.support.transition && $tip.hasClass(\'fade\') ?\n      $tip\n        .one(\'bsTransitionEnd\', complete)\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n      complete()\n\n    this.hoverState = null\n\n    return this\n  }\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element\n    if ($e.attr(\'title\') || typeof $e.attr(\'data-original-title\') != \'string\') {\n      $e.attr(\'data-original-title\', $e.attr(\'title\') || \'\').attr(\'title\', \'\')\n    }\n  }\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle()\n  }\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element   = $element || this.$element\n\n    var el     = $element[0]\n    var isBody = el.tagName == \'BODY\'\n\n    var elRect    = el.getBoundingClientRect()\n    if (elRect.width == null) {\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\n    }\n    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\n\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\n  }\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == \'bottom\' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == \'top\'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == \'left\'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n        /* placement == \'right\' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\n\n  }\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 }\n    if (!this.$viewport) return delta\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\n    var viewportDimensions = this.getPosition(this.$viewport)\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\n      }\n    } else {\n      var leftEdgeOffset  = pos.left - viewportPadding\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset\n      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\n      }\n    }\n\n    return delta\n  }\n\n  Tooltip.prototype.getTitle = function () {\n    var title\n    var $e = this.$element\n    var o  = this.options\n\n    title = $e.attr(\'data-original-title\')\n      || (typeof o.title == \'function\' ? o.title.call($e[0]) :  o.title)\n\n    return title\n  }\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do prefix += ~~(Math.random() * 1000000)\n    while (document.getElementById(prefix))\n    return prefix\n  }\n\n  Tooltip.prototype.tip = function () {\n    if (!this.$tip) {\n      this.$tip = $(this.options.template)\n      if (this.$tip.length != 1) {\n        throw new Error(this.type + \' `template` option must consist of exactly 1 top-level element!\')\n      }\n    }\n    return this.$tip\n  }\n\n  Tooltip.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find(\'.tooltip-arrow\'))\n  }\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true\n  }\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false\n  }\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled\n  }\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this\n    if (e) {\n      self = $(e.currentTarget).data(\'bs.\' + this.type)\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\n        $(e.currentTarget).data(\'bs.\' + this.type, self)\n      }\n    }\n\n    if (e) {\n      self.inState.click = !self.inState.click\n      if (self.isInStateTrue()) self.enter(self)\n      else self.leave(self)\n    } else {\n      self.tip().hasClass(\'in\') ? self.leave(self) : self.enter(self)\n    }\n  }\n\n  Tooltip.prototype.destroy = function () {\n    var that = this\n    clearTimeout(this.timeout)\n    this.hide(function () {\n      that.$element.off(\'.\' + that.type).removeData(\'bs.\' + that.type)\n      if (that.$tip) {\n        that.$tip.detach()\n      }\n      that.$tip = null\n      that.$arrow = null\n      that.$viewport = null\n    })\n  }\n\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.tooltip\')\n      var options = typeof option == \'object\' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data(\'bs.tooltip\', (data = new Tooltip(this, options)))\n      if (typeof option == \'string\') data[option]()\n    })\n  }\n\n  var old = $.fn.tooltip\n\n  $.fn.tooltip             = Plugin\n  $.fn.tooltip.Constructor = Tooltip\n\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old\n    return this\n  }\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/popover.js*/
define('bootstrap@3.3.6#js/popover.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: popover.js v3.3.6\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Popover = function (element, options) {\n    this.init(\'popover\', element, options)\n  }\n\n  if (!$.fn.tooltip) throw new Error(\'Popover requires tooltip.js\')\n\n  Popover.VERSION  = \'3.3.6\'\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: \'right\',\n    trigger: \'click\',\n    content: \'\',\n    template: \'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>\'\n  })\n\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\n\n  Popover.prototype.constructor = Popover\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS\n  }\n\n  Popover.prototype.setContent = function () {\n    var $tip    = this.tip()\n    var title   = this.getTitle()\n    var content = this.getContent()\n\n    $tip.find(\'.popover-title\')[this.options.html ? \'html\' : \'text\'](title)\n    $tip.find(\'.popover-content\').children().detach().end()[ // we use append for html objects to maintain js events\n      this.options.html ? (typeof content == \'string\' ? \'html\' : \'append\') : \'text\'\n    ](content)\n\n    $tip.removeClass(\'fade top bottom left right in\')\n\n    // IE8 doesn\'t accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find(\'.popover-title\').html()) $tip.find(\'.popover-title\').hide()\n  }\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent()\n  }\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element\n    var o  = this.options\n\n    return $e.attr(\'data-content\')\n      || (typeof o.content == \'function\' ?\n            o.content.call($e[0]) :\n            o.content)\n  }\n\n  Popover.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find(\'.arrow\'))\n  }\n\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.popover\')\n      var options = typeof option == \'object\' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data(\'bs.popover\', (data = new Popover(this, options)))\n      if (typeof option == \'string\') data[option]()\n    })\n  }\n\n  var old = $.fn.popover\n\n  $.fn.popover             = Plugin\n  $.fn.popover.Constructor = Popover\n\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old\n    return this\n  }\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/scrollspy.js*/
define('bootstrap@3.3.6#js/scrollspy.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: scrollspy.js v3.3.6\n * http://getbootstrap.com/javascript/#scrollspy\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // SCROLLSPY CLASS DEFINITION\n  // ==========================\n\n  function ScrollSpy(element, options) {\n    this.$body          = $(document.body)\n    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\n    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\n    this.selector       = (this.options.target || \'\') + \' .nav li > a\'\n    this.offsets        = []\n    this.targets        = []\n    this.activeTarget   = null\n    this.scrollHeight   = 0\n\n    this.$scrollElement.on(\'scroll.bs.scrollspy\', $.proxy(this.process, this))\n    this.refresh()\n    this.process()\n  }\n\n  ScrollSpy.VERSION  = \'3.3.6\'\n\n  ScrollSpy.DEFAULTS = {\n    offset: 10\n  }\n\n  ScrollSpy.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\n  }\n\n  ScrollSpy.prototype.refresh = function () {\n    var that          = this\n    var offsetMethod  = \'offset\'\n    var offsetBase    = 0\n\n    this.offsets      = []\n    this.targets      = []\n    this.scrollHeight = this.getScrollHeight()\n\n    if (!$.isWindow(this.$scrollElement[0])) {\n      offsetMethod = \'position\'\n      offsetBase   = this.$scrollElement.scrollTop()\n    }\n\n    this.$body\n      .find(this.selector)\n      .map(function () {\n        var $el   = $(this)\n        var href  = $el.data(\'target\') || $el.attr(\'href\')\n        var $href = /^#./.test(href) && $(href)\n\n        return ($href\n          && $href.length\n          && $href.is(\':visible\')\n          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\n      })\n      .sort(function (a, b) { return a[0] - b[0] })\n      .each(function () {\n        that.offsets.push(this[0])\n        that.targets.push(this[1])\n      })\n  }\n\n  ScrollSpy.prototype.process = function () {\n    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\n    var scrollHeight = this.getScrollHeight()\n    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\n    var offsets      = this.offsets\n    var targets      = this.targets\n    var activeTarget = this.activeTarget\n    var i\n\n    if (this.scrollHeight != scrollHeight) {\n      this.refresh()\n    }\n\n    if (scrollTop >= maxScroll) {\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\n    }\n\n    if (activeTarget && scrollTop < offsets[0]) {\n      this.activeTarget = null\n      return this.clear()\n    }\n\n    for (i = offsets.length; i--;) {\n      activeTarget != targets[i]\n        && scrollTop >= offsets[i]\n        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])\n        && this.activate(targets[i])\n    }\n  }\n\n  ScrollSpy.prototype.activate = function (target) {\n    this.activeTarget = target\n\n    this.clear()\n\n    var selector = this.selector +\n      \'[data-target="\' + target + \'"],\' +\n      this.selector + \'[href="\' + target + \'"]\'\n\n    var active = $(selector)\n      .parents(\'li\')\n      .addClass(\'active\')\n\n    if (active.parent(\'.dropdown-menu\').length) {\n      active = active\n        .closest(\'li.dropdown\')\n        .addClass(\'active\')\n    }\n\n    active.trigger(\'activate.bs.scrollspy\')\n  }\n\n  ScrollSpy.prototype.clear = function () {\n    $(this.selector)\n      .parentsUntil(this.options.target, \'.active\')\n      .removeClass(\'active\')\n  }\n\n\n  // SCROLLSPY PLUGIN DEFINITION\n  // ===========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.scrollspy\')\n      var options = typeof option == \'object\' && option\n\n      if (!data) $this.data(\'bs.scrollspy\', (data = new ScrollSpy(this, options)))\n      if (typeof option == \'string\') data[option]()\n    })\n  }\n\n  var old = $.fn.scrollspy\n\n  $.fn.scrollspy             = Plugin\n  $.fn.scrollspy.Constructor = ScrollSpy\n\n\n  // SCROLLSPY NO CONFLICT\n  // =====================\n\n  $.fn.scrollspy.noConflict = function () {\n    $.fn.scrollspy = old\n    return this\n  }\n\n\n  // SCROLLSPY DATA-API\n  // ==================\n\n  $(window).on(\'load.bs.scrollspy.data-api\', function () {\n    $(\'[data-spy="scroll"]\').each(function () {\n      var $spy = $(this)\n      Plugin.call($spy, $spy.data())\n    })\n  })\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/tab.js*/
define('bootstrap@3.3.6#js/tab.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: tab.js v3.3.6\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // TAB CLASS DEFINITION\n  // ====================\n\n  var Tab = function (element) {\n    // jscs:disable requireDollarBeforejQueryAssignment\n    this.element = $(element)\n    // jscs:enable requireDollarBeforejQueryAssignment\n  }\n\n  Tab.VERSION = \'3.3.6\'\n\n  Tab.TRANSITION_DURATION = 150\n\n  Tab.prototype.show = function () {\n    var $this    = this.element\n    var $ul      = $this.closest(\'ul:not(.dropdown-menu)\')\n    var selector = $this.data(\'target\')\n\n    if (!selector) {\n      selector = $this.attr(\'href\')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, \'\') // strip for ie7\n    }\n\n    if ($this.parent(\'li\').hasClass(\'active\')) return\n\n    var $previous = $ul.find(\'.active:last a\')\n    var hideEvent = $.Event(\'hide.bs.tab\', {\n      relatedTarget: $this[0]\n    })\n    var showEvent = $.Event(\'show.bs.tab\', {\n      relatedTarget: $previous[0]\n    })\n\n    $previous.trigger(hideEvent)\n    $this.trigger(showEvent)\n\n    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\n\n    var $target = $(selector)\n\n    this.activate($this.closest(\'li\'), $ul)\n    this.activate($target, $target.parent(), function () {\n      $previous.trigger({\n        type: \'hidden.bs.tab\',\n        relatedTarget: $this[0]\n      })\n      $this.trigger({\n        type: \'shown.bs.tab\',\n        relatedTarget: $previous[0]\n      })\n    })\n  }\n\n  Tab.prototype.activate = function (element, container, callback) {\n    var $active    = container.find(\'> .active\')\n    var transition = callback\n      && $.support.transition\n      && ($active.length && $active.hasClass(\'fade\') || !!container.find(\'> .fade\').length)\n\n    function next() {\n      $active\n        .removeClass(\'active\')\n        .find(\'> .dropdown-menu > .active\')\n          .removeClass(\'active\')\n        .end()\n        .find(\'[data-toggle="tab"]\')\n          .attr(\'aria-expanded\', false)\n\n      element\n        .addClass(\'active\')\n        .find(\'[data-toggle="tab"]\')\n          .attr(\'aria-expanded\', true)\n\n      if (transition) {\n        element[0].offsetWidth // reflow for transition\n        element.addClass(\'in\')\n      } else {\n        element.removeClass(\'fade\')\n      }\n\n      if (element.parent(\'.dropdown-menu\').length) {\n        element\n          .closest(\'li.dropdown\')\n            .addClass(\'active\')\n          .end()\n          .find(\'[data-toggle="tab"]\')\n            .attr(\'aria-expanded\', true)\n      }\n\n      callback && callback()\n    }\n\n    $active.length && transition ?\n      $active\n        .one(\'bsTransitionEnd\', next)\n        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\n      next()\n\n    $active.removeClass(\'in\')\n  }\n\n\n  // TAB PLUGIN DEFINITION\n  // =====================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data(\'bs.tab\')\n\n      if (!data) $this.data(\'bs.tab\', (data = new Tab(this)))\n      if (typeof option == \'string\') data[option]()\n    })\n  }\n\n  var old = $.fn.tab\n\n  $.fn.tab             = Plugin\n  $.fn.tab.Constructor = Tab\n\n\n  // TAB NO CONFLICT\n  // ===============\n\n  $.fn.tab.noConflict = function () {\n    $.fn.tab = old\n    return this\n  }\n\n\n  // TAB DATA-API\n  // ============\n\n  var clickHandler = function (e) {\n    e.preventDefault()\n    Plugin.call($(this), \'show\')\n  }\n\n  $(document)\n    .on(\'click.bs.tab.data-api\', \'[data-toggle="tab"]\', clickHandler)\n    .on(\'click.bs.tab.data-api\', \'[data-toggle="pill"]\', clickHandler)\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#js/affix.js*/
define('bootstrap@3.3.6#js/affix.js', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* ========================================================================\n * Bootstrap: affix.js v3.3.6\n * http://getbootstrap.com/javascript/#affix\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  \'use strict\';\n\n  // AFFIX CLASS DEFINITION\n  // ======================\n\n  var Affix = function (element, options) {\n    this.options = $.extend({}, Affix.DEFAULTS, options)\n\n    this.$target = $(this.options.target)\n      .on(\'scroll.bs.affix.data-api\', $.proxy(this.checkPosition, this))\n      .on(\'click.bs.affix.data-api\',  $.proxy(this.checkPositionWithEventLoop, this))\n\n    this.$element     = $(element)\n    this.affixed      = null\n    this.unpin        = null\n    this.pinnedOffset = null\n\n    this.checkPosition()\n  }\n\n  Affix.VERSION  = \'3.3.6\'\n\n  Affix.RESET    = \'affix affix-top affix-bottom\'\n\n  Affix.DEFAULTS = {\n    offset: 0,\n    target: window\n  }\n\n  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\n    var scrollTop    = this.$target.scrollTop()\n    var position     = this.$element.offset()\n    var targetHeight = this.$target.height()\n\n    if (offsetTop != null && this.affixed == \'top\') return scrollTop < offsetTop ? \'top\' : false\n\n    if (this.affixed == \'bottom\') {\n      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : \'bottom\'\n      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : \'bottom\'\n    }\n\n    var initializing   = this.affixed == null\n    var colliderTop    = initializing ? scrollTop : position.top\n    var colliderHeight = initializing ? targetHeight : height\n\n    if (offsetTop != null && scrollTop <= offsetTop) return \'top\'\n    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return \'bottom\'\n\n    return false\n  }\n\n  Affix.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset\n    this.$element.removeClass(Affix.RESET).addClass(\'affix\')\n    var scrollTop = this.$target.scrollTop()\n    var position  = this.$element.offset()\n    return (this.pinnedOffset = position.top - scrollTop)\n  }\n\n  Affix.prototype.checkPositionWithEventLoop = function () {\n    setTimeout($.proxy(this.checkPosition, this), 1)\n  }\n\n  Affix.prototype.checkPosition = function () {\n    if (!this.$element.is(\':visible\')) return\n\n    var height       = this.$element.height()\n    var offset       = this.options.offset\n    var offsetTop    = offset.top\n    var offsetBottom = offset.bottom\n    var scrollHeight = Math.max($(document).height(), $(document.body).height())\n\n    if (typeof offset != \'object\')         offsetBottom = offsetTop = offset\n    if (typeof offsetTop == \'function\')    offsetTop    = offset.top(this.$element)\n    if (typeof offsetBottom == \'function\') offsetBottom = offset.bottom(this.$element)\n\n    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\n\n    if (this.affixed != affix) {\n      if (this.unpin != null) this.$element.css(\'top\', \'\')\n\n      var affixType = \'affix\' + (affix ? \'-\' + affix : \'\')\n      var e         = $.Event(affixType + \'.bs.affix\')\n\n      this.$element.trigger(e)\n\n      if (e.isDefaultPrevented()) return\n\n      this.affixed = affix\n      this.unpin = affix == \'bottom\' ? this.getPinnedOffset() : null\n\n      this.$element\n        .removeClass(Affix.RESET)\n        .addClass(affixType)\n        .trigger(affixType.replace(\'affix\', \'affixed\') + \'.bs.affix\')\n    }\n\n    if (affix == \'bottom\') {\n      this.$element.offset({\n        top: scrollHeight - height - offsetBottom\n      })\n    }\n  }\n\n\n  // AFFIX PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data(\'bs.affix\')\n      var options = typeof option == \'object\' && option\n\n      if (!data) $this.data(\'bs.affix\', (data = new Affix(this, options)))\n      if (typeof option == \'string\') data[option]()\n    })\n  }\n\n  var old = $.fn.affix\n\n  $.fn.affix             = Plugin\n  $.fn.affix.Constructor = Affix\n\n\n  // AFFIX NO CONFLICT\n  // =================\n\n  $.fn.affix.noConflict = function () {\n    $.fn.affix = old\n    return this\n  }\n\n\n  // AFFIX DATA-API\n  // ==============\n\n  $(window).on(\'load\', function () {\n    $(\'[data-spy="affix"]\').each(function () {\n      var $spy = $(this)\n      var data = $spy.data()\n\n      data.offset = data.offset || {}\n\n      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\n      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\n\n      Plugin.call($spy, data)\n    })\n  })\n\n}(jQuery);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*bootstrap@3.3.6#dist/js/npm*/
define('bootstrap@3.3.6#dist/js/npm', function (require, exports, module) {
    require('../../js/transition.js');
    require('../../js/alert.js');
    require('../../js/button.js');
    require('../../js/carousel.js');
    require('../../js/collapse.js');
    require('../../js/dropdown.js');
    require('../../js/modal.js');
    require('../../js/tooltip.js');
    require('../../js/popover.js');
    require('../../js/scrollspy.js');
    require('../../js/tab.js');
    require('../../js/affix.js');
});
/*angular-ui-bootstrap@0.14.3#ui-bootstrap-tpls*/
define('angular-ui-bootstrap@0.14.3#ui-bootstrap-tpls', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 0.14.3 - 2015-10-23\n * License: MIT\n */\nangular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);\nangular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-popup.html","template/tooltip/tooltip-popup.html","template/tooltip/tooltip-template-popup.html","template/popover/popover-html.html","template/popover/popover-template.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);\nangular.module(\'ui.bootstrap.collapse\', [])\n\n  .directive(\'uibCollapse\', [\'$animate\', \'$injector\', function($animate, $injector) {\n    var $animateCss = $injector.has(\'$animateCss\') ? $injector.get(\'$animateCss\') : null;\n    return {\n      link: function(scope, element, attrs) {\n        function expand() {\n          element.removeClass(\'collapse\')\n            .addClass(\'collapsing\')\n            .attr(\'aria-expanded\', true)\n            .attr(\'aria-hidden\', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: \'in\',\n              easing: \'ease\',\n              to: { height: element[0].scrollHeight + \'px\' }\n            }).start().finally(expandDone);\n          } else {\n            $animate.addClass(element, \'in\', {\n              to: { height: element[0].scrollHeight + \'px\' }\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass(\'collapsing\')\n            .addClass(\'collapse\')\n            .css({height: \'auto\'});\n        }\n\n        function collapse() {\n          if (!element.hasClass(\'collapse\') && !element.hasClass(\'in\')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding "collapsing" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + \'px\'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass(\'collapse\')\n            .addClass(\'collapsing\')\n            .attr(\'aria-expanded\', false)\n            .attr(\'aria-hidden\', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: \'in\',\n              to: {height: \'0\'}\n            }).start().finally(collapseDone);\n          } else {\n            $animate.removeClass(element, \'in\', {\n              to: {height: \'0\'}\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: \'0\'}); // Required so that collapse works when animation is disabled\n          element.removeClass(\'collapsing\')\n            .addClass(\'collapse\');\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\n/* Deprecated collapse below */\n\nangular.module(\'ui.bootstrap.collapse\')\n\n  .value(\'$collapseSuppressWarning\', false)\n\n  .directive(\'collapse\', [\'$animate\', \'$injector\', \'$log\', \'$collapseSuppressWarning\', function($animate, $injector, $log, $collapseSuppressWarning) {\n    var $animateCss = $injector.has(\'$animateCss\') ? $injector.get(\'$animateCss\') : null;\n    return {\n      link: function(scope, element, attrs) {\n        if (!$collapseSuppressWarning) {\n          $log.warn(\'collapse is now deprecated. Use uib-collapse instead.\');\n        }\n\n        function expand() {\n          element.removeClass(\'collapse\')\n            .addClass(\'collapsing\')\n            .attr(\'aria-expanded\', true)\n            .attr(\'aria-hidden\', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              easing: \'ease\',\n              to: { height: element[0].scrollHeight + \'px\' }\n            }).start().done(expandDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: element[0].scrollHeight + \'px\'\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass(\'collapsing\')\n            .addClass(\'collapse in\')\n            .css({height: \'auto\'});\n        }\n\n        function collapse() {\n          if (!element.hasClass(\'collapse\') && !element.hasClass(\'in\')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding "collapsing" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + \'px\'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass(\'collapse in\')\n            .addClass(\'collapsing\')\n            .attr(\'aria-expanded\', false)\n            .attr(\'aria-hidden\', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              to: {height: \'0\'}\n            }).start().done(collapseDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: \'0\'\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: \'0\'}); // Required so that collapse works when animation is disabled\n          element.removeClass(\'collapsing\')\n            .addClass(\'collapse\');\n        }\n\n        scope.$watch(attrs.collapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module(\'ui.bootstrap.accordion\', [\'ui.bootstrap.collapse\'])\n\n.constant(\'uibAccordionConfig\', {\n  closeOthers: true\n})\n\n.controller(\'UibAccordionController\', [\'$scope\', \'$attrs\', \'uibAccordionConfig\', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on(\'$destroy\', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive(\'uibAccordion\', function() {\n  return {\n    controller: \'UibAccordionController\',\n    controllerAs: \'accordion\',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/accordion/accordion.html\';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive(\'uibAccordionGroup\', function() {\n  return {\n    require: \'^uibAccordion\',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/accordion/accordion-group.html\';\n    },\n    scope: {\n      heading: \'@\',               // Interpolate the heading attribute onto this scope\n      isOpen: \'=?\',\n      isDisabled: \'=?\'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || \'panel-open\';\n      scope.panelClass = attrs.panelClass;\n      scope.$watch(\'isOpen\', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive(\'uibAccordionHeading\', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: \'\',       // In effect remove this element!\n    replace: true,\n    require: \'^uibAccordionGroup\',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive(\'uibAccordionTransclude\', function() {\n  return {\n    require: [\'?^uibAccordionGroup\', \'?^accordionGroup\'],\n    link: function(scope, element, attrs, controller) {\n      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          element.find(\'span\').html(\'\');\n          element.find(\'span\').append(heading);\n        }\n      });\n    }\n  };\n});\n\n/* Deprecated accordion below */\n\nangular.module(\'ui.bootstrap.accordion\')\n\n  .value(\'$accordionSuppressWarning\', false)\n\n  .controller(\'AccordionController\', [\'$scope\', \'$attrs\', \'$controller\', \'$log\', \'$accordionSuppressWarning\', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {\n    if (!$accordionSuppressWarning) {\n      $log.warn(\'AccordionController is now deprecated. Use UibAccordionController instead.\');\n    }\n\n    angular.extend(this, $controller(\'UibAccordionController\', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive(\'accordion\', [\'$log\', \'$accordionSuppressWarning\', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: \'EA\',\n      controller: \'AccordionController\',\n      controllerAs: \'accordion\',\n      transclude: true,\n      replace: false,\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || \'template/accordion/accordion.html\';\n      },\n      link: function() {\n        if (!$accordionSuppressWarning) {\n          $log.warn(\'accordion is now deprecated. Use uib-accordion instead.\');\n        }\n      }\n    };\n  }])\n\n  .directive(\'accordionGroup\', [\'$log\', \'$accordionSuppressWarning\', function($log, $accordionSuppressWarning) {\n    return {\n      require: \'^accordion\',         // We need this directive to be inside an accordion\n      restrict: \'EA\',\n      transclude: true,              // It transcludes the contents of the directive into the template\n      replace: true,                // The element containing the directive will be replaced with the template\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || \'template/accordion/accordion-group.html\';\n      },\n      scope: {\n        heading: \'@\',               // Interpolate the heading attribute onto this scope\n        isOpen: \'=?\',\n        isDisabled: \'=?\'\n      },\n      controller: function() {\n        this.setHeading = function(element) {\n          this.heading = element;\n        };\n      },\n      link: function(scope, element, attrs, accordionCtrl) {\n        if (!$accordionSuppressWarning) {\n          $log.warn(\'accordion-group is now deprecated. Use uib-accordion-group instead.\');\n        }\n\n        accordionCtrl.addGroup(scope);\n\n        scope.openClass = attrs.openClass || \'panel-open\';\n        scope.panelClass = attrs.panelClass;\n        scope.$watch(\'isOpen\', function(value) {\n          element.toggleClass(scope.openClass, !!value);\n          if (value) {\n            accordionCtrl.closeOthers(scope);\n          }\n        });\n\n        scope.toggleOpen = function($event) {\n          if (!scope.isDisabled) {\n            if (!$event || $event.which === 32) {\n              scope.isOpen = !scope.isOpen;\n            }\n          }\n        };\n      }\n    };\n  }])\n\n  .directive(\'accordionHeading\', [\'$log\', \'$accordionSuppressWarning\', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: \'EA\',\n      transclude: true,   // Grab the contents to be used as the heading\n      template: \'\',       // In effect remove this element!\n      replace: true,\n      require: \'^accordionGroup\',\n      link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n        if (!$accordionSuppressWarning) {\n          $log.warn(\'accordion-heading is now deprecated. Use uib-accordion-heading instead.\');\n        }\n        // Pass the heading to the accordion-group controller\n        // so that it can be transcluded into the right place in the template\n        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n      }\n    };\n  }])\n\n  .directive(\'accordionTransclude\', [\'$log\', \'$accordionSuppressWarning\', function($log, $accordionSuppressWarning) {\n    return {\n      require: \'^accordionGroup\',\n      link: function(scope, element, attr, controller) {\n        if (!$accordionSuppressWarning) {\n          $log.warn(\'accordion-transclude is now deprecated. Use uib-accordion-transclude instead.\');\n        }\n\n        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n          if (heading) {\n            element.find(\'span\').html(\'\');\n            element.find(\'span\').append(heading);\n          }\n        });\n      }\n    };\n  }]);\n\n\nangular.module(\'ui.bootstrap.alert\', [])\n\n.controller(\'UibAlertController\', [\'$scope\', \'$attrs\', \'$interpolate\', \'$timeout\', function($scope, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive(\'uibAlert\', function() {\n  return {\n    controller: \'UibAlertController\',\n    controllerAs: \'alert\',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/alert/alert.html\';\n    },\n    transclude: true,\n    replace: true,\n    scope: {\n      type: \'@\',\n      close: \'&\'\n    }\n  };\n});\n\n/* Deprecated alert below */\n\nangular.module(\'ui.bootstrap.alert\')\n\n  .value(\'$alertSuppressWarning\', false)\n\n  .controller(\'AlertController\', [\'$scope\', \'$attrs\', \'$controller\', \'$log\', \'$alertSuppressWarning\', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {\n    if (!$alertSuppressWarning) {\n      $log.warn(\'AlertController is now deprecated. Use UibAlertController instead.\');\n    }\n\n    angular.extend(this, $controller(\'UibAlertController\', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive(\'alert\', [\'$log\', \'$alertSuppressWarning\', function($log, $alertSuppressWarning) {\n    return {\n      controller: \'AlertController\',\n      controllerAs: \'alert\',\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || \'template/alert/alert.html\';\n      },\n      transclude: true,\n      replace: true,\n      scope: {\n        type: \'@\',\n        close: \'&\'\n      },\n      link: function() {\n        if (!$alertSuppressWarning) {\n          $log.warn(\'alert is now deprecated. Use uib-alert instead.\');\n        }\n      }\n    };\n  }]);\n\nangular.module(\'ui.bootstrap.buttons\', [])\n\n.constant(\'uibButtonConfig\', {\n  activeClass: \'active\',\n  toggleEvent: \'click\'\n})\n\n.controller(\'UibButtonsController\', [\'uibButtonConfig\', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || \'active\';\n  this.toggleEvent = buttonConfig.toggleEvent || \'click\';\n}])\n\n.directive(\'uibBtnRadio\', function() {\n  return {\n    require: [\'uibBtnRadio\', \'ngModel\'],\n    controller: \'UibButtonsController\',\n    controllerAs: \'buttons\',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find(\'input\').css({display: \'none\'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n})\n\n.directive(\'uibBtnCheckbox\', function() {\n  return {\n    require: [\'uibBtnCheckbox\', \'ngModel\'],\n    controller: \'UibButtonsController\',\n    controllerAs: \'button\',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find(\'input\').css({display: \'none\'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\n/* Deprecated buttons below */\n\nangular.module(\'ui.bootstrap.buttons\')\n\n  .value(\'$buttonsSuppressWarning\', false)\n\n  .controller(\'ButtonsController\', [\'$controller\', \'$log\', \'$buttonsSuppressWarning\', function($controller, $log, $buttonsSuppressWarning) {\n    if (!$buttonsSuppressWarning) {\n      $log.warn(\'ButtonsController is now deprecated. Use UibButtonsController instead.\');\n    }\n\n    angular.extend(this, $controller(\'UibButtonsController\'));\n  }])\n\n  .directive(\'btnRadio\', [\'$log\', \'$buttonsSuppressWarning\', function($log, $buttonsSuppressWarning) {\n    return {\n      require: [\'btnRadio\', \'ngModel\'],\n      controller: \'ButtonsController\',\n      controllerAs: \'buttons\',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn(\'btn-radio is now deprecated. Use uib-btn-radio instead.\');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find(\'input\').css({display: \'none\'});\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n          if (!isActive || angular.isDefined(attrs.uncheckable)) {\n            scope.$apply(function() {\n              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n              ngModelCtrl.$render();\n            });\n          }\n        });\n      }\n    };\n  }])\n\n  .directive(\'btnCheckbox\', [\'$document\', \'$log\', \'$buttonsSuppressWarning\', function($document, $log, $buttonsSuppressWarning) {\n    return {\n      require: [\'btnCheckbox\', \'ngModel\'],\n      controller: \'ButtonsController\',\n      controllerAs: \'button\',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn(\'btn-checkbox is now deprecated. Use uib-btn-checkbox instead.\');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find(\'input\').css({display: \'none\'});\n\n        function getTrueValue() {\n          return getCheckboxValue(attrs.btnCheckboxTrue, true);\n        }\n\n        function getFalseValue() {\n          return getCheckboxValue(attrs.btnCheckboxFalse, false);\n        }\n\n        function getCheckboxValue(attributeValue, defaultValue) {\n          var val = scope.$eval(attributeValue);\n          return angular.isDefined(val) ? val : defaultValue;\n        }\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n\n        //accessibility\n        element.on(\'keypress\', function(e) {\n          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n      }\n    };\n  }]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.carousel\n *\n * @description\n * AngularJS version of an image carousel.\n *\n */\nangular.module(\'ui.bootstrap.carousel\', [])\n\n.controller(\'UibCarouselController\', [\'$scope\', \'$element\', \'$interval\', \'$animate\', function($scope, $element, $interval, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    NEW_ANIMATE = angular.version.minor >= 4,\n    NO_TRANSITION = \'uib-noTransition\',\n    SLIDE_DIRECTION = \'uib-slideDirection\',\n    currentIndex = -1,\n    currentInterval, isPlaying;\n  self.currentSlide = null;\n\n  var destroyed = false;\n  /* direction: "prev" or "next" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = $scope.indexOfSlide(nextSlide);\n    //Decide direction if it\'s not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? \'next\' : \'prev\';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n      goNext(nextSlide, nextIndex, direction);\n    }\n  };\n\n  function goNext(slide, index, direction) {\n    // Scope has been destroyed, stop here.\n    if (destroyed) { return; }\n\n    angular.extend(slide, {direction: direction, active: true});\n    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&\n      slide.$element && self.slides.length > 1) {\n      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n      if (self.currentSlide && self.currentSlide.$element) {\n        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      if (NEW_ANIMATE) {\n        $animate.on(\'addClass\', slide.$element, function(element, phase) {\n          if (phase === \'close\') {\n            $scope.$currentTransition = null;\n            $animate.off(\'addClass\', element);\n          }\n        });\n      } else {\n        slide.$element.one(\'$animate:close\', function closeFn() {\n          $scope.$currentTransition = null;\n        });\n      }\n    }\n\n    self.currentSlide = slide;\n    currentIndex = index;\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  $scope.$on(\'$destroy\', function() {\n    destroyed = true;\n  });\n\n  function getSlideByIndex(index) {\n    if (angular.isUndefined(slides[index].index)) {\n      return slides[index];\n    }\n    var i, len = slides.length;\n    for (i = 0; i < slides.length; ++i) {\n      if (slides[i].index == index) {\n        return slides[i];\n      }\n    }\n  }\n\n  self.getCurrentIndex = function() {\n    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n      return +self.currentSlide.index;\n    }\n    return currentIndex;\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n  };\n\n  $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), \'next\');\n  };\n\n  $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), \'prev\');\n  };\n\n  $scope.isActive = function(slide) {\n     return self.currentSlide === slide;\n  };\n\n  $scope.$watch(\'interval\', restartTimer);\n  $scope.$watchCollection(\'slides\', resetTransition);\n  $scope.$on(\'$destroy\', resetTimer);\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n    }\n  }\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  self.addSlide = function(slide, element) {\n    slide.$element = element;\n    slides.push(slide);\n    //if this is the first slide or the slide is set to active, select it\n    if (slides.length === 1 || slide.active) {\n      self.select(slides[slides.length - 1]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    } else {\n      slide.active = false;\n    }\n  };\n\n  self.removeSlide = function(slide) {\n    if (angular.isDefined(slide.index)) {\n      slides.sort(function(a, b) {\n        return +a.index > +b.index;\n      });\n    }\n    //get the index of the slide inside the carousel\n    var index = slides.indexOf(slide);\n    slides.splice(index, 1);\n    if (slides.length > 0 && slide.active) {\n      if (index >= slides.length) {\n        self.select(slides[index - 1]);\n      } else {\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n    }\n\n    //clean the currentSlide when no more slide\n    if (slides.length === 0) {\n      self.currentSlide = null;\n    }\n  };\n\n  $scope.$watch(\'noTransition\', function(noTransition) {\n    $element.data(NO_TRANSITION, noTransition);\n  });\n\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:carousel\n * @restrict EA\n *\n * @description\n * Carousel is the outer container for a set of image \'slides\' to showcase.\n *\n * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n *\n * @example\n<example module="ui.bootstrap">\n  <file name="index.html">\n    <uib-carousel>\n      <uib-slide>\n        <img src="http://placekitten.com/150/150" style="margin:auto;">\n        <div class="carousel-caption">\n          <p>Beautiful!</p>\n        </div>\n      </uib-slide>\n      <uib-slide>\n        <img src="http://placekitten.com/100/150" style="margin:auto;">\n        <div class="carousel-caption">\n          <p>D\'aww!</p>\n        </div>\n      </uib-slide>\n    </uib-carousel>\n  </file>\n  <file name="demo.css">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n */\n.directive(\'uibCarousel\', [function() {\n  return {\n    transclude: true,\n    replace: true,\n    controller: \'UibCarouselController\',\n    controllerAs: \'carousel\',\n    require: \'carousel\',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/carousel/carousel.html\';\n    },\n    scope: {\n      interval: \'=\',\n      noTransition: \'=\',\n      noPause: \'=\',\n      noWrap: \'&\'\n    }\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:slide\n * @restrict EA\n *\n * @description\n * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n *\n * @param {boolean=} active Model binding, whether or not this slide is currently active.\n * @param {number=} index The index of the slide. The slides will be sorted by this parameter.\n *\n * @example\n<example module="ui.bootstrap">\n  <file name="index.html">\n<div ng-controller="CarouselDemoCtrl">\n  <uib-carousel>\n    <uib-slide ng-repeat="slide in slides" active="slide.active" index="$index">\n      <img ng-src="{{slide.image}}" style="margin:auto;">\n      <div class="carousel-caption">\n        <h4>Slide {{$index}}</h4>\n        <p>{{slide.text}}</p>\n      </div>\n    </uib-slide>\n  </uib-carousel>\n  Interval, in milliseconds: <input type="number" ng-model="myInterval">\n  <br />Enter a negative number to stop the interval.\n</div>\n  </file>\n  <file name="script.js">\nfunction CarouselDemoCtrl($scope) {\n  $scope.myInterval = 5000;\n}\n  </file>\n  <file name="demo.css">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n*/\n\n.directive(\'uibSlide\', function() {\n  return {\n    require: \'^uibCarousel\',\n    restrict: \'EA\',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/carousel/slide.html\';\n    },\n    scope: {\n      active: \'=?\',\n      actual: \'=?\',\n      index: \'=?\'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on(\'$destroy\', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch(\'active\', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n})\n\n.animation(\'.item\', [\n         \'$injector\', \'$animate\',\nfunction ($injector, $animate) {\n  var NO_TRANSITION = \'uib-noTransition\',\n    SLIDE_DIRECTION = \'uib-slideDirection\',\n    $animateCss = null;\n\n  if ($injector.has(\'$animateCss\')) {\n    $animateCss = $injector.get(\'$animateCss\');\n  }\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      // Due to transclusion, noTransition property is on parent\'s scope\n      if (className == \'active\' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == \'next\' ? \'left\' : \'right\';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + \' \' + direction, done);\n        element.addClass(direction);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function () {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n\n        return function () {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      // Due to transclusion, noTransition property is on parent\'s scope\n      if (className === \'active\' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == \'next\' ? \'left\' : \'right\';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function() {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\n/* deprecated carousel below */\n\nangular.module(\'ui.bootstrap.carousel\')\n\n.value(\'$carouselSuppressWarning\', false)\n\n.controller(\'CarouselController\', [\'$scope\', \'$element\', \'$controller\', \'$log\', \'$carouselSuppressWarning\', function($scope, $element, $controller, $log, $carouselSuppressWarning) {\n  if (!$carouselSuppressWarning) {\n    $log.warn(\'CarouselController is now deprecated. Use UibCarouselController instead.\');\n  }\n\n  angular.extend(this, $controller(\'UibCarouselController\', {\n    $scope: $scope,\n    $element: $element\n  }));\n}])\n\n.directive(\'carousel\', [\'$log\', \'$carouselSuppressWarning\', function($log, $carouselSuppressWarning) {\n  return {\n    transclude: true,\n    replace: true,\n    controller: \'CarouselController\',\n    controllerAs: \'carousel\',\n    require: \'carousel\',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/carousel/carousel.html\';\n    },\n    scope: {\n      interval: \'=\',\n      noTransition: \'=\',\n      noPause: \'=\',\n      noWrap: \'&\'\n    },\n    link: function() {\n      if (!$carouselSuppressWarning) {\n        $log.warn(\'carousel is now deprecated. Use uib-carousel instead.\');\n      }\n    }\n  };\n}])\n\n.directive(\'slide\', [\'$log\', \'$carouselSuppressWarning\', function($log, $carouselSuppressWarning) {\n  return {\n    require: \'^carousel\',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/carousel/slide.html\';\n    },\n    scope: {\n      active: \'=?\',\n      actual: \'=?\',\n      index: \'=?\'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      if (!$carouselSuppressWarning) {\n        $log.warn(\'slide is now deprecated. Use uib-slide instead.\');\n      }\n\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on(\'$destroy\', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch(\'active\', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n}]);\n\nangular.module(\'ui.bootstrap.dateparser\', [])\n\n.service(\'uibDateParser\', [\'$log\', \'$locale\', \'orderByFilter\', function($log, $locale, orderByFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n\n    formatCodeToRegex = {\n      \'yyyy\': {\n        regex: \'\\\\d{4}\',\n        apply: function(value) { this.year = +value; }\n      },\n      \'yy\': {\n        regex: \'\\\\d{2}\',\n        apply: function(value) { this.year = +value + 2000; }\n      },\n      \'y\': {\n        regex: \'\\\\d{1,4}\',\n        apply: function(value) { this.year = +value; }\n      },\n      \'MMMM\': {\n        regex: $locale.DATETIME_FORMATS.MONTH.join(\'|\'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n      },\n      \'MMM\': {\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join(\'|\'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n      },\n      \'MM\': {\n        regex: \'0[1-9]|1[0-2]\',\n        apply: function(value) { this.month = value - 1; }\n      },\n      \'M\': {\n        regex: \'[1-9]|1[0-2]\',\n        apply: function(value) { this.month = value - 1; }\n      },\n      \'dd\': {\n        regex: \'[0-2][0-9]{1}|3[0-1]{1}\',\n        apply: function(value) { this.date = +value; }\n      },\n      \'d\': {\n        regex: \'[1-2]?[0-9]{1}|3[0-1]{1}\',\n        apply: function(value) { this.date = +value; }\n      },\n      \'EEEE\': {\n        regex: $locale.DATETIME_FORMATS.DAY.join(\'|\')\n      },\n      \'EEE\': {\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join(\'|\')\n      },\n      \'HH\': {\n        regex: \'(?:0|1)[0-9]|2[0-3]\',\n        apply: function(value) { this.hours = +value; }\n      },\n      \'hh\': {\n        regex: \'0[0-9]|1[0-2]\',\n        apply: function(value) { this.hours = +value; }\n      },\n      \'H\': {\n        regex: \'1?[0-9]|2[0-3]\',\n        apply: function(value) { this.hours = +value; }\n      },\n      \'h\': {\n        regex: \'[0-9]|1[0-2]\',\n        apply: function(value) { this.hours = +value; }\n      },\n      \'mm\': {\n        regex: \'[0-5][0-9]\',\n        apply: function(value) { this.minutes = +value; }\n      },\n      \'m\': {\n        regex: \'[0-9]|[1-5][0-9]\',\n        apply: function(value) { this.minutes = +value; }\n      },\n      \'sss\': {\n        regex: \'[0-9][0-9][0-9]\',\n        apply: function(value) { this.milliseconds = +value; }\n      },\n      \'ss\': {\n        regex: \'[0-5][0-9]\',\n        apply: function(value) { this.seconds = +value; }\n      },\n      \'s\': {\n        regex: \'[0-9]|[1-5][0-9]\',\n        apply: function(value) { this.seconds = +value; }\n      },\n      \'a\': {\n        regex: $locale.DATETIME_FORMATS.AMPMS.join(\'|\'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === \'PM\') {\n            this.hours += 12;\n          }\n        }\n      }\n    };\n  };\n\n  this.init();\n\n  function createParser(format) {\n    var map = [], regex = format.split(\'\');\n\n    angular.forEach(formatCodeToRegex, function(data, code) {\n      var index = format.indexOf(code);\n\n      if (index > -1) {\n        format = format.split(\'\');\n\n        regex[index] = \'(\' + data.regex + \')\';\n        format[index] = \'$\'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + code.length; i < n; i++) {\n          regex[i] = \'\';\n          format[i] = \'$\';\n        }\n        format = format.join(\'\');\n\n        map.push({ index: index, apply: data.apply });\n      }\n    });\n\n    return {\n      regex: new RegExp(\'^\' + regex.join(\'\') + \'$\'),\n      map: orderByFilter(map, \'index\')\n    };\n  }\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, \'\\\\$&\');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format);\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex);\n\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn(\'dateparser:\', \'baseDate is not a valid date\');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i-1];\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n          dt = new Date(baseDate);\n          dt.setFullYear(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        } else {\n          dt = new Date(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n}]);\n\n/* Deprecated dateparser below */\n\nangular.module(\'ui.bootstrap.dateparser\')\n\n.value(\'$dateParserSuppressWarning\', false)\n\n.service(\'dateParser\', [\'$log\', \'$dateParserSuppressWarning\', \'uibDateParser\', function($log, $dateParserSuppressWarning, uibDateParser) {\n  if (!$dateParserSuppressWarning) {\n    $log.warn(\'dateParser is now deprecated. Use uibDateParser instead.\');\n  }\n\n  angular.extend(this, uibDateParser);\n}]);\n\nangular.module(\'ui.bootstrap.position\', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory(\'$uibPosition\', [\'$document\', \'$window\', function($document, $window) {\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, \'position\') || \'static\' ) === \'static\';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function(element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery\'s position function:\n       * http://api.jquery.com/position/\n       */\n      position: function(element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop(\'offsetWidth\'),\n          height: boundingClientRect.height || element.prop(\'offsetHeight\'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery\'s offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function(element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop(\'offsetWidth\'),\n          height: boundingClientRect.height || element.prop(\'offsetHeight\'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n        };\n      },\n\n      /**\n       * Provides coordinates for the targetEl in relation to hostEl\n       */\n      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {\n        var positionStrParts = positionStr.split(\'-\');\n        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || \'center\';\n\n        var hostElPos,\n          targetElWidth,\n          targetElHeight,\n          targetElPos;\n\n        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n        targetElWidth = targetEl.prop(\'offsetWidth\');\n        targetElHeight = targetEl.prop(\'offsetHeight\');\n\n        var shiftWidth = {\n          center: function() {\n            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n          },\n          left: function() {\n            return hostElPos.left;\n          },\n          right: function() {\n            return hostElPos.left + hostElPos.width;\n          }\n        };\n\n        var shiftHeight = {\n          center: function() {\n            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n          },\n          top: function() {\n            return hostElPos.top;\n          },\n          bottom: function() {\n            return hostElPos.top + hostElPos.height;\n          }\n        };\n\n        switch (pos0) {\n          case \'right\':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: shiftWidth[pos0]()\n            };\n            break;\n          case \'left\':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: hostElPos.left - targetElWidth\n            };\n            break;\n          case \'bottom\':\n            targetElPos = {\n              top: shiftHeight[pos0](),\n              left: shiftWidth[pos1]()\n            };\n            break;\n          default:\n            targetElPos = {\n              top: hostElPos.top - targetElHeight,\n              left: shiftWidth[pos1]()\n            };\n            break;\n        }\n\n        return targetElPos;\n      }\n    };\n  }]);\n\n/* Deprecated position below */\n\nangular.module(\'ui.bootstrap.position\')\n\n.value(\'$positionSuppressWarning\', false)\n\n.service(\'$position\', [\'$log\', \'$positionSuppressWarning\', \'$uibPosition\', function($log, $positionSuppressWarning, $uibPosition) {\n  if (!$positionSuppressWarning) {\n    $log.warn(\'$position is now deprecated. Use $uibPosition instead.\');\n  }\n\n  angular.extend(this, $uibPosition);\n}]);\n\nangular.module(\'ui.bootstrap.datepicker\', [\'ui.bootstrap.dateparser\', \'ui.bootstrap.position\'])\n\n.value(\'$datepickerSuppressError\', false)\n\n.constant(\'uibDatepickerConfig\', {\n  formatDay: \'dd\',\n  formatMonth: \'MMMM\',\n  formatYear: \'yyyy\',\n  formatDayHeader: \'EEE\',\n  formatDayTitle: \'MMMM yyyy\',\n  formatMonthTitle: \'yyyy\',\n  datepickerMode: \'day\',\n  minMode: \'day\',\n  maxMode: \'year\',\n  showWeeks: true,\n  startingDay: 0,\n  yearRange: 20,\n  minDate: null,\n  maxDate: null,\n  shortcutPropagation: false\n})\n\n.controller(\'UibDatepickerController\', [\'$scope\', \'$attrs\', \'$parse\', \'$interpolate\', \'$log\', \'dateFilter\', \'uibDatepickerConfig\', \'$datepickerSuppressError\', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  // Modes chain\n  this.modes = [\'day\', \'month\', \'year\'];\n\n  // Configuration attributes\n  angular.forEach([\'formatDay\', \'formatMonth\', \'formatYear\', \'formatDayHeader\', \'formatDayTitle\', \'formatMonthTitle\',\n                   \'showWeeks\', \'startingDay\', \'yearRange\', \'shortcutPropagation\'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  // Watchable date attributes\n  angular.forEach([\'minDate\', \'maxDate\'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach([\'minMode\', \'maxMode\'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == \'minMode\' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == \'maxMode\' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = \'datepicker-\' + $scope.$id + \'-\' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error(\'Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.\');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity(\'dateDisabled\', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: \'enter\', 32: \'space\', 33: \'pageup\', 34: \'pagedown\', 35: \'end\', 36: \'home\', 37: \'left\', 38: \'up\', 39: \'right\', 40: \'down\' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on(\'uib:datepicker.focus\', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === \'enter\' || key === \'space\') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === \'up\' || key === \'down\')) {\n      $scope.toggleMode(key === \'up\' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.controller(\'UibDaypickerController\', [\'$scope\', \'$element\', \'dateFilter\', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-month calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + \'-\' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, \'EEEE\')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === \'left\') {\n      date = date - 1;   // up\n    } else if (key === \'up\') {\n      date = date - 7;   // down\n    } else if (key === \'right\') {\n      date = date + 1;   // down\n    } else if (key === \'down\') {\n      date = date + 7;\n    } else if (key === \'pageup\' || key === \'pagedown\') {\n      var month = this.activeDate.getMonth() + (key === \'pageup\' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === \'home\') {\n      date = 1;\n    } else if (key === \'end\') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller(\'UibMonthpickerController\', [\'$scope\', \'$element\', \'dateFilter\', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + \'-\' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, 3);\n  };\n\n  this.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === \'left\') {\n      date = date - 1;   // up\n    } else if (key === \'up\') {\n      date = date - 3;   // down\n    } else if (key === \'right\') {\n      date = date + 1;   // down\n    } else if (key === \'down\') {\n      date = date + 3;\n    } else if (key === \'pageup\' || key === \'pagedown\') {\n      var year = this.activeDate.getFullYear() + (key === \'pageup\' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === \'home\') {\n      date = 0;\n    } else if (key === \'end\') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller(\'UibYearpickerController\', [\'$scope\', \'$element\', \'dateFilter\', function(scope, $element, dateFilter) {\n  var range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    range = this.yearRange;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + \'-\' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(\' - \');\n    scope.rows = this.split(years, 5);\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === \'left\') {\n      date = date - 1;   // up\n    } else if (key === \'up\') {\n      date = date - 5;   // down\n    } else if (key === \'right\') {\n      date = date + 1;   // down\n    } else if (key === \'down\') {\n      date = date + 5;\n    } else if (key === \'pageup\' || key === \'pagedown\') {\n      date += (key === \'pageup\' ? - 1 : 1) * this.step.years;\n    } else if (key === \'home\') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === \'end\') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive(\'uibDatepicker\', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/datepicker/datepicker.html\';\n    },\n    scope: {\n      datepickerMode: \'=?\',\n      dateDisabled: \'&\',\n      customClass: \'&\',\n      shortcutPropagation: \'&?\'\n    },\n    require: [\'uibDatepicker\', \'^ngModel\'],\n    controller: \'UibDatepickerController\',\n    controllerAs: \'datepicker\',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive(\'uibDaypicker\', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/datepicker/day.html\';\n    },\n    require: [\'^?uibDatepicker\', \'uibDaypicker\', \'^?datepicker\'],\n    controller: \'UibDaypickerController\',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive(\'uibMonthpicker\', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/datepicker/month.html\';\n    },\n    require: [\'^?uibDatepicker\', \'uibMonthpicker\', \'^?datepicker\'],\n    controller: \'UibMonthpickerController\',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive(\'uibYearpicker\', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/datepicker/year.html\';\n    },\n    require: [\'^?uibDatepicker\', \'uibYearpicker\', \'^?datepicker\'],\n    controller: \'UibYearpickerController\',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0] || ctrls[2];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n})\n\n.constant(\'uibDatepickerPopupConfig\', {\n  datepickerPopup: \'yyyy-MM-dd\',\n  datepickerPopupTemplateUrl: \'template/datepicker/popup.html\',\n  datepickerTemplateUrl: \'template/datepicker/datepicker.html\',\n  html5Types: {\n    date: \'yyyy-MM-dd\',\n    \'datetime-local\': \'yyyy-MM-ddTHH:mm:ss.sss\',\n    \'month\': \'yyyy-MM\'\n  },\n  currentText: \'Today\',\n  clearText: \'Clear\',\n  closeText: \'Done\',\n  closeOnDateSelection: true,\n  appendToBody: false,\n  showButtonBar: true,\n  onOpenFocus: true\n})\n\n.controller(\'UibDatepickerPopupController\', [\'$scope\', \'$element\', \'$attrs\', \'$compile\', \'$parse\', \'$document\', \'$rootScope\', \'$uibPosition\', \'dateFilter\', \'uibDateParser\', \'uibDatepickerPopupConfig\', \'$timeout\',\nfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {\n  var self = this;\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n    ngModel, $popup;\n\n  scope.watchData = {};\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\n    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      attrs.$observe(\'uibDatepickerPopup\', function(value, oldValue) {\n          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n          // Invalidate the $modelValue to ensure that formatters re-run\n          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n          if (newDateFormat !== dateFormat) {\n            dateFormat = newDateFormat;\n            ngModel.$modelValue = null;\n\n            if (!dateFormat) {\n              throw new Error(\'uibDatepickerPopup must have a date format specified.\');\n            }\n          }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error(\'uibDatepickerPopup must have a date format specified.\');\n    }\n\n    if (isHtml5DateInput && attrs.datepickerPopup) {\n      throw new Error(\'HTML5 date input types do not support custom formats.\');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element(\'<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>\');\n    popupEl.attr({\n      \'ng-model\': \'date\',\n      \'ng-change\': \'dateSelection(date)\',\n      \'template-url\': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr(\'template-url\', datepickerTemplateUrl);\n\n    if (isHtml5DateInput) {\n      if (attrs.type === \'month\') {\n        datepickerEl.attr(\'datepicker-mode\', \'"month"\');\n        datepickerEl.attr(\'min-mode\', \'month\');\n      }\n    }\n\n    if (attrs.datepickerOptions) {\n      var options = scope.$parent.$eval(attrs.datepickerOptions);\n      if (options && options.initDate) {\n        scope.initDate = options.initDate;\n        datepickerEl.attr(\'init-date\', \'initDate\');\n        delete options.initDate;\n      }\n      angular.forEach(options, function(value, option) {\n        datepickerEl.attr(cameltoDash(option), value);\n      });\n    }\n\n    angular.forEach([\'minMode\', \'maxMode\', \'minDate\', \'maxDate\', \'datepickerMode\', \'initDate\', \'shortcutPropagation\'], function(key) {\n      if (attrs[key]) {\n        var getAttribute = $parse(attrs[key]);\n        scope.$parent.$watch(getAttribute, function(value) {\n          scope.watchData[key] = value;\n          if (key === \'minDate\' || key === \'maxDate\') {\n            cache[key] = new Date(value);\n          }\n        });\n        datepickerEl.attr(cameltoDash(key), \'watchData.\' + key);\n\n        // Propagate changes from datepicker to outside\n        if (key === \'datepickerMode\') {\n          var setAttribute = getAttribute.assign;\n          scope.$watch(\'watchData.\' + key, function(value, oldvalue) {\n            if (angular.isFunction(setAttribute) && value !== oldvalue) {\n              setAttribute(scope.$parent, value);\n            }\n          });\n        }\n      }\n    });\n    if (attrs.dateDisabled) {\n      datepickerEl.attr(\'date-disabled\', \'dateDisabled({ date: date, mode: mode })\');\n    }\n\n    if (attrs.showWeeks) {\n      datepickerEl.attr(\'show-weeks\', attrs.showWeeks);\n    }\n\n    if (attrs.customClass) {\n      datepickerEl.attr(\'custom-class\', \'customClass({ date: date, mode: mode })\');\n    }\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = \'date\';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);\n    });\n\n    element.bind(\'keydown\', inputKeydownBind);\n\n    $popup = $compile(popupEl)(scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find(\'body\').append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    scope.$on(\'$destroy\', function() {\n      if (scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          scope.$apply(function() {\n            scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      element.unbind(\'keydown\', inputKeydownBind);\n      $document.unbind(\'click\', documentClickBind);\n    });\n  };\n\n  scope.getText = function(key) {\n    return scope[key + \'Text\'] || datepickerPopupConfig[key + \'Text\'];\n  };\n\n  scope.isDisabled = function(date) {\n    if (date === \'today\') {\n      date = new Date();\n    }\n\n    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||\n      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));\n  };\n\n  scope.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  // Inner change\n  scope.dateSelection = function(dt) {\n    if (angular.isDefined(dt)) {\n      scope.date = dt;\n    }\n    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.select = function(date) {\n    if (date === \'today\') {\n      var today = new Date();\n      if (angular.isDate(scope.date)) {\n        date = new Date(scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = new Date(today.setHours(0, 0, 0, 0));\n      }\n    }\n    scope.dateSelection(date);\n  };\n\n  scope.close = function() {\n    scope.isOpen = false;\n    element[0].focus();\n  };\n\n  scope.$watch(\'isOpen\', function(value) {\n    if (value) {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top = scope.position.top + element.prop(\'offsetHeight\');\n\n      $timeout(function() {\n        if (onOpenFocus) {\n          scope.$broadcast(\'uib:datepicker.focus\');\n        }\n        $document.bind(\'click\', documentClickBind);\n      }, 0, false);\n    } else {\n      $document.unbind(\'click\', documentClickBind);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return \'-\' + $1.toLowerCase(); });\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    } else if (angular.isString(viewValue)) {\n      var date = dateParser.parse(viewValue, dateFormat, scope.date);\n      if (isNaN(date)) {\n        return undefined;\n      } else {\n        return date;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n    if (!value) {\n      return true;\n    } else if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    } else if (angular.isString(value)) {\n      var date = dateParser.parse(value, dateFormat);\n      return !isNaN(date);\n    } else {\n      return false;\n    }\n  }\n\n  function documentClickBind(event) {\n    var popup = $popup[0];\n    var dpContainsTarget = element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the \'contains\' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n      element[0].focus();\n    } else if (evt.which === 40 && !scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = true;\n      });\n    }\n  }\n}])\n\n.directive(\'uibDatepickerPopup\', function() {\n  return {\n    require: [\'ngModel\', \'uibDatepickerPopup\'],\n    controller: \'UibDatepickerPopupController\',\n    scope: {\n      isOpen: \'=?\',\n      currentText: \'@\',\n      clearText: \'@\',\n      closeText: \'@\',\n      dateDisabled: \'&\',\n      customClass: \'&\'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive(\'uibDatepickerPopupWrap\', function() {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/datepicker/popup.html\';\n    }\n  };\n});\n\n/* Deprecated datepicker below */\n\nangular.module(\'ui.bootstrap.datepicker\')\n\n.value(\'$datepickerSuppressWarning\', false)\n\n.controller(\'DatepickerController\', [\'$scope\', \'$attrs\', \'$parse\', \'$interpolate\', \'$log\', \'dateFilter\', \'uibDatepickerConfig\', \'$datepickerSuppressError\', \'$datepickerSuppressWarning\', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {\n  if (!$datepickerSuppressWarning) {\n    $log.warn(\'DatepickerController is now deprecated. Use UibDatepickerController instead.\');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  this.modes = [\'day\', \'month\', \'year\'];\n\n  angular.forEach([\'formatDay\', \'formatMonth\', \'formatYear\', \'formatDayHeader\', \'formatDayTitle\', \'formatMonthTitle\',\n    \'showWeeks\', \'startingDay\', \'yearRange\', \'shortcutPropagation\'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  angular.forEach([\'minDate\', \'maxDate\'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach([\'minMode\', \'maxMode\'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == \'minMode\' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == \'maxMode\' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = \'datepicker-\' + $scope.$id + \'-\' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n        isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error(\'Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.\');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity(\'dateDisabled\', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  this.fixTimeZone = function(date) {\n    var hours = date.getHours();\n    date.setHours(hours === 23 ? hours + 2 : 0);\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n      month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: \'enter\', 32: \'space\', 33: \'pageup\', 34: \'pagedown\', 35: \'end\', 36: \'home\', 37: \'left\', 38: \'up\', 39: \'right\', 40: \'down\' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  $scope.$on(\'uib:datepicker.focus\', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === \'enter\' || key === \'space\') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === \'up\' || key === \'down\')) {\n      $scope.toggleMode(key === \'up\' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.directive(\'datepicker\', [\'$log\', \'$datepickerSuppressWarning\', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/datepicker/datepicker.html\';\n    },\n    scope: {\n      datepickerMode: \'=?\',\n      dateDisabled: \'&\',\n      customClass: \'&\',\n      shortcutPropagation: \'&?\'\n    },\n    require: [\'datepicker\', \'^ngModel\'],\n    controller: \'DatepickerController\',\n    controllerAs: \'datepicker\',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn(\'datepicker is now deprecated. Use uib-datepicker instead.\');\n      }\n\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n}])\n\n.directive(\'daypicker\', [\'$log\', \'$datepickerSuppressWarning\', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: \'template/datepicker/day.html\',\n    require: [\'^datepicker\', \'daypicker\'],\n    controller: \'UibDaypickerController\',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn(\'daypicker is now deprecated. Use uib-daypicker instead.\');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive(\'monthpicker\', [\'$log\', \'$datepickerSuppressWarning\', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: \'template/datepicker/month.html\',\n    require: [\'^datepicker\', \'monthpicker\'],\n    controller: \'UibMonthpickerController\',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn(\'monthpicker is now deprecated. Use uib-monthpicker instead.\');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive(\'yearpicker\', [\'$log\', \'$datepickerSuppressWarning\', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: \'template/datepicker/year.html\',\n    require: [\'^datepicker\', \'yearpicker\'],\n    controller: \'UibYearpickerController\',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn(\'yearpicker is now deprecated. Use uib-yearpicker instead.\');\n      }\n\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive(\'datepickerPopup\', [\'$log\', \'$datepickerSuppressWarning\', function($log, $datepickerSuppressWarning) {\n  return {\n    require: [\'ngModel\', \'datepickerPopup\'],\n    controller: \'UibDatepickerPopupController\',\n    scope: {\n      isOpen: \'=?\',\n      currentText: \'@\',\n      clearText: \'@\',\n      closeText: \'@\',\n      dateDisabled: \'&\',\n      customClass: \'&\'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn(\'datepicker-popup is now deprecated. Use uib-datepicker-popup instead.\');\n      }\n\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n}])\n\n.directive(\'datepickerPopupWrap\', [\'$log\', \'$datepickerSuppressWarning\', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/datepicker/popup.html\';\n    },\n    link: function() {\n      if (!$datepickerSuppressWarning) {\n        $log.warn(\'datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.\');\n      }\n    }\n  };\n}]);\n\nangular.module(\'ui.bootstrap.dropdown\', [\'ui.bootstrap.position\'])\n\n.constant(\'uibDropdownConfig\', {\n  openClass: \'open\'\n})\n\n.service(\'uibDropdownService\', [\'$document\', \'$rootScope\', function($document, $rootScope) {\n  var openScope = null;\n\n  this.open = function(dropdownScope) {\n    if (!openScope) {\n      $document.bind(\'click\', closeDropdown);\n      $document.bind(\'keydown\', keybindFilter);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function(dropdownScope) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.unbind(\'click\', closeDropdown);\n      $document.unbind(\'keydown\', keybindFilter);\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) { return; }\n\n    if (evt && openScope.getAutoClose() === \'disabled\')  { return ; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === \'outsideClick\' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var keybindFilter = function(evt) {\n    if (evt.which === 27) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller(\'UibDropdownController\', [\'$scope\', \'$element\', \'$attrs\', \'$parse\', \'uibDropdownConfig\', \'uibDropdownService\', \'$animate\', \'$uibPosition\', \'$document\', \'$compile\', \'$templateRequest\', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass(\'dropdown\');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find(\'body\').append(self.dropdownMenu);\n      $element.on(\'$destroy\', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || \'always\'; //or \'outsideClick\' or \'disabled\'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find(\'a\')) :\n      (angular.element($element).find(\'ul\').eq(0).find(\'a\'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch(\'isOpen\', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, \'bottom-left\', true);\n      var css = {\n        top: pos.top + \'px\',\n        display: isOpen ? \'block\' : \'none\'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass(\'dropdown-menu-right\');\n      if (!rightalign) {\n        css.left = pos.left + \'px\';\n        css.right = \'auto\';\n      } else {\n        css.left = \'auto\';\n        css.right = (window.innerWidth - (pos.left + $element.prop(\'offsetWidth\'))) + \'px\';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? \'addClass\' : \'removeClass\']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element(\'<ul class="dropdown-menu"></ul>\');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on(\'$locationChangeSuccess\', function() {\n    if (scope.getAutoClose() !== \'disabled\') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on(\'$destroy\', function() {\n    scope.$destroy();\n  });\n  scope.$on(\'$destroy\', offDestroy);\n}])\n\n.directive(\'uibDropdown\', function() {\n  return {\n    controller: \'UibDropdownController\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive(\'uibDropdownMenu\', function() {\n  return {\n    restrict: \'AC\',\n    require: \'?^uibDropdown\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass(\'dropdown-menu\');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive(\'uibKeyboardNav\', function() {\n  return {\n    restrict: \'A\',\n    require: \'?^uibDropdown\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      element.bind(\'keydown\', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find(\'a\');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n})\n\n.directive(\'uibDropdownToggle\', function() {\n  return {\n    require: \'?^uibDropdown\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass(\'dropdown-toggle\');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass(\'disabled\') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind(\'click\', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ \'aria-haspopup\': true, \'aria-expanded\': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr(\'aria-expanded\', !!isOpen);\n      });\n\n      scope.$on(\'$destroy\', function() {\n        element.unbind(\'click\', toggleDropdown);\n      });\n    }\n  };\n});\n\n/* Deprecated dropdown below */\n\nangular.module(\'ui.bootstrap.dropdown\')\n\n.value(\'$dropdownSuppressWarning\', false)\n\n.service(\'dropdownService\', [\'$log\', \'$dropdownSuppressWarning\', \'uibDropdownService\', function($log, $dropdownSuppressWarning, uibDropdownService) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn(\'dropdownService is now deprecated. Use uibDropdownService instead.\');\n  }\n\n  angular.extend(this, uibDropdownService);\n}])\n\n.controller(\'DropdownController\', [\'$scope\', \'$element\', \'$attrs\', \'$parse\', \'uibDropdownConfig\', \'uibDropdownService\', \'$animate\', \'$uibPosition\', \'$document\', \'$compile\', \'$templateRequest\', \'$log\', \'$dropdownSuppressWarning\', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn(\'DropdownController is now deprecated. Use UibDropdownController instead.\');\n  }\n\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass(\'dropdown\');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find(\'body\').append(self.dropdownMenu);\n      $element.on(\'$destroy\', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || \'always\'; //or \'outsideClick\' or \'disabled\'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find(\'a\')) :\n      (angular.element($element).find(\'ul\').eq(0).find(\'a\'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length -1 ?\n            self.selectedOption :\n          self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch(\'isOpen\', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, \'bottom-left\', true);\n      var css = {\n        top: pos.top + \'px\',\n        display: isOpen ? \'block\' : \'none\'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass(\'dropdown-menu-right\');\n      if (!rightalign) {\n        css.left = pos.left + \'px\';\n        css.right = \'auto\';\n      } else {\n        css.left = \'auto\';\n        css.right = (window.innerWidth - (pos.left + $element.prop(\'offsetWidth\'))) + \'px\';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? \'addClass\' : \'removeClass\']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element(\'<ul class="dropdown-menu"></ul>\');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on(\'$locationChangeSuccess\', function() {\n    if (scope.getAutoClose() !== \'disabled\') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on(\'$destroy\', function() {\n    scope.$destroy();\n  });\n  scope.$on(\'$destroy\', offDestroy);\n}])\n\n.directive(\'dropdown\', [\'$log\', \'$dropdownSuppressWarning\', function($log, $dropdownSuppressWarning) {\n  return {\n    controller: \'DropdownController\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn(\'dropdown is now deprecated. Use uib-dropdown instead.\');\n      }\n\n      dropdownCtrl.init();\n    }\n  };\n}])\n\n.directive(\'dropdownMenu\', [\'$log\', \'$dropdownSuppressWarning\', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: \'AC\',\n    require: \'?^dropdown\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      if (!$dropdownSuppressWarning) {\n        $log.warn(\'dropdown-menu is now deprecated. Use uib-dropdown-menu instead.\');\n      }\n\n      element.addClass(\'dropdown-menu\');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n}])\n\n.directive(\'keyboardNav\', [\'$log\', \'$dropdownSuppressWarning\', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: \'A\',\n    require: \'?^dropdown\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn(\'keyboard-nav is now deprecated. Use uib-keyboard-nav instead.\');\n      }\n\n      element.bind(\'keydown\', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find(\'a\');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n}])\n\n.directive(\'dropdownToggle\', [\'$log\', \'$dropdownSuppressWarning\', function($log, $dropdownSuppressWarning) {\n  return {\n    require: \'?^dropdown\',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn(\'dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.\');\n      }\n\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass(\'dropdown-toggle\');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass(\'disabled\') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind(\'click\', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ \'aria-haspopup\': true, \'aria-expanded\': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr(\'aria-expanded\', !!isOpen);\n      });\n\n      scope.$on(\'$destroy\', function() {\n        element.unbind(\'click\', toggleDropdown);\n      });\n    }\n  };\n}]);\n\nangular.module(\'ui.bootstrap.stackedMap\', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory(\'$$stackedMap\', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module(\'ui.bootstrap.modal\', [\'ui.bootstrap.stackedMap\'])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory(\'$$multiMap\', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive(\'uibModalBackdrop\', [\n           \'$animate\', \'$injector\', \'$uibModalStack\',\n  function($animate ,  $injector,   $modalStack) {\n    var $animateCss = null;\n\n    if ($injector.has(\'$animateCss\')) {\n      $animateCss = $injector.get(\'$animateCss\');\n    }\n\n    return {\n      replace: true,\n      templateUrl: \'template/modal/backdrop.html\',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      // Temporary fix for prefixing\n      element.addClass(\'modal-backdrop\');\n\n      if (attrs.modalInClass) {\n        if ($animateCss) {\n          $animateCss(element, {\n            addClass: attrs.modalInClass\n          }).start();\n        } else {\n          $animate.addClass(element, attrs.modalInClass);\n        }\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: attrs.modalInClass\n            }).start().then(done);\n          } else {\n            $animate.removeClass(element, attrs.modalInClass).then(done);\n          }\n        });\n      }\n    }\n  }])\n\n  .directive(\'uibModalWindow\', [\n           \'$uibModalStack\', \'$q\', \'$animate\', \'$injector\',\n  function($modalStack ,  $q ,  $animate,   $injector) {\n    var $animateCss = null;\n\n    if ($injector.has(\'$animateCss\')) {\n      $animateCss = $injector.get(\'$animateCss\');\n    }\n\n    return {\n      scope: {\n        index: \'@\'\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || \'template/modal/window.html\';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowClass || \'\');\n        element.addClass(attrs.windowTopClass || \'\');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop && modal.value.backdrop !== \'static\' && (evt.target === evt.currentTarget)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, \'backdrop click\');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on(\'click\', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is render.\n        var modalRenderDeferObj = $q.defer();\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal\'s template.\n        attrs.$observe(\'modalRender\', function(value) {\n          if (value == \'true\') {\n            modalRenderDeferObj.resolve();\n          }\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            if ($animateCss) {\n              animationPromise = $animateCss(element, {\n                addClass: attrs.modalInClass\n              }).start();\n            } else {\n              animationPromise = $animate.addClass(element, attrs.modalInClass);\n            }\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: attrs.modalInClass\n                }).start().then(done);\n              } else {\n                $animate.removeClass(element, attrs.modalInClass).then(done);\n              }\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            var inputWithAutofocus = element[0].querySelector(\'[autofocus]\');\n            /**\n             * Auto-focusing of a freshly-opened modal element causes any child elements\n             * with the autofocus attribute to lose focus. This is an issue on touch\n             * based devices which will show and then hide the onscreen keyboard.\n             * Attempts to refocus the autofocus element via JavaScript will not reopen\n             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n             * the modal element if the modal does not contain an autofocus element.\n             */\n            if (inputWithAutofocus) {\n              inputWithAutofocus.focus();\n            } else {\n              element[0].focus();\n            }\n          });\n\n          // Notify {@link $modalStack} that modal is rendered.\n          var modal = $modalStack.getTop();\n          if (modal) {\n            $modalStack.modalRendered(modal.key);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive(\'uibModalAnimationClass\', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive(\'uibModalTransclude\', function() {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory(\'$uibModalStack\', [\n             \'$animate\', \'$timeout\', \'$document\', \'$compile\', \'$rootScope\',\n             \'$q\',\n             \'$injector\',\n             \'$$multiMap\',\n             \'$$stackedMap\',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n              $q,\n              $injector,\n              $$multiMap,\n              $$stackedMap) {\n      var $animateCss = null;\n\n      if ($injector.has(\'$animateCss\')) {\n        $animateCss = $injector.get(\'$animateCss\');\n      }\n\n      var OPENED_MODAL_CLASS = \'modal-open\';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: \'modal.stack.now-closing\'\n      };\n\n      //Modal focus behavior\n      var focusableElementList;\n      var focusIndex = 0;\n      var tababbleSelector = \'a[href], area[href], input:not([disabled]), \' +\n        \'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), \' +\n        \'iframe, object, embed, *[tabindex], *[contenteditable=true]\';\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var body = $document.find(\'body\').eq(0);\n        var modalWindow = openedWindows.get(modalInstance).value;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n          toggleTopWindowClass(true);\n        });\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else {\n          body.focus();\n        }\n      }\n\n      // Add or remove "windowTopClass" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || \'\', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() == -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it\'s intentional that asyncPromise might be null.\n        // That\'s when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          if ($animateCss) {\n            $animateCss(domEl, {\n              event: \'leave\'\n            }).start().then(function() {\n              domEl.remove();\n            });\n          } else {\n            $animate.leave(domEl);\n          }\n          scope.$destroy();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.bind(\'keydown\', function(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal && modal.value.keyboard) {\n          switch (evt.which) {\n            case 27: {\n              evt.preventDefault();\n              $rootScope.$apply(function() {\n                $modalStack.dismiss(modal.key, \'escape key press\');\n              });\n              break;\n            }\n            case 9: {\n              $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt)) {\n                  focusChanged = $modalStack.focusLastFocusableElement();\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement();\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n              break;\n            }\n          }\n        }\n      });\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var body = $document.find(\'body\').eq(0),\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.index = currBackdropIndex;\n          var angularBackgroundDomEl = angular.element(\'<div uib-modal-backdrop="modal-backdrop"></div>\');\n          angularBackgroundDomEl.attr(\'backdrop-class\', modal.backdropClass);\n          if (modal.animation) {\n            angularBackgroundDomEl.attr(\'modal-animation\', \'true\');\n          }\n          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n          body.append(backdropDomEl);\n        }\n\n        var angularDomEl = angular.element(\'<div uib-modal-window="modal-window"></div>\');\n        angularDomEl.attr({\n          \'template-url\': modal.windowTemplateUrl,\n          \'window-class\': modal.windowClass,\n          \'window-top-class\': modal.windowTopClass,\n          \'size\': modal.size,\n          \'index\': openedWindows.length() - 1,\n          \'animate\': \'animate\'\n        }).html(modal.content);\n        if (modal.animation) {\n          angularDomEl.attr(\'modal-animation\', \'true\');\n        }\n\n        var modalDomEl = $compile(angularDomEl)(modal.scope);\n        openedWindows.top().value.modalDomEl = modalDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n        body.append(modalDomEl);\n        body.addClass(modalBodyClass);\n\n        $modalStack.clearFocusListCache();\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast(\'modal.closing\', resultOrReason, closing).defaultPrevented;\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[0].focus();\n          return true;\n        }\n        return false;\n      };\n      $modalStack.focusLastFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[focusableElementList.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.clearFocusListCache = function() {\n        focusableElementList = [];\n        focusIndex = 0;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (focusableElementList === undefined || !focusableElementList.length) {\n          if (modalWindow) {\n            var modalDomE1 = modalWindow.value.modalDomEl;\n            if (modalDomE1 && modalDomE1.length) {\n              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n            }\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider(\'$uibModal\', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or \'static\'\n        keyboard: true\n      },\n      $get: [\'$injector\', \'$rootScope\', \'$q\', \'$templateRequest\', \'$controller\', \'$uibModalStack\', \'$modalSuppressWarning\', \'$log\',\n        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n          }\n\n          function getResolvePromises(resolves) {\n            var promisesArr = [];\n            angular.forEach(resolves, function(value) {\n              if (angular.isFunction(value) || angular.isArray(value)) {\n                promisesArr.push($q.when($injector.invoke(value)));\n              } else if (angular.isString(value)) {\n                promisesArr.push($q.when($injector.get(value)));\n              } else {\n                promisesArr.push($q.when(value));\n              }\n            });\n            return promisesArr;\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error(\'One of template or templateUrl options is required.\');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n\n                var modalScope = (modalOptions.scope || $rootScope).$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on(\'$destroy\', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss(\'$uibUnscheduledDestruction\');\n                  }\n                });\n\n                var ctrlInstance, ctrlLocals = {};\n                var resolveIter = 1;\n\n                //controllers\n                if (modalOptions.controller) {\n                  ctrlLocals.$scope = modalScope;\n                  ctrlLocals.$uibModalInstance = modalInstance;\n                  Object.defineProperty(ctrlLocals, \'$modalInstance\', {\n                    get: function() {\n                      if (!$modalSuppressWarning) {\n                        $log.warn(\'$modalInstance is now deprecated. Use $uibModalInstance instead.\');\n                      }\n\n                      return modalInstance;\n                    }\n                  });\n                  angular.forEach(modalOptions.resolve, function(value, key) {\n                    ctrlLocals[key] = tplAndVars[resolveIter++];\n                  });\n\n                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                  if (modalOptions.controllerAs) {\n                    if (modalOptions.bindToController) {\n                      angular.extend(ctrlInstance, modalScope);\n                    }\n\n                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n                  }\n                }\n\n                $modalStack.open(modalInstance, {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  content: tplAndVars[0],\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass\n                });\n                modalOpenedDeferred.resolve(true);\n\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })\n            .finally(function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\n/* deprecated modal below */\n\nangular.module(\'ui.bootstrap.modal\')\n\n  .value(\'$modalSuppressWarning\', false)\n\n  /**\n   * A helper directive for the $modal service. It creates a backdrop element.\n   */\n  .directive(\'modalBackdrop\', [\n    \'$animate\', \'$injector\', \'$modalStack\', \'$log\', \'$modalSuppressWarning\',\n    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has(\'$animateCss\')) {\n        $animateCss = $injector.get(\'$animateCss\');\n      }\n\n      return {\n        replace: true,\n        templateUrl: \'template/modal/backdrop.html\',\n        compile: function(tElement, tAttrs) {\n          tElement.addClass(tAttrs.backdropClass);\n          return linkFn;\n        }\n      };\n\n      function linkFn(scope, element, attrs) {\n        if (!$modalSuppressWarning) {\n          $log.warn(\'modal-backdrop is now deprecated. Use uib-modal-backdrop instead.\');\n        }\n        element.addClass(\'modal-backdrop\');\n\n        if (attrs.modalInClass) {\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n          } else {\n            $animate.addClass(element, attrs.modalInClass);\n          }\n\n          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n            var done = setIsAsync();\n            if ($animateCss) {\n              $animateCss(element, {\n                removeClass: attrs.modalInClass\n              }).start().then(done);\n            } else {\n              $animate.removeClass(element, attrs.modalInClass).then(done);\n            }\n          });\n        }\n      }\n    }])\n\n  .directive(\'modalWindow\', [\n    \'$modalStack\', \'$q\', \'$animate\', \'$injector\', \'$log\', \'$modalSuppressWarning\',\n    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has(\'$animateCss\')) {\n        $animateCss = $injector.get(\'$animateCss\');\n      }\n\n      return {\n        scope: {\n          index: \'@\'\n        },\n        replace: true,\n        transclude: true,\n        templateUrl: function(tElement, tAttrs) {\n          return tAttrs.templateUrl || \'template/modal/window.html\';\n        },\n        link: function(scope, element, attrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn(\'modal-window is now deprecated. Use uib-modal-window instead.\');\n          }\n          element.addClass(attrs.windowClass || \'\');\n          element.addClass(attrs.windowTopClass || \'\');\n          scope.size = attrs.size;\n\n          scope.close = function(evt) {\n            var modal = $modalStack.getTop();\n            if (modal && modal.value.backdrop && modal.value.backdrop !== \'static\' && (evt.target === evt.currentTarget)) {\n              evt.preventDefault();\n              evt.stopPropagation();\n              $modalStack.dismiss(modal.key, \'backdrop click\');\n            }\n          };\n\n          // moved from template to fix issue #2280\n          element.on(\'click\', scope.close);\n\n          // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n          // We can detect that by using this property in the template associated with this directive and then use\n          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n          scope.$isRendered = true;\n\n          // Deferred object that will be resolved when this modal is render.\n          var modalRenderDeferObj = $q.defer();\n          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal\'s template.\n          attrs.$observe(\'modalRender\', function(value) {\n            if (value == \'true\') {\n              modalRenderDeferObj.resolve();\n            }\n          });\n\n          modalRenderDeferObj.promise.then(function() {\n            var animationPromise = null;\n\n            if (attrs.modalInClass) {\n              if ($animateCss) {\n                animationPromise = $animateCss(element, {\n                  addClass: attrs.modalInClass\n                }).start();\n              } else {\n                animationPromise = $animate.addClass(element, attrs.modalInClass);\n              }\n\n              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n                var done = setIsAsync();\n                if ($animateCss) {\n                  $animateCss(element, {\n                    removeClass: attrs.modalInClass\n                  }).start().then(done);\n                } else {\n                  $animate.removeClass(element, attrs.modalInClass).then(done);\n                }\n              });\n            }\n\n\n            $q.when(animationPromise).then(function() {\n              var inputWithAutofocus = element[0].querySelector(\'[autofocus]\');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            });\n\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n          });\n        }\n      };\n    }])\n\n  .directive(\'modalAnimationClass\', [\n    \'$log\', \'$modalSuppressWarning\',\n    function ($log, $modalSuppressWarning) {\n      return {\n        compile: function(tElement, tAttrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn(\'modal-animation-class is now deprecated. Use uib-modal-animation-class instead.\');\n          }\n          if (tAttrs.modalAnimation) {\n            tElement.addClass(tAttrs.modalAnimationClass);\n          }\n        }\n      };\n    }])\n\n  .directive(\'modalTransclude\', [\n    \'$log\', \'$modalSuppressWarning\',\n    function ($log, $modalSuppressWarning) {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        if (!$modalSuppressWarning) {\n          $log.warn(\'modal-transclude is now deprecated. Use uib-modal-transclude instead.\');\n        }\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  }])\n\n  .service(\'$modalStack\', [\n    \'$animate\', \'$timeout\', \'$document\', \'$compile\', \'$rootScope\',\n    \'$q\',\n    \'$injector\',\n    \'$$multiMap\',\n    \'$$stackedMap\',\n    \'$uibModalStack\',\n    \'$log\',\n    \'$modalSuppressWarning\',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n             $q,\n             $injector,\n             $$multiMap,\n             $$stackedMap,\n             $uibModalStack,\n             $log,\n             $modalSuppressWarning) {\n      if (!$modalSuppressWarning) {\n        $log.warn(\'$modalStack is now deprecated. Use $uibModalStack instead.\');\n      }\n\n      angular.extend(this, $uibModalStack);\n    }])\n\n  .provider(\'$modal\', [\'$uibModalProvider\', function($uibModalProvider) {\n    angular.extend(this, $uibModalProvider);\n\n    this.$get = [\'$injector\', \'$log\', \'$modalSuppressWarning\',\n      function ($injector, $log, $modalSuppressWarning) {\n        if (!$modalSuppressWarning) {\n          $log.warn(\'$modal is now deprecated. Use $uibModal instead.\');\n        }\n\n        return $injector.invoke($uibModalProvider.$get);\n      }];\n  }]);\n\nangular.module(\'ui.bootstrap.pagination\', [])\n.controller(\'UibPaginationController\', [\'$scope\', \'$attrs\', \'$parse\', function($scope, $attrs, $parse) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch(\'totalItems\', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch(\'totalPages\', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + \'Text\'] || self.config[key + \'Text\'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n\n.constant(\'uibPaginationConfig\', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: \'First\',\n  previousText: \'Previous\',\n  nextText: \'Next\',\n  lastText: \'Last\',\n  rotate: true\n})\n\n.directive(\'uibPagination\', [\'$parse\', \'uibPaginationConfig\', function($parse, paginationConfig) {\n  return {\n    restrict: \'EA\',\n    scope: {\n      totalItems: \'=\',\n      firstText: \'@\',\n      previousText: \'@\',\n      nextText: \'@\',\n      lastText: \'@\',\n      ngDisabled:\'=\'\n    },\n    require: [\'uibPagination\', \'?ngModel\'],\n    controller: \'UibPaginationController\',\n    controllerAs: \'pagination\',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/pagination/pagination.html\';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, \'...\', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, \'...\', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.constant(\'uibPagerConfig\', {\n  itemsPerPage: 10,\n  previousText: \'\xAB Previous\',\n  nextText: \'Next \xBB\',\n  align: true\n})\n\n.directive(\'uibPager\', [\'uibPagerConfig\', function(pagerConfig) {\n  return {\n    restrict: \'EA\',\n    scope: {\n      totalItems: \'=\',\n      previousText: \'@\',\n      nextText: \'@\',\n      ngDisabled: \'=\'\n    },\n    require: [\'uibPager\', \'?ngModel\'],\n    controller: \'UibPaginationController\',\n    controllerAs: \'pagination\',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/pagination/pager.html\';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/* Deprecated Pagination Below */\n\nangular.module(\'ui.bootstrap.pagination\')\n.value(\'$paginationSuppressWarning\', false)\n.controller(\'PaginationController\', [\'$scope\', \'$attrs\', \'$parse\', \'$log\', \'$paginationSuppressWarning\', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {\n  if (!$paginationSuppressWarning) {\n    $log.warn(\'PaginationController is now deprecated. Use UibPaginationController instead.\');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch(\'totalItems\', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch(\'totalPages\', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + \'Text\'] || self.config[key + \'Text\'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n.directive(\'pagination\', [\'$parse\', \'uibPaginationConfig\', \'$log\', \'$paginationSuppressWarning\', function($parse, paginationConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: \'EA\',\n    scope: {\n      totalItems: \'=\',\n      firstText: \'@\',\n      previousText: \'@\',\n      nextText: \'@\',\n      lastText: \'@\',\n      ngDisabled:\'=\'\n    },\n    require: [\'pagination\', \'?ngModel\'],\n    controller: \'PaginationController\',\n    controllerAs: \'pagination\',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/pagination/pagination.html\';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn(\'pagination is now deprecated. Use uib-pagination instead.\');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, \'...\', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, \'...\', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.directive(\'pager\', [\'uibPagerConfig\', \'$log\', \'$paginationSuppressWarning\', function(pagerConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: \'EA\',\n    scope: {\n      totalItems: \'=\',\n      previousText: \'@\',\n      nextText: \'@\',\n      ngDisabled: \'=\'\n    },\n    require: [\'pager\', \'?ngModel\'],\n    controller: \'PaginationController\',\n    controllerAs: \'pagination\',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/pagination/pager.html\';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn(\'pager is now deprecated. Use uib-pager instead.\');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module(\'ui.bootstrap.tooltip\', [\'ui.bootstrap.position\', \'ui.bootstrap.stackedMap\'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider(\'$uibTooltip\', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: \'top\',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    \'mouseenter\': \'mouseleave\',\n    \'click\': \'click\',\n    \'focus\': \'blur\',\n    \'none\': \'\'\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( \'App\', [\'ui.bootstrap.tooltip\'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: \'left\' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( \'openTrigger\': \'closeTrigger\' );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake-case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = \'-\';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : \'\') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = [\'$window\', \'$compile\', \'$timeout\', \'$document\', \'$uibPosition\', \'$interpolate\', \'$rootScope\', \'$parse\', \'$$stackedMap\', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on(\'keypress\', function(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          openedTooltips.removeTop();\n          last = null;\n        }\n      }\n    });\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(\' \');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        \'<div \'+ directiveName + \'-popup \'+\n          \'title="\' + startSym + \'title\' + endSym + \'" \'+\n          (options.useContentExp ?\n            \'content-exp="contentExp()" \' :\n            \'content="\' + startSym + \'content\' + endSym + \'" \') +\n          \'placement="\' + startSym + \'placement\' + endSym + \'" \'+\n          \'popup-class="\' + startSym + \'popupClass\' + endSym + \'" \'+\n          \'animation="animation" \' +\n          \'is-open="isOpen"\' +\n          \'origin-scope="origScope" \' +\n          \'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"\' +\n          \'>\' +\n        \'</div>\';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + \'Enable\']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + \'IsOpen\']) ? $parse(attrs[prefix + \'IsOpen\']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  // Reset the positioning.\n                  tooltip.css({ top: 0, left: 0 });\n\n                  // Now set the calculated positioning.\n                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  ttCss.top += \'px\';\n                  ttCss.left += \'px\';\n                  ttCss.visibility = \'visible\';\n                  tooltip.css(ttCss);\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n            openedTooltips.add(ttScope, {\n              close: hide\n            });\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + \'Enable\'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don\'t show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              cancelShow();\n              cancelHide();\n\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don\'t show it anymore.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = false;\n                assignIsOpen(false);\n                // And now we remove it from the DOM. However, if we have animation, we\n                // need to wait for it to expire beforehand.\n                // FIXME: this is a placeholder for a port of the transitions library.\n                // The fade transition in TWBS is 150ms.\n                if (ttScope.animation) {\n                  if (!transitionTimeout) {\n                    transitionTimeout = $timeout(removeTooltip, 150, false);\n                  }\n                } else {\n                  removeTooltip();\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find(\'body\').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              unregisterObservers();\n\n              transitionTimeout = null;\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the inital scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in synch.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + \'Title\'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + \'Class\'];\n              ttScope.placement = angular.isDefined(attrs[prefix + \'Placement\']) ? attrs[prefix + \'Placement\'] : options.placement;\n\n              var delay = parseInt(attrs[prefix + \'PopupDelay\'], 10);\n              var closeDelay = parseInt(attrs[prefix + \'PopupCloseDelay\'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe(\'disabled\', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                /*jshint -W018 */\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n                /*jshint +W018 */\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + \'Title\', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + \'Placement\', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                element.unbind(trigger, showTooltipBind);\n              });\n              triggers.hide.forEach(function(trigger) {\n                trigger.split(\' \').forEach(function(hideTrigger) {\n                  element[0].removeEventListener(hideTrigger, hideTooltipBind);\n                });\n              });\n            };\n\n            function prepTriggers() {\n              var val = attrs[prefix + \'Trigger\'];\n              unregisterTriggers();\n\n              triggers = getTriggers(val);\n\n              if (triggers.show !== \'none\') {\n                triggers.show.forEach(function(trigger, idx) {\n                  // Using raw addEventListener due to jqLite/jQuery bug - #4060\n                  if (trigger === triggers.hide[idx]) {\n                    element[0].addEventListener(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element[0].addEventListener(trigger, showTooltipBind);\n                    triggers.hide[idx].split(\' \').forEach(function(trigger) {\n                      element[0].addEventListener(trigger, hideTooltipBind);\n                    });\n                  }\n\n                  element.on(\'keypress\', function(e) {\n                    if (e.which === 27) {\n                      hideTooltipBind();\n                    }\n                  });\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + \'Animation\']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal = scope.$eval(attrs[prefix + \'AppendToBody\']);\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // if a tooltip is attached to <body> we need to remove it on\n            // location change as its parent scope will probably not be destroyed\n            // by the change.\n            if (appendToBody) {\n              scope.$on(\'$locationChangeSuccess\', function closeTooltipOnLocationChangeSuccess() {\n                if (ttScope.isOpen) {\n                  hide();\n                }\n              });\n            }\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on(\'$destroy\', function onDestroyTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterTriggers();\n              removeTooltip();\n              openedTooltips.remove(ttScope);\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive(\'uibTooltipTemplateTransclude\', [\n         \'$animate\', \'$sce\', \'$compile\', \'$templateRequest\',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit(\'$includeContentLoaded\', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit(\'$includeContentError\', src);\n            }\n          });\n          scope.$emit(\'$includeContentRequested\', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on(\'$destroy\', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it\'s intentional that these classes are *not* applied through $animate.\n * They must not be animated as they\'re expected to be present on the tooltip on\n * initialization.\n */\n.directive(\'uibTooltipClasses\', function() {\n  return {\n    restrict: \'A\',\n    link: function(scope, element, attrs) {\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n})\n\n.directive(\'uibTooltipPopup\', function() {\n  return {\n    replace: true,\n    scope: { content: \'@\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/tooltip/tooltip-popup.html\',\n    link: function(scope, element) {\n      element.addClass(\'tooltip\');\n    }\n  };\n})\n\n.directive(\'uibTooltip\', [ \'$uibTooltip\', function($uibTooltip) {\n  return $uibTooltip(\'uibTooltip\', \'tooltip\', \'mouseenter\');\n}])\n\n.directive(\'uibTooltipTemplatePopup\', function() {\n  return {\n    replace: true,\n    scope: { contentExp: \'&\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\',\n      originScope: \'&\' },\n    templateUrl: \'template/tooltip/tooltip-template-popup.html\',\n    link: function(scope, element) {\n      element.addClass(\'tooltip\');\n    }\n  };\n})\n\n.directive(\'uibTooltipTemplate\', [\'$uibTooltip\', function($uibTooltip) {\n  return $uibTooltip(\'uibTooltipTemplate\', \'tooltip\', \'mouseenter\', {\n    useContentExp: true\n  });\n}])\n\n.directive(\'uibTooltipHtmlPopup\', function() {\n  return {\n    replace: true,\n    scope: { contentExp: \'&\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/tooltip/tooltip-html-popup.html\',\n    link: function(scope, element) {\n      element.addClass(\'tooltip\');\n    }\n  };\n})\n\n.directive(\'uibTooltipHtml\', [\'$uibTooltip\', function($uibTooltip) {\n  return $uibTooltip(\'uibTooltipHtml\', \'tooltip\', \'mouseenter\', {\n    useContentExp: true\n  });\n}]);\n\n/* Deprecated tooltip below */\n\nangular.module(\'ui.bootstrap.tooltip\')\n\n.value(\'$tooltipSuppressWarning\', false)\n\n.provider(\'$tooltip\', [\'$uibTooltipProvider\', function($uibTooltipProvider) {\n  angular.extend(this, $uibTooltipProvider);\n\n  this.$get = [\'$log\', \'$tooltipSuppressWarning\', \'$injector\', function($log, $tooltipSuppressWarning, $injector) {\n    if (!$tooltipSuppressWarning) {\n      $log.warn(\'$tooltip is now deprecated. Use $uibTooltip instead.\');\n    }\n\n    return $injector.invoke($uibTooltipProvider.$get);\n  }];\n}])\n\n// This is mostly ngInclude code but with a custom scope\n.directive(\'tooltipTemplateTransclude\', [\n         \'$animate\', \'$sce\', \'$compile\', \'$templateRequest\', \'$log\', \'$tooltipSuppressWarning\',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {\n  return {\n    link: function(scope, elem, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn(\'tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.\');\n      }\n\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit(\'$includeContentLoaded\', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit(\'$includeContentError\', src);\n            }\n          });\n          scope.$emit(\'$includeContentRequested\', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on(\'$destroy\', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n.directive(\'tooltipClasses\', [\'$log\', \'$tooltipSuppressWarning\', function($log, $tooltipSuppressWarning) {\n  return {\n    restrict: \'A\',\n    link: function(scope, element, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn(\'tooltip-classes is now deprecated. Use uib-tooltip-classes instead.\');\n      }\n\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive(\'tooltipPopup\', [\'$log\', \'$tooltipSuppressWarning\', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { content: \'@\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/tooltip/tooltip-popup.html\',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn(\'tooltip-popup is now deprecated. Use uib-tooltip-popup instead.\');\n      }\n\n      element.addClass(\'tooltip\');\n    }\n  };\n}])\n\n.directive(\'tooltip\', [\'$tooltip\', function($tooltip) {\n  return $tooltip(\'tooltip\', \'tooltip\', \'mouseenter\');\n}])\n\n.directive(\'tooltipTemplatePopup\', [\'$log\', \'$tooltipSuppressWarning\', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: \'&\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\',\n      originScope: \'&\' },\n    templateUrl: \'template/tooltip/tooltip-template-popup.html\',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn(\'tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.\');\n      }\n\n      element.addClass(\'tooltip\');\n    }\n  };\n}])\n\n.directive(\'tooltipTemplate\', [\'$tooltip\', function($tooltip) {\n  return $tooltip(\'tooltipTemplate\', \'tooltip\', \'mouseenter\', {\n    useContentExp: true\n  });\n}])\n\n.directive(\'tooltipHtmlPopup\', [\'$log\', \'$tooltipSuppressWarning\', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: \'&\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/tooltip/tooltip-html-popup.html\',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn(\'tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.\');\n      }\n\n      element.addClass(\'tooltip\');\n    }\n  };\n}])\n\n.directive(\'tooltipHtml\', [\'$tooltip\', function($tooltip) {\n  return $tooltip(\'tooltipHtml\', \'tooltip\', \'mouseenter\', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module(\'ui.bootstrap.popover\', [\'ui.bootstrap.tooltip\'])\n\n.directive(\'uibPopoverTemplatePopup\', function() {\n  return {\n    replace: true,\n    scope: { title: \'@\', contentExp: \'&\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\',\n      originScope: \'&\' },\n    templateUrl: \'template/popover/popover-template.html\',\n    link: function(scope, element) {\n      element.addClass(\'popover\');\n    }\n  };\n})\n\n.directive(\'uibPopoverTemplate\', [\'$uibTooltip\', function($uibTooltip) {\n  return $uibTooltip(\'uibPopoverTemplate\', \'popover\', \'click\', {\n    useContentExp: true\n  });\n}])\n\n.directive(\'uibPopoverHtmlPopup\', function() {\n  return {\n    replace: true,\n    scope: { contentExp: \'&\', title: \'@\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/popover/popover-html.html\',\n    link: function(scope, element) {\n      element.addClass(\'popover\');\n    }\n  };\n})\n\n.directive(\'uibPopoverHtml\', [\'$uibTooltip\', function($uibTooltip) {\n  return $uibTooltip(\'uibPopoverHtml\', \'popover\', \'click\', {\n    useContentExp: true\n  });\n}])\n\n.directive(\'uibPopoverPopup\', function() {\n  return {\n    replace: true,\n    scope: { title: \'@\', content: \'@\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/popover/popover.html\',\n    link: function(scope, element) {\n      element.addClass(\'popover\');\n    }\n  };\n})\n\n.directive(\'uibPopover\', [\'$uibTooltip\', function($uibTooltip) {\n  return $uibTooltip(\'uibPopover\', \'popover\', \'click\');\n}]);\n\n/* Deprecated popover below */\n\nangular.module(\'ui.bootstrap.popover\')\n\n.value(\'$popoverSuppressWarning\', false)\n\n.directive(\'popoverTemplatePopup\', [\'$log\', \'$popoverSuppressWarning\', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: \'@\', contentExp: \'&\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\',\n      originScope: \'&\' },\n    templateUrl: \'template/popover/popover-template.html\',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn(\'popover-template-popup is now deprecated. Use uib-popover-template-popup instead.\');\n      }\n\n      element.addClass(\'popover\');\n    }\n  };\n}])\n\n.directive(\'popoverTemplate\', [\'$tooltip\', function($tooltip) {\n  return $tooltip(\'popoverTemplate\', \'popover\', \'click\', {\n    useContentExp: true\n  });\n}])\n\n.directive(\'popoverHtmlPopup\', [\'$log\', \'$popoverSuppressWarning\', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: \'&\', title: \'@\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/popover/popover-html.html\',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn(\'popover-html-popup is now deprecated. Use uib-popover-html-popup instead.\');\n      }\n\n      element.addClass(\'popover\');\n    }\n  };\n}])\n\n.directive(\'popoverHtml\', [\'$tooltip\', function($tooltip) {\n  return $tooltip(\'popoverHtml\', \'popover\', \'click\', {\n    useContentExp: true\n  });\n}])\n\n.directive(\'popoverPopup\', [\'$log\', \'$popoverSuppressWarning\', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: \'@\', content: \'@\', placement: \'@\', popupClass: \'@\', animation: \'&\', isOpen: \'&\' },\n    templateUrl: \'template/popover/popover.html\',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn(\'popover-popup is now deprecated. Use uib-popover-popup instead.\');\n      }\n\n      element.addClass(\'popover\');\n    }\n  };\n}])\n\n.directive(\'popover\', [\'$tooltip\', function($tooltip) {\n\n  return $tooltip(\'popover\', \'popover\', \'click\');\n}]);\n\nangular.module(\'ui.bootstrap.progressbar\', [])\n\n.constant(\'uibProgressConfig\', {\n  animate: true,\n  max: 100\n})\n\n.controller(\'UibProgressController\', [\'$scope\', \'$attrs\', \'uibProgressConfig\', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({\'transition\': \'none\'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : \'progressbar\';\n\n    bar.$watch(\'value\', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on(\'$destroy\', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  $scope.$watch(\'max\', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive(\'uibProgress\', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: \'UibProgressController\',\n    require: \'uibProgress\',\n    scope: {\n      max: \'=?\'\n    },\n    templateUrl: \'template/progressbar/progress.html\'\n  };\n})\n\n.directive(\'uibBar\', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: \'^uibProgress\',\n    scope: {\n      value: \'=\',\n      type: \'@\'\n    },\n    templateUrl: \'template/progressbar/bar.html\',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive(\'uibProgressbar\', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: \'UibProgressController\',\n    scope: {\n      value: \'=\',\n      max: \'=?\',\n      type: \'@\'\n    },\n    templateUrl: \'template/progressbar/progressbar.html\',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\n/* Deprecated progressbar below */\n\nangular.module(\'ui.bootstrap.progressbar\')\n\n.value(\'$progressSuppressWarning\', false)\n\n.controller(\'ProgressController\', [\'$scope\', \'$attrs\', \'uibProgressConfig\', \'$log\', \'$progressSuppressWarning\', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {\n  if (!$progressSuppressWarning) {\n    $log.warn(\'ProgressController is now deprecated. Use UibProgressController instead.\');\n  }\n\n  var self = this,\n    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({\'transition\': \'none\'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : \'progressbar\';\n\n    bar.$watch(\'value\', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on(\'$destroy\', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n  };\n\n  $scope.$watch(\'max\', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive(\'progress\', [\'$log\', \'$progressSuppressWarning\', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: \'ProgressController\',\n    require: \'progress\',\n    scope: {\n      max: \'=?\',\n      title: \'@?\'\n    },\n    templateUrl: \'template/progressbar/progress.html\',\n    link: function() {\n      if (!$progressSuppressWarning) {\n        $log.warn(\'progress is now deprecated. Use uib-progress instead.\');\n      }\n    }\n  };\n}])\n\n.directive(\'bar\', [\'$log\', \'$progressSuppressWarning\', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    require: \'^progress\',\n    scope: {\n      value: \'=\',\n      type: \'@\'\n    },\n    templateUrl: \'template/progressbar/bar.html\',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn(\'bar is now deprecated. Use uib-bar instead.\');\n      }\n      progressCtrl.addBar(scope, element);\n    }\n  };\n}])\n\n.directive(\'progressbar\', [\'$log\', \'$progressSuppressWarning\', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: \'ProgressController\',\n    scope: {\n      value: \'=\',\n      max: \'=?\',\n      type: \'@\'\n    },\n    templateUrl: \'template/progressbar/progressbar.html\',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn(\'progressbar is now deprecated. Use uib-progressbar instead.\');\n      }\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n}]);\n\nangular.module(\'ui.bootstrap.rating\', [])\n\n.constant(\'uibRatingConfig\', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  titles : [\'one\', \'two\', \'three\', \'four\', \'five\']\n})\n\n.controller(\'UibRatingController\', [\'$scope\', \'$attrs\', \'uibRatingConfig\', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl  = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    } else {\n      return this.titles[index];\n    }\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive(\'uibRating\', function() {\n  return {\n    require: [\'uibRating\', \'ngModel\'],\n    scope: {\n      readonly: \'=?\',\n      onHover: \'&\',\n      onLeave: \'&\'\n    },\n    controller: \'UibRatingController\',\n    templateUrl: \'template/rating/rating.html\',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\n/* Deprecated rating below */\n\nangular.module(\'ui.bootstrap.rating\')\n\n.value(\'$ratingSuppressWarning\', false)\n\n.controller(\'RatingController\', [\'$scope\', \'$attrs\', \'$controller\', \'$log\', \'$ratingSuppressWarning\', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {\n  if (!$ratingSuppressWarning) {\n    $log.warn(\'RatingController is now deprecated. Use UibRatingController instead.\');\n  }\n\n  angular.extend(this, $controller(\'UibRatingController\', {\n    $scope: $scope,\n    $attrs: $attrs\n  }));\n}])\n\n.directive(\'rating\', [\'$log\', \'$ratingSuppressWarning\', function($log, $ratingSuppressWarning) {\n  return {\n    require: [\'rating\', \'ngModel\'],\n    scope: {\n      readonly: \'=?\',\n      onHover: \'&\',\n      onLeave: \'&\'\n    },\n    controller: \'RatingController\',\n    templateUrl: \'template/rating/rating.html\',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$ratingSuppressWarning) {\n        $log.warn(\'rating is now deprecated. Use uib-rating instead.\');\n      }\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n}]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.tabs\n *\n * @description\n * AngularJS version of the tabs directive.\n */\n\nangular.module(\'ui.bootstrap.tabs\', [])\n\n.controller(\'UibTabsetController\', [\'$scope\', function ($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(selectedTab) {\n    angular.forEach(tabs, function(tab) {\n      if (tab.active && tab !== selectedTab) {\n        tab.active = false;\n        tab.onDeselect();\n        selectedTab.selectCalled = false;\n      }\n    });\n    selectedTab.active = true;\n    // only call select if it has not already been called\n    if (!selectedTab.selectCalled) {\n      selectedTab.onSelect();\n      selectedTab.selectCalled = true;\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    // we can\'t run the select function on the first tab\n    // since that would select it twice\n    if (tabs.length === 1 && tab.active !== false) {\n      tab.active = true;\n    } else if (tab.active) {\n      ctrl.select(tab);\n    } else {\n      tab.active = false;\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected and not destroyed\n    if (tab.active && tabs.length > 1 && !destroyed) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n\n  var destroyed;\n  $scope.$on(\'$destroy\', function() {\n    destroyed = true;\n  });\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabset\n * @restrict EA\n *\n * @description\n * Tabset is the outer container for the tabs directive\n *\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n *\n * @example\n<example module="ui.bootstrap">\n  <file name="index.html">\n    <uib-tabset>\n      <uib-tab heading="Tab 1"><b>First</b> Content!</uib-tab>\n      <uib-tab heading="Tab 2"><i>Second</i> Content!</uib-tab>\n    </uib-tabset>\n    <hr />\n    <uib-tabset vertical="true">\n      <uib-tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</uib-tab>\n      <uib-tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</uib-tab>\n    </uib-tabset>\n    <uib-tabset justified="true">\n      <uib-tab heading="Justified Tab 1"><b>First</b> Justified Content!</uib-tab>\n      <uib-tab heading="Justified Tab 2"><i>Second</i> Justified Content!</uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive(\'uibTabset\', function() {\n  return {\n    restrict: \'EA\',\n    transclude: true,\n    replace: true,\n    scope: {\n      type: \'@\'\n    },\n    controller: \'UibTabsetController\',\n    templateUrl: \'template/tabs/tabset.html\',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tab\n * @restrict EA\n *\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n * @param {string=} select An expression to evaluate when the tab is selected.\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n *\n * @description\n * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n *\n * @example\n<example module="ui.bootstrap">\n  <file name="index.html">\n    <div ng-controller="TabsDemoCtrl">\n      <button class="btn btn-small" ng-click="items[0].active = true">\n        Select item 1, using active binding\n      </button>\n      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">\n        Enable/disable item 2, using disabled binding\n      </button>\n      <br />\n      <uib-tabset>\n        <uib-tab heading="Tab 1">First Tab</uib-tab>\n        <uib-tab select="alertMe()">\n          <uib-tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>\n          Second Tab, with alert callback and html heading!\n        </uib-tab>\n        <uib-tab ng-repeat="item in items"\n          heading="{{item.title}}"\n          disabled="item.disabled"\n          active="item.active">\n          {{item.content}}\n        </uib-tab>\n      </uib-tabset>\n    </div>\n  </file>\n  <file name="script.js">\n    function TabsDemoCtrl($scope) {\n      $scope.items = [\n        { title:"Dynamic Title 1", content:"Dynamic Item 0" },\n        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }\n      ];\n\n      $scope.alertMe = function() {\n        setTimeout(function() {\n          alert("You\'ve selected the alert tab!");\n        });\n      };\n    };\n  </file>\n</example>\n */\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabHeading\n * @restrict EA\n *\n * @description\n * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n *\n * @example\n<example module="ui.bootstrap">\n  <file name="index.html">\n    <uib-tabset>\n      <uib-tab>\n        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>\n        And some content, too!\n      </uib-tab>\n      <uib-tab>\n        <uib-tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>\n        That\'s right.\n      </uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive(\'uibTab\', [\'$parse\', function($parse) {\n  return {\n    require: \'^uibTabset\',\n    restrict: \'EA\',\n    replace: true,\n    templateUrl: \'template/tabs/tab.html\',\n    transclude: true,\n    scope: {\n      active: \'=?\',\n      heading: \'@\',\n      onSelect: \'&select\', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab\'s content into the dom\n      onDeselect: \'&deselect\'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being \'under\' a tab\n    },\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.$watch(\'active\', function(active) {\n        if (active) {\n          tabsetCtrl.select(scope);\n        }\n      });\n\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      scope.select = function() {\n        if (!scope.disabled) {\n          scope.active = true;\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on(\'$destroy\', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we\'re inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive(\'uibTabHeadingTransclude\', function() {\n  return {\n    restrict: \'A\',\n    require: [\'?^uibTab\', \'?^tab\'], // TODO: change to \'^uibTab\' after deprecation removal\n    link: function(scope, elm) {\n      scope.$watch(\'headingElement\', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html(\'\');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive(\'uibTabContentTransclude\', function() {\n  return {\n    restrict: \'A\',\n    require: [\'?^uibTabset\', \'?^tabset\'], // TODO: change to \'^uibTabset\' after deprecation removal\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude \'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute(\'tab-heading\') || // TODO: remove after deprecation removal\n      node.hasAttribute(\'data-tab-heading\') || // TODO: remove after deprecation removal\n      node.hasAttribute(\'x-tab-heading\') || // TODO: remove after deprecation removal\n      node.hasAttribute(\'uib-tab-heading\') ||\n      node.hasAttribute(\'data-uib-tab-heading\') ||\n      node.hasAttribute(\'x-uib-tab-heading\') ||\n      node.tagName.toLowerCase() === \'tab-heading\' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === \'data-tab-heading\' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === \'x-tab-heading\' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === \'uib-tab-heading\' ||\n      node.tagName.toLowerCase() === \'data-uib-tab-heading\' ||\n      node.tagName.toLowerCase() === \'x-uib-tab-heading\'\n    );\n  }\n});\n\n/* deprecated tabs below */\n\nangular.module(\'ui.bootstrap.tabs\')\n\n  .value(\'$tabsSuppressWarning\', false)\n\n  .controller(\'TabsetController\', [\'$scope\', \'$controller\', \'$log\', \'$tabsSuppressWarning\', function($scope, $controller, $log, $tabsSuppressWarning) {\n    if (!$tabsSuppressWarning) {\n      $log.warn(\'TabsetController is now deprecated. Use UibTabsetController instead.\');\n    }\n\n    angular.extend(this, $controller(\'UibTabsetController\', {\n      $scope: $scope\n    }));\n  }])\n\n  .directive(\'tabset\', [\'$log\', \'$tabsSuppressWarning\', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: \'EA\',\n      transclude: true,\n      replace: true,\n      scope: {\n        type: \'@\'\n      },\n      controller: \'TabsetController\',\n      templateUrl: \'template/tabs/tabset.html\',\n      link: function(scope, element, attrs) {\n\n        if (!$tabsSuppressWarning) {\n          $log.warn(\'tabset is now deprecated. Use uib-tabset instead.\');\n        }\n        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n      }\n    };\n  }])\n\n  .directive(\'tab\', [\'$parse\', \'$log\', \'$tabsSuppressWarning\', function($parse, $log, $tabsSuppressWarning) {\n    return {\n      require: \'^tabset\',\n      restrict: \'EA\',\n      replace: true,\n      templateUrl: \'template/tabs/tab.html\',\n      transclude: true,\n      scope: {\n        active: \'=?\',\n        heading: \'@\',\n        onSelect: \'&select\', //This callback is called in contentHeadingTransclude\n        //once it inserts the tab\'s content into the dom\n        onDeselect: \'&deselect\'\n      },\n      controller: function() {\n        //Empty controller so other directives can require being \'under\' a tab\n      },\n      link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n        if (!$tabsSuppressWarning) {\n          $log.warn(\'tab is now deprecated. Use uib-tab instead.\');\n        }\n\n        scope.$watch(\'active\', function(active) {\n          if (active) {\n            tabsetCtrl.select(scope);\n          }\n        });\n\n        scope.disabled = false;\n        if (attrs.disable) {\n          scope.$parent.$watch($parse(attrs.disable), function(value) {\n            scope.disabled = !!value;\n          });\n        }\n\n        scope.select = function() {\n          if (!scope.disabled) {\n            scope.active = true;\n          }\n        };\n\n        tabsetCtrl.addTab(scope);\n        scope.$on(\'$destroy\', function() {\n          tabsetCtrl.removeTab(scope);\n        });\n\n        //We need to transclude later, once the content container is ready.\n        //when this link happens, we\'re inside a tab heading.\n        scope.$transcludeFn = transclude;\n      }\n    };\n  }])\n\n  .directive(\'tabHeadingTransclude\', [\'$log\', \'$tabsSuppressWarning\', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: \'A\',\n      require: \'^tab\',\n      link: function(scope, elm) {\n        if (!$tabsSuppressWarning) {\n          $log.warn(\'tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.\');\n        }\n\n        scope.$watch(\'headingElement\', function updateHeadingElement(heading) {\n          if (heading) {\n            elm.html(\'\');\n            elm.append(heading);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive(\'tabContentTransclude\', [\'$log\', \'$tabsSuppressWarning\', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: \'A\',\n      require: \'^tabset\',\n      link: function(scope, elm, attrs) {\n        if (!$tabsSuppressWarning) {\n          $log.warn(\'tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.\');\n        }\n\n        var tab = scope.$eval(attrs.tabContentTransclude);\n\n        //Now our tab is ready to be transcluded: both the tab heading area\n        //and the tab content area are loaded.  Transclude \'em both.\n        tab.$transcludeFn(tab.$parent, function(contents) {\n          angular.forEach(contents, function(node) {\n            if (isTabHeading(node)) {\n              //Let tabHeadingTransclude know.\n              tab.headingElement = node;\n            }\n            else {\n              elm.append(node);\n            }\n          });\n        });\n      }\n    };\n\n    function isTabHeading(node) {\n      return node.tagName && (\n          node.hasAttribute(\'tab-heading\') ||\n          node.hasAttribute(\'data-tab-heading\') ||\n          node.hasAttribute(\'x-tab-heading\') ||\n          node.tagName.toLowerCase() === \'tab-heading\' ||\n          node.tagName.toLowerCase() === \'data-tab-heading\' ||\n          node.tagName.toLowerCase() === \'x-tab-heading\'\n        );\n    }\n  }]);\n\nangular.module(\'ui.bootstrap.timepicker\', [])\n\n.constant(\'uibTimepickerConfig\', {\n  hourStep: 1,\n  minuteStep: 1,\n  showMeridian: true,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true\n})\n\n.controller(\'UibTimepickerController\', [\'$scope\', \'$element\', \'$attrs\', \'$parse\', \'$log\', \'$locale\', \'uibTimepickerConfig\', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr(\'tabindex\');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = parseInt(value, 10);\n    });\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = parseInt(value, 10);\n    });\n  }\n\n  var min;\n  $scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  });\n\n  var max;\n  $scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  });\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 13) {\n      return addMinutes(selected, 12 * 60) > max;\n    } else {\n      return addMinutes(selected, -12 * 60) < min;\n    }\n  };\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    });\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = parseInt($scope.hours, 10);\n    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n    if (!valid) {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = parseInt($scope.minutes, 10);\n    return (minutes >= 0 && minutes < 60) ? minutes : undefined;\n  }\n\n  function pad(value) {\n    return (angular.isDefined(value) && value.toString().length < 2) ? \'0\' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n      return (e.detail || delta > 0);\n    };\n\n    hoursInputEl.bind(\'mousewheel wheel\', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind(\'mousewheel wheel\', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      e.preventDefault();\n    });\n\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {\n    hoursInputEl.bind(\'keydown\', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementHours();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementHours();\n        $scope.$apply();\n      }\n    });\n\n    minutesInputEl.bind(\'keydown\', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementMinutes();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementMinutes();\n        $scope.$apply();\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity(\'time\', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh(\'h\');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind(\'blur\', function(e) {\n      if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh(\'m\');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind(\'blur\', function(e) {\n      if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity(\'time\', false);\n      $log.error(\'Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.\');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity(\'time\', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity(\'time\', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    var hours = selected.getHours(), minutes = selected.getMinutes();\n\n    if ($scope.showMeridian) {\n      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system\n    }\n\n    $scope.hours = keyboardChange === \'h\' ? hours : pad(hours);\n    if (keyboardChange !== \'m\') {\n      $scope.minutes = pad(minutes);\n    }\n    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n  }\n\n  function addMinutes(date, minutes) {\n    var dt = new Date(date.getTime() + minutes * 60000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes());\n    return newDate;\n  }\n\n  function addMinutesToSelected(minutes) {\n    selected = addMinutes(selected, minutes);\n    refresh();\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addMinutesToSelected(hourStep * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addMinutesToSelected(-hourStep * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addMinutesToSelected(minuteStep);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addMinutesToSelected(-minuteStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    if (!$scope.noToggleMeridian()) {\n      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));\n    }\n  };\n}])\n\n.directive(\'uibTimepicker\', function() {\n  return {\n    restrict: \'EA\',\n    require: [\'uibTimepicker\', \'?^ngModel\'],\n    controller: \'UibTimepickerController\',\n    controllerAs: \'timepicker\',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/timepicker/timepicker.html\';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find(\'input\'));\n      }\n    }\n  };\n});\n\n/* Deprecated timepicker below */\n\nangular.module(\'ui.bootstrap.timepicker\')\n\n.value(\'$timepickerSuppressWarning\', false)\n\n.controller(\'TimepickerController\', [\'$scope\', \'$element\', \'$attrs\', \'$controller\', \'$log\', \'$timepickerSuppressWarning\', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {\n  if (!$timepickerSuppressWarning) {\n    $log.warn(\'TimepickerController is now deprecated. Use UibTimepickerController instead.\');\n  }\n\n  angular.extend(this, $controller(\'UibTimepickerController\', {\n    $scope: $scope,\n    $element: $element,\n    $attrs: $attrs\n  }));\n}])\n\n.directive(\'timepicker\', [\'$log\', \'$timepickerSuppressWarning\', function($log, $timepickerSuppressWarning) {\n  return {\n    restrict: \'EA\',\n    require: [\'timepicker\', \'?^ngModel\'],\n    controller: \'TimepickerController\',\n    controllerAs: \'timepicker\',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || \'template/timepicker/timepicker.html\';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$timepickerSuppressWarning) {\n        $log.warn(\'timepicker is now deprecated. Use uib-timepicker instead.\');\n      }\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find(\'input\'));\n      }\n    }\n  };\n}]);\n\nangular.module(\'ui.bootstrap.typeahead\', [\'ui.bootstrap.position\'])\n\n/**\n * A helper service that can parse typeahead\'s syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory(\'uibTypeaheadParser\', [\'$parse\', function($parse) {\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            \'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"\' +\n              \' but got "\' + input + \'".\');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller(\'UibTypeaheadController\', [\'$scope\', \'$element\', \'$attrs\', \'$compile\', \'$parse\', \'$q\', \'$timeout\', \'$document\', \'$window\', \'$rootScope\', \'$uibPosition\', \'uibTypeaheadParser\',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + \'($$$p)\');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      } else {\n        return parsedModel.assign(scope, newValue);\n      }\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on(\'$destroy\', function() {\n      scope.$destroy();\n    });\n    scope.$on(\'$destroy\', offDestroy);\n\n    // WAI-ARIA\n    var popupId = \'typeahead-\' + scope.$id + \'-\' + Math.floor(Math.random() * 10000);\n    element.attr({\n      \'aria-autocomplete\': \'list\',\n      \'aria-expanded\': false,\n      \'aria-owns\': popupId\n    });\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element(\'<div uib-typeahead-popup></div>\');\n    popUpEl.attr({\n      id: popupId,\n      matches: \'matches\',\n      active: \'activeIdx\',\n      select: \'select(activeIdx)\',\n      \'move-in-progress\': \'moveInProgress\',\n      query: \'query\',\n      position: \'position\'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr(\'template-url\', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr(\'popup-template-url\', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr(\'aria-expanded\', false);\n    };\n\n    var getMatchId = function(index) {\n      return popupId + \'-option-\' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch(\'activeIdx\', function(index) {\n      if (index < 0) {\n        element.removeAttr(\'aria-activedescendant\');\n      } else {\n        element.attr(\'aria-activedescendant\', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr(\'aria-expanded\', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              scope.select(0);\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).bind(\'resize\', fireRecalculating);\n      $document.find(\'body\').bind(\'scroll\', fireRecalculating);\n    }\n\n    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutEventPromise;\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      // Cancel previous timeout\n      if (timeoutEventPromise) {\n        $timeout.cancel(timeoutEventPromise);\n      }\n\n      // Debounced executing recalculate after events fired\n      timeoutEventPromise = $timeout(function() {\n        // if popup is visible\n        if (scope.matches.length) {\n          recalculatePosition();\n        }\n\n        scope.moveInProgress = false;\n      }, eventDebounceTime);\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop(\'offsetHeight\');\n    }\n\n    //we need to propagate user\'s query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.select = function(activeIdx) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity(\'editable\', true);\n      modelCtrl.$setValidity(\'parse\', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals)\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.bind(\'keydown\', function(evt) {\n      //typeahead is open and an "interesting" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      // if there\'s nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n\n      if (evt.which === 40) {\n        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n        scope.$digest();\n      } else if (evt.which === 38) {\n        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n        scope.$digest();\n      } else if (evt.which === 13 || evt.which === 9) {\n        scope.$apply(function () {\n          scope.select(scope.activeIdx);\n        });\n      } else if (evt.which === 27) {\n        evt.stopPropagation();\n\n        resetMatches();\n        scope.$digest();\n      }\n    });\n\n    element.bind(\'blur\', function() {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          scope.select(scope.activeIdx);\n        });\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          scope.$digest();\n        }\n      }\n    };\n\n    $document.bind(\'click\', dismissClickHandler);\n\n    originalScope.$on(\'$destroy\', function() {\n      $document.unbind(\'click\', dismissClickHandler);\n      if (appendToBody || appendToElementId) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).unbind(\'resize\', fireRecalculating);\n        $document.find(\'body\').unbind(\'scroll\', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find(\'body\').append($popup);\n    } else if (appendToElementId !== false) {\n      angular.element($document[0].getElementById(appendToElementId)).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl, _ngModelOptions) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = _ngModelOptions;\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          if (!inputValue) {\n            // Reset in case user had typed something previously.\n            modelCtrl.$setValidity(\'editable\', true);\n            return null;\n          } else {\n            modelCtrl.$setValidity(\'editable\', false);\n            return undefined;\n          }\n        }\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity(\'editable\', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        } else {\n          //it might happen that we don\'t have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can\'t apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n    };\n  }])\n\n  .directive(\'uibTypeahead\', function() {\n    return {\n      controller: \'UibTypeaheadController\',\n      require: [\'ngModel\', \'^?ngModelOptions\', \'uibTypeahead\'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[2].init(ctrls[0], ctrls[1]);\n      }\n    };\n  })\n\n  .directive(\'uibTypeaheadPopup\', function() {\n    return {\n      scope: {\n        matches: \'=\',\n        query: \'=\',\n        active: \'=\',\n        position: \'&\',\n        moveInProgress: \'=\',\n        select: \'&\'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || \'template/typeahead/typeahead-popup.html\';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive(\'uibTypeaheadMatch\', [\'$templateRequest\', \'$compile\', \'$parse\', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: \'=\',\n        match: \'=\',\n        query: \'=\'\n      },\n      link:function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || \'template/typeahead/typeahead-match.html\';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n\n  .filter(\'uibTypeaheadHighlight\', [\'$sce\', \'$injector\', \'$log\', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has(\'$sanitize\');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is "a" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, \'\\\\$1\');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn(\'Unsafe use of typeahead please use ngSanitize\'); // Warn the user about the danger\n      }\n      matchItem = query? (\'\' + matchItem).replace(new RegExp(escapeRegexp(query), \'gi\'), \'<strong>$&</strong>\') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\n/* Deprecated typeahead below */\n  \nangular.module(\'ui.bootstrap.typeahead\')\n  .value(\'$typeaheadSuppressWarning\', false)\n  .service(\'typeaheadParser\', [\'$parse\', \'uibTypeaheadParser\', \'$log\', \'$typeaheadSuppressWarning\', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {\n    if (!$typeaheadSuppressWarning) {\n      $log.warn(\'typeaheadParser is now deprecated. Use uibTypeaheadParser instead.\');\n    }\n\n    return uibTypeaheadParser;\n  }])\n\n  .directive(\'typeahead\', [\'$compile\', \'$parse\', \'$q\', \'$timeout\', \'$document\', \'$window\', \'$rootScope\', \'$uibPosition\', \'typeaheadParser\', \'$log\', \'$typeaheadSuppressWarning\',\n    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    return {\n      require: [\'ngModel\', \'^?ngModelOptions\'],\n      link: function(originalScope, element, attrs, ctrls) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn(\'typeahead is now deprecated. Use uib-typeahead instead.\');\n        }\n        var modelCtrl = ctrls[0];\n        var ngModelOptions = ctrls[1];\n        //SUPPORTED ATTRIBUTES (OPTIONS)\n\n        //minimal no of characters that needs to be entered before typeahead kicks-in\n        var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n        if (!minLength && minLength !== 0) {\n          minLength = 1;\n        }\n\n        //minimal wait time after last character typed before typeahead kicks-in\n        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n        //should it restrict model values to the ones selected from the popup only?\n        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n        //binding to a variable that indicates if matches are being retrieved asynchronously\n        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n        //a callback executed when a match is selected\n        var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n        //should it select highlighted popup value when losing focus?\n        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n        //binding to a variable that indicates if there were no results after the query is completed\n        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n        var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n        //If input matches an item of the list exactly, select it automatically\n        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n        //INTERNAL VARIABLES\n\n        //model setter executed upon match selection\n        var parsedModel = $parse(attrs.ngModel);\n        var invokeModelSetter = $parse(attrs.ngModel + \'($$$p)\');\n        var $setModelValue = function(scope, newValue) {\n          if (angular.isFunction(parsedModel(originalScope)) &&\n            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n            return invokeModelSetter(scope, {$$$p: newValue});\n          } else {\n            return parsedModel.assign(scope, newValue);\n          }\n        };\n\n        //expressions used by typeahead\n        var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n        var hasFocus;\n\n        //Used to avoid bug in iOS webview where iOS keyboard does not fire\n        //mousedown & mouseup events\n        //Issue #3699\n        var selected;\n\n        //create a child scope for the typeahead directive so we are not polluting original scope\n        //with typeahead-specific data (matches, query etc.)\n        var scope = originalScope.$new();\n        var offDestroy = originalScope.$on(\'$destroy\', function() {\n\t\t\t    scope.$destroy();\n        });\n        scope.$on(\'$destroy\', offDestroy);\n\n        // WAI-ARIA\n        var popupId = \'typeahead-\' + scope.$id + \'-\' + Math.floor(Math.random() * 10000);\n        element.attr({\n          \'aria-autocomplete\': \'list\',\n          \'aria-expanded\': false,\n          \'aria-owns\': popupId\n        });\n\n        //pop-up element used to display matches\n        var popUpEl = angular.element(\'<div typeahead-popup></div>\');\n        popUpEl.attr({\n          id: popupId,\n          matches: \'matches\',\n          active: \'activeIdx\',\n          select: \'select(activeIdx)\',\n          \'move-in-progress\': \'moveInProgress\',\n          query: \'query\',\n          position: \'position\'\n        });\n        //custom item template\n        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n          popUpEl.attr(\'template-url\', attrs.typeaheadTemplateUrl);\n        }\n\n        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n          popUpEl.attr(\'popup-template-url\', attrs.typeaheadPopupTemplateUrl);\n        }\n\n        var resetMatches = function() {\n          scope.matches = [];\n          scope.activeIdx = -1;\n          element.attr(\'aria-expanded\', false);\n        };\n\n        var getMatchId = function(index) {\n          return popupId + \'-option-\' + index;\n        };\n\n        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n        // This attribute is added or removed automatically when the `activeIdx` changes.\n        scope.$watch(\'activeIdx\', function(index) {\n          if (index < 0) {\n            element.removeAttr(\'aria-activedescendant\');\n          } else {\n            element.attr(\'aria-activedescendant\', getMatchId(index));\n          }\n        });\n\n        var inputIsExactMatch = function(inputValue, index) {\n          if (scope.matches.length > index && inputValue) {\n            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n          }\n\n          return false;\n        };\n\n        var getMatchesAsync = function(inputValue) {\n          var locals = {$viewValue: inputValue};\n          isLoadingSetter(originalScope, true);\n          isNoResultsSetter(originalScope, false);\n          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n            //it might happen that several async queries were in progress if a user were typing fast\n            //but we are interested only in responses that correspond to the current view value\n            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n            if (onCurrentRequest && hasFocus) {\n              if (matches && matches.length > 0) {\n                scope.activeIdx = focusFirst ? 0 : -1;\n                isNoResultsSetter(originalScope, false);\n                scope.matches.length = 0;\n\n                //transform labels\n                for (var i = 0; i < matches.length; i++) {\n                  locals[parserResult.itemName] = matches[i];\n                  scope.matches.push({\n                    id: getMatchId(i),\n                    label: parserResult.viewMapper(scope, locals),\n                    model: matches[i]\n                  });\n                }\n\n                scope.query = inputValue;\n                //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n                //due to other elements being rendered\n                recalculatePosition();\n\n                element.attr(\'aria-expanded\', true);\n\n                //Select the single remaining option if user input matches\n                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n                  scope.select(0);\n                }\n              } else {\n                resetMatches();\n                isNoResultsSetter(originalScope, true);\n              }\n            }\n            if (onCurrentRequest) {\n              isLoadingSetter(originalScope, false);\n            }\n          }, function() {\n            resetMatches();\n            isLoadingSetter(originalScope, false);\n            isNoResultsSetter(originalScope, true);\n          });\n        };\n\n        // bind events only if appendToBody params exist - performance feature\n        if (appendToBody) {\n          angular.element($window).bind(\'resize\', fireRecalculating);\n          $document.find(\'body\').bind(\'scroll\', fireRecalculating);\n        }\n\n        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutEventPromise;\n\n        // Default progress type\n        scope.moveInProgress = false;\n\n        function fireRecalculating() {\n          if (!scope.moveInProgress) {\n            scope.moveInProgress = true;\n            scope.$digest();\n          }\n\n          // Cancel previous timeout\n          if (timeoutEventPromise) {\n            $timeout.cancel(timeoutEventPromise);\n          }\n\n          // Debounced executing recalculate after events fired\n          timeoutEventPromise = $timeout(function() {\n            // if popup is visible\n            if (scope.matches.length) {\n              recalculatePosition();\n            }\n\n            scope.moveInProgress = false;\n          }, eventDebounceTime);\n        }\n\n        // recalculate actual position and set new values to scope\n        // after digest loop is popup in right position\n        function recalculatePosition() {\n          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n          scope.position.top += element.prop(\'offsetHeight\');\n        }\n\n        resetMatches();\n\n        //we need to propagate user\'s query so we can higlight matches\n        scope.query = undefined;\n\n        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutPromise;\n\n        var scheduleSearchWithTimeout = function(inputValue) {\n          timeoutPromise = $timeout(function() {\n            getMatchesAsync(inputValue);\n          }, waitTime);\n        };\n\n        var cancelPreviousTimeout = function() {\n          if (timeoutPromise) {\n            $timeout.cancel(timeoutPromise);\n          }\n        };\n\n        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n        modelCtrl.$parsers.unshift(function(inputValue) {\n          hasFocus = true;\n\n          if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n            if (waitTime > 0) {\n              cancelPreviousTimeout();\n              scheduleSearchWithTimeout(inputValue);\n            } else {\n              getMatchesAsync(inputValue);\n            }\n          } else {\n            isLoadingSetter(originalScope, false);\n            cancelPreviousTimeout();\n            resetMatches();\n          }\n\n          if (isEditable) {\n            return inputValue;\n          } else {\n            if (!inputValue) {\n              // Reset in case user had typed something previously.\n              modelCtrl.$setValidity(\'editable\', true);\n              return null;\n            } else {\n              modelCtrl.$setValidity(\'editable\', false);\n              return undefined;\n            }\n          }\n        });\n\n        modelCtrl.$formatters.push(function(modelValue) {\n          var candidateViewValue, emptyViewValue;\n          var locals = {};\n\n          // The validity may be set to false via $parsers (see above) if\n          // the model is restricted to selected values. If the model\n          // is set manually it is considered to be valid.\n          if (!isEditable) {\n            modelCtrl.$setValidity(\'editable\', true);\n          }\n\n          if (inputFormatter) {\n            locals.$model = modelValue;\n            return inputFormatter(originalScope, locals);\n          } else {\n            //it might happen that we don\'t have enough info to properly render input value\n            //we need to check for this situation and simply return model value if we can\'t apply custom formatting\n            locals[parserResult.itemName] = modelValue;\n            candidateViewValue = parserResult.viewMapper(originalScope, locals);\n            locals[parserResult.itemName] = undefined;\n            emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n          }\n        });\n\n        scope.select = function(activeIdx) {\n          //called from within the $digest() cycle\n          var locals = {};\n          var model, item;\n\n          selected = true;\n          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n          model = parserResult.modelMapper(originalScope, locals);\n          $setModelValue(originalScope, model);\n          modelCtrl.$setValidity(\'editable\', true);\n          modelCtrl.$setValidity(\'parse\', true);\n\n          onSelectCallback(originalScope, {\n            $item: item,\n            $model: model,\n            $label: parserResult.viewMapper(originalScope, locals)\n          });\n\n          resetMatches();\n\n          //return focus to the input element if a match was selected via a mouse click event\n          // use timeout to avoid $rootScope:inprog error\n          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n            $timeout(function() { element[0].focus(); }, 0, false);\n          }\n        };\n\n        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n        element.bind(\'keydown\', function(evt) {\n          //typeahead is open and an "interesting" key was pressed\n          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n            return;\n          }\n\n          // if there\'s nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n            resetMatches();\n            scope.$digest();\n            return;\n          }\n\n          evt.preventDefault();\n\n          if (evt.which === 40) {\n            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n            scope.$digest();\n          } else if (evt.which === 38) {\n            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n            scope.$digest();\n          } else if (evt.which === 13 || evt.which === 9) {\n            scope.$apply(function () {\n              scope.select(scope.activeIdx);\n            });\n          } else if (evt.which === 27) {\n            evt.stopPropagation();\n\n            resetMatches();\n            scope.$digest();\n          }\n        });\n\n        element.bind(\'blur\', function() {\n          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n            selected = true;\n            scope.$apply(function() {\n              scope.select(scope.activeIdx);\n            });\n          }\n          hasFocus = false;\n          selected = false;\n        });\n\n        // Keep reference to click handler to unbind it.\n        var dismissClickHandler = function(evt) {\n          // Issue #3973\n          // Firefox treats right click as a click on document\n          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n            resetMatches();\n            if (!$rootScope.$$phase) {\n              scope.$digest();\n            }\n          }\n        };\n\n        $document.bind(\'click\', dismissClickHandler);\n\n        originalScope.$on(\'$destroy\', function() {\n          $document.unbind(\'click\', dismissClickHandler);\n          if (appendToBody || appendToElementId) {\n            $popup.remove();\n          }\n\n          if (appendToBody) {\n            angular.element($window).unbind(\'resize\', fireRecalculating);\n            $document.find(\'body\').unbind(\'scroll\', fireRecalculating);\n          }\n          // Prevent jQuery cache memory leak\n          popUpEl.remove();\n        });\n\n        var $popup = $compile(popUpEl)(scope);\n\n        if (appendToBody) {\n          $document.find(\'body\').append($popup);\n        } else if (appendToElementId !== false) {\n          angular.element($document[0].getElementById(appendToElementId)).append($popup);\n        } else {\n          element.after($popup);\n        }\n      }\n    };\n  }])\n  \n  .directive(\'typeaheadPopup\', [\'$typeaheadSuppressWarning\', \'$log\', function($typeaheadSuppressWarning, $log) {\n    return {\n      scope: {\n        matches: \'=\',\n        query: \'=\',\n        active: \'=\',\n        position: \'&\',\n        moveInProgress: \'=\',\n        select: \'&\'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || \'template/typeahead/typeahead-popup.html\';\n      },\n      link: function(scope, element, attrs) {\n        \n        if (!$typeaheadSuppressWarning) {\n          $log.warn(\'typeahead-popup is now deprecated. Use uib-typeahead-popup instead.\');\n        }\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  }])\n  \n  .directive(\'typeaheadMatch\', [\'$templateRequest\', \'$compile\', \'$parse\', \'$typeaheadSuppressWarning\', \'$log\', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {\n    return {\n      restrict: \'EA\',\n      scope: {\n        index: \'=\',\n        match: \'=\',\n        query: \'=\'\n      },\n      link:function(scope, element, attrs) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn(\'typeahead-match is now deprecated. Use uib-typeahead-match instead.\');\n        }\n\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || \'template/typeahead/typeahead-match.html\';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n  \n  .filter(\'typeaheadHighlight\', [\'$sce\', \'$injector\', \'$log\', \'$typeaheadSuppressWarning\', function($sce, $injector, $log, $typeaheadSuppressWarning) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has(\'$sanitize\');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is "a" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, \'\\\\$1\');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!$typeaheadSuppressWarning) {\n        $log.warn(\'typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.\');\n      }\n\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn(\'Unsafe use of typeahead please use ngSanitize\'); // Warn the user about the danger\n      }\n\n      matchItem = query? (\'\' + matchItem).replace(new RegExp(escapeRegexp(query), \'gi\'), \'<strong>$&</strong>\') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n\n      return matchItem;\n    };\n  }]);\n\nangular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/accordion/accordion-group.html",\n    "<div class=\\"panel {{panelClass || \'panel-default\'}}\\">\\n" +\n    "  <div class=\\"panel-heading\\" ng-keypress=\\"toggleOpen($event)\\">\\n" +\n    "    <h4 class=\\"panel-title\\">\\n" +\n    "      <a href tabindex=\\"0\\" class=\\"accordion-toggle\\" ng-click=\\"toggleOpen()\\" uib-accordion-transclude=\\"heading\\"><span ng-class=\\"{\'text-muted\': isDisabled}\\">{{heading}}</span></a>\\n" +\n    "    </h4>\\n" +\n    "  </div>\\n" +\n    "  <div class=\\"panel-collapse collapse\\" uib-collapse=\\"!isOpen\\">\\n" +\n    "\t  <div class=\\"panel-body\\" ng-transclude></div>\\n" +\n    "  </div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/accordion/accordion.html",\n    "<div class=\\"panel-group\\" ng-transclude></div>");\n}]);\n\nangular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/alert/alert.html",\n    "<div class=\\"alert\\" ng-class=\\"[\'alert-\' + (type || \'warning\'), closeable ? \'alert-dismissible\' : null]\\" role=\\"alert\\">\\n" +\n    "    <button ng-show=\\"closeable\\" type=\\"button\\" class=\\"close\\" ng-click=\\"close({$event: $event})\\">\\n" +\n    "        <span aria-hidden=\\"true\\">&times;</span>\\n" +\n    "        <span class=\\"sr-only\\">Close</span>\\n" +\n    "    </button>\\n" +\n    "    <div ng-transclude></div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/carousel/carousel.html",\n    "<div ng-mouseenter=\\"pause()\\" ng-mouseleave=\\"play()\\" class=\\"carousel\\" ng-swipe-right=\\"prev()\\" ng-swipe-left=\\"next()\\">\\n" +\n    "  <div class=\\"carousel-inner\\" ng-transclude></div>\\n" +\n    "  <a role=\\"button\\" href class=\\"left carousel-control\\" ng-click=\\"prev()\\" ng-show=\\"slides.length > 1\\">\\n" +\n    "    <span aria-hidden=\\"true\\" class=\\"glyphicon glyphicon-chevron-left\\"></span>\\n" +\n    "    <span class=\\"sr-only\\">previous</span>\\n" +\n    "  </a>\\n" +\n    "  <a role=\\"button\\" href class=\\"right carousel-control\\" ng-click=\\"next()\\" ng-show=\\"slides.length > 1\\">\\n" +\n    "    <span aria-hidden=\\"true\\" class=\\"glyphicon glyphicon-chevron-right\\"></span>\\n" +\n    "    <span class=\\"sr-only\\">next</span>\\n" +\n    "  </a>\\n" +\n    "  <ol class=\\"carousel-indicators\\" ng-show=\\"slides.length > 1\\">\\n" +\n    "    <li ng-repeat=\\"slide in slides | orderBy:indexOfSlide track by $index\\" ng-class=\\"{ active: isActive(slide) }\\" ng-click=\\"select(slide)\\">\\n" +\n    "      <span class=\\"sr-only\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\"isActive(slide)\\">, currently active</span></span>\\n" +\n    "    </li>\\n" +\n    "  </ol>\\n" +\n    "</div>");\n}]);\n\nangular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/carousel/slide.html",\n    "<div ng-class=\\"{\\n" +\n    "    \'active\': active\\n" +\n    "  }\\" class=\\"item text-center\\" ng-transclude></div>\\n" +\n    "");\n}]);\n\nangular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/datepicker/datepicker.html",\n    "<div ng-switch=\\"datepickerMode\\" role=\\"application\\" ng-keydown=\\"keydown($event)\\">\\n" +\n    "  <uib-daypicker ng-switch-when=\\"day\\" tabindex=\\"0\\"></uib-daypicker>\\n" +\n    "  <uib-monthpicker ng-switch-when=\\"month\\" tabindex=\\"0\\"></uib-monthpicker>\\n" +\n    "  <uib-yearpicker ng-switch-when=\\"year\\" tabindex=\\"0\\"></uib-yearpicker>\\n" +\n    "</div>");\n}]);\n\nangular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/datepicker/day.html",\n    "<table role=\\"grid\\" aria-labelledby=\\"{{::uniqueId}}-title\\" aria-activedescendant=\\"{{activeDateId}}\\">\\n" +\n    "  <thead>\\n" +\n    "    <tr>\\n" +\n    "      <th><button type=\\"button\\" class=\\"btn btn-default btn-sm pull-left\\" ng-click=\\"move(-1)\\" tabindex=\\"-1\\"><i class=\\"glyphicon glyphicon-chevron-left\\"></i></button></th>\\n" +\n    "      <th colspan=\\"{{::5 + showWeeks}}\\"><button id=\\"{{::uniqueId}}-title\\" role=\\"heading\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\" type=\\"button\\" class=\\"btn btn-default btn-sm\\" ng-click=\\"toggleMode()\\" ng-disabled=\\"datepickerMode === maxMode\\" tabindex=\\"-1\\" style=\\"width:100%;\\"><strong>{{title}}</strong></button></th>\\n" +\n    "      <th><button type=\\"button\\" class=\\"btn btn-default btn-sm pull-right\\" ng-click=\\"move(1)\\" tabindex=\\"-1\\"><i class=\\"glyphicon glyphicon-chevron-right\\"></i></button></th>\\n" +\n    "    </tr>\\n" +\n    "    <tr>\\n" +\n    "      <th ng-if=\\"showWeeks\\" class=\\"text-center\\"></th>\\n" +\n    "      <th ng-repeat=\\"label in ::labels track by $index\\" class=\\"text-center\\"><small aria-label=\\"{{::label.full}}\\">{{::label.abbr}}</small></th>\\n" +\n    "    </tr>\\n" +\n    "  </thead>\\n" +\n    "  <tbody>\\n" +\n    "    <tr ng-repeat=\\"row in rows track by $index\\">\\n" +\n    "      <td ng-if=\\"showWeeks\\" class=\\"text-center h6\\"><em>{{ weekNumbers[$index] }}</em></td>\\n" +\n    "      <td ng-repeat=\\"dt in row track by dt.date\\" class=\\"text-center\\" role=\\"gridcell\\" id=\\"{{::dt.uid}}\\" ng-class=\\"::dt.customClass\\">\\n" +\n    "        <button type=\\"button\\" style=\\"min-width:100%;\\" class=\\"btn btn-default btn-sm\\" ng-class=\\"{\'btn-info\': dt.selected, active: isActive(dt)}\\" ng-click=\\"select(dt.date)\\" ng-disabled=\\"dt.disabled\\" tabindex=\\"-1\\"><span ng-class=\\"::{\'text-muted\': dt.secondary, \'text-info\': dt.current}\\">{{::dt.label}}</span></button>\\n" +\n    "      </td>\\n" +\n    "    </tr>\\n" +\n    "  </tbody>\\n" +\n    "</table>\\n" +\n    "");\n}]);\n\nangular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/datepicker/month.html",\n    "<table role=\\"grid\\" aria-labelledby=\\"{{::uniqueId}}-title\\" aria-activedescendant=\\"{{activeDateId}}\\">\\n" +\n    "  <thead>\\n" +\n    "    <tr>\\n" +\n    "      <th><button type=\\"button\\" class=\\"btn btn-default btn-sm pull-left\\" ng-click=\\"move(-1)\\" tabindex=\\"-1\\"><i class=\\"glyphicon glyphicon-chevron-left\\"></i></button></th>\\n" +\n    "      <th><button id=\\"{{::uniqueId}}-title\\" role=\\"heading\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\" type=\\"button\\" class=\\"btn btn-default btn-sm\\" ng-click=\\"toggleMode()\\" ng-disabled=\\"datepickerMode === maxMode\\" tabindex=\\"-1\\" style=\\"width:100%;\\"><strong>{{title}}</strong></button></th>\\n" +\n    "      <th><button type=\\"button\\" class=\\"btn btn-default btn-sm pull-right\\" ng-click=\\"move(1)\\" tabindex=\\"-1\\"><i class=\\"glyphicon glyphicon-chevron-right\\"></i></button></th>\\n" +\n    "    </tr>\\n" +\n    "  </thead>\\n" +\n    "  <tbody>\\n" +\n    "    <tr ng-repeat=\\"row in rows track by $index\\">\\n" +\n    "      <td ng-repeat=\\"dt in row track by dt.date\\" class=\\"text-center\\" role=\\"gridcell\\" id=\\"{{::dt.uid}}\\" ng-class=\\"::dt.customClass\\">\\n" +\n    "        <button type=\\"button\\" style=\\"min-width:100%;\\" class=\\"btn btn-default\\" ng-class=\\"{\'btn-info\': dt.selected, active: isActive(dt)}\\" ng-click=\\"select(dt.date)\\" ng-disabled=\\"dt.disabled\\" tabindex=\\"-1\\"><span ng-class=\\"::{\'text-info\': dt.current}\\">{{::dt.label}}</span></button>\\n" +\n    "      </td>\\n" +\n    "    </tr>\\n" +\n    "  </tbody>\\n" +\n    "</table>\\n" +\n    "");\n}]);\n\nangular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/datepicker/popup.html",\n    "<ul class=\\"dropdown-menu\\" dropdown-nested ng-if=\\"isOpen\\" style=\\"display: block\\" ng-style=\\"{top: position.top+\'px\', left: position.left+\'px\'}\\" ng-keydown=\\"keydown($event)\\" ng-click=\\"$event.stopPropagation()\\">\\n" +\n    "\t<li ng-transclude></li>\\n" +\n    "\t<li ng-if=\\"showButtonBar\\" style=\\"padding:10px 9px 2px\\">\\n" +\n    "\t\t<span class=\\"btn-group pull-left\\">\\n" +\n    "\t\t\t<button type=\\"button\\" class=\\"btn btn-sm btn-info\\" ng-click=\\"select(\'today\')\\" ng-disabled=\\"isDisabled(\'today\')\\">{{ getText(\'current\') }}</button>\\n" +\n    "\t\t\t<button type=\\"button\\" class=\\"btn btn-sm btn-danger\\" ng-click=\\"select(null)\\">{{ getText(\'clear\') }}</button>\\n" +\n    "\t\t</span>\\n" +\n    "\t\t<button type=\\"button\\" class=\\"btn btn-sm btn-success pull-right\\" ng-click=\\"close()\\">{{ getText(\'close\') }}</button>\\n" +\n    "\t</li>\\n" +\n    "</ul>\\n" +\n    "");\n}]);\n\nangular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/datepicker/year.html",\n    "<table role=\\"grid\\" aria-labelledby=\\"{{::uniqueId}}-title\\" aria-activedescendant=\\"{{activeDateId}}\\">\\n" +\n    "  <thead>\\n" +\n    "    <tr>\\n" +\n    "      <th><button type=\\"button\\" class=\\"btn btn-default btn-sm pull-left\\" ng-click=\\"move(-1)\\" tabindex=\\"-1\\"><i class=\\"glyphicon glyphicon-chevron-left\\"></i></button></th>\\n" +\n    "      <th colspan=\\"3\\"><button id=\\"{{::uniqueId}}-title\\" role=\\"heading\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\" type=\\"button\\" class=\\"btn btn-default btn-sm\\" ng-click=\\"toggleMode()\\" ng-disabled=\\"datepickerMode === maxMode\\" tabindex=\\"-1\\" style=\\"width:100%;\\"><strong>{{title}}</strong></button></th>\\n" +\n    "      <th><button type=\\"button\\" class=\\"btn btn-default btn-sm pull-right\\" ng-click=\\"move(1)\\" tabindex=\\"-1\\"><i class=\\"glyphicon glyphicon-chevron-right\\"></i></button></th>\\n" +\n    "    </tr>\\n" +\n    "  </thead>\\n" +\n    "  <tbody>\\n" +\n    "    <tr ng-repeat=\\"row in rows track by $index\\">\\n" +\n    "      <td ng-repeat=\\"dt in row track by dt.date\\" class=\\"text-center\\" role=\\"gridcell\\" id=\\"{{::dt.uid}}\\" ng-class=\\"::dt.customClass\\">\\n" +\n    "        <button type=\\"button\\" style=\\"min-width:100%;\\" class=\\"btn btn-default\\" ng-class=\\"{\'btn-info\': dt.selected, active: isActive(dt)}\\" ng-click=\\"select(dt.date)\\" ng-disabled=\\"dt.disabled\\" tabindex=\\"-1\\"><span ng-class=\\"::{\'text-info\': dt.current}\\">{{::dt.label}}</span></button>\\n" +\n    "      </td>\\n" +\n    "    </tr>\\n" +\n    "  </tbody>\\n" +\n    "</table>\\n" +\n    "");\n}]);\n\nangular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/modal/backdrop.html",\n    "<div uib-modal-animation-class=\\"fade\\"\\n" +\n    "     modal-in-class=\\"in\\"\\n" +\n    "     ng-style=\\"{\'z-index\': 1040 + (index && 1 || 0) + index*10}\\"\\n" +\n    "></div>\\n" +\n    "");\n}]);\n\nangular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/modal/window.html",\n    "<div modal-render=\\"{{$isRendered}}\\" tabindex=\\"-1\\" role=\\"dialog\\" class=\\"modal\\"\\n" +\n    "    uib-modal-animation-class=\\"fade\\"\\n" +\n    "    modal-in-class=\\"in\\"\\n" +\n    "    ng-style=\\"{\'z-index\': 1050 + index*10, display: \'block\'}\\">\\n" +\n    "    <div class=\\"modal-dialog\\" ng-class=\\"size ? \'modal-\' + size : \'\'\\"><div class=\\"modal-content\\" uib-modal-transclude></div></div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/pagination/pager.html",\n    "<ul class=\\"pager\\">\\n" +\n    "  <li ng-class=\\"{disabled: noPrevious()||ngDisabled, previous: align}\\"><a href ng-click=\\"selectPage(page - 1, $event)\\">{{::getText(\'previous\')}}</a></li>\\n" +\n    "  <li ng-class=\\"{disabled: noNext()||ngDisabled, next: align}\\"><a href ng-click=\\"selectPage(page + 1, $event)\\">{{::getText(\'next\')}}</a></li>\\n" +\n    "</ul>\\n" +\n    "");\n}]);\n\nangular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/pagination/pagination.html",\n    "<ul class=\\"pagination\\">\\n" +\n    "  <li ng-if=\\"::boundaryLinks\\" ng-class=\\"{disabled: noPrevious()||ngDisabled}\\" class=\\"pagination-first\\"><a href ng-click=\\"selectPage(1, $event)\\">{{::getText(\'first\')}}</a></li>\\n" +\n    "  <li ng-if=\\"::directionLinks\\" ng-class=\\"{disabled: noPrevious()||ngDisabled}\\" class=\\"pagination-prev\\"><a href ng-click=\\"selectPage(page - 1, $event)\\">{{::getText(\'previous\')}}</a></li>\\n" +\n    "  <li ng-repeat=\\"page in pages track by $index\\" ng-class=\\"{active: page.active,disabled: ngDisabled&&!page.active}\\" class=\\"pagination-page\\"><a href ng-click=\\"selectPage(page.number, $event)\\">{{page.text}}</a></li>\\n" +\n    "  <li ng-if=\\"::directionLinks\\" ng-class=\\"{disabled: noNext()||ngDisabled}\\" class=\\"pagination-next\\"><a href ng-click=\\"selectPage(page + 1, $event)\\">{{::getText(\'next\')}}</a></li>\\n" +\n    "  <li ng-if=\\"::boundaryLinks\\" ng-class=\\"{disabled: noNext()||ngDisabled}\\" class=\\"pagination-last\\"><a href ng-click=\\"selectPage(totalPages, $event)\\">{{::getText(\'last\')}}</a></li>\\n" +\n    "</ul>\\n" +\n    "");\n}]);\n\nangular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/tooltip/tooltip-html-popup.html",\n    "<div\\n" +\n    "  tooltip-animation-class=\\"fade\\"\\n" +\n    "  uib-tooltip-classes\\n" +\n    "  ng-class=\\"{ in: isOpen() }\\">\\n" +\n    "  <div class=\\"tooltip-arrow\\"></div>\\n" +\n    "  <div class=\\"tooltip-inner\\" ng-bind-html=\\"contentExp()\\"></div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/tooltip/tooltip-popup.html",\n    "<div\\n" +\n    "  tooltip-animation-class=\\"fade\\"\\n" +\n    "  uib-tooltip-classes\\n" +\n    "  ng-class=\\"{ in: isOpen() }\\">\\n" +\n    "  <div class=\\"tooltip-arrow\\"></div>\\n" +\n    "  <div class=\\"tooltip-inner\\" ng-bind=\\"content\\"></div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/tooltip/tooltip-template-popup.html",\n    "<div\\n" +\n    "  tooltip-animation-class=\\"fade\\"\\n" +\n    "  uib-tooltip-classes\\n" +\n    "  ng-class=\\"{ in: isOpen() }\\">\\n" +\n    "  <div class=\\"tooltip-arrow\\"></div>\\n" +\n    "  <div class=\\"tooltip-inner\\"\\n" +\n    "    uib-tooltip-template-transclude=\\"contentExp()\\"\\n" +\n    "    tooltip-template-transclude-scope=\\"originScope()\\"></div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/popover/popover-html.html",\n    "<div tooltip-animation-class=\\"fade\\"\\n" +\n    "  uib-tooltip-classes\\n" +\n    "  ng-class=\\"{ in: isOpen() }\\">\\n" +\n    "  <div class=\\"arrow\\"></div>\\n" +\n    "\\n" +\n    "  <div class=\\"popover-inner\\">\\n" +\n    "      <h3 class=\\"popover-title\\" ng-bind=\\"title\\" ng-if=\\"title\\"></h3>\\n" +\n    "      <div class=\\"popover-content\\" ng-bind-html=\\"contentExp()\\"></div>\\n" +\n    "  </div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/popover/popover-template.html",\n    "<div tooltip-animation-class=\\"fade\\"\\n" +\n    "  uib-tooltip-classes\\n" +\n    "  ng-class=\\"{ in: isOpen() }\\">\\n" +\n    "  <div class=\\"arrow\\"></div>\\n" +\n    "\\n" +\n    "  <div class=\\"popover-inner\\">\\n" +\n    "      <h3 class=\\"popover-title\\" ng-bind=\\"title\\" ng-if=\\"title\\"></h3>\\n" +\n    "      <div class=\\"popover-content\\"\\n" +\n    "        uib-tooltip-template-transclude=\\"contentExp()\\"\\n" +\n    "        tooltip-template-transclude-scope=\\"originScope()\\"></div>\\n" +\n    "  </div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/popover/popover.html",\n    "<div tooltip-animation-class=\\"fade\\"\\n" +\n    "  uib-tooltip-classes\\n" +\n    "  ng-class=\\"{ in: isOpen() }\\">\\n" +\n    "  <div class=\\"arrow\\"></div>\\n" +\n    "\\n" +\n    "  <div class=\\"popover-inner\\">\\n" +\n    "      <h3 class=\\"popover-title\\" ng-bind=\\"title\\" ng-if=\\"title\\"></h3>\\n" +\n    "      <div class=\\"popover-content\\" ng-bind=\\"content\\"></div>\\n" +\n    "  </div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/progressbar/bar.html",\n    "<div class=\\"progress-bar\\" ng-class=\\"type && \'progress-bar-\' + type\\" role=\\"progressbar\\" aria-valuenow=\\"{{value}}\\" aria-valuemin=\\"0\\" aria-valuemax=\\"{{max}}\\" ng-style=\\"{width: (percent < 100 ? percent : 100) + \'%\'}\\" aria-valuetext=\\"{{percent | number:0}}%\\" aria-labelledby=\\"{{::title}}\\" style=\\"min-width: 0;\\" ng-transclude></div>\\n" +\n    "");\n}]);\n\nangular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/progressbar/progress.html",\n    "<div class=\\"progress\\" ng-transclude aria-labelledby=\\"{{::title}}\\"></div>");\n}]);\n\nangular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/progressbar/progressbar.html",\n    "<div class=\\"progress\\">\\n" +\n    "  <div class=\\"progress-bar\\" ng-class=\\"type && \'progress-bar-\' + type\\" role=\\"progressbar\\" aria-valuenow=\\"{{value}}\\" aria-valuemin=\\"0\\" aria-valuemax=\\"{{max}}\\" ng-style=\\"{width: (percent < 100 ? percent : 100) + \'%\'}\\" aria-valuetext=\\"{{percent | number:0}}%\\" aria-labelledby=\\"{{::title}}\\" style=\\"min-width: 0;\\" ng-transclude></div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/rating/rating.html",\n    "<span ng-mouseleave=\\"reset()\\" ng-keydown=\\"onKeydown($event)\\" tabindex=\\"0\\" role=\\"slider\\" aria-valuemin=\\"0\\" aria-valuemax=\\"{{range.length}}\\" aria-valuenow=\\"{{value}}\\">\\n" +\n    "    <span ng-repeat-start=\\"r in range track by $index\\" class=\\"sr-only\\">({{ $index < value ? \'*\' : \' \' }})</span>\\n" +\n    "    <i ng-repeat-end ng-mouseenter=\\"enter($index + 1)\\" ng-click=\\"rate($index + 1)\\" class=\\"glyphicon\\" ng-class=\\"$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')\\" ng-attr-title=\\"{{r.title}}\\" aria-valuetext=\\"{{r.title}}\\"></i>\\n" +\n    "</span>\\n" +\n    "");\n}]);\n\nangular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/tabs/tab.html",\n    "<li ng-class=\\"{active: active, disabled: disabled}\\">\\n" +\n    "  <a href ng-click=\\"select()\\" uib-tab-heading-transclude>{{heading}}</a>\\n" +\n    "</li>\\n" +\n    "");\n}]);\n\nangular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/tabs/tabset.html",\n    "<div>\\n" +\n    "  <ul class=\\"nav nav-{{type || \'tabs\'}}\\" ng-class=\\"{\'nav-stacked\': vertical, \'nav-justified\': justified}\\" ng-transclude></ul>\\n" +\n    "  <div class=\\"tab-content\\">\\n" +\n    "    <div class=\\"tab-pane\\" \\n" +\n    "         ng-repeat=\\"tab in tabs\\" \\n" +\n    "         ng-class=\\"{active: tab.active}\\"\\n" +\n    "         uib-tab-content-transclude=\\"tab\\">\\n" +\n    "    </div>\\n" +\n    "  </div>\\n" +\n    "</div>\\n" +\n    "");\n}]);\n\nangular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/timepicker/timepicker.html",\n    "<table>\\n" +\n    "  <tbody>\\n" +\n    "    <tr class=\\"text-center\\" ng-show=\\"::showSpinners\\">\\n" +\n    "      <td><a ng-click=\\"incrementHours()\\" ng-class=\\"{disabled: noIncrementHours()}\\" class=\\"btn btn-link\\" ng-disabled=\\"noIncrementHours()\\" tabindex=\\"{{::tabindex}}\\"><span class=\\"glyphicon glyphicon-chevron-up\\"></span></a></td>\\n" +\n    "      <td>&nbsp;</td>\\n" +\n    "      <td><a ng-click=\\"incrementMinutes()\\" ng-class=\\"{disabled: noIncrementMinutes()}\\" class=\\"btn btn-link\\" ng-disabled=\\"noIncrementMinutes()\\" tabindex=\\"{{::tabindex}}\\"><span class=\\"glyphicon glyphicon-chevron-up\\"></span></a></td>\\n" +\n    "      <td ng-show=\\"showMeridian\\"></td>\\n" +\n    "    </tr>\\n" +\n    "    <tr>\\n" +\n    "      <td class=\\"form-group\\" ng-class=\\"{\'has-error\': invalidHours}\\">\\n" +\n    "        <input style=\\"width:50px;\\" type=\\"text\\" ng-model=\\"hours\\" ng-change=\\"updateHours()\\" class=\\"form-control text-center\\" ng-readonly=\\"::readonlyInput\\" maxlength=\\"2\\" tabindex=\\"{{::tabindex}}\\">\\n" +\n    "      </td>\\n" +\n    "      <td>:</td>\\n" +\n    "      <td class=\\"form-group\\" ng-class=\\"{\'has-error\': invalidMinutes}\\">\\n" +\n    "        <input style=\\"width:50px;\\" type=\\"text\\" ng-model=\\"minutes\\" ng-change=\\"updateMinutes()\\" class=\\"form-control text-center\\" ng-readonly=\\"::readonlyInput\\" maxlength=\\"2\\" tabindex=\\"{{::tabindex}}\\">\\n" +\n    "      </td>\\n" +\n    "      <td ng-show=\\"showMeridian\\"><button type=\\"button\\" ng-class=\\"{disabled: noToggleMeridian()}\\" class=\\"btn btn-default text-center\\" ng-click=\\"toggleMeridian()\\" ng-disabled=\\"noToggleMeridian()\\" tabindex=\\"{{::tabindex}}\\">{{meridian}}</button></td>\\n" +\n    "    </tr>\\n" +\n    "    <tr class=\\"text-center\\" ng-show=\\"::showSpinners\\">\\n" +\n    "      <td><a ng-click=\\"decrementHours()\\" ng-class=\\"{disabled: noDecrementHours()}\\" class=\\"btn btn-link\\" ng-disabled=\\"noDecrementHours()\\" tabindex=\\"{{::tabindex}}\\"><span class=\\"glyphicon glyphicon-chevron-down\\"></span></a></td>\\n" +\n    "      <td>&nbsp;</td>\\n" +\n    "      <td><a ng-click=\\"decrementMinutes()\\" ng-class=\\"{disabled: noDecrementMinutes()}\\" class=\\"btn btn-link\\" ng-disabled=\\"noDecrementMinutes()\\" tabindex=\\"{{::tabindex}}\\"><span class=\\"glyphicon glyphicon-chevron-down\\"></span></a></td>\\n" +\n    "      <td ng-show=\\"showMeridian\\"></td>\\n" +\n    "    </tr>\\n" +\n    "  </tbody>\\n" +\n    "</table>\\n" +\n    "");\n}]);\n\nangular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/typeahead/typeahead-match.html",\n    "<a href tabindex=\\"-1\\" ng-bind-html=\\"match.label | uibTypeaheadHighlight:query\\"></a>\\n" +\n    "");\n}]);\n\nangular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {\n  $templateCache.put("template/typeahead/typeahead-popup.html",\n    "<ul class=\\"dropdown-menu\\" ng-show=\\"isOpen() && !moveInProgress\\" ng-style=\\"{top: position().top+\'px\', left: position().left+\'px\'}\\" style=\\"display: block;\\" role=\\"listbox\\" aria-hidden=\\"{{!isOpen()}}\\">\\n" +\n    "    <li ng-repeat=\\"match in matches track by $index\\" ng-class=\\"{active: isActive($index) }\\" ng-mouseenter=\\"selectActive($index)\\" ng-click=\\"selectMatch($index)\\" role=\\"option\\" id=\\"{{::match.id}}\\">\\n" +\n    "        <div uib-typeahead-match index=\\"$index\\" match=\\"match\\" query=\\"query\\" template-url=\\"templateUrl\\"></div>\\n" +\n    "    </li>\\n" +\n    "</ul>\\n" +\n    "");\n}]);\n!angular.$$csp() && angular.element(document).find(\'head\').prepend(\'<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>\');';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*angular-ui-bootstrap@0.14.3#index*/
define('angular-ui-bootstrap@0.14.3#index', function (require, exports, module) {
    require('./ui-bootstrap-tpls');
    module.exports = 'ui.bootstrap';
});
/*angular-route@1.5.0#angular-route*/
define('angular-route@1.5.0#angular-route', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/**\n * @license AngularJS v1.5.0\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {\'use strict\';\n\n/**\n * @ngdoc module\n * @name ngRoute\n * @description\n *\n * # ngRoute\n *\n * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n *\n * <div doc-module-components="ngRoute"></div>\n */\n /* global -ngRouteModule */\nvar ngRouteModule = angular.module(\'ngRoute\', [\'ng\']).\n                        provider(\'$route\', $RouteProvider),\n    $routeMinErr = angular.$$minErr(\'ngRoute\');\n\n/**\n * @ngdoc provider\n * @name $routeProvider\n *\n * @description\n *\n * Used for configuring routes.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n * ## Dependencies\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n */\nfunction $RouteProvider() {\n  function inherit(parent, extra) {\n    return angular.extend(Object.create(parent), extra);\n  }\n\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#when\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain named groups starting with a colon and ending with a star:\n   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.\n   *\n   *    For example, routes like `/color/:color/largecode/:largecode*\\/edit` will match\n   *    `/color/brown/largecode/code/with/slashes/edit` and extract:\n   *\n   *    * `color: brown`\n   *    * `largecode: code/with/slashes`.\n   *\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller` \u2013 `{(string|function()=}` \u2013 Controller fn that should be associated with\n   *      newly created scope or the name of a {@link angular.Module#controller registered\n   *      controller} if passed as a string.\n   *    - `controllerAs` \u2013 `{string=}` \u2013 An identifier name for a reference to the controller.\n   *      If present, the controller will be published to scope under the `controllerAs` name.\n   *    - `template` \u2013 `{string=|function()=}` \u2013 html template as a string or a function that\n   *      returns an html template as a string which should be used by {@link\n   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.\n   *      This property takes precedence over `templateUrl`.\n   *\n   *      If `template` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `templateUrl` \u2013 `{string=|function()=}` \u2013 path or function that returns a path to an html\n   *      template that should be used by {@link ngRoute.directive:ngView ngView}.\n   *\n   *      If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, the router\n   *      will wait for them all to be resolved or one to be rejected before the controller is\n   *      instantiated.\n   *      If all the promises are resolved successfully, the values of the resolved promises are\n   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is\n   *      fired. If any of the promises are rejected the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired.\n   *      For easier access to the resolved dependencies from the template, the `resolve` map will\n   *      be available on the scope of the route, under `$resolve` (by default) or a custom name\n   *      specified by the `resolveAs` property (see below). This can be particularly useful, when\n   *      working with {@link angular.Module#component components} as route templates.<br />\n   *      <div class="alert alert-warning">\n   *        **Note:** If your scope already contains a property with this name, it will be hidden\n   *        or overwritten. Make sure, you specify an appropriate name for this property, that\n   *        does not collide with other properties on the scope.\n   *      </div>\n   *      The map object is:\n   *\n   *      - `key` \u2013 `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link auto.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is\n   *        resolved before its value is injected into the controller. Be aware that\n   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve\n   *        functions.  Use `$route.current.params` to access the new route parameters, instead.\n   *\n   *    - `resolveAs` - `{string=}` - The name under which the `resolve` map will be available on\n   *      the scope of the route. If omitted, defaults to `$resolve`.\n   *\n   *    - `redirectTo` \u2013 `{(string|function())=}` \u2013 value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.path()` and `$location.search()`.\n   *\n   *    - `[reloadOnSearch=true]` - `{boolean=}` - reload route when only `$location.search()`\n   *      or `$location.hash()` changes.\n   *\n   *      If the option is set to `false` and url in the browser changes, then\n   *      `$routeUpdate` event is broadcasted on the root scope.\n   *\n   *    - `[caseInsensitiveMatch=false]` - `{boolean=}` - match routes without being case sensitive\n   *\n   *      If the option is set to `true`, then the particular route can be matched without being\n   *      case sensitive\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    //copy original route object to preserve params inherited from proto chain\n    var routeCopy = angular.copy(route);\n    if (angular.isUndefined(routeCopy.reloadOnSearch)) {\n      routeCopy.reloadOnSearch = true;\n    }\n    if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {\n      routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;\n    }\n    routes[path] = angular.extend(\n      routeCopy,\n      path && pathRegExp(path, routeCopy)\n    );\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length - 1] == \'/\')\n            ? path.substr(0, path.length - 1)\n            : path + \'/\';\n\n      routes[redirectPath] = angular.extend(\n        {redirectTo: path},\n        pathRegExp(redirectPath, routeCopy)\n      );\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc property\n   * @name $routeProvider#caseInsensitiveMatch\n   * @description\n   *\n   * A boolean property indicating if routes defined\n   * using this provider should be matched using a case insensitive\n   * algorithm. Defaults to `false`.\n   */\n  this.caseInsensitiveMatch = false;\n\n   /**\n    * @param path {string} path\n    * @param opts {Object} options\n    * @return {?Object}\n    *\n    * @description\n    * Normalizes the given path, returning a regular expression\n    * and the original path.\n    *\n    * Inspired by pathRexp in visionmedia/express/lib/utils.js.\n    */\n  function pathRegExp(path, opts) {\n    var insensitive = opts.caseInsensitiveMatch,\n        ret = {\n          originalPath: path,\n          regexp: path\n        },\n        keys = ret.keys = [];\n\n    path = path\n      .replace(/([().])/g, \'\\\\$1\')\n      .replace(/(\\/)?:(\\w+)([\\?\\*])?/g, function(_, slash, key, option) {\n        var optional = option === \'?\' ? option : null;\n        var star = option === \'*\' ? option : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || \'\';\n        return \'\'\n          + (optional ? \'\' : slash)\n          + \'(?:\'\n          + (optional ? slash : \'\')\n          + (star && \'(.+?)\' || \'([^/]+)\')\n          + (optional || \'\')\n          + \')\'\n          + (optional || \'\');\n      })\n      .replace(/([\\/$\\*])/g, \'\\\\$1\');\n\n    ret.regexp = new RegExp(\'^\' + path + \'$\', insensitive ? \'i\' : \'\');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#otherwise\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object|string} params Mapping information to be assigned to `$route.current`.\n   * If called with a string, the value maps to `redirectTo`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    if (typeof params === \'string\') {\n      params = {redirectTo: params};\n    }\n    this.when(null, params);\n    return this;\n  };\n\n\n  this.$get = [\'$rootScope\',\n               \'$location\',\n               \'$routeParams\',\n               \'$q\',\n               \'$injector\',\n               \'$templateRequest\',\n               \'$sce\',\n      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {\n\n    /**\n     * @ngdoc service\n     * @name $route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as defined in the route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     *     The `locals` will be assigned to the route scope\'s `$resolve` property. You can override\n     *     the property name, using `resolveAs` in the route definition. See\n     *     {@link ngRoute.$routeProvider $routeProvider} for more info.\n     *\n     * @property {Object} routes Object with all route configuration Objects as its properties.\n     *\n     * @description\n     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * Requires the {@link ngRoute `ngRoute`} module to be installed.\n     *\n     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}\'s API.\n     *\n     * The `$route` service is typically used in conjunction with the\n     * {@link ngRoute.directive:ngView `ngView`} directive and the\n     * {@link ngRoute.$routeParams `$routeParams`} service.\n     *\n     * @example\n     * This example shows how changing the URL hash causes the `$route` to match a route against the\n     * URL, and the `ngView` pulls in the partial.\n     *\n     * <example name="$route-service" module="ngRouteExample"\n     *          deps="angular-route.js" fixBase="true">\n     *   <file name="index.html">\n     *     <div ng-controller="MainController">\n     *       Choose:\n     *       <a href="Book/Moby">Moby</a> |\n     *       <a href="Book/Moby/ch/1">Moby: Ch1</a> |\n     *       <a href="Book/Gatsby">Gatsby</a> |\n     *       <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |\n     *       <a href="Book/Scarlet">Scarlet Letter</a><br/>\n     *\n     *       <div ng-view></div>\n     *\n     *       <hr />\n     *\n     *       <pre>$location.path() = {{$location.path()}}</pre>\n     *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n     *       <pre>$route.current.params = {{$route.current.params}}</pre>\n     *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n     *       <pre>$routeParams = {{$routeParams}}</pre>\n     *     </div>\n     *   </file>\n     *\n     *   <file name="book.html">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *   </file>\n     *\n     *   <file name="chapter.html">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *     Chapter Id: {{params.chapterId}}\n     *   </file>\n     *\n     *   <file name="script.js">\n     *     angular.module(\'ngRouteExample\', [\'ngRoute\'])\n     *\n     *      .controller(\'MainController\', function($scope, $route, $routeParams, $location) {\n     *          $scope.$route = $route;\n     *          $scope.$location = $location;\n     *          $scope.$routeParams = $routeParams;\n     *      })\n     *\n     *      .controller(\'BookController\', function($scope, $routeParams) {\n     *          $scope.name = "BookController";\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *      .controller(\'ChapterController\', function($scope, $routeParams) {\n     *          $scope.name = "ChapterController";\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *     .config(function($routeProvider, $locationProvider) {\n     *       $routeProvider\n     *        .when(\'/Book/:bookId\', {\n     *         templateUrl: \'book.html\',\n     *         controller: \'BookController\',\n     *         resolve: {\n     *           // I will cause a 1 second delay\n     *           delay: function($q, $timeout) {\n     *             var delay = $q.defer();\n     *             $timeout(delay.resolve, 1000);\n     *             return delay.promise;\n     *           }\n     *         }\n     *       })\n     *       .when(\'/Book/:bookId/ch/:chapterId\', {\n     *         templateUrl: \'chapter.html\',\n     *         controller: \'ChapterController\'\n     *       });\n     *\n     *       // configure html5 to get links working on jsfiddle\n     *       $locationProvider.html5Mode(true);\n     *     });\n     *\n     *   </file>\n     *\n     *   <file name="protractor.js" type="protractor">\n     *     it(\'should load and compile correct template\', function() {\n     *       element(by.linkText(\'Moby: Ch1\')).click();\n     *       var content = element(by.css(\'[ng-view]\')).getText();\n     *       expect(content).toMatch(/controller\\: ChapterController/);\n     *       expect(content).toMatch(/Book Id\\: Moby/);\n     *       expect(content).toMatch(/Chapter Id\\: 1/);\n     *\n     *       element(by.partialLinkText(\'Scarlet\')).click();\n     *\n     *       content = element(by.css(\'[ng-view]\')).getText();\n     *       expect(content).toMatch(/controller\\: BookController/);\n     *       expect(content).toMatch(/Book Id\\: Scarlet/);\n     *     });\n     *   </file>\n     * </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeStart\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occur.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * The route change (and the `$location` change that triggered it) can be prevented\n     * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}\n     * for more details about event object.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeSuccess\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route change has happened successfully.\n     * The `resolve` dependencies are now available in the `current.locals` property.\n     *\n     * {@link ngRoute.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is\n     * first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeError\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if any of the resolve promises are rejected.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeUpdate\n     * @eventType broadcast on root scope\n     * @description\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\n     * instance of the Controller.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current/previous route information.\n     */\n\n    var forceReload = false,\n        preparedRoute,\n        preparedRouteIsUpdateOnly,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name $route#reload\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn\'t changed.\n           *\n           * As a result of that, {@link ngRoute.directive:ngView ngView}\n           * creates new scope and reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n\n            var fakeLocationEvent = {\n              defaultPrevented: false,\n              preventDefault: function fakePreventDefault() {\n                this.defaultPrevented = true;\n                forceReload = false;\n              }\n            };\n\n            $rootScope.$evalAsync(function() {\n              prepareRoute(fakeLocationEvent);\n              if (!fakeLocationEvent.defaultPrevented) commitRoute();\n            });\n          },\n\n          /**\n           * @ngdoc method\n           * @name $route#updateParams\n           *\n           * @description\n           * Causes `$route` service to update the current URL, replacing\n           * current route parameters with those specified in `newParams`.\n           * Provided property names that match the route\'s path segment\n           * definitions will be interpolated into the location\'s path, while\n           * remaining properties will be treated as query params.\n           *\n           * @param {!Object<string, string>} newParams mapping of URL parameter names to values\n           */\n          updateParams: function(newParams) {\n            if (this.current && this.current.$$route) {\n              newParams = angular.extend({}, this.current.params, newParams);\n              $location.path(interpolate(this.current.$$route.originalPath, newParams));\n              // interpolate modifies newParams, only query params are left\n              $location.search(newParams);\n            } else {\n              throw $routeMinErr(\'norout\', \'Tried updating route when with no current route\');\n            }\n          }\n        };\n\n    $rootScope.$on(\'$locationChangeStart\', prepareRoute);\n    $rootScope.$on(\'$locationChangeSuccess\', commitRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param route {Object} route regexp to match the url against\n     * @return {?Object}\n     *\n     * @description\n     * Check if the route matches the current url.\n     *\n     * Inspired by match in\n     * visionmedia/express/lib/router/router.js.\n     */\n    function switchRouteMatcher(on, route) {\n      var keys = route.keys,\n          params = {};\n\n      if (!route.regexp) return null;\n\n      var m = route.regexp.exec(on);\n      if (!m) return null;\n\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n\n        var val = m[i];\n\n        if (key && val) {\n          params[key.name] = val;\n        }\n      }\n      return params;\n    }\n\n    function prepareRoute($locationEvent) {\n      var lastRoute = $route.current;\n\n      preparedRoute = parseRoute();\n      preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route\n          && angular.equals(preparedRoute.pathParams, lastRoute.pathParams)\n          && !preparedRoute.reloadOnSearch && !forceReload;\n\n      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {\n        if ($rootScope.$broadcast(\'$routeChangeStart\', preparedRoute, lastRoute).defaultPrevented) {\n          if ($locationEvent) {\n            $locationEvent.preventDefault();\n          }\n        }\n      }\n    }\n\n    function commitRoute() {\n      var lastRoute = $route.current;\n      var nextRoute = preparedRoute;\n\n      if (preparedRouteIsUpdateOnly) {\n        lastRoute.params = nextRoute.params;\n        angular.copy(lastRoute.params, $routeParams);\n        $rootScope.$broadcast(\'$routeUpdate\', lastRoute);\n      } else if (nextRoute || lastRoute) {\n        forceReload = false;\n        $route.current = nextRoute;\n        if (nextRoute) {\n          if (nextRoute.redirectTo) {\n            if (angular.isString(nextRoute.redirectTo)) {\n              $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params)\n                       .replace();\n            } else {\n              $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search()))\n                       .replace();\n            }\n          }\n        }\n\n        $q.when(nextRoute).\n          then(function() {\n            if (nextRoute) {\n              var locals = angular.extend({}, nextRoute.resolve),\n                  template, templateUrl;\n\n              angular.forEach(locals, function(value, key) {\n                locals[key] = angular.isString(value) ?\n                    $injector.get(value) : $injector.invoke(value, null, null, key);\n              });\n\n              if (angular.isDefined(template = nextRoute.template)) {\n                if (angular.isFunction(template)) {\n                  template = template(nextRoute.params);\n                }\n              } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {\n                if (angular.isFunction(templateUrl)) {\n                  templateUrl = templateUrl(nextRoute.params);\n                }\n                if (angular.isDefined(templateUrl)) {\n                  nextRoute.loadedTemplateUrl = $sce.valueOf(templateUrl);\n                  template = $templateRequest(templateUrl);\n                }\n              }\n              if (angular.isDefined(template)) {\n                locals[\'$template\'] = template;\n              }\n              return $q.all(locals);\n            }\n          }).\n          then(function(locals) {\n            // after route change\n            if (nextRoute == $route.current) {\n              if (nextRoute) {\n                nextRoute.locals = locals;\n                angular.copy(nextRoute.params, $routeParams);\n              }\n              $rootScope.$broadcast(\'$routeChangeSuccess\', nextRoute, lastRoute);\n            }\n          }, function(error) {\n            if (nextRoute == $route.current) {\n              $rootScope.$broadcast(\'$routeChangeError\', nextRoute, lastRoute, error);\n            }\n          });\n      }\n    }\n\n\n    /**\n     * @returns {Object} the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      angular.forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), route))) {\n          match = inherit(route, {\n            params: angular.extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to "otherwise" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @returns {string} interpolation of the redirect path with the parameters\n     */\n    function interpolate(string, params) {\n      var result = [];\n      angular.forEach((string || \'\').split(\':\'), function(segment, i) {\n        if (i === 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(?:[?*])?(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || \'\');\n          delete params[key];\n        }\n      });\n      return result.join(\'\');\n    }\n  }];\n}\n\nngRouteModule.provider(\'$routeParams\', $RouteParamsProvider);\n\n\n/**\n * @ngdoc service\n * @name $routeParams\n * @requires $route\n *\n * @description\n * The `$routeParams` service allows you to retrieve the current set of route parameters.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * The route parameters are a combination of {@link ng.$location `$location`}\'s\n * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.\n * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route\'s parameters.\n *\n * @example\n * ```js\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:\'1\', sectionId:\'2\', search:\'moby\'}\n * ```\n */\nfunction $RouteParamsProvider() {\n  this.$get = function() { return {}; };\n}\n\nngRouteModule.directive(\'ngView\', ngViewFactory);\nngRouteModule.directive(\'ngView\', ngViewFillContentFactory);\n\n\n/**\n * @ngdoc directive\n * @name ngView\n * @restrict ECA\n *\n * @description\n * # Overview\n * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * @animations\n * enter - animation is used to bring new content into the browser.\n * leave - animation is used to animate existing content away.\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n * @priority 400\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the view is updated.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated\n *                    as an expression yields a truthy value.\n * @example\n    <example name="ngView-directive" module="ngViewExample"\n             deps="angular-route.js;angular-animate.js"\n             animations="true" fixBase="true">\n      <file name="index.html">\n        <div ng-controller="MainCtrl as main">\n          Choose:\n          <a href="Book/Moby">Moby</a> |\n          <a href="Book/Moby/ch/1">Moby: Ch1</a> |\n          <a href="Book/Gatsby">Gatsby</a> |\n          <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |\n          <a href="Book/Scarlet">Scarlet Letter</a><br/>\n\n          <div class="view-animate-container">\n            <div ng-view class="view-animate"></div>\n          </div>\n          <hr />\n\n          <pre>$location.path() = {{main.$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\n          <pre>$routeParams = {{main.$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name="book.html">\n        <div>\n          controller: {{book.name}}<br />\n          Book Id: {{book.params.bookId}}<br />\n        </div>\n      </file>\n\n      <file name="chapter.html">\n        <div>\n          controller: {{chapter.name}}<br />\n          Book Id: {{chapter.params.bookId}}<br />\n          Chapter Id: {{chapter.params.chapterId}}\n        </div>\n      </file>\n\n      <file name="animations.css">\n        .view-animate-container {\n          position:relative;\n          height:100px!important;\n          background:white;\n          border:1px solid black;\n          height:40px;\n          overflow:hidden;\n        }\n\n        .view-animate {\n          padding:10px;\n        }\n\n        .view-animate.ng-enter, .view-animate.ng-leave {\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n\n          display:block;\n          width:100%;\n          border-left:1px solid black;\n\n          position:absolute;\n          top:0;\n          left:0;\n          right:0;\n          bottom:0;\n          padding:10px;\n        }\n\n        .view-animate.ng-enter {\n          left:100%;\n        }\n        .view-animate.ng-enter.ng-enter-active {\n          left:0;\n        }\n        .view-animate.ng-leave.ng-leave-active {\n          left:-100%;\n        }\n      </file>\n\n      <file name="script.js">\n        angular.module(\'ngViewExample\', [\'ngRoute\', \'ngAnimate\'])\n          .config([\'$routeProvider\', \'$locationProvider\',\n            function($routeProvider, $locationProvider) {\n              $routeProvider\n                .when(\'/Book/:bookId\', {\n                  templateUrl: \'book.html\',\n                  controller: \'BookCtrl\',\n                  controllerAs: \'book\'\n                })\n                .when(\'/Book/:bookId/ch/:chapterId\', {\n                  templateUrl: \'chapter.html\',\n                  controller: \'ChapterCtrl\',\n                  controllerAs: \'chapter\'\n                });\n\n              $locationProvider.html5Mode(true);\n          }])\n          .controller(\'MainCtrl\', [\'$route\', \'$routeParams\', \'$location\',\n            function($route, $routeParams, $location) {\n              this.$route = $route;\n              this.$location = $location;\n              this.$routeParams = $routeParams;\n          }])\n          .controller(\'BookCtrl\', [\'$routeParams\', function($routeParams) {\n            this.name = "BookCtrl";\n            this.params = $routeParams;\n          }])\n          .controller(\'ChapterCtrl\', [\'$routeParams\', function($routeParams) {\n            this.name = "ChapterCtrl";\n            this.params = $routeParams;\n          }]);\n\n      </file>\n\n      <file name="protractor.js" type="protractor">\n        it(\'should load and compile correct template\', function() {\n          element(by.linkText(\'Moby: Ch1\')).click();\n          var content = element(by.css(\'[ng-view]\')).getText();\n          expect(content).toMatch(/controller\\: ChapterCtrl/);\n          expect(content).toMatch(/Book Id\\: Moby/);\n          expect(content).toMatch(/Chapter Id\\: 1/);\n\n          element(by.partialLinkText(\'Scarlet\')).click();\n\n          content = element(by.css(\'[ng-view]\')).getText();\n          expect(content).toMatch(/controller\\: BookCtrl/);\n          expect(content).toMatch(/Book Id\\: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ngView#$viewContentLoaded\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nngViewFactory.$inject = [\'$route\', \'$anchorScroll\', \'$animate\'];\nfunction ngViewFactory($route, $anchorScroll, $animate) {\n  return {\n    restrict: \'ECA\',\n    terminal: true,\n    priority: 400,\n    transclude: \'element\',\n    link: function(scope, $element, attr, ctrl, $transclude) {\n        var currentScope,\n            currentElement,\n            previousLeaveAnimation,\n            autoScrollExp = attr.autoscroll,\n            onloadExp = attr.onload || \'\';\n\n        scope.$on(\'$routeChangeSuccess\', update);\n        update();\n\n        function cleanupLastView() {\n          if (previousLeaveAnimation) {\n            $animate.cancel(previousLeaveAnimation);\n            previousLeaveAnimation = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if (currentElement) {\n            previousLeaveAnimation = $animate.leave(currentElement);\n            previousLeaveAnimation.then(function() {\n              previousLeaveAnimation = null;\n            });\n            currentElement = null;\n          }\n        }\n\n        function update() {\n          var locals = $route.current && $route.current.locals,\n              template = locals && locals.$template;\n\n          if (angular.isDefined(template)) {\n            var newScope = scope.$new();\n            var current = $route.current;\n\n            // Note: This will also link all children of ng-view that were contained in the original\n            // html. If that content contains controllers, ... they could pollute/change the scope.\n            // However, using ng-view on an element with additional content does not make sense...\n            // Note: We can\'t remove them in the cloneAttchFn of $transclude as that\n            // function is called before linking the content, which would apply child\n            // directives to non existing elements.\n            var clone = $transclude(newScope, function(clone) {\n              $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {\n                if (angular.isDefined(autoScrollExp)\n                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                  $anchorScroll();\n                }\n              });\n              cleanupLastView();\n            });\n\n            currentElement = clone;\n            currentScope = current.scope = newScope;\n            currentScope.$emit(\'$viewContentLoaded\');\n            currentScope.$eval(onloadExp);\n          } else {\n            cleanupLastView();\n          }\n        }\n    }\n  };\n}\n\n// This directive is called during the $transclude call of the first `ngView` directive.\n// It will replace and compile the content of the element with the loaded template.\n// We need this directive so that the element content is already filled when\n// the link function of another directive on the same element as ngView\n// is called.\nngViewFillContentFactory.$inject = [\'$compile\', \'$controller\', \'$route\'];\nfunction ngViewFillContentFactory($compile, $controller, $route) {\n  return {\n    restrict: \'ECA\',\n    priority: -400,\n    link: function(scope, $element) {\n      var current = $route.current,\n          locals = current.locals;\n\n      $element.html(locals.$template);\n\n      var link = $compile($element.contents());\n\n      if (current.controller) {\n        locals.$scope = scope;\n        var controller = $controller(current.controller, locals);\n        if (current.controllerAs) {\n          scope[current.controllerAs] = controller;\n        }\n        $element.data(\'$ngControllerController\', controller);\n        $element.children().data(\'$ngControllerController\', controller);\n      }\n      scope[current.resolveAs || \'$resolve\'] = locals;\n\n      link(scope);\n    }\n  };\n}\n\n\n})(window, window.angular);\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*angular-route@1.5.0#index*/
define('angular-route@1.5.0#index', function (require, exports, module) {
    require('./angular-route');
    module.exports = 'ngRoute';
});
/*app/views/root/controllers/RootCtrl*/
define('app/views/root/controllers/RootCtrl', [], function () {
    var RootCtrl = function (SideMenuSrv, $state, $scope, $rootScope, sidepanelSrvc) {
        var header = { fixed: true };
        var footer = { fixed: true };
        var columnScroll = true;
        var columnContentScroll = true;
        var isLeftLayoutClosed = false;
        this.isSideMenuCollapse = function () {
            return SideMenuSrv.isShrink();
        };
        this.isSideMenu = function () {
            var result = $state.current.data && $state.current.data.sidemenuUrl ? true : false;
            return result;
        };
        this.isHeaderFixed = function () {
            return header.fixed;
        };
        $scope.$on('ui:toggleFixedHeader', function () {
            console.debug('ui:toggleFixedHeader', header.fixed);
            header.fixed = !header.fixed;
        });
        this.isFooterFixed = function () {
            return footer.fixed;
        };
        $scope.$on('ui:toggleFixedFooter', function () {
            console.debug('ui:toggleFixedFooter', footer.fixed);
            footer.fixed = !footer.fixed;
        });
        this.toggleLeft = function () {
            isLeftLayoutClosed = !isLeftLayoutClosed;
            $rootScope.$broadcast('ui:layoutColumn:toggle', { position: 'left' });
            console.debug('hide left');
        };
        this.isLeftClosed = function () {
            return sidepanelSrvc.isCollapsed();
        };
        $scope.$on('ui:toggleColumnScroll', function () {
            console.debug('ui:toggleColumnScroll', columnScroll);
            columnScroll = !columnScroll;
        });
        this.isColumnScroll = function () {
            return columnScroll;
        };
        $scope.$on('ui:toggleColumnContentScroll', function () {
            console.debug('ui:toggleColumnContentScroll', columnContentScroll);
            columnContentScroll = !columnContentScroll;
        });
        this.isColumnContentScroll = function () {
            return columnContentScroll;
        };
        this.curDate = function () {
            return new Date();
        };
        this.getCss = function () {
            var css = {
                'fixed-header': this.isHeaderFixed(),
                'fixed-footer': this.isFooterFixed()
            };
            $state.current.name.split('.').map(function (item) {
                css['state-' + item] = true;
            });
            return css;
        };
    };
    RootCtrl.$inject = [
        'SideMenuSrv',
        '$state',
        '$scope',
        '$rootScope',
        'sidepanelSrvc'
    ];
    RootCtrl.$name = 'RootCtrl';
    return RootCtrl;
});
/*app/views/root/views.root.module*/
define('app/views/root/views.root.module', [
    'ng',
    'lodash',
    './controllers/RootCtrl'
], function (ng, _, RootCtrl) {
    var module = ng.module('mui.views.root', ['mui.widgets.common']);
    module.controller(RootCtrl.$name, RootCtrl);
    return module;
});
/*app/views/import/ImportVM*/
define('app/views/import/ImportVM', [
    'ng',
    'lodash'
], function (ng, _) {
    var ImportVM = function ImportVM(DatasetRepository, dataset, $state) {
        var self = this;
        this.dataset = dataset;
        console.debug('IMPORTING >>', dataset);
        this.completeImport = function () {
            var importedDataset = _.cloneDeep(dataset);
            importedDataset.id = undefined;
            DatasetRepository.put(importedDataset);
            $state.go('root.home');
        };
    };
    ImportVM.$inject = [
        'DatasetRepository',
        'dataset',
        '$state'
    ];
    return ImportVM;
});
/*app/views/import/views.import.module*/
define('app/views/import/views.import.module', [
    'ng',
    'lodash',
    './ImportVM'
], function (ng, _, ImportVM, mevWorkspace) {
    var module = ng.module('mui.views.import', arguments, arguments);
    module.config([
        '$stateProvider',
        '$urlRouterProvider',
        function ($stateProvider, $urlRouterProvider) {
            $stateProvider.state('root.import', {
                url: '/datasource/:datasourceId/:datasetId',
                templateUrl: 'app/views/import/import.tpl.html',
                controller: 'ImportVM',
                controllerAs: 'ImportVM',
                parent: 'root',
                resolve: {
                    datasource: [
                        'DatasourceRepository',
                        '$stateParams',
                        function (DatasourceRepository, $stateParams) {
                            return DatasourceRepository.get($stateParams.datasourceId);
                        }
                    ],
                    dataset: [
                        'datasource',
                        '$stateParams',
                        function (datasource, $stateParams) {
                            var findDataset = function (response) {
                                var dataset = _.filter(response.dataset, function (item) {
                                    return item.id == $stateParams.datasetId;
                                });
                                console.debug('resolved import dataset', dataset);
                                return dataset[0];
                            };
                            if (datasource.$promise)
                                return datasource.$promise.then(findDataset);
                            else
                                return findDataset(datasource);
                        }
                    ]
                }
            });
        }
    ]);
    module.controller('ImportVM', ImportVM);
    return module;
});
/*app/views/welcome/controllers/WelcomeVM*/
define('app/views/welcome/controllers/WelcomeVM', ['ng'], function (ng) {
    var WelcomeVM = function () {
    };
    WelcomeVM.$inject = [];
    return WelcomeVM;
});
/*app/views/welcome/views.welcome.module*/
define('app/views/welcome/views.welcome.module', [
    'ng',
    './controllers/WelcomeVM'
], function (ng, WelcomeVM) {
    var module = ng.module('mui.views.welcome', []);
    module.config([
        '$stateProvider',
        '$$animateJsProvider',
        function ($stateProvider, $$animateJsProvider) {
            $stateProvider.state('root.welcome', {
                url: '/welcome',
                controller: 'WelcomeVM',
                controllerAs: 'WelcomeVM',
                parent: 'root',
                templateUrl: 'app/views/welcome/templates/views.welcome.tpl.html',
                displayName: 'mev',
                onEnter: [
                    'mevFetchSrc',
                    function (mevFetchSrc) {
                        return mevFetchSrc.fetch('app/views/dataset/views.dataset.module', $$animateJsProvider).catch(function (e) {
                            throw e;
                        });
                    }
                ]
            });
        }
    ]);
    module.controller('WelcomeVM', WelcomeVM);
    return module;
});
/*app/widgets/common/sidepanel/directives/sidepanel.directive*/
define('app/widgets/common/sidepanel/directives/sidepanel.directive', ['ng'], function (ng) {
    var SidePanelDirective = function SidePanelDirective(sidepanelSrvc) {
        function toggle(menu, content, direction) {
            console.debug('toggling ....', menu, content);
            content.removeClass('no-transition');
            if (direction === 'right') {
                if (menu.is(':visible') && content.hasClass('col-md-8')) {
                    menu.animate({ right: -(menu.outerWidth() + 10) }, function () {
                        menu.hide(100);
                    });
                    content.removeClass('col-md-8').addClass('col-md-12');
                } else {
                    menu.show(500).animate({ right: 0 });
                    content.removeClass('col-md-12').addClass('col-md-8');
                }
                if (content.hasClass('col-md-12') && menu.is(':hidden')) {
                    menu.animate({ right: 0 }, function () {
                        menu.show(100);
                    });
                    content.removeClass('no-transition');
                    content.removeClass('col-md-12').addClass('col-md-8');
                }
            } else if (direction === 'left') {
                if (menu.is(':visible') && content.hasClass('col-md-8')) {
                    menu.animate({ left: -(menu.outerWidth() + 10) }, function () {
                        menu.hide(400);
                    });
                } else {
                    menu.show(400).animate({ left: 0 });
                    content.removeClass('col-md-12').addClass('col-md-8');
                }
                if (content.hasClass('col-md-12') && menu.is(':hidden')) {
                    menu.animate({ left: 0 }, function () {
                        menu.show(100);
                    });
                    content.removeClass('no-transition');
                    content.removeClass('col-md-12').addClass('col-md-8');
                }
            }
        }
        return {
            restrict: 'EA',
            scope: {
                direction: '@',
                sidepanel: '@',
                contentId: '@'
            },
            link: function (scope, elem, attr) {
                scope.$watch(function () {
                    return sidepanelSrvc.isCollapsed(scope.sidepanel);
                }, function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        toggle(elem, ng.element('#' + scope.contentId), scope.sidepanel);
                    }
                });
            }
        };
    };
    SidePanelDirective.$inject = ['sidepanelSrvc'];
    return SidePanelDirective;
});
/*app/widgets/common/sidepanel/directives/toggleSidepanel.directive*/
define('app/widgets/common/sidepanel/directives/toggleSidepanel.directive', ['ng'], function (ng) {
    var ToggleSidepanelDirective = function (sidepanelSrvc) {
        return {
            restrict: 'A',
            controller: 'ToggleSidepanelVM',
            controllerAs: 'ToggleSidepanelVM',
            link: function (scope, elem, attr) {
                scope.sideMenuVM = {
                    toggle: function () {
                        console.debug('GOGGLE!!!', attr);
                        sidepanelSrvc.toggle(attr.toggleSidepanel);
                    },
                    isCollapsed: function () {
                        return sidepanelSrvc.isCollapsed(attr.toggleSidepanel);
                    }
                };
            }
        };
    };
    ToggleSidepanelDirective.$inject = ['sidepanelSrvc'];
    return ToggleSidepanelDirective;
});
/*app/widgets/common/sidepanel/services/sidepanelSrvc*/
define('app/widgets/common/sidepanel/services/sidepanelSrvc', ['ng'], function (ng) {
    var SidePanelSrvc = function SidePanelSrvc() {
        var sidePanelCollapse = {
            left: false,
            right: false
        };
        function toggle(direction) {
            sidePanelCollapse[direction] = !sidePanelCollapse[direction];
            console.debug('sidepanel ' + direction + ' toggled to ' + sidePanelCollapse[direction]);
        }
        function isCollapsed(direction) {
            return sidePanelCollapse[direction];
        }
        this.toggle = toggle;
        this.isCollapsed = isCollapsed;
    };
    SidePanelSrvc.$inject = [];
    return SidePanelSrvc;
});
/*app/widgets/common/sidepanel/controllers/ToggleSidepanelVM*/
define('app/widgets/common/sidepanel/controllers/ToggleSidepanelVM', [], function () {
    var ToggleSidepanelVM = function ToggleSidepanelVM(sidepanelSrvc) {
        this.toggleSidepanel = function (direction) {
            console.debug('CLIK CTRL!!! toggle 1');
            sidepanelSrvc.toggle(direction);
        };
        this.isCollapsed = sidepanelSrvc.isCollapsed;
    };
    ToggleSidepanelVM.$inject = ['sidepanelSrvc'];
    return ToggleSidepanelVM;
});
/*app/widgets/common/sidepanel/widgets.common.sidePanel.module*/
define('app/widgets/common/sidepanel/widgets.common.sidePanel.module', [
    'ng',
    './directives/sidepanel.directive',
    './directives/toggleSidepanel.directive',
    './services/sidepanelSrvc',
    './controllers/ToggleSidepanelVM'
], function (ng, SidepanelDirective, ToggleSidepanelDirective, SidepanelSrvc, ToggleSidepanelVM) {
    var module = ng.module('mui.widgets.common.sidePanel', []);
    module.directive('sidepanel', SidepanelDirective);
    module.directive('toggleSidepanel', ToggleSidepanelDirective);
    module.controller('ToggleSidepanelVM', ToggleSidepanelVM);
    module.service('sidepanelSrvc', SidepanelSrvc);
    return module;
});
/*app/widgets/common/sidemenu/directives/sidemenu.directive*/
'use strict';
define('app/widgets/common/sidemenu/directives/sidemenu.directive', ['ng'], function (ng) {
    var SideMenuDirective = function SideMenuDirective(SidemenuSrv, LayoutSrv, mevAnalysisTypes) {
        return {
            restrict: 'E',
            transclude: true,
            template: '<div ng-transclude><div/>',
            controller: 'SideMenuVM',
            controllerAs: 'SideMenuVM',
            link: function (scope, elem, attr) {
                scope.closed = false;
                scope.test = function ($event) {
                    scope.closed = !scope.closed;
                    console.debug('test', elem, $event, scope.closed);
                };
                scope.shrink = function ($event) {
                    if (SidemenuSrv.isShrink()) {
                        ng.element($event.target).closest('#sidemenu-container').addClass('shrink');
                        var openPanels = ng.element(elem).find('.panel-collapse.in');
                        if (openPanels.length > 0) {
                            openPanels.scope().isOpen = false;
                        }
                    }
                };
                scope.open = function ($event) {
                    ng.element($event.target).parent().parent().toggleClass('open');
                    var targetPanel = ng.element($event.target).closest('.panel').find('.panel-collapse');
                    if (SidemenuSrv.isShrink()) {
                        ng.element($event.target).closest('#sidemenu-container').removeClass('shrink');
                    }
                };
                ng.element(elem).on('transitionend', function ($event) {
                });
                scope.LayoutSrv = LayoutSrv;
            }
        };
    };
    SideMenuDirective.$inject = [
        'SideMenuSrv',
        'LayoutSrv'
    ];
    return SideMenuDirective;
});
/*app/widgets/common/sidemenu/controllers/SideMenuVM*/
'use strict';
define('app/widgets/common/sidemenu/controllers/SideMenuVM', ['ng'], function (ng) {
    var SideMenuVM = function ($scope, mevAnalysisTypes) {
        this.analysisTypes = mevAnalysisTypes.all();
        console.debug('analysisTypes', this.analysisTypes);
        this.hi = 'hiiii';
    };
    SideMenuVM.$injcet = [
        '$scope',
        'mevAnalysisTypes'
    ];
    return SideMenuVM;
});
/*app/widgets/common/sidemenu/services/sidemenuSrvc*/
define('app/widgets/common/sidemenu/services/sidemenuSrvc', ['ng'], function (ng) {
    var SideMenuSrvc = function SideMenuSrvc() {
        var sideMenuShrink = false;
        function toggle() {
            sideMenuShrink = !sideMenuShrink;
        }
        function isShrink() {
            return sideMenuShrink;
        }
        this.toggle = toggle;
        this.isShrink = isShrink;
    };
    SideMenuSrvc.$inject = [];
    return SideMenuSrvc;
});
/*app/widgets/common/sidemenu/directives/toggleSidemenu.directive*/
define('app/widgets/common/sidemenu/directives/toggleSidemenu.directive', ['ng'], function (ng) {
    var ToggleSidemenuDirective = function (SideMenuSrv) {
        return {
            restrict: 'A',
            controller: [
                '$scope',
                function ($scope) {
                    $scope.toggleSide = function () {
                        console.debug('CONTRA!!! toggle 1');
                        SideMenuSrv.toggle();
                    };
                }
            ],
            link: function (scope, elem, attr) {
                scope.toogle = function () {
                    console.debug('CLIK!!! toggle 1');
                    SideMenuSrv.toggle();
                };
            }
        };
    };
    ToggleSidemenuDirective.$inject = ['SideMenuSrv'];
    return ToggleSidemenuDirective;
});
/*app/widgets/common/sidemenu/widgets.common.sideMenu.module*/
define('app/widgets/common/sidemenu/widgets.common.sideMenu.module', [
    'ng',
    './directives/sidemenu.directive',
    './controllers/SideMenuVM',
    './services/sidemenuSrvc',
    './directives/toggleSidemenu.directive'
], function (ng, SidemenuDirective, SideMenuVM, SideMenuSrvc, ToggleSidemenuDirective) {
    var module = ng.module('mui.widgets.common.sideMenu', []);
    module.directive('sidemenu', SidemenuDirective);
    module.controller('SideMenuVM', SideMenuVM);
    module.service('SideMenuSrv', SideMenuSrvc);
    module.directive('toggleSidemenu', ToggleSidemenuDirective);
    return module;
});
/*app/widgets/common/panel/directives/panel.directive*/
define('app/widgets/common/panel/directives/panel.directive', ['ng'], function (ng) {
    var PanelDirective = function PanelDirective(PanelSrv) {
        return {
            restrict: 'E',
            transclude: true,
            template: '<div ng-transclude><div/>',
            controller: 'PanelVM',
            link: function (scope, elem, attr) {
            }
        };
    };
    PanelDirective.$inject = ['PanelSrv'];
    return PanelDirective;
});
/*app/widgets/common/panel/directives/panelControlls.directive*/
define('app/widgets/common/panel/directives/panelControlls.directive', ['ng'], function (ng) {
    var PanelControllsDirective = function ($compile) {
        return {
            restrict: 'EA',
            controller: [
                '$scope',
                function ($scope) {
                    $scope.panelControlls = {
                        isCollapsed: false,
                        toggle: function () {
                            console.debug('panelControlls.isCollapsed!');
                            $scope.panelControlls.isCollapsed = !$scope.panelControlls.isCollapsed;
                        }
                    };
                }
            ],
            compile: function (tElem, tAttr) {
                var notHeading = tElem.children(':not(.panel-heading)');
                notHeading.attr('collapse', 'panelControlls.isCollapsed');
                return {
                    post: function () {
                    },
                    pre: function (scope, elem, attr, controller) {
                        var heading = elem.children('.panel-heading');
                        heading.prepend($compile('<div class=\'panel-controls btn-group pull-right\' >' + '<button type="button" class="btn" ng-click="panelControlls.toggle()">\n' + '\t\t        <i ng-class="{\'fa fa-caret-up\': !panelControlls.isCollapsed, \'fa fa-caret-down\': panelControlls.isCollapsed}"></i>\n' + '\t\t      </button>\t\t    \n' + '</div>')(scope));
                        elem.on('click', function () {
                            console.debug('CLIKKC PANEL');
                        });
                    }
                };
            }
        };
    };
    PanelControllsDirective.$inject = ['$compile'];
    return PanelControllsDirective;
});
/*app/widgets/common/panel/controllers/PanelVM*/
define('app/widgets/common/panel/controllers/PanelVM', ['ng'], function (ng) {
    var PanelVM = function ($scope) {
        var isOpen;
        $scope.panel = { helloCtrl: 'heyyyyy' };
    };
    PanelVM.$injcet = ['$scope'];
    return PanelVM;
});
/*app/widgets/common/panel/services/panelSrvc*/
define('app/widgets/common/panel/services/panelSrvc', ['ng'], function (ng) {
    var PanelSrvc = function PanelSrvc() {
    };
    PanelSrvc.$inject = [];
    return PanelSrvc;
});
/*app/widgets/common/panel/widgets.common.panel.module*/
define('app/widgets/common/panel/widgets.common.panel.module', [
    'ng',
    './directives/panel.directive',
    './directives/panelControlls.directive',
    './controllers/PanelVM',
    './services/panelSrvc'
], function (ng, PanelDirective, PanelControllsDirective, PanelVM, PanelSrvc) {
    var module = ng.module('mui.widgets.common.panel', []);
    module.directive('panel', PanelDirective);
    module.directive('panelControlls', PanelControllsDirective);
    module.controller('PanelVM', PanelVM);
    module.service('PanelSrv', PanelSrvc);
    return module;
});
/*app/widgets/common/layout/directives/layout.directive*/
define('app/widgets/common/layout/directives/layout.directive', ['ng'], function (ng) {
    var LayoutDirective = function LayoutDirective(LayoutSrv) {
        return {
            restrict: 'E',
            transclude: true,
            template: 'app/widgets/common/directives/layout.tpl.html',
            controller: 'LayoutVM',
            link: function (scope, elem, attr) {
            }
        };
    };
    LayoutDirective.$inject = ['LayoutSrv'];
    return LayoutDirective;
});
/*app/widgets/common/layout/directives/layoutRow.directive*/
define('app/widgets/common/layout/directives/layoutRow.directive', ['ng'], function (ng) {
    var LayoutColumnDirective = function ($rootScope) {
        return {
            restrict: 'AE',
            controller: 'LayoutRowVM',
            controllerAs: 'LayoutRowVM',
            link: function (scope, elem, attrs, controller) {
                console.debug('LayoutRowDirective.link controller', controller);
            }
        };
    };
    LayoutColumnDirective.$inject = ['$rootScope'];
    return LayoutColumnDirective;
});
/*app/widgets/common/layout/directives/layoutColumn.directive*/
define('app/widgets/common/layout/directives/layoutColumn.directive', ['ng'], function (ng) {
    var LayoutColumnDirective = function ($rootScope, LayoutSrv, $animate) {
        return {
            restrict: 'A',
            require: [
                '^layoutRow',
                'layoutColumn'
            ],
            controller: 'LayoutColumnVM',
            controllerAs: 'layoutColumn',
            link: function (scope, elem, attrs, controller) {
                console.debug('LayoutColumnDirective.link controller', controller);
                var isClosed = false;
                layoutColumn = {
                    hide: function () {
                        console.debug('HIDE', elem);
                        isClosed = true;
                    },
                    show: function () {
                        isClosed = true;
                    },
                    toggle: function () {
                        $rootScope.$broadcast('ui:layoutColumn:toggle', { position: self.position });
                    },
                    isClosed: function () {
                        return isClosed;
                    },
                    position: attrs.layoutColumn
                };
                ng.extend(controller[1], layoutColumn);
                LayoutSrv.register(layoutColumn);
                scope.$on('ui:layoutColumn:toggle', function (event, args) {
                    isClosed = !isClosed;
                    console.debug('ui:layoutColumn:toggle', isClosed);
                });
                $animate.on('addClass', elem, function (element, phase) {
                    console.debug('ANIMATE3 ... ', phase, elem, element.context.className);
                });
                $animate.on('removeClass', elem, function (element, phase) {
                    console.debug('ANIMATE4 ... ', phase, elem, element.context.className);
                });
            }
        };
    };
    LayoutColumnDirective.$inject = [
        '$rootScope',
        'LayoutSrv',
        '$animate'
    ];
    return LayoutColumnDirective;
});
/*app/widgets/common/layout/directives/layoutColumnButtons.directive*/
define('app/widgets/common/layout/directives/layoutColumnButtons.directive', ['ng'], function (ng) {
    var LayoutColumnButtons = function (LayoutSrv) {
        return {
            restrict: 'E',
            templateUrl: 'app/widgets/common/layout/directives/layoutColumnButtons.tpl.html',
            require: [
                'layoutColumnButtons',
                '^layoutColumn'
            ],
            controller: 'LayoutColumnButtonsVM',
            controllerAs: 'vm',
            link: function (scope, elem, attr, controllers) {
                var vm = controllers[0];
                var layoutColumn = controllers[1];
                console.debug('LayoutColumnButtons.link', controllers);
            }
        };
    };
    LayoutColumnButtons.$inject = ['LayoutSrv'];
    return LayoutColumnButtons;
});
/*app/widgets/common/layout/controllers/LayoutVM*/
define('app/widgets/common/layout/controllers/LayoutVM', ['ng'], function (ng) {
    var LayoutVM = function ($scope) {
        this.columns = [];
    };
    LayoutVM.$injcet = ['$scope'];
    return LayoutVM;
});
/*app/widgets/common/layout/controllers/LayoutRowVM*/
define('app/widgets/common/layout/controllers/LayoutRowVM', ['ng'], function (ng) {
    var counter = 0;
    var LayouRowtVM = function ($scope) {
        this.rand = counter++;
        console.debug('LayoutRowVM', $scope.$id, this.rand);
        var columns;
        this.addColumn = function (column) {
            columns.push(column);
        };
    };
    LayouRowtVM.$injcet = ['$scope'];
    return LayouRowtVM;
});
/*app/widgets/common/layout/controllers/LayoutColumnVM*/
define('app/widgets/common/layout/controllers/LayoutColumnVM', ['ng'], function (ng) {
    var counter = 10;
    var LayoutColumnVM = function ($scope) {
        this.rand = counter++;
        console.debug('LayoutColumnVM', $scope.$id, this.rand);
        this.dosomething = function () {
        };
        this.ngClass = function () {
        };
    };
    LayoutColumnVM.$inject = ['$scope'];
    return LayoutColumnVM;
});
/*app/widgets/common/layout/controllers/LayoutColumnButtonsVM*/
define('app/widgets/common/layout/controllers/LayoutColumnButtonsVM', ['ng'], function (ng) {
    var LayoutColumnButtonsVM = function ($scope) {
        console.debug('LayoutColumnButtonsCtrl', $scope.$id, this.rand);
        this.canExpandLeft = function () {
            return true;
        };
        this.canExpandRight = function () {
            return true;
        };
    };
    LayoutColumnButtonsVM.$inject = ['$scope'];
    return LayoutColumnButtonsVM;
});
/*app/widgets/common/layout/services/layoutSrv*/
define('app/widgets/common/layout/services/layoutSrv', ['ng'], function (ng) {
    var LayoutSrv = function LayoutSrv() {
        var columns = {};
        this.register = function (column) {
            columns[column.position] = column;
        };
        this.isClosed = function (position) {
            return columns[position].isClosed();
        };
        this.toggle = function (position) {
            columns[position].toggle();
        };
    };
    LayoutSrv.$inject = [];
    return LayoutSrv;
});
/*app/widgets/common/layout/widgets.common.layout.module*/
define('app/widgets/common/layout/widgets.common.layout.module', [
    'ng',
    './directives/layout.directive',
    './directives/layoutRow.directive',
    './directives/layoutColumn.directive',
    './directives/layoutColumnButtons.directive',
    './controllers/LayoutVM',
    './controllers/LayoutRowVM',
    './controllers/LayoutColumnVM',
    './controllers/LayoutColumnButtonsVM',
    './services/layoutSrv'
], function (ng, LayoutDirective, LayoutRowDirective, LayoutColumnDirective, LayoutColumnButtonsDirective, LayoutVM, LayoutRowVM, LayoutColumnVM, LayoutColumnButtonsVM, LayoutSrv) {
    var module = ng.module('mui.widgets.common.layout', []);
    module.directive('layout', LayoutDirective);
    module.directive('layoutRow', LayoutRowDirective);
    module.directive('layoutColumn', LayoutColumnDirective);
    module.directive('layoutColumnButtons', LayoutColumnButtonsDirective);
    module.controller('LayoutVM', LayoutVM);
    module.controller('LayoutRowVM', LayoutRowVM);
    module.controller('LayoutColumnVM', LayoutColumnVM);
    module.controller('LayoutColumnButtonsVM', LayoutColumnButtonsVM);
    module.service('LayoutSrv', LayoutSrv);
    module.animation('.layout-column', function () {
        return {
            addClass: function (element, addedClasses, done, options) {
                console.debug('ANIMATE addClass', element, addedClasses, done, options);
                done();
            }
        };
    });
    return module;
});
/*app/widgets/common/yank/directives/yank.directive*/
define('app/widgets/common/yank/directives/yank.directive', ['ng'], function (ng) {
    var YankDirective = function () {
        return {
            restrict: 'A',
            link: function (scope, elem, attrs, ctrl) {
                console.log('YANK targetElement', attrs.muiYank, elem);
                scope.$emit('mui:utils:yank', attrs.muiYank, elem);
            }
        };
    };
    YankDirective.$name = 'muiYankDirective';
    YankDirective.$inject = [];
    return YankDirective;
});
/*app/widgets/common/yank/directives/paste.directive*/
define('app/widgets/common/yank/directives/paste.directive', ['ng'], function (ng) {
    var YankDirective = function () {
        return {
            restrict: 'A',
            link: function (scope, elem, attrs, ctrl) {
                scope.$on('mui:utils:yank', function ($event, targetId, sourceElement) {
                    var targetElement = elem;
                    console.log('PASTE targetElement', attrs.muiPaste, targetId, sourceElement);
                    if (attrs.muiPaste === targetId) {
                        targetElement.html('');
                        console.debug('PASTE remove', attrs.muiYank, targetElement);
                        console.debug('PASTE appaned', attrs.muiYank, targetElement);
                        targetElement.append(sourceElement);
                        $event.stopPropagation();
                    }
                });
            }
        };
    };
    YankDirective.$inject = [];
    YankDirective.$name = 'muiPasteDirective';
    return YankDirective;
});
/*app/widgets/common/yank/widgets.common.yank.module*/
define('app/widgets/common/yank/widgets.common.yank.module', [
    'ng',
    './directives/yank.directive',
    './directives/paste.directive'
], function (ng) {
    var module = ng.module('mui.widgets.common.yank', [], arguments);
    return module;
});
/*app/widgets/common/plots/widgets.common.plots.module*/
define('app/widgets/common/plots/widgets.common.plots.module', ['ng'], function (ng) {
    var module = ng.module('mui.widgets.common.plots', arguments, arguments);
    return module;
});
/*app/widgets/common/widgets.common.module*/
define('app/widgets/common/widgets.common.module', [
    'ng',
    './sidepanel/widgets.common.sidePanel.module',
    './sidemenu/widgets.common.sideMenu.module',
    './panel/widgets.common.panel.module',
    './layout/widgets.common.layout.module',
    './yank/widgets.common.yank.module',
    './plots/widgets.common.plots.module'
], function (ng) {
    var module = ng.module('mui.widgets.common', [
        'mui.widgets.common.sidePanel',
        'mui.widgets.common.sideMenu',
        'mui.widgets.common.panel',
        'mui.widgets.common.layout',
        'mui.widgets.common.yank',
        'mui.widgets.common.plots'
    ]);
    return module;
});
/*app/widgets/mainmenu/directives/mainmenu.directive*/
define('app/widgets/mainmenu/directives/mainmenu.directive', [], function () {
    var MenuDirective = function (SideMenuSrv, $rootScope) {
        return {
            restrict: 'AE',
            replace: true,
            templateUrl: 'app/widgets/mainmenu/directives/mainmenu.tpl.html',
            transclude: true,
            link: function (scope, elm, attrs, ctrl) {
                scope.hasSidePanel = scope.$state.current.name === 'root.project';
                scope.settings = {
                    sidemenu: { shrink: true },
                    header: { fixed: true },
                    footer: { fixed: true },
                    columnScroll: true,
                    columnContentScroll: true
                };
                scope.toggleFixedHeader = function () {
                    $rootScope.$broadcast('ui:toggleFixedHeader');
                };
                scope.toggleFixedFooter = function () {
                    $rootScope.$broadcast('ui:toggleFixedFooter');
                };
                scope.toggleColumnScroll = function () {
                    $rootScope.$broadcast('ui:toggleColumnScroll');
                };
                scope.toggleColumnContentScroll = function () {
                    $rootScope.$broadcast('ui:toggleColumnContentScroll');
                };
                scope.$watch('settings.sidemenu.shrink', SideMenuSrv.toggle);
            }
        };
    };
    MenuDirective.$inject = [
        'SideMenuSrv',
        '$rootScope'
    ];
    return MenuDirective;
});
/*app/widgets/mainmenu/controllers/mainmenu.controller*/
define('app/widgets/mainmenu/controllers/mainmenu.controller', [], function () {
    var MainMenuController = [
        '$scope',
        '$element',
        '$attrs',
        '$state',
        function ($scope, $element, $attrs, $state) {
            $scope.navbarCollapsed = true;
        }
    ];
    return MainMenuController;
});
/*app/widgets/mainmenu/mainmenu.module*/
define('app/widgets/mainmenu/mainmenu.module', [
    'ng',
    './directives/mainmenu.directive',
    './controllers/mainmenu.controller'
], function (ng, MainMenuDirective, MainMenuController) {
    var module = ng.module('mui.widgets.mainmenu', []);
    module.directive('mainMenu', MainMenuDirective);
    return module;
});
/*app/widgets/project/projectTree/controllers/RecursiveTreeMixin*/
define('app/widgets/project/projectTree/controllers/RecursiveTreeMixin', [], function () {
    return function RecursiveTreeMixin() {
        this.delete = function (data) {
            data.nodes = [];
        };
        this.add = function (data) {
            var post = data.nodes.length + 1;
            var newName = data.name + '-' + post;
            data.nodes.push({
                name: newName,
                nodes: []
            });
        };
        this.tree = [{
                name: 'Bloat',
                nodes: []
            }];
    };
});
/*app/widgets/project/projectTree/controllers/ProjectTreeVM*/
define('app/widgets/project/projectTree/controllers/ProjectTreeVM', [
    'ng',
    './RecursiveTreeMixin'
], function (ng, RecursiveTreeMixin) {
    var ProjectTreeVM = function ProjectTreeVM(ProjectTreeAdaptor, $modal, $scope, $timeout, AnalysisEventBus) {
        $scope['delete'] = function (data) {
            data.nodes = [];
        };
        $scope.add = function (data, nodeSubType) {
            var post = data.nodes.length + 1;
            var newName = data.name + '-' + post;
            data.nodes.push({
                name: newName + '-' + nodeSubType,
                nodes: []
            });
        };
        console.debug('ProjectTreeAdaptor', $scope.project);
        $scope.tree = ProjectTreeAdaptor($scope.project).nodes;
        $scope.script_id = 'tree_item_renderer.html';
        $scope.$on('$includeContentLoaded', function ($scope) {
        });
        $scope.selected = { id: undefined };
        this.getSelected = function () {
            return $scope.selected.id;
        };
        this.toggleSelected = function (id) {
            console.debug('projectNode:ctrl:toggleSelected', $scope.selected.id, id);
            $scope.selected.id = id;
        };
        $scope.$on('ui:projectTree:dataChanged', function () {
            console.debug('on ui:projectTree:dataChanged');
            $timeout(function () {
                $scope.tree = ProjectTreeAdaptor($scope.project).nodes;
            });
        });
    };
    ProjectTreeVM.$inject = [
        'ProjectTreeAdaptor2',
        '$modal',
        '$scope',
        '$timeout',
        'mevAnalysisEventBus'
    ];
    return ProjectTreeVM;
});
/*app/utils/utils*/
define('app/utils/utils', ['lodash'], function (_) {
    function sleep(milliseconds) {
        var start = new Date().getTime();
        for (var i = 0; i < 10000000; i++) {
            if (new Date().getTime() - start > milliseconds) {
                break;
            }
        }
    }
    ;
    function walkObjectTree(obj, callback, path, limit) {
        var path = path || [];
        _.transform(obj, function (acc, value, key, obj) {
            if (_.isObject(value)) {
                acc.push(key);
                console.debug('push:', acc.join('.'));
                callback(value, acc);
                walkObjectTree(value, callback, acc);
                console.debug('pop:', acc.join('.'));
                path.pop();
            } else if (_.isArray(value)) {
                acc.push(key);
                console.debug('push:', acc.join('.'));
                _.forEach(value, function (item) {
                    callback(item, acc);
                    walkObjectTree(item, callback, acc);
                    console.debug('pop:', acc.join('.'));
                    path.pop();
                });
                acc.pop();
                console.debug('pop:', acc.join('.'));
            } else if (!_.isFunction(value) && !_.isUndefined(value) && !_.isEmpty(value) && !_.isNull(value)) {
                acc.push(key);
                console.debug('push:', acc.join('.'));
                callback(value, acc);
                walkObjectTree(value, callback, acc);
                console.debug('pop:', acc.join('.'));
                path.pop();
            }
        }, path);
    }
    ;
    function walkObjectTree2(obj, callback, path, limit) {
        var path = path || [];
        _.transform(obj, function (acc, value, key, obj) {
            if (_.isObject(value)) {
                acc.push(key);
                console.debug('push2:', acc.join('.'));
                if (callback(value, acc))
                    walkObjectTree2(value, callback, acc);
                console.debug('pop2:', acc.join('.'));
                path.pop();
            } else if (_.isArray(value)) {
                acc.push(key);
                console.debug('push2:', acc.join('.'));
                if (callback(value, acc)) {
                    _.forEach(value, function (item) {
                        acc.push(item, acc);
                        console.debug('push2:', acc.join('.'));
                        var keepGoing = callback(item, acc);
                        if (keepGoing) {
                            walkObjectTree2(item, callback, acc);
                            console.debug('pop2:', acc.join('.'));
                            acc.pop();
                        } else {
                            console.debug('aborting ... pop2:', acc.join('.'));
                            acc.pop();
                            return false;
                        }
                    });
                }
                acc.pop();
                console.debug('pop2:', acc.join('.'));
            } else if (!_.isFunction(value) && !_.isUndefined(value) && !_.isEmpty(value) && !_.isNull(value)) {
                acc.push(key);
                console.debug('push2:', acc.join('.'));
                if (callback(value, acc))
                    walkObjectTree2(value, callback, acc);
                console.debug('pop2:', acc.join('.'));
                path.pop();
            }
        }, path);
    }
    ;
    function objectToNodeTree(obj, callback, path, tree, limit) {
        var path = path || [];
        var tree = tree || {
            nodeName: 'root',
            nodes: []
        };
        var newNode;
        _.transform(obj, function (acc, value, key, obj) {
            if (_.isObject(value)) {
                acc.push({
                    key: key,
                    node: tree
                });
                newNode = callback(value, acc);
                if (newNode) {
                    tree = newNode;
                    objectToNodeTree(value, callback, acc, tree);
                }
                tree = acc.pop().node;
            } else if (_.isArray(value)) {
                acc.push({
                    key: key,
                    node: tree
                });
                newNode = callback(value, acc);
                if (newNode) {
                    tree = newNode;
                    _.forEach(value, function (item) {
                        acc.push({
                            key: item,
                            node: tree
                        });
                        newNode = callback(value, acc);
                        if (newNode) {
                            tree = newNode;
                            objectToNodeTree(item, callback, acc, tree);
                            tree = acc.pop().node;
                        } else {
                            tree = acc.pop().node;
                            return false;
                        }
                    });
                }
                tree = acc.pop().node;
            } else if (!_.isFunction(value) && !_.isUndefined(value) && !_.isEmpty(value) && !_.isNull(value)) {
                acc.push({
                    key: key,
                    node: tree
                });
                newNode = callback(value, acc);
                if (newNode) {
                    tree = newNode;
                    objectToNodeTree(value, callback, acc, tree);
                }
                tree = acc.pop().node;
            }
        }, path);
        return tree;
    }
    ;
    function buildNodeTree(source, schema, fnBuildNodeCallback) {
        var tree = objectToNodeTree(source, function (obj, path) {
            var fnBuildNode = fnBuildNodeCallback || function (config, data, path) {
                return {
                    nodeName: config.label || path[path.length - 1].key,
                    nodeConfig: config,
                    nodeData: data,
                    nodePath: _.map(path, 'key').join('.'),
                    nodeParent: path.length > 1 ? path[path.length - 2].node : undefined,
                    nodes: []
                };
            };
            var nodePath = _.map(path, 'key').join('.');
            if (Array.isArray(obj)) {
                console.debug('buildNodeTree length', obj.length, nodePath);
            }
            var nodeDef = _.find(schema, function (value, key) {
                return nodePath.match(key + '$') !== null;
            });
            if (nodeDef) {
                console.debug('nodeDef', nodeDef);
                if (nodeDef.skip) {
                    return path[path.length - 1].node;
                } else {
                    var newNode = fnBuildNode(nodeDef, obj, path);
                    path[path.length - 1].node.nodes.push(newNode);
                    return newNode;
                }
            }
            return undefined;
        });
        console.info('NODETREE', tree);
        return tree;
    }
    function createNodeTree(obj, callback, tree, limit) {
        var tree = {
            node: name,
            nodes: []
        };
        _.transform(obj, function (acc, value, key, obj) {
            if (_.isObject(value)) {
                acc.push(key);
                console.debug('push:', acc.join('.'));
                callback(value, acc);
                walkObjectTree(value, callback, acc);
                console.debug('pop:', acc.join('.'));
                path.pop();
            } else if (_.isArray(value)) {
                acc.push(key);
                console.debug('push:', acc.join('.'));
                _.forEach(value, function (item) {
                    callback(item, acc);
                    walkObjectTree(item, callback, acc);
                    console.debug('pop:', acc.join('.'));
                    path.pop();
                });
                acc.pop();
                console.debug('pop:', acc.join('.'));
            } else if (!_.isFunction(value) && !_.isUndefined(value) && !_.isEmpty(value) && !_.isNull(value)) {
                acc.push(key);
                console.debug('push:', acc.join('.'));
                callback(value, acc);
                walkObjectTree(value, callback, acc);
                console.debug('pop:', acc.join('.'));
                path.pop();
            }
        }, path);
    }
    ;
    function traverse1(obj, callback, path) {
        var path = path || [];
        path.push(obj);
        callback(obj, path);
        var chldren = _.filter(_.values(obj), _.isObject);
        if (chldren.length > 0) {
            _.map(chldren, function (child) {
                traverse1(child, callback, path);
                path.pop();
            });
        } else {
            return obj;
        }
    }
    ;
    function traverse(obj, callback, path) {
        if (!path) {
            path = [];
            callback(obj, path);
        }
        _.mapValues(obj, function (value, key, obj) {
            if (_.isObject(value)) {
                path.push(key);
                callback(value, path);
                traverse(value, callback, path);
                path.pop();
            }
        });
    }
    ;
    function traverseRev(obj, callback, path) {
        var isRoot = false;
        if (!path) {
            path = [];
            isRoot = true;
        }
        _.mapValues(obj, function (value, key, obj) {
            if (_.isObject(value)) {
                path.push(key);
                traverseRev(value, callback, path);
                callback(value, path);
                path.pop();
            }
        });
        if (isRoot) {
            callback(obj, path);
        }
    }
    ;
    function getProp(objPath) {
        return _.reduce(objPath, function (result, prop) {
            return result[prop];
        }, data);
    }
    function urlToObj(objPath, data) {
        return _.reduce(objPath, function (result, prop) {
            return result[prop];
        }, data);
    }
    ;
    function urlToArray(objPath, data, fnGetId) {
        fnGetId = fnGetId || function (obj) {
            return obj.name;
        };
        return _.reduce(objPath, function (result, prop) {
            if (prop === '')
                return result;
            try {
                if (_.isArray(result)) {
                    var found = _.find(result, function (item) {
                        return String(fnGetId(item)) === prop;
                    });
                    return found;
                } else {
                    return result[prop];
                }
            } catch (e) {
                errContext = [
                    objPath,
                    data,
                    prop,
                    result,
                    e
                ];
                errMsg = 'Error mapping urlToArray from [objPath, data, result, prop, e]:';
                console.error(errMsg, errContext);
                throw new Error(errMsg + JSON.stringify(errContext));
            }
        }, data);
    }
    ;
    return {
        traverse: traverse,
        traverse1: traverse1,
        traverseRev: traverseRev,
        urlToObj: urlToObj,
        urlToArray: urlToArray,
        sleep: sleep,
        walkObjectTree: walkObjectTree,
        walkObjectTree2: walkObjectTree2,
        objectToNodeTree: objectToNodeTree,
        buildNodeTree: buildNodeTree
    };
});
/*app/widgets/project/projectTree/controllers/ProjectTreeAdaptor*/
'use strict';
define('app/widgets/project/projectTree/controllers/ProjectTreeAdaptor', [
    'mui',
    'lodash',
    'app/utils/utils'
], function (ng, _, utils) {
    var ProjectTreeAdaptor = function ProjectTreeAdaptor(DatasetProjectTreeSchema, DatasetProjectTreeEventBus, $state) {
        return function (project) {
            var tree = {
                name: project.name,
                nodes: []
            };
            tree = utils.buildNodeTree(project, DatasetProjectTreeSchema, function (config, data, path) {
                console.debug('Nodepath:', _.map(path, 'key').join('.'));
                return {
                    nodeName: config.label || path[path.length - 1].key,
                    nodeConfig: config,
                    nodeData: data,
                    nodePath: _.map(path, 'key').join('.'),
                    nodeParent: path.length > 1 ? path[path.length - 2].node : undefined,
                    activate: function () {
                        var node = this;
                        var params = node.nodeConfig.state.getParams(node);
                        var targetState = 'root' + node.nodeConfig.state.name;
                        console.debug('node.activate', node, $state, params, targetState);
                        $state.go(targetState, params);
                    },
                    nodes: []
                };
            });
            console.debug('ProjectTREE', tree);
            return tree;
        };
    };
    ProjectTreeAdaptor.$inject = [
        'DatasetProjectTreeSchema',
        'DatasetProjectTreeEventBus',
        '$state'
    ];
    return ProjectTreeAdaptor;
});
/*app/widgets/project/projectTree/controllers/ProjectTreeAdaptor2*/
define('app/widgets/project/projectTree/controllers/ProjectTreeAdaptor2', [
    'mui',
    'lodash',
    'app/utils/utils'
], function (ng, _, utils) {
    'use strict';
    var ProjectTreeAdaptor2 = function ProjectTreeAdaptor2(DatasetProjectTreeSchema, DatasetProjectTreeEventBus, $state) {
        function getInheritedParams(defaults, node) {
            var params = defaults || {};
            if (node.nodeParent && node.nodeParent.nodeConfig) {
                _.extend(params, node.nodeParent.nodeConfig.state.getParams(node.nodeParent));
            }
            return params;
        }
        function getNodePath(node) {
            if (!node.parent)
                return node.nodeName;
            else
                return node.parent.path + '.' + node.nodeName;
        }
        function createNode(data, pConfig, parent) {
            var config = pConfig || {};
            return _.assign(Object.create({}, {
                nodePath: {
                    configurable: false,
                    get: function () {
                        return getNodePath(this);
                    }
                }
            }), {
                nodeName: config.label || data.name || data.id,
                nodeConfig: config || {},
                nodeData: data,
                nodeParent: parent,
                activate: function () {
                    var node = this;
                    var params = node.nodeConfig.state.getParams(node);
                    var targetState = 'root' + node.nodeConfig.state.name;
                    console.debug('node.activate', node, $state, params, targetState);
                    $state.go(targetState, params);
                },
                add: function (node) {
                    node.parent = this;
                    this.nodes.push(node);
                },
                child: function (name) {
                    return _.find(this.nodes, { nodeName: name });
                },
                descendant: function (name, node) {
                    if (!node)
                        node = this;
                    var result = node.child(name);
                    if (result)
                        return result;
                    for (var i = 0; i < node.nodes.length; i++) {
                        var cur = node.nodes[i];
                        result = node.descendant(name, cur);
                        if (result)
                            return result;
                    }
                },
                nodes: []
            });
        }
        return function (project) {
            var projectNode = createNode(project);
            var datasetNode = createNode(project.dataset, {
                label: 'Dataset',
                state: {
                    name: '.dataset.home',
                    getParams: function (node) {
                        return {
                            datasetId: node.nodeData.id,
                            node: node
                        };
                    }
                }
            });
            projectNode.add(datasetNode);
            var columnSetsNode = createNode(project.dataset.column, {
                label: 'Sample Sets',
                state: {
                    name: '.dataset.columnSets',
                    getParams: function (node) {
                        return {};
                    }
                }
            });
            datasetNode.add(columnSetsNode);
            project.dataset.column.selections.forEach(function (selection) {
                var selectionNode = createNode(selection, {
                    type: 'selectionSet',
                    state: {
                        name: '.dataset.columnSet',
                        getParams: function (node) {
                            return { setId: node.nodeData.name };
                        }
                    }
                });
                columnSetsNode.add(selectionNode);
            });
            var rowSetsNode = createNode(project.dataset.row, {
                label: 'Gene Sets',
                state: {
                    name: '.dataset.rowSets',
                    getParams: function (node) {
                        return {};
                    }
                }
            });
            datasetNode.add(rowSetsNode);
            project.dataset.row.selections.forEach(function (selection) {
                var selectionNode = createNode(selection, {
                    type: 'selectionSet',
                    state: {
                        name: '.dataset.rowSet',
                        getParams: function (node) {
                            return { setId: node.nodeData.name };
                        }
                    }
                });
                rowSetsNode.add(selectionNode);
            });
            var analysesNode = createNode(project.dataset.analyses, {
                label: 'Analyses',
                state: {
                    name: '.dataset.analyses',
                    getParams: function (node) {
                    }
                }
            });
            datasetNode.add(analysesNode);
            _.transform(_.sortBy(project.dataset.analyses, 'name'), function (node, analysis, index, analyses) {
                var analysisNode = createNode(analysis, {
                    type: 'Analysis',
                    state: {
                        name: '.dataset.analysis',
                        getParams: function (node) {
                            return getInheritedParams({
                                analysisId: node.nodeData.name,
                                analysisType: node.nodeData.type
                            }, node);
                        },
                        isDisabled: function (node) {
                            return node.nodeData.status === 'IN_PROGRESS';
                        }
                    }
                });
                var parentNode = node;
                var prevAnalysis = _.find(analyses, function (item) {
                    return analysis.name.indexOf(item.name + '.') === 0;
                });
                if (prevAnalysis)
                    parentNode = node.descendant(prevAnalysis.name);
                parentNode.add(analysisNode);
            }, analysesNode);
            console.debug('ProjectTREE', projectNode);
            return projectNode;
        };
    };
    ProjectTreeAdaptor2.$inject = [
        'DatasetProjectTreeSchema',
        'DatasetProjectTreeEventBus',
        '$state'
    ];
    ProjectTreeAdaptor2.$name = 'ProjectTreeAdaptor2';
    return ProjectTreeAdaptor2;
});
/*app/widgets/project/projectTree/controllers/DatasetProjectTreeEventBus*/
define('app/widgets/project/projectTree/controllers/DatasetProjectTreeEventBus', [], function () {
    var DatasetProjectTreeEventBus = function ($rootScope) {
    };
    return DatasetProjectTreeEventBus;
    DatasetProjectTreeEventBus.$inject = ['$rootScope'];
});
/*app/widgets/project/projectTree/directives/projectTree.directive*/
define('app/widgets/project/projectTree/directives/projectTree.directive', ['jquery'], function ($) {
    return function ProjectTree() {
        return {
            scope: {
                project: '=',
                nodeType: '@'
            },
            restrict: 'AE',
            templateUrl: 'app/widgets/project/projectTree/templates/projectTree.bootstrapTree.tpl.html',
            controller: 'ProjectTreeVM',
            controllerAs: 'ProjectTreeVM',
            link: {
                post: function (scope) {
                    console.debug('**scope', scope);
                }
            }
        };
    };
});
/*app/widgets/project/projectTree/controllers/ProjectTreeSchema*/
define('app/widgets/project/projectTree/controllers/ProjectTreeSchema', [], function () {
    var ProjectTreeSchema = function ProjectTreeSchema() {
        return {
            'dataset': { label: 'Datasets' },
            'dataset.[0-9]+': {
                label: 'Dataset',
                state: {
                    name: '.dataset',
                    getParams: function (node) {
                        return {
                            datasetId: node.nodeData.id,
                            node: node
                        };
                    }
                }
            },
            'dataset.[0-9]+.dataref': {
                label: '',
                skip: true
            },
            'dataset.[0-9]+.dataref.column': {
                label: 'Samples',
                state: {
                    name: '.dataset.samples',
                    getParams: function (node) {
                        return {};
                    }
                }
            },
            'dataset.[0-9]+.dataref.row': {
                label: 'Genes/Probes',
                state: {
                    name: '.dataset.rows',
                    getParams: function (node) {
                        return {};
                    }
                }
            },
            'analysis': { label: 'Analyses' },
            'analysis.[0-9]+': {
                label: 'Analysis',
                state: {
                    name: '.analysis',
                    getParams: function (node) {
                        return {
                            analysisId: node.nodeData.id,
                            analysisType: node.nodeData.type
                        };
                    }
                }
            },
            'analysis.[0-9]+.result': {
                label: 'Results',
                skip: true
            },
            'analysis.[0-9]+.result.[0-9]+': {
                label: 'result',
                state: {
                    name: '.analysis.result',
                    getParams: function (node) {
                        return { resultId: node.nodeData.name };
                    }
                }
            }
        };
    };
    return ProjectTreeSchema;
    ProjectTreeSchema.$inject = [];
});
/*app/widgets/project/projectTree/controllers/DatasetProjectTreeSchema*/
define('app/widgets/project/projectTree/controllers/DatasetProjectTreeSchema', ['lodash'], function (_) {
    var DatasetProjectTreeSchema = function DatasetProjectTreeSchema() {
        function getInheritedParams(defaults, node) {
            var params = defaults || {};
            if (node.nodeParent && node.nodeParent.nodeConfig) {
                _.extend(params, node.nodeParent.nodeConfig.state.getParams(node.nodeParent));
            }
            return params;
        }
        var stateBase = {
            getParams: function (node) {
                return {};
            }
        };
        return {
            'dataset': {
                label: 'Dataset',
                state: {
                    name: '.dataset.home',
                    getParams: function (node) {
                        return {
                            datasetId: node.nodeData.id,
                            node: node
                        };
                    }
                }
            },
            'dataset.column': {
                label: 'Sample Sets',
                state: {
                    name: '.dataset.columnSets',
                    getParams: function (node) {
                        return {};
                    }
                }
            },
            'dataset.column.selections': {
                label: 'Selections',
                skip: true
            },
            'dataset.column.selections.[0-9]+': {
                state: {
                    name: '.dataset.columnSet',
                    getParams: function (node) {
                        return { setId: node.nodeData.name };
                    }
                }
            },
            'dataset.row': {
                label: 'Gene Sets',
                state: {
                    name: '.dataset.rowSets',
                    getParams: function (node) {
                        return {};
                    }
                }
            },
            'dataset.row.selections': {
                label: 'Selections',
                skip: true
            },
            'dataset.row.selections.[0-9]+': {
                state: {
                    name: '.dataset.rowSet',
                    getParams: function (node) {
                        return { setId: node.nodeData.name };
                    }
                }
            },
            'dataset.analyses': {
                label: 'Analyses',
                state: {
                    name: '.dataset.analyses',
                    getParams: function (node) {
                    }
                }
            },
            'dataset.analyses.[0123456789][0123456789]*': {
                type: 'Analysis',
                state: {
                    name: '.dataset.analysis',
                    getParams: function (node) {
                        return getInheritedParams({
                            analysisId: node.nodeData.name,
                            analysisType: node.nodeData.type
                        }, node);
                    },
                    isDisabled: function (node) {
                        return node.nodeData.status === 'IN_PROGRESS';
                    }
                }
            }
        };
    };
    return DatasetProjectTreeSchema;
    DatasetProjectTreeSchema.$inject = [];
});
/*app/widgets/project/projectTree/_projectNode/directives/projectNode.directive*/
define('app/widgets/project/projectTree/_projectNode/directives/projectNode.directive', [], function () {
    var ProjectNodeDirective = function ProjectNodeDirective($compile, $rootScope) {
        function initBootstrapTree() {
            console.debug('INITIT Bootstrap TREE');
            $('.tree > ul').attr('role', 'tree').find('ul').attr('role', 'group');
            $('.tree').find('li:has(ul)').addClass('parent_li').attr('role', 'treeitem').find(' > span').attr('title', 'Collapse this branch').on('click', function (e) {
                var children = $(this).parent('li.parent_li').find(' > ul > li');
                if (children.is(':visible')) {
                    children.hide('fast');
                    $(this).attr('title', 'Expand this branch').find(' > i').addClass('glyphicon-plus-sign').removeClass('glyphicon-minus-sign');
                } else {
                    children.show('fast');
                    $(this).attr('title', 'Collapse this branch').find(' > i').addClass('glyphicon-minus-sign').removeClass('glyphicon-plus-sign');
                }
                e.stopPropagation();
            });
        }
        var templateMap = {
            Datasets: '<div>{{node.nodeName}}</div>',
            Analyses: '<div>{{node.nodeName}}</div>',
            'Sample Sets': '<column-node node=\'node\'></column-node>',
            'Gene Sets': '<row-node node=\'node\'></row-node>',
            'Analysis': '<analysis-node node=\'node\'></analysis-node>',
            'selectionSet': '<selection-set-node node=\'node\'></selection-set-node>',
            Default: '<project-node-default node=\'node\' ></project-node-default>'
        };
        return {
            restrict: 'AE',
            scope: {
                name: '&',
                data: '=',
                config: '&',
                children: '=',
                node: '='
            },
            replace: true,
            template: '<span  id=\'{{vm.id}}\'  ng-class=\'{selected: vm.isSelected(), disabled: vm.isDisabled(), error: vm.isError()}\' class=\'nodeWrapper node-{{node.nodenode.name || node.nodeName}}\' ng-click=\'vm.onClick($event)\' ng-dblclick=\'vm.toggle($event)\'></span>',
            require: '^projectTree',
            compile: function (elm, attr) {
                link = {
                    post: function (scope, elm, attr, ctrl) {
                        scope.vm = {
                            id: scope.node.nodePath,
                            toggle: function (e) {
                                console.debug('node.toggle', scope.node.nodeName);
                                var nodeWrapper = $(e.target).closest('.nodeWrapper');
                                var parent = nodeWrapper.parent('li.parent_li');
                                var children = parent.find(' > ul > li');
                                if (children.is(':visible')) {
                                    children.hide('fast');
                                    nodeWrapper.attr('title', 'Expand this branch').find(' > i').addClass('glyphicon-plus-sign').removeClass('glyphicon-minus-sign');
                                } else {
                                    children.show('fast');
                                    nodeWrapper.attr('title', 'Collapse this branch').find(' > i').addClass('glyphicon-minus-sign').removeClass('glyphicon-plus-sign');
                                }
                                e.stopPropagation();
                            },
                            isSelected: function () {
                                return ctrl.getSelected() === scope.node.nodePath;
                            },
                            isDisabled: function () {
                                return scope.node.nodeData.status && scope.node.nodeData.status === 'IN_PROGRESS';
                            },
                            isError: function () {
                                return scope.node.nodeData.status && scope.node.nodeData.status === 'ERROR';
                            },
                            onClick: function (e) {
                                ctrl.toggleSelected(scope.node.nodePath);
                                console.debug('node.click, ui:projectTree:nodeSelected', scope.node.nodeName);
                                $rootScope.$broadcast('ui:projectTree:nodeSelected', scope.node);
                            }
                        };
                        console.debug('Post LINK node: ', scope.node.nodeName, scope.node.nodeConfig.type, scope.node);
                        var template = templateMap[scope.node.nodeName] || templateMap[scope.node.nodeConfig.type] || templateMap.Default;
                        template = '<i class=\'nodeToggle glyphicon glyphicon-minus-sign\' ng-click=\'vm.nodeclick($event)\'></i>' + template;
                        elm.html(template);
                        $compile(elm.contents())(scope);
                    }
                };
                return link;
            }
        };
    };
    ProjectNodeDirective.$inject = [
        '$compile',
        '$rootScope'
    ];
    return ProjectNodeDirective;
});
/*app/widgets/project/projectTree/_projectNode/directives/projectNodeDefault.directive*/
define('app/widgets/project/projectTree/_projectNode/directives/projectNodeDefault.directive', ['ng'], function (ng) {
    var ProjectNodeDefaultDirective = function ProjectNodeDefaultDirective() {
        return {
            restrict: 'AE',
            scope: { node: '=' },
            templateUrl: 'app/widgets/project/projectTree/_projectNode/templates/projectNodeDefault.bootstrapTree.tpl.html',
            link: function (scope, elem, attr) {
                scope.isObject = ng.isObject;
                scope.vm = {
                    onClick: function () {
                        console.debug('DefaultNode.click', attr, scope.node);
                    }
                };
            }
        };
    };
    ProjectNodeDefaultDirective.$inject = [];
    return ProjectNodeDefaultDirective;
});
/*app/widgets/project/projectTree/widgets.projectTree.module*/
define('app/widgets/project/projectTree/widgets.projectTree.module', [
    'ng',
    './controllers/ProjectTreeVM',
    './controllers/ProjectTreeAdaptor',
    './controllers/ProjectTreeAdaptor2',
    './controllers/DatasetProjectTreeEventBus',
    './directives/projectTree.directive',
    './controllers/ProjectTreeSchema',
    './controllers/DatasetProjectTreeSchema',
    './_projectNode/directives/projectNode.directive',
    './_projectNode/directives/projectNodeDefault.directive'
], function (ng, ProjectTreeVM, ProjectTreeAdaptor, ProjectTreeAdaptor2, DatasetProjectTreeEventBus, ProjectTreeDirective, ProjectTreeSchema, DatasetProjectTreeSchema, ProjectNodeDirective, projectNodeDefaultDirective) {
    var module = ng.module('mui.widgets.projecttree', []);
    module.factory('ProjectTreeSchema', ProjectTreeSchema);
    module.factory('DatasetProjectTreeSchema', DatasetProjectTreeSchema);
    module.factory('ProjectTreeAdaptor', ProjectTreeAdaptor);
    module.factory('ProjectTreeAdaptor2', ProjectTreeAdaptor2);
    module.service('DatasetProjectTreeEventBus', DatasetProjectTreeEventBus);
    module.controller('ProjectTreeVM', ProjectTreeVM);
    module.directive('projectTree', ProjectTreeDirective);
    module.directive('projectNode', ProjectNodeDirective);
    module.directive('projectNodeDefault', projectNodeDefaultDirective);
    return module;
});
/*app/widgets/project/widgets.project.module*/
define('app/widgets/project/widgets.project.module', [
    'ng',
    './projectTree/widgets.projectTree.module'
], function (ng) {
    var module = ng.module('mui.widgets.project', ['mui.widgets.projecttree']);
    return module;
});
/*app/widgets/dataset/column/columnNode/controllers/ColumnNodeVM*/
define('app/widgets/dataset/column/columnNode/controllers/ColumnNodeVM', [], function () {
    var ColumnNodeVM = function ColumnNodeVM($scope) {
    };
    ColumnNodeVM.$inject = ['$scope'];
    return ColumnNodeVM;
});
/*app/widgets/dataset/column/columnNode/directives/columnNode.directive*/
define('app/widgets/dataset/column/columnNode/directives/columnNode.directive', [], function () {
    var ColumnNode = function ($rootScope) {
        return {
            scope: { node: '=' },
            restrict: 'AE',
            templateUrl: 'app/widgets/dataset/column/columnNode/templates/columnNode.tpl.html',
            controller: 'ColumnNodeVM',
            controllerAs: 'ColumnNodeVM',
            link: function (scope, elm, attrs, ctrl) {
                console.debug('columnNode link', scope.node);
                scope.vm = {
                    onClick: function (e) {
                        console.debug('columnNode onClick', e);
                        $rootScope.$state.go('root.dataset.columnSet', { setId: 'new' });
                        e.stopPropagation();
                    }
                };
            }
        };
    };
    ColumnNode.$inject = ['$rootScope'];
    return ColumnNode;
});
/*app/widgets/dataset/column/columnNode/widgets.dataset.columnNode.module*/
define('app/widgets/dataset/column/columnNode/widgets.dataset.columnNode.module', [
    'ng',
    './controllers/ColumnNodeVM',
    './directives/columnNode.directive'
], function (ng, ColumnNodeVM, ColumnNodeDirective) {
    var module = ng.module('mui.widgets.dataset.ColumnNode', []);
    module.controller('ColumnNodeVM', ColumnNodeVM);
    module.directive('columnNode', ColumnNodeDirective);
    return module;
});
/*app/widgets/dataset/column/widgets.dataset.column.module*/
define('app/widgets/dataset/column/widgets.dataset.column.module', [
    'ng',
    './columnNode/widgets.dataset.columnNode.module'
], function (ng) {
    var module = ng.module('mui.widgets.dataset.column', ['mui.widgets.dataset.ColumnNode']);
    return module;
});
/*app/widgets/dataset/row/rowNode/controllers/RowNodeVM*/
define('app/widgets/dataset/row/rowNode/controllers/RowNodeVM', [], function () {
    var RowNodeVM = function RowNodeVM($scope) {
    };
    RowNodeVM.$inject = ['$scope'];
    return RowNodeVM;
});
/*app/widgets/dataset/row/rowNode/directives/rowNode.directive*/
define('app/widgets/dataset/row/rowNode/directives/rowNode.directive', [], function () {
    var RowNode = function ($rootScope) {
        return {
            scope: { node: '=' },
            restrict: 'AE',
            templateUrl: 'app/widgets/dataset/row/rowNode/templates/rowNode.tpl.html',
            controller: 'RowNodeVM',
            controllerAs: 'RowNodeVM',
            link: function (scope, elm, attrs, ctrl) {
                console.debug('rowNode link', scope.node);
                scope.vm = {
                    onClick: function (e) {
                        console.debug('rowNode onClick', e);
                        $rootScope.$state.go('root.dataset.rowSet', { setId: 'new' });
                        e.stopPropagation();
                    }
                };
            }
        };
    };
    RowNode.$inject = ['$rootScope'];
    return RowNode;
});
/*app/widgets/dataset/row/rowNode/widgets.dataset.rowNode.module*/
define('app/widgets/dataset/row/rowNode/widgets.dataset.rowNode.module', [
    'ng',
    './controllers/RowNodeVM',
    './directives/rowNode.directive'
], function (ng, RowNodeVM, RowNodeDirective) {
    var module = ng.module('mui.widgets.dataset.RowNode', []);
    module.controller('RowNodeVM', RowNodeVM);
    module.directive('rowNode', RowNodeDirective);
    return module;
});
/*app/widgets/dataset/row/widgets.dataset.row.module*/
define('app/widgets/dataset/row/widgets.dataset.row.module', [
    'ng',
    './rowNode/widgets.dataset.rowNode.module'
], function (ng) {
    var module = ng.module('mui.widgets.dataset.row', ['mui.widgets.dataset.RowNode']);
    return module;
});
/*$css*/
define('$css', function (require, exports, module) {
    var loader = require('@loader');
    if (isProduction()) {
        exports.fetch = function (load) {
            var cssFile = load.address;
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = cssFile;
            document.head.appendChild(link);
            return '';
        };
    } else {
        exports.instantiate = function (load) {
            var loader = this;
            load.metadata.deps = [];
            load.metadata.execute = function () {
                var source = load.source + '/*# sourceURL=' + load.address + ' */';
                source = source.replace(/url\(['"]?([^'"\)]*)['"]?\)/g, function (whole, part) {
                    return 'url(' + steal.joinURIs(load.address, part) + ')';
                });
                if (load.source && typeof document !== 'undefined') {
                    var doc = document.head ? document : document.getElementsByTagName ? document : document.documentElement;
                    var head = doc.head || doc.getElementsByTagName('head')[0], style = document.createElement('style');
                    if (!head) {
                        var docEl = doc.documentElement || doc;
                        head = document.createElement('head');
                        docEl.insertBefore(head, docEl.firstChild);
                    }
                    style.type = 'text/css';
                    if (style.styleSheet) {
                        style.styleSheet.cssText = source;
                    } else {
                        style.appendChild(document.createTextNode(source));
                    }
                    head.appendChild(style);
                    if (loader.has('live-reload')) {
                        var cssReload = loader['import']('live-reload', { name: '$css' });
                        Promise.resolve(cssReload).then(function (reload) {
                            loader['import'](load.name).then(function () {
                                reload.once(load.name, function () {
                                    head.removeChild(style);
                                });
                            });
                        });
                    }
                }
                return System.newModule({ source: source });
            };
            load.metadata.format = 'css';
        };
    }
    function isProduction() {
        return loader.isEnv && loader.isEnv('production') || loader.env === 'production';
    }
    exports.buildType = 'css';
    exports.includeInBuild = true;
});
/*less*/
define('less', [], function(){ return {}; });
/*$less*/
define('$less', [], function(){ return {}; });
/*app/widgets/dataset/selectionSet/SelectionSetNode/selectionSetNode.directive*/
define('app/widgets/dataset/selectionSet/SelectionSetNode/selectionSetNode.directive', ['./selectionSetNode.less'], function () {
    var selectionSetNode = function ($rootScope) {
        return {
            scope: { node: '=' },
            restrict: 'AE',
            templateUrl: 'app/widgets/dataset/selectionSet/SelectionSetNode/selectionSetNode.tpl.html',
            link: function (scope, elm, attrs, ctrl) {
                console.debug('selectionSetNode link', scope.node);
                scope.vm = {
                    delete: function (e) {
                        console.debug('selectionSetNode onClick', e);
                        if (confirm('Delete selection \'' + scope.node.nodeData.name + '\'?'))
                            $rootScope.$broadcast('root.dataset.selectionSet.delete', scope.node.parent.nodeData.type, scope.node.nodeData);
                        e.stopPropagation();
                    }
                };
            }
        };
    };
    selectionSetNode.$inject = ['$rootScope'];
    return selectionSetNode;
});
/*app/widgets/dataset/selectionSet/widgets.dataset.selectionSet.module*/
define('app/widgets/dataset/selectionSet/widgets.dataset.selectionSet.module', [
    'ng',
    './SelectionSetNode/selectionSetNode.directive'
], function (ng, SelectionSetNodeDirective) {
    var module = ng.module('mui.widgets.dataset.SelectionSet', []);
    module.directive('selectionSetNode', SelectionSetNodeDirective);
    return module;
});
/*app/widgets/dataset/datasetNode/controllers/DatasetNodeVM*/
define('app/widgets/dataset/datasetNode/controllers/DatasetNodeVM', [], function () {
    var DatasetNodeVM = function DatasetNodeVM($scope) {
    };
    DatasetNodeVM.$inject = ['$scope'];
    return DatasetNodeVM;
});
/*app/widgets/dataset/datasetNode/directives/datasetNode.directive*/
define('app/widgets/dataset/datasetNode/directives/datasetNode.directive', [], function () {
    var DatasetNode = function ($rootScope) {
        return {
            scope: { node: '=' },
            restrict: 'AE',
            templateUrl: 'app/widgets/dataset/row/datasetNode/templates/datasetNode.tpl.html',
            controller: 'DatasetNodeVM',
            controllerAs: 'DatasetNodeVM',
            link: function (scope, elm, attrs, ctrl) {
                console.debug('datasetNode link', scope.node);
                scope.vm = {
                    onClick: function (e) {
                        console.debug('datasetNode onClick', e);
                        $rootScope.$state.go('root.dataset', { datsetId: scope.node.nodeData.name });
                        e.stopPropagation();
                    }
                };
            }
        };
    };
    DatasetNode.$inject = ['$rootScope'];
    return DatasetNode;
});
/*app/widgets/dataset/datasetNode/widgets.dataset.datasetNode.module*/
define('app/widgets/dataset/datasetNode/widgets.dataset.datasetNode.module', [
    'ng',
    './controllers/DatasetNodeVM',
    './directives/datasetNode.directive'
], function (ng, DatasetNodeVM, DatasetNodeDirective) {
    var module = ng.module('mui.widgets.dataset.DatasetNode', []);
    module.controller('DatasetNodeVM', DatasetNodeVM);
    module.directive('datasetNode', DatasetNodeDirective);
    return module;
});
/*app/widgets/dataset/widgets.dataset.module*/
define('app/widgets/dataset/widgets.dataset.module', [
    'ng',
    './column/widgets.dataset.column.module',
    './row/widgets.dataset.row.module',
    './selectionSet/widgets.dataset.selectionSet.module',
    './datasetNode/widgets.dataset.datasetNode.module'
], function (ng) {
    var module = ng.module('mui.widgets.dataset', [
        'mui.widgets.dataset.DatasetNode',
        'mui.widgets.dataset.column',
        'mui.widgets.dataset.row',
        'mui.widgets.dataset.SelectionSet'
    ]);
    return module;
});
/*app/widgets/dashboard/directives/dashboardDirective*/
define('app/widgets/dashboard/directives/dashboardDirective', ['ng'], function (ng) {
    var DashboardDirective = function DashboardDirective(setTransscope) {
        return {
            restrict: 'E',
            transclude: true,
            scope: {
                id: '@',
                hStretchItems: '=',
                muiContext: '&',
                dashboardItems: '='
            },
            template: '<div  ng-class="{\'container-flex\': true, \'v-stretch\': true, \'h-stretch\': dashboard.hStretchItems}" ng-transscope>' + '</div>',
            compile: function () {
                return {
                    pre: setTransscope,
                    post: function (scope, elm, attr, controller, $transclude) {
                        console.debug('dashboard link');
                        Object.keys(scope.muiContext()).map(function (key) {
                            scope[key] = scope.muiContext()[key];
                        });
                        controller.setAttr({ hStretchItems: scope.hStretchItems });
                    }
                };
            },
            controller: 'DashboardVM',
            controllerAs: 'dashboard'
        };
    };
    DashboardDirective.$inject = ['setTransscope'];
    DashboardDirective.$name = 'muiDashboardDirective';
    return DashboardDirective;
});
/*app/widgets/dashboard/directives/dashboardItemDirective*/
define('app/widgets/dashboard/directives/dashboardItemDirective', ['ng'], function (ng) {
    'use strict';
    var DashbaordItemDirective = function DashbaordItemDirective(DashboardLayout, $rootScope) {
        function Panel(name, elm, attr, controller) {
            var _self = this;
            _self.name = attr.name, _self.elm = elm;
            _self.isMax = false;
            _self.isRowMax = false;
            _self.controller = controller;
            _self.header = { title: attr.title };
            _self.content = {
                height: attr.contentHeight,
                width: attr.contentWidth
            };
            _self.max = function () {
                _self.elm.siblings().hide();
                _self.isMax = true;
            };
            _self.min = function () {
                _self.controller.resetOptions();
                _self.elm.siblings().show();
                _self.isMax = false;
            };
            _self.rowMax = function () {
                _self.isRowMax = true;
            };
            _self.rowMin = function () {
                _self.isRowMax = false;
            };
            _self.remove = function ($event) {
                console.debug('panel.remove', $event, _self.name);
                if (_self.isMax)
                    _self.min();
                _self.controller.remove(_self.name);
                delete DashboardLayout.panels[_self.name];
            };
        }
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            require: '^muiDashboard',
            scope: {
                name: '@',
                contentWidth: '@',
                contentHeight: '@',
                contentTemplate: '@',
                muiOptions: '='
            },
            templateUrl: 'app/widgets/dashboard/directives/dashboardItem.tpl.html',
            link: function (scope, elm, attr, controller, $transclude) {
                if (!DashboardLayout.panels[attr.name]) {
                    DashboardLayout.panels[attr.name] = new Panel(attr.name, elm, attr, controller);
                    if (scope.muiOptions) {
                        ng.extend(DashboardLayout.panels[attr.name], scope.muiOptions);
                        console.debug('muiDashboardItem options', scope.muiOptions, scope, attr, scope.panel);
                    }
                }
                scope.panel = DashboardLayout.panels[attr.name];
                scope.panel.elm = elm;
                scope.panel.controller = controller;
                scope.$on('ui:dashboard:removeItem', function ($event, data) {
                    console.debug('on panel ui:dashboard:removeItem', $event, data);
                    if (attr.name === data.name) {
                        scope.panel.remove(data.name);
                    }
                });
                elm.find('.content > *').width(attr.contentWidth).height(attr.contentHeight);
            }
        };
    };
    DashbaordItemDirective.$inject = [
        'DashboardLayout',
        '$rootScope'
    ];
    DashbaordItemDirective.$name = 'muiDashboardItem';
    DashbaordItemDirective.provider = 'Directive';
    return DashbaordItemDirective;
});
/*app/widgets/dashboard/directives/dashboardItemAddDirective*/
define('app/widgets/dashboard/directives/dashboardItemAddDirective', ['ng'], function (ng) {
    var DashbaordItemAddDirective = function DashbaordItemAddDirective($rootScope) {
        return {
            restrict: 'AC',
            scope: {
                name: '@',
                targetId: '@',
                contentWidth: '@',
                contentHeight: '@'
            },
            link: function (scope, elm, attr) {
                scope.vm = {
                    addItem: function () {
                        $rootScope.$broadcast('ui:dashboard:addItem', {
                            targetId: attr.targetId,
                            name: 'dashlet',
                            title: 'added from outside',
                            content: 'content content'
                        });
                        console.debug('add item click');
                    }
                };
                elm.bind('click', function () {
                    scope.$apply(scope.vm.addItem);
                });
            }
        };
    };
    DashbaordItemAddDirective.$inject = ['$rootScope'];
    DashbaordItemAddDirective.$name = 'muiDashboardItemAddDirective';
    return DashbaordItemAddDirective;
});
/*app/widgets/dashboard/directives/dashboardItemRemoveDirective*/
define('app/widgets/dashboard/directives/dashboardItemRemoveDirective', ['ng'], function (ng) {
    var DashbaordItemAddDirective = function DashbaordItemAddDirective($rootScope) {
        return {
            restrict: 'AC',
            scope: { muiDashboardItemRemove: '@' },
            link: function (scope, elm, attr) {
                scope.vm = {
                    removeItem: function () {
                        console.debug('remove item button click');
                        $rootScope.$broadcast('ui:dashboard:removeItem', { name: attr.muiDashboardItemRemove });
                    }
                };
                elm.bind('click', function () {
                    scope.$apply(scope.vm.removeItem);
                });
            }
        };
    };
    DashbaordItemAddDirective.$inject = ['$rootScope'];
    DashbaordItemAddDirective.$name = 'muiDashboardItemRemoveDirective';
    return DashbaordItemAddDirective;
});
/*app/widgets/dashboard/controllers/DashboardVM*/
define('app/widgets/dashboard/controllers/DashboardVM', [
    'ng',
    'lodash'
], function (ng, _) {
    'use strict';
    var DashboardVM = function DashboardVM($scope, $rootScope) {
        var _self = this;
        this.toggleHStretch = function (isOn) {
            _self.setOptions(options);
        };
        this.updateOptions = function (options) {
            ng.extend(_self, options);
        };
        this.resetOptions = function () {
            _self.updateOptions(_self.attr);
        };
        this.setAttr = function (attr) {
            _self.attr = attr;
            _self.updateOptions(attr);
        };
        this.remove = function (target) {
            delete _self.items[target];
            console.debug('remove _self.items', _self.items);
        };
        this.items = $scope.dashboardItems;
        $scope.$on('ui:dashboard:addItem', function ($event, data) {
            var exists = _.find(_self.items, { name: data.name });
            if (exists) {
                $rootScope.$broadcast('ui:analysisLog.append', 'info', 'Cannot add analysis \'' + data.name + '\' to the dashboard. It is already there.');
            } else {
                _self.items.$add(data);
            }
        });
        $scope.$on('ui:dashboard:removeItem', function ($event, data) {
            console.debug('on ui:dashboard:removeItem', $event, data);
            _self.remove(data.name);
        });
    };
    DashboardVM.$inject = [
        '$scope',
        '$rootScope'
    ];
    DashboardVM.$name = 'DashboardVMController';
    return DashboardVM;
});
/*app/widgets/dashboard/services/dashboardLayoutService*/
define('app/widgets/dashboard/services/dashboardLayoutService', [], function () {
    var DashboardLayoutService = function DashboardLayoutService() {
        this.panels = {};
    };
    DashboardLayoutService.$name = 'DashboardLayout';
    DashboardLayoutService.provider = 'service';
    DashboardLayoutService.$inject = [];
    return DashboardLayoutService;
});
/*app/widgets/dashboard/widgets.dashboard.module*/
define('app/widgets/dashboard/widgets.dashboard.module', [
    'mui',
    './directives/dashboardDirective',
    './directives/dashboardItemDirective',
    './directives/dashboardItemAddDirective',
    './directives/dashboardItemRemoveDirective',
    './controllers/DashboardVM',
    './services/dashboardLayoutService'
], function (ng, DashboardDirective, DashboardItemDirective, DashboardItemAddDirective, DashboardVM) {
    'use strict';
    console.debug('mui.widgets.dashboard');
    return ng.module('mui.widgets.dashboard', arguments, arguments).animation('.flex-spacing', [
        '$rootScope',
        function ($rootScope) {
            return {
                enter: function (element, done, options) {
                    console.debug('ANIMATE ENTER', element, done, options);
                    if (options.preparationClasses === 'rowMax-add')
                        $rootScope.$broadcast('mui:dashboard:panel:rowMax', element);
                    done();
                },
                addClass: function (element, addedClasses, done, options) {
                    console.debug('ANIMATE ADD', element, addedClasses, done, options);
                    if (addedClasses === 'max')
                        $rootScope.$broadcast('mui:dashboard:panel:max', element);
                    else if (addedClasses === 'rowMax') {
                        $rootScope.$broadcast('mui:dashboard:panel:rowMax', element);
                    }
                    done();
                },
                removeClass: function (element, addedClasses, done, options) {
                    console.debug('ANIMATE REMOVE', element, addedClasses, done, options);
                    if (addedClasses === 'max')
                        $rootScope.$broadcast('mui:dashboard:panel:min', element);
                    else if (addedClasses === 'rowMax') {
                        $rootScope.$broadcast('mui:dashboard:panel:rowMin', element);
                    }
                    done();
                }
            };
        }
    ]);
});
/*app/widgets/widgets.module*/
define('app/widgets/widgets.module', [
    'ng',
    './common/widgets.common.module',
    './mainmenu/mainmenu.module',
    './project/widgets.project.module',
    './dataset/widgets.dataset.module',
    './dashboard/widgets.dashboard.module'
], function (ng) {
    var module = ng.module('mui.components', arguments, arguments);
    return module;
});
/*app/utils/transscope/transscope.module*/
define('app/utils/transscope/transscope.module', ['ng'], function (ng) {
    var module = ng.module('mui.utils.transscope', []);
    module.directive('myDirective', function (setTransscope) {
        return {
            scope: { display: '=' },
            transclude: true,
            restrict: 'EA',
            templateUrl: 'my-template.html',
            link: setTransscope
        };
    });
    module.factory('setTransscope', function () {
        return function setTransscope($scope, $element) {
            $element.data('transscope', $scope);
            console.debug('set transscope: $element, $scope', $element, $scope);
        };
    });
    module.directive('ngTransscope', function () {
        return {
            restrict: 'EAC',
            link: function ($scope, $element, $attrs, $ctrls, $transclude) {
                console.debug('link ngTransscope');
                if (!$transclude) {
                    throw Error('No parent directive that requires a transclusion found.');
                }
                var targetScope = $element.inheritedData('transscope');
                if (!targetScope) {
                    throw Error('No transscope defined by parent directive.');
                }
                $transclude(targetScope.$new(), function (clone) {
                    console.debug('transscope transclude - clone', targetScope, clone);
                    $element.append(clone);
                });
            }
        };
    });
    return module;
});
/*app/utils/transcludePoint/transcludePointDirective*/
define('app/utils/transcludePoint/transcludePointDirective', [], function () {
    var transcludePointDirective = function transcludePointDirective() {
        return {
            priority: 1000,
            link: function (scope, elm, attr, ctrl, $transclude) {
                console.debug('transcludePoint', elm);
                elm.append($transclude());
            }
        };
    };
    transcludePointDirective.$inject = [];
    transcludePointDirective.$name = 'transcludePointDirective';
    return transcludePointDirective;
});
/*app/utils/utils.module*/
define('app/utils/utils.module', [
    'ng',
    './transscope/transscope.module',
    './transcludePoint/transcludePointDirective'
], function (ng, transcludePointDirective) {
    console.debug('mui.utils');
    return ng.module('mui.utils', arguments, arguments);
});
/*browser-filesaver@1.1.0#FileSaver*/
var saveAs = saveAs || function (view) {
    'use strict';
    if (typeof navigator !== 'undefined' && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var doc = view.document, get_URL = function () {
            return view.URL || view.webkitURL || view;
        }, save_link = doc.createElementNS('http://www.w3.org/1999/xhtml', 'a'), can_use_save_link = 'download' in save_link, click = function (node) {
            var event = new MouseEvent('click');
            node.dispatchEvent(event);
        }, webkit_req_fs = view.webkitRequestFileSystem, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem, throw_outside = function (ex) {
            (view.setImmediate || view.setTimeout)(function () {
                throw ex;
            }, 0);
        }, force_saveable_type = 'application/octet-stream', fs_min_size = 0, arbitrary_revoke_timeout = 500, revoke = function (file) {
            var revoker = function () {
                if (typeof file === 'string') {
                    get_URL().revokeObjectURL(file);
                } else {
                    file.remove();
                }
            };
            if (view.chrome) {
                revoker();
            } else {
                setTimeout(revoker, arbitrary_revoke_timeout);
            }
        }, dispatch = function (filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver['on' + event_types[i]];
                if (typeof listener === 'function') {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }, auto_bom = function (blob) {
            if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                return new Blob([
                    '\uFEFF',
                    blob
                ], { type: blob.type });
            }
            return blob;
        }, FileSaver = function (blob, name, no_auto_bom) {
            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            var filesaver = this, type = blob.type, blob_changed = false, object_url, target_view, dispatch_all = function () {
                    dispatch(filesaver, 'writestart progress write writeend'.split(' '));
                }, fs_error = function () {
                    if (blob_changed || !object_url) {
                        object_url = get_URL().createObjectURL(blob);
                    }
                    if (target_view) {
                        target_view.location.href = object_url;
                    } else {
                        var new_tab = view.open(object_url, '_blank');
                        if (new_tab == undefined && typeof safari !== 'undefined') {
                            view.location.href = object_url;
                        }
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                    revoke(object_url);
                }, abortable = function (func) {
                    return function () {
                        if (filesaver.readyState !== filesaver.DONE) {
                            return func.apply(this, arguments);
                        }
                    };
                }, create_if_not_found = {
                    create: true,
                    exclusive: false
                }, slice;
            filesaver.readyState = filesaver.INIT;
            if (!name) {
                name = 'download';
            }
            if (can_use_save_link) {
                object_url = get_URL().createObjectURL(blob);
                save_link.href = object_url;
                save_link.download = name;
                setTimeout(function () {
                    click(save_link);
                    dispatch_all();
                    revoke(object_url);
                    filesaver.readyState = filesaver.DONE;
                });
                return;
            }
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            if (webkit_req_fs && name !== 'download') {
                name += '.download';
            }
            if (type === force_saveable_type || webkit_req_fs) {
                target_view = view;
            }
            if (!req_fs) {
                fs_error();
                return;
            }
            fs_min_size += blob.size;
            req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
                fs.root.getDirectory('saved', create_if_not_found, abortable(function (dir) {
                    var save = function () {
                        dir.getFile(name, create_if_not_found, abortable(function (file) {
                            file.createWriter(abortable(function (writer) {
                                writer.onwriteend = function (event) {
                                    target_view.location.href = file.toURL();
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch(filesaver, 'writeend', event);
                                    revoke(file);
                                };
                                writer.onerror = function () {
                                    var error = writer.error;
                                    if (error.code !== error.ABORT_ERR) {
                                        fs_error();
                                    }
                                };
                                'writestart progress write abort'.split(' ').forEach(function (event) {
                                    writer['on' + event] = filesaver['on' + event];
                                });
                                writer.write(blob);
                                filesaver.abort = function () {
                                    writer.abort();
                                    filesaver.readyState = filesaver.DONE;
                                };
                                filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, { create: false }, abortable(function (file) {
                        file.remove();
                        save();
                    }), abortable(function (ex) {
                        if (ex.code === ex.NOT_FOUND_ERR) {
                            save();
                        } else {
                            fs_error();
                        }
                    }));
                }), fs_error);
            }), fs_error);
        }, FS_proto = FileSaver.prototype, saveAs = function (blob, name, no_auto_bom) {
            return new FileSaver(blob, name, no_auto_bom);
        };
    if (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {
        return function (blob, name, no_auto_bom) {
            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            return navigator.msSaveOrOpenBlob(blob, name || 'download');
        };
    }
    FS_proto.abort = function () {
        var filesaver = this;
        filesaver.readyState = filesaver.DONE;
        dispatch(filesaver, 'abort');
    };
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;
    FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
    return saveAs;
}(typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || this.content);
if (typeof module !== 'undefined' && module.exports) {
    module.exports.saveAs = saveAs;
} else if (typeof define !== 'undefined' && define !== null && define.amd != null) {
    define('browser-filesaver@1.1.0#FileSaver', [], function () {
        return saveAs;
    });
}
/*angular-utils-ui-breadcrumbs@0.2.2#uiBreadcrumbs*/
define('angular-utils-ui-breadcrumbs@0.2.2#uiBreadcrumbs', [
    'module',
    '@loader'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, []);
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/**\n * uiBreadcrumbs automatic breadcrumbs directive for AngularJS & Angular ui-router.\n *\n * https://github.com/michaelbromley/angularUtils/tree/master/src/directives/uiBreadcrumbs\n *\n * Copyright 2014 Michael Bromley <michael@michaelbromley.co.uk>\n */\n\n\n(function() {\n\n    /**\n     * Config\n     */\n    var moduleName = \'angularUtils.directives.uiBreadcrumbs\';\n    var templateUrl = \'directives/uiBreadcrumbs/uiBreadcrumbs.tpl.html\';\n\n    /**\n     * Module\n     */\n    var module;\n    try {\n        module = angular.module(moduleName);\n    } catch(err) {\n        // named module does not exist, so create one\n        module = angular.module(moduleName, [\'ui.router\']);\n    }\n\n    module.directive(\'uiBreadcrumbs\', [\'$interpolate\', \'$state\', \'$injector\', function($interpolate, $state, $injector) {\n            return {\n                restrict: \'E\',\n                templateUrl: function(elem, attrs) {\n                    return attrs.templateUrl || templateUrl;\n                },\n                scope: {\n                    displaynameProperty: \'@\',\n                    abstractProxyProperty: \'@?\'\n                },\n                link: function(scope) {\n                    scope.breadcrumbs = [];\n                    if ($state.$current.name !== \'\') {\n                        updateBreadcrumbsArray();\n                    }\n                    scope.$on(\'$stateChangeSuccess\', function() {\n                        updateBreadcrumbsArray();\n                    });\n\n                    /**\n                     * Start with the current state and traverse up the path to build the\n                     * array of breadcrumbs that can be used in an ng-repeat in the template.\n                     */\n                    function updateBreadcrumbsArray() {\n                        var workingState;\n                        var displayName;\n                        var breadcrumbs = [];\n                        var currentState = $state.$current;\n\n                        while(currentState && currentState.name !== \'\') {\n                            workingState = getWorkingState(currentState);\n                            if (workingState) {\n                                displayName = getDisplayName(workingState);\n\n                                if (displayName !== false && !stateAlreadyInBreadcrumbs(workingState, breadcrumbs)) {\n                                    breadcrumbs.push({\n                                        displayName: displayName,\n                                        route: workingState.name\n                                    });\n                                }\n                            }\n                            currentState = currentState.parent;\n                        }\n                        breadcrumbs.reverse();\n                        scope.breadcrumbs = breadcrumbs;\n                    }\n\n                    /**\n                     * Get the state to put in the breadcrumbs array, taking into account that if the current state is abstract,\n                     * we need to either substitute it with the state named in the `scope.abstractProxyProperty` property, or\n                     * set it to `false` which means this breadcrumb level will be skipped entirely.\n                     * @param currentState\n                     * @returns {*}\n                     */\n                    function getWorkingState(currentState) {\n                        var proxyStateName;\n                        var workingState = currentState;\n                        if (currentState.abstract === true) {\n                            if (typeof scope.abstractProxyProperty !== \'undefined\') {\n                                proxyStateName = getObjectValue(scope.abstractProxyProperty, currentState);\n                                if (proxyStateName) {\n                                    workingState = angular.copy($state.get(proxyStateName));\n                                    if (workingState) {\n                                        workingState.locals = currentState.locals;\n                                    }else{\n                                        if($injector.has("$futureState")){\n                                            var $futureState = $injector.get("$futureState");\n                                            var futureState = angular.copy($futureState.get(proxyStateName));\n                                            workingState = futureState[proxyStateName];\n                                            if(workingState){\n                                                workingState.locals = currentState.locals;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    workingState = false;\n                                }\n                            } else {\n                                workingState = false;\n                            }\n                        }\n                        return workingState;\n                    }\n\n                    /**\n                     * Resolve the displayName of the specified state. Take the property specified by the `displayname-property`\n                     * attribute and look up the corresponding property on the state\'s config object. The specified string can be interpolated against any resolved\n                     * properties on the state config object, by using the usual {{ }} syntax.\n                     * @param currentState\n                     * @returns {*}\n                     */\n                    function getDisplayName(currentState) {\n                        var interpolationContext;\n                        var propertyReference;\n                        var displayName;\n\n                        if (!scope.displaynameProperty) {\n                            // if the displayname-property attribute was not specified, default to the state\'s name\n                            return currentState.name;\n                        }\n                        propertyReference = getObjectValue(scope.displaynameProperty, currentState);\n\n                        if (propertyReference === false) {\n                            return false;\n                        } else if (typeof propertyReference === \'undefined\') {\n                            return currentState.name;\n                        } else {\n                            // use the $interpolate service to handle any bindings in the propertyReference string.\n                            interpolationContext =  (typeof currentState.locals !== \'undefined\') ? currentState.locals.globals : currentState;\n                            displayName = $interpolate(propertyReference)(interpolationContext);\n                            return displayName;\n                        }\n                    }\n\n                    /**\n                     * Given a string of the type \'object.property.property\', traverse the given context (eg the current $state object) and return the\n                     * value found at that path.\n                     *\n                     * @param objectPath\n                     * @param context\n                     * @returns {*}\n                     */\n                    function getObjectValue(objectPath, context) {\n                        var i;\n                        var propertyArray = objectPath.split(\'.\');\n                        var propertyReference = context;\n\n                        for (i = 0; i < propertyArray.length; i ++) {\n                            if (angular.isDefined(propertyReference[propertyArray[i]])) {\n                                propertyReference = propertyReference[propertyArray[i]];\n                            } else {\n                                // if the specified property was not found, default to the state\'s name\n                                return undefined;\n                            }\n                        }\n                        return propertyReference;\n                    }\n\n                    /**\n                     * Check whether the current `state` has already appeared in the current breadcrumbs array. This check is necessary\n                     * when using abstract states that might specify a proxy that is already there in the breadcrumbs.\n                     * @param state\n                     * @param breadcrumbs\n                     * @returns {boolean}\n                     */\n                    function stateAlreadyInBreadcrumbs(state, breadcrumbs) {\n                        var i;\n                        var alreadyUsed = false;\n                        for(i = 0; i < breadcrumbs.length; i++) {\n                            if (breadcrumbs[i].route === state.name) {\n                                alreadyUsed = true;\n                            }\n                        }\n                        return alreadyUsed;\n                    }\n                }\n            };\n        }]);\n})();\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*angular-utils-ui-breadcrumbs@0.2.2#index*/
define('angular-utils-ui-breadcrumbs@0.2.2#index', function (require, exports, module) {
    require('./uiBreadcrumbs');
    module.exports = 'angularUtils.directives.uiBreadcrumbs';
});
/*ui-router-extras@0.1.2#release/ct-ui-router-extras*/
(function (root, factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define('ui-router-extras@0.1.2#release/ct-ui-router-extras', ['angular'], function (angular) {
            factory(angular);
        });
    } else if (typeof exports === 'object') {
        factory(require('angular'));
    } else {
        factory(root.angular);
    }
}(this, function (angular, undefined) {
    var mod_core = angular.module('ct.ui.router.extras.core', ['ui.router']);
    var internalStates = {}, stateRegisteredCallbacks = [];
    mod_core.config([
        '$stateProvider',
        '$injector',
        function ($stateProvider, $injector) {
            $stateProvider.decorator('parent', function (state, parentFn) {
                internalStates[state.self.name] = state;
                state.self.$$state = function () {
                    return internalStates[state.self.name];
                };
                angular.forEach(stateRegisteredCallbacks, function (callback) {
                    callback(state);
                });
                return parentFn(state);
            });
        }
    ]);
    var DEBUG = false;
    var forEach = angular.forEach;
    var extend = angular.extend;
    var isArray = angular.isArray;
    var map = function (collection, callback) {
        'use strict';
        var result = [];
        forEach(collection, function (item, index) {
            result.push(callback(item, index));
        });
        return result;
    };
    var keys = function (collection) {
        'use strict';
        return map(collection, function (collection, key) {
            return key;
        });
    };
    var filter = function (collection, callback) {
        'use strict';
        var result = [];
        forEach(collection, function (item, index) {
            if (callback(item, index)) {
                result.push(item);
            }
        });
        return result;
    };
    var filterObj = function (collection, callback) {
        'use strict';
        var result = {};
        forEach(collection, function (item, index) {
            if (callback(item, index)) {
                result[index] = item;
            }
        });
        return result;
    };
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n])
                break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];
        angular.forEach(object, function (val, key) {
            result.push(key);
        });
        return result;
    }
    function protoKeys(object, ignoreKeys) {
        var result = [];
        for (var key in object) {
            if (!ignoreKeys || ignoreKeys.indexOf(key) === -1)
                result.push(key);
        }
        return result;
    }
    function arraySearch(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
            from += len;
        for (; from < len; from++) {
            if (from in array && array[from] === value)
                return from;
        }
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i].params)
                continue;
            parentParams = isArray(parents[i].params) ? parents[i].params : objectKeys(parents[i].params);
            if (!parentParams.length)
                continue;
            for (var j in parentParams) {
                if (arraySearch(inheritList, parentParams[j]) >= 0)
                    continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }
    function inherit(parent, extra) {
        return extend(new (extend(function () {
        }, { prototype: parent }))(), extra);
    }
    function onStateRegistered(callback) {
        stateRegisteredCallbacks.push(callback);
    }
    mod_core.provider('uirextras_core', function () {
        var core = {
            internalStates: internalStates,
            onStateRegistered: onStateRegistered,
            forEach: forEach,
            extend: extend,
            isArray: isArray,
            map: map,
            keys: keys,
            filter: filter,
            filterObj: filterObj,
            ancestors: ancestors,
            objectKeys: objectKeys,
            protoKeys: protoKeys,
            arraySearch: arraySearch,
            inheritParams: inheritParams,
            inherit: inherit
        };
        angular.extend(this, core);
        this.$get = function () {
            return core;
        };
    });
    var ignoreDsr;
    function resetIgnoreDsr() {
        ignoreDsr = undefined;
    }
    angular.module('ct.ui.router.extras.dsr', ['ct.ui.router.extras.core']).config([
        '$provide',
        function ($provide) {
            var $state_transitionTo;
            $provide.decorator('$state', [
                '$delegate',
                '$q',
                function ($state, $q) {
                    $state_transitionTo = $state.transitionTo;
                    $state.transitionTo = function (to, toParams, options) {
                        if (options.ignoreDsr) {
                            ignoreDsr = options.ignoreDsr;
                        }
                        return $state_transitionTo.apply($state, arguments).then(function (result) {
                            resetIgnoreDsr();
                            return result;
                        }, function (err) {
                            resetIgnoreDsr();
                            return $q.reject(err);
                        });
                    };
                    return $state;
                }
            ]);
        }
    ]);
    angular.module('ct.ui.router.extras.dsr').service('$deepStateRedirect', [
        '$rootScope',
        '$state',
        '$injector',
        function ($rootScope, $state, $injector) {
            var lastSubstate = {};
            var deepStateRedirectsByName = {};
            var REDIRECT = 'Redirect', ANCESTOR_REDIRECT = 'AncestorRedirect';
            function computeDeepStateStatus(state) {
                var name = state.name;
                if (deepStateRedirectsByName.hasOwnProperty(name))
                    return deepStateRedirectsByName[name];
                recordDeepStateRedirectStatus(name);
            }
            function getConfig(state) {
                var declaration = state.deepStateRedirect || state.dsr;
                if (!declaration)
                    return { dsr: false };
                var dsrCfg = { dsr: true };
                if (angular.isFunction(declaration)) {
                    dsrCfg.fn = declaration;
                } else if (angular.isObject(declaration)) {
                    dsrCfg = angular.extend(dsrCfg, declaration);
                }
                if (angular.isString(dsrCfg['default'])) {
                    dsrCfg['default'] = { state: dsrCfg['default'] };
                }
                if (!dsrCfg.fn) {
                    dsrCfg.fn = [
                        '$dsr$',
                        function ($dsr$) {
                            return $dsr$.redirect.state != $dsr$.to.state;
                        }
                    ];
                }
                return dsrCfg;
            }
            function recordDeepStateRedirectStatus(stateName) {
                var state = $state.get(stateName);
                if (!state)
                    return false;
                var cfg = getConfig(state);
                if (cfg.dsr) {
                    deepStateRedirectsByName[state.name] = REDIRECT;
                    if (lastSubstate[stateName] === undefined)
                        lastSubstate[stateName] = {};
                }
                var parent = state.$$state && state.$$state().parent;
                if (parent) {
                    var parentStatus = recordDeepStateRedirectStatus(parent.self.name);
                    if (parentStatus && deepStateRedirectsByName[state.name] === undefined) {
                        deepStateRedirectsByName[state.name] = ANCESTOR_REDIRECT;
                    }
                }
                return deepStateRedirectsByName[state.name] || false;
            }
            function getMatchParams(params, dsrParams) {
                if (dsrParams === true)
                    dsrParams = Object.keys(params);
                if (dsrParams === null || dsrParams === undefined)
                    dsrParams = [];
                var matchParams = {};
                angular.forEach(dsrParams.sort(), function (name) {
                    matchParams[name] = params[name];
                });
                return matchParams;
            }
            function getParamsString(params, dsrParams) {
                var matchParams = getMatchParams(params, dsrParams);
                function safeString(input) {
                    return !input ? input : input.toString();
                }
                var paramsToString = {};
                angular.forEach(matchParams, function (val, name) {
                    paramsToString[name] = safeString(val);
                });
                return angular.toJson(paramsToString);
            }
            $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {
                var cfg = getConfig(toState);
                if (ignoreDsr || computeDeepStateStatus(toState) !== REDIRECT && !cfg['default'])
                    return;
                var key = getParamsString(toParams, cfg.params);
                var redirect = lastSubstate[toState.name][key] || cfg['default'];
                if (!redirect)
                    return;
                var $dsr$ = {
                    redirect: {
                        state: redirect.state,
                        params: redirect.params
                    },
                    to: {
                        state: toState.name,
                        params: toParams
                    }
                };
                var result = $injector.invoke(cfg.fn, toState, { $dsr$: $dsr$ });
                if (!result)
                    return;
                if (result.state)
                    redirect = result;
                event.preventDefault();
                var redirectParams = getMatchParams(toParams, cfg.params);
                $state.go(redirect.state, angular.extend(redirectParams, redirect.params));
            });
            $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
                var deepStateStatus = computeDeepStateStatus(toState);
                if (deepStateStatus) {
                    var name = toState.name;
                    angular.forEach(lastSubstate, function (redirect, dsrState) {
                        var cfg = getConfig($state.get(dsrState));
                        var key = getParamsString(toParams, cfg.params);
                        if (toState.$$state().includes[dsrState]) {
                            lastSubstate[dsrState][key] = {
                                state: name,
                                params: angular.copy(toParams)
                            };
                        }
                    });
                }
            });
            return {
                getRedirect: function (dsrState, params) {
                    var state = $state.get(dsrState);
                    computeDeepStateStatus(state);
                    var cfg = getConfig(state);
                    var key = getParamsString(params, cfg.params);
                    var redirect = lastSubstate[state.name][key] || cfg['default'];
                    return redirect;
                },
                reset: function (stateOrName, params) {
                    if (!stateOrName) {
                        angular.forEach(lastSubstate, function (redirect, dsrState) {
                            lastSubstate[dsrState] = {};
                        });
                    } else {
                        var state = $state.get(stateOrName);
                        if (!state)
                            throw new Error('Unknown state: ' + stateOrName);
                        if (lastSubstate[state.name]) {
                            if (params) {
                                var key = getParamsString(params, getConfig(state).params);
                                delete lastSubstate[state.name][key];
                            } else {
                                lastSubstate[state.name] = {};
                            }
                        }
                    }
                }
            };
        }
    ]);
    angular.module('ct.ui.router.extras.dsr').run([
        '$deepStateRedirect',
        function ($deepStateRedirect) {
        }
    ]);
    angular.module('ct.ui.router.extras.sticky', ['ct.ui.router.extras.core']);
    var mod_sticky = angular.module('ct.ui.router.extras.sticky');
    $StickyStateProvider.$inject = [
        '$stateProvider',
        'uirextras_coreProvider'
    ];
    function $StickyStateProvider($stateProvider, uirextras_coreProvider) {
        var core = uirextras_coreProvider;
        var inheritParams = core.inheritParams;
        var objectKeys = core.objectKeys;
        var protoKeys = core.protoKeys;
        var forEach = core.forEach;
        var map = core.map;
        var inactiveStates = {};
        var stickyStates = {};
        var $state;
        var DEBUG = false;
        this.registerStickyState = function (state) {
            stickyStates[state.name] = state;
        };
        this.enableDebug = this.debugMode = function (enabled) {
            if (angular.isDefined(enabled))
                DEBUG = enabled;
            return DEBUG;
        };
        this.$get = [
            '$rootScope',
            '$state',
            '$stateParams',
            '$injector',
            '$log',
            function ($rootScope, $state, $stateParams, $injector, $log) {
                function mapInactives() {
                    var mappedStates = {};
                    angular.forEach(inactiveStates, function (state, name) {
                        var stickyAncestors = getStickyStateStack(state);
                        for (var i = 0; i < stickyAncestors.length; i++) {
                            var parent = stickyAncestors[i].parent;
                            mappedStates[parent.name] = mappedStates[parent.name] || [];
                            mappedStates[parent.name].push(state);
                        }
                        if (mappedStates['']) {
                            mappedStates['__inactives'] = mappedStates[''];
                        }
                    });
                    return mappedStates;
                }
                function mapInactivesByImmediateParent() {
                    var inactivesByAllParents = {};
                    forEach(inactiveStates, function (state) {
                        forEach(state.path, function (ancestor) {
                            if (ancestor === state)
                                return;
                            inactivesByAllParents[ancestor.name] = inactivesByAllParents[ancestor.name] || [];
                            inactivesByAllParents[ancestor.name].push(state);
                        });
                    });
                    return inactivesByAllParents;
                }
                function getStickyStateStack(state) {
                    var stack = [];
                    if (!state)
                        return stack;
                    do {
                        if (state.sticky)
                            stack.push(state);
                        state = state.parent;
                    } while (state);
                    stack.reverse();
                    return stack;
                }
                function getEnterTransition(state, stateParams, reloadStateTree, ancestorReloaded) {
                    if (ancestorReloaded)
                        return 'reload';
                    var inactiveState = inactiveStates[state.self.name];
                    if (!inactiveState)
                        return 'enter';
                    if (state.self === reloadStateTree)
                        return 'reload';
                    var paramsMatch = paramsEqualForState(state.ownParams, stateParams, inactiveState.locals.globals.$stateParams);
                    return paramsMatch ? 'reactivate' : 'reload';
                }
                function getInactivatedState(state, stateParams) {
                    var inactiveState = inactiveStates[state.name];
                    if (!inactiveState)
                        return null;
                    if (!stateParams)
                        return inactiveState;
                    var paramsMatch = paramsEqualForState(state.ownParams, stateParams, inactiveState.locals.globals.$stateParams);
                    return paramsMatch ? inactiveState : null;
                }
                function paramsEqualForState(ownParams, stateParams, stateParams2) {
                    if (typeof ownParams.$$equals === 'function')
                        return ownParams.$$equals(stateParams, stateParams2);
                    return equalForKeys(stateParams, stateParams2, ownParams);
                }
                function equalForKeys(a, b, keys) {
                    if (!angular.isArray(keys) && angular.isObject(keys)) {
                        keys = protoKeys(keys, [
                            '$$keys',
                            '$$values',
                            '$$equals',
                            '$$validates',
                            '$$new',
                            '$$parent'
                        ]);
                    }
                    if (!keys) {
                        keys = [];
                        for (var n in a)
                            keys.push(n);
                    }
                    for (var i = 0; i < keys.length; i++) {
                        var k = keys[i];
                        if (a[k] != b[k])
                            return false;
                    }
                    return true;
                }
                function calcTreeChanges(transition) {
                    var fromPath = transition.fromState.path;
                    var toPath = transition.toState.path;
                    var toParams = transition.toParams;
                    var keep = 0, state = toPath[keep];
                    if (transition.options && transition.options.inherit) {
                        toParams = transition.toParams = inheritParams($stateParams, toParams || {}, $state.$current, transition.toState);
                    }
                    while (state && state === fromPath[keep] && paramsEqualForState(state.ownParams, toParams, transition.fromParams)) {
                        state = toPath[++keep];
                    }
                    return {
                        keep: keep,
                        retained: fromPath.slice(0, keep),
                        exiting: fromPath.slice(keep),
                        entering: toPath.slice(keep)
                    };
                }
                var stickySupport = {
                    getInactiveStates: function () {
                        return map(inactiveStates, angular.identity);
                    },
                    getInactiveStatesByParent: function () {
                        return mapInactives();
                    },
                    processTransition: function (transition) {
                        var treeChanges = calcTreeChanges(transition);
                        var currentInactives = map(inactiveStates, angular.identity);
                        var futureInactives, exitingTypes, enteringTypes;
                        var keep = treeChanges.keep;
                        function notIn(array) {
                            return function (elem) {
                                return array.indexOf(elem) === -1;
                            };
                        }
                        function flattenReduce(memo, list) {
                            return memo.concat(list);
                        }
                        function uniqReduce(memo, orphan) {
                            if (notIn(memo)(orphan))
                                memo.push(orphan);
                            return memo;
                        }
                        function prop(attr) {
                            return function (obj) {
                                return obj[attr];
                            };
                        }
                        function typeIs(type) {
                            return function (obj) {
                                return obj.type === type;
                            };
                        }
                        function isChildOf(state) {
                            return function (other) {
                                return other.parent === state;
                            };
                        }
                        var notEntering = notIn(treeChanges.entering);
                        function notSticky(state) {
                            return !state.sticky;
                        }
                        var shouldInactivate = treeChanges.exiting[0] && treeChanges.exiting[0].sticky && treeChanges.entering.length > 0;
                        exitingTypes = treeChanges.exiting.map(function (state) {
                            var stateRentering = treeChanges.entering.indexOf(state) !== -1;
                            var type = shouldInactivate && !stateRentering ? 'inactivate' : 'exit';
                            return {
                                type: type,
                                state: state
                            };
                        });
                        var reloaded = transition.options && !!transition.options.reload;
                        enteringTypes = treeChanges.entering.map(function (state) {
                            var type = getEnterTransition(state, transition.toParams, transition.reloadStateTree, reloaded);
                            reloaded = reloaded || type === 'reload';
                            return {
                                type: type,
                                state: state
                            };
                        });
                        var orphanedRoots = treeChanges.entering.map(function (entering) {
                            return currentInactives.filter(isChildOf(entering.parent));
                        }).reduce(flattenReduce, []).filter(notEntering).filter(notSticky).concat(currentInactives.filter(isChildOf(transition.toState)));
                        var currentInactivesByParent = mapInactivesByImmediateParent();
                        var allOrphans = orphanedRoots.map(function (root) {
                            return currentInactivesByParent[root.name];
                        }).filter(angular.isDefined).reduce(flattenReduce, []).concat(orphanedRoots).sort(function (a, b) {
                            return a.name.split('.').length - b.name.split('.').length;
                        });
                        var exitOrOrphaned = exitingTypes.filter(typeIs('exit')).map(prop('state')).concat(allOrphans);
                        futureInactives = currentInactives.filter(notIn(exitOrOrphaned)).filter(notIn(treeChanges.entering)).concat(exitingTypes.filter(typeIs('inactivate')).map(prop('state')));
                        return {
                            keep: keep,
                            enter: new Array(keep).concat(enteringTypes.map(prop('type'))),
                            exit: new Array(keep).concat(exitingTypes.map(prop('type'))),
                            inactives: futureInactives,
                            reactivatingStates: enteringTypes.filter(typeIs('reactivate')).map(prop('state')),
                            orphans: allOrphans
                        };
                    },
                    stateInactivated: function (state) {
                        inactiveStates[state.self.name] = state;
                        state.self.status = 'inactive';
                        if (state.self.onInactivate)
                            $injector.invoke(state.self.onInactivate, state.self, state.locals.globals);
                    },
                    stateReactivated: function (state) {
                        if (inactiveStates[state.self.name]) {
                            delete inactiveStates[state.self.name];
                        }
                        state.self.status = 'entered';
                        if (state.self.onReactivate)
                            $injector.invoke(state.self.onReactivate, state.self, state.locals.globals);
                    },
                    stateExiting: function (exiting, exitQueue, onExit) {
                        var exitingNames = {};
                        angular.forEach(exitQueue, function (state) {
                            exitingNames[state.self.name] = true;
                        });
                        angular.forEach(inactiveStates, function (inactiveExiting, name) {
                            if (!exitingNames[name] && inactiveExiting.includes[exiting.name]) {
                                if (DEBUG)
                                    $log.debug('Exiting ' + name + ' because it\'s a substate of ' + exiting.name + ' and wasn\'t found in ', exitingNames);
                                if (inactiveExiting.self.onExit)
                                    $injector.invoke(inactiveExiting.self.onExit, inactiveExiting.self, inactiveExiting.locals.globals);
                                angular.forEach(inactiveExiting.locals, function (localval, key) {
                                    delete inactivePseudoState.locals[key];
                                });
                                inactiveExiting.locals = null;
                                inactiveExiting.self.status = 'exited';
                                delete inactiveStates[name];
                            }
                        });
                        if (onExit)
                            $injector.invoke(onExit, exiting.self, exiting.locals.globals);
                        exiting.locals = null;
                        exiting.self.status = 'exited';
                        delete inactiveStates[exiting.self.name];
                    },
                    stateEntering: function (entering, params, onEnter, updateParams) {
                        var inactivatedState = getInactivatedState(entering);
                        if (inactivatedState && (updateParams || !getInactivatedState(entering, params))) {
                            var savedLocals = entering.locals;
                            this.stateExiting(inactivatedState);
                            entering.locals = savedLocals;
                        }
                        entering.self.status = 'entered';
                        if (onEnter)
                            $injector.invoke(onEnter, entering.self, entering.locals.globals);
                    },
                    reset: function reset(inactiveState, params) {
                        function resetOne(state) {
                            stickySupport.reset(state);
                        }
                        if (inactiveState === '*') {
                            angular.forEach(stickySupport.getInactiveStates(), resetOne);
                            return true;
                        }
                        var state = $state.get(inactiveState);
                        if (!state)
                            return false;
                        var exiting = getInactivatedState(state, params);
                        if (!exiting)
                            return false;
                        stickySupport.stateExiting(exiting);
                        $rootScope.$broadcast('$viewContentLoading');
                        return true;
                    }
                };
                return stickySupport;
            }
        ];
    }
    mod_sticky.provider('$stickyState', $StickyStateProvider);
    var _StickyState;
    var internalStates = {};
    var root, pendingTransitions = [], pendingRestore, inactivePseudoState, reactivatingLocals = {}, versionHeuristics = { hasParamSet: false };
    function SurrogateState(type) {
        return {
            resolve: {},
            locals: { globals: root && root.locals && root.locals.globals },
            views: {},
            self: {},
            params: {},
            ownParams: versionHeuristics.hasParamSet ? {
                $$equals: function () {
                    return true;
                }
            } : [],
            surrogateType: type
        };
    }
    angular.module('ct.ui.router.extras.sticky').run([
        '$stickyState',
        function ($stickyState) {
            _StickyState = $stickyState;
        }
    ]);
    angular.module('ct.ui.router.extras.sticky').config([
        '$provide',
        '$stateProvider',
        '$stickyStateProvider',
        '$urlMatcherFactoryProvider',
        'uirextras_coreProvider',
        function ($provide, $stateProvider, $stickyStateProvider, $urlMatcherFactoryProvider, uirextras_coreProvider) {
            var core = uirextras_coreProvider;
            var internalStates = core.internalStates;
            var inherit = core.inherit;
            var inheritParams = core.inheritParams;
            var forEach = core.forEach;
            var map = core.map;
            var filterObj = core.filterObj;
            versionHeuristics.hasParamSet = !!$urlMatcherFactoryProvider.ParamSet;
            inactivePseudoState = angular.extend(new SurrogateState('__inactives'), { self: { name: '__inactives' } });
            root = pendingRestore = undefined;
            pendingTransitions = [];
            uirextras_coreProvider.onStateRegistered(function (state) {
                if (state.self.sticky === true) {
                    $stickyStateProvider.registerStickyState(state.self);
                }
            });
            var $state_transitionTo;
            $provide.decorator('$state', [
                '$delegate',
                '$log',
                '$q',
                function ($state, $log, $q) {
                    root = $state.$current;
                    internalStates[''] = root;
                    root.parent = inactivePseudoState;
                    inactivePseudoState.parent = undefined;
                    inactivePseudoState.locals = inherit(reactivatingLocals, inactivePseudoState.locals);
                    root.locals = inherit(inactivePseudoState.locals, root.locals);
                    delete inactivePseudoState.locals.globals;
                    $state_transitionTo = $state.transitionTo;
                    $state.transitionTo = function (to, toParams, options) {
                        var DEBUG = $stickyStateProvider.debugMode();
                        if (!inactivePseudoState.locals)
                            inactivePseudoState.locals = root.locals;
                        var idx = pendingTransitions.length;
                        if (pendingRestore) {
                            pendingRestore();
                            if (DEBUG) {
                                $log.debug('Restored paths from pending transition');
                            }
                        }
                        var fromState = $state.$current, fromParams = $state.params;
                        var rel = options && options.relative || $state.$current;
                        var toStateSelf = $state.get(to, rel);
                        var savedToStatePath, savedFromStatePath, stickyTransitions;
                        var reactivated = [], exited = [], terminalReactivatedState;
                        toParams = toParams || {};
                        arguments[1] = toParams;
                        var noop = function () {
                        };
                        var restore = function () {
                            if (savedToStatePath) {
                                toState.path = savedToStatePath;
                                savedToStatePath = null;
                            }
                            if (savedFromStatePath) {
                                fromState.path = savedFromStatePath;
                                savedFromStatePath = null;
                            }
                            angular.forEach(restore.restoreFunctions, function (restoreFunction) {
                                restoreFunction();
                            });
                            restore = noop;
                            pendingRestore = null;
                            pendingTransitions.splice(idx, 1);
                        };
                        restore.restoreFunctions = [];
                        restore.addRestoreFunction = function addRestoreFunction(fn) {
                            this.restoreFunctions.push(fn);
                        };
                        function stateReactivatedSurrogatePhase1(state) {
                            var surrogate = angular.extend(new SurrogateState('reactivate_phase1'), { locals: state.locals });
                            surrogate.self = angular.extend({}, state.self);
                            return surrogate;
                        }
                        function stateReactivatedSurrogatePhase2(state) {
                            var surrogate = angular.extend(new SurrogateState('reactivate_phase2'), state);
                            var oldOnEnter = surrogate.self.onEnter;
                            surrogate.resolve = {};
                            surrogate.views = {};
                            surrogate.self.onEnter = function () {
                                surrogate.locals = state.locals;
                                _StickyState.stateReactivated(state);
                            };
                            restore.addRestoreFunction(function () {
                                state.self.onEnter = oldOnEnter;
                            });
                            return surrogate;
                        }
                        function stateInactivatedSurrogate(state) {
                            var surrogate = new SurrogateState('inactivate');
                            surrogate.self = state.self;
                            var oldOnExit = state.self.onExit;
                            surrogate.self.onExit = function () {
                                _StickyState.stateInactivated(state);
                            };
                            restore.addRestoreFunction(function () {
                                state.self.onExit = oldOnExit;
                            });
                            return surrogate;
                        }
                        function stateEnteredSurrogate(state, toParams) {
                            var oldOnEnter = state.self.onEnter;
                            state.self.onEnter = function () {
                                _StickyState.stateEntering(state, toParams, oldOnEnter);
                            };
                            restore.addRestoreFunction(function () {
                                state.self.onEnter = oldOnEnter;
                            });
                            return state;
                        }
                        function stateUpdateParamsSurrogate(state, toParams) {
                            var oldOnEnter = state.self.onEnter;
                            state.self.onEnter = function () {
                                _StickyState.stateEntering(state, toParams, oldOnEnter, true);
                            };
                            restore.addRestoreFunction(function () {
                                state.self.onEnter = oldOnEnter;
                            });
                            return state;
                        }
                        function stateExitedSurrogate(state) {
                            var oldOnExit = state.self.onExit;
                            state.self.onExit = function () {
                                _StickyState.stateExiting(state, exited, oldOnExit);
                            };
                            restore.addRestoreFunction(function () {
                                state.self.onExit = oldOnExit;
                            });
                            return state;
                        }
                        if (toStateSelf) {
                            var toState = internalStates[toStateSelf.name];
                            if (toState) {
                                savedToStatePath = toState.path;
                                savedFromStatePath = fromState.path;
                                var reload = options && options.reload || false;
                                var reloadStateTree = reload && (reload === true ? savedToStatePath[0].self : $state.get(reload, rel));
                                if (options && reload && reload !== true)
                                    delete options.reload;
                                var currentTransition = {
                                    toState: toState,
                                    toParams: toParams || {},
                                    fromState: fromState,
                                    fromParams: fromParams || {},
                                    options: options,
                                    reloadStateTree: reloadStateTree
                                };
                                pendingTransitions.push(currentTransition);
                                pendingRestore = restore;
                                if (reloadStateTree) {
                                    currentTransition.toParams.$$uirouterextrasreload = Math.random();
                                    var params = reloadStateTree.$$state().params;
                                    var ownParams = reloadStateTree.$$state().ownParams;
                                    if (versionHeuristics.hasParamSet) {
                                        var tempParam = new $urlMatcherFactoryProvider.Param('$$uirouterextrasreload');
                                        params.$$uirouterextrasreload = ownParams.$$uirouterextrasreload = tempParam;
                                        restore.restoreFunctions.push(function () {
                                            delete params.$$uirouterextrasreload;
                                            delete ownParams.$$uirouterextrasreload;
                                        });
                                    } else {
                                        params.push('$$uirouterextrasreload');
                                        ownParams.push('$$uirouterextrasreload');
                                        restore.restoreFunctions.push(function () {
                                            params.length = params.length - 1;
                                            ownParams.length = ownParams.length - 1;
                                        });
                                    }
                                }
                                stickyTransitions = _StickyState.processTransition(currentTransition);
                                if (DEBUG)
                                    debugTransition($log, currentTransition, stickyTransitions);
                                var surrogateToPath = toState.path.slice(0, stickyTransitions.keep);
                                var surrogateFromPath = fromState.path.slice(0, stickyTransitions.keep);
                                angular.forEach(inactivePseudoState.locals, function (local, name) {
                                    if (name.indexOf('@') != -1)
                                        delete inactivePseudoState.locals[name];
                                });
                                var saveViewsToLocals = function (targetObj) {
                                    return function (view, name) {
                                        if (name.indexOf('@') !== -1) {
                                            targetObj[name] = view;
                                        }
                                    };
                                };
                                forEach(stickyTransitions.inactives, function (state) {
                                    forEach(state.locals, saveViewsToLocals(inactivePseudoState.locals));
                                });
                                forEach(stickyTransitions.reactivatingStates, function (state) {
                                    forEach(state.locals, saveViewsToLocals(reactivatingLocals));
                                });
                                restore.addRestoreFunction(function clearReactivatingLocals() {
                                    forEach(reactivatingLocals, function (val, viewname) {
                                        delete reactivatingLocals[viewname];
                                    });
                                });
                                angular.forEach(stickyTransitions.enter, function (value, idx) {
                                    var surrogate;
                                    var enteringState = toState.path[idx];
                                    if (value === 'reactivate') {
                                        surrogate = stateReactivatedSurrogatePhase1(enteringState);
                                        surrogateToPath.push(surrogate);
                                        surrogateFromPath.push(surrogate);
                                        reactivated.push(stateReactivatedSurrogatePhase2(enteringState));
                                        terminalReactivatedState = enteringState;
                                    } else if (value === 'reload') {
                                        surrogateToPath.push(stateUpdateParamsSurrogate(enteringState));
                                        terminalReactivatedState = enteringState;
                                    } else if (value === 'enter') {
                                        surrogateToPath.push(stateEnteredSurrogate(enteringState));
                                    }
                                });
                                angular.forEach(stickyTransitions.exit, function (value, idx) {
                                    var exiting = fromState.path[idx];
                                    if (value === 'inactivate') {
                                        surrogateFromPath.push(stateInactivatedSurrogate(exiting));
                                        exited.push(exiting);
                                    } else if (value === 'exit') {
                                        surrogateFromPath.push(stateExitedSurrogate(exiting));
                                        exited.push(exiting);
                                    }
                                });
                                if (reactivated.length) {
                                    angular.forEach(reactivated, function (surrogate) {
                                        surrogateToPath.push(surrogate);
                                    });
                                }
                                var orphans = stickyTransitions.orphans;
                                surrogateFromPath = surrogateFromPath.concat(map(orphans, function (exiting) {
                                    return stateExitedSurrogate(exiting);
                                }));
                                exited = exited.concat(orphans);
                                fromState.path = surrogateFromPath;
                                toState.path = surrogateToPath;
                                var pathMessage = function (state) {
                                    return (state.surrogateType ? state.surrogateType + ':' : '') + state.self.name;
                                };
                                if (DEBUG)
                                    $log.debug('SurrogateFromPath: ', map(surrogateFromPath, pathMessage));
                                if (DEBUG)
                                    $log.debug('SurrogateToPath:   ', map(surrogateToPath, pathMessage));
                            }
                        }
                        var transitionPromise = $state_transitionTo.apply($state, arguments);
                        return transitionPromise.then(function transitionSuccess(state) {
                            restore();
                            if (DEBUG)
                                debugViewsAfterSuccess($log, internalStates[state.name], $state);
                            state.status = 'active';
                            return state;
                        }, function transitionFailed(err) {
                            restore();
                            if (DEBUG && err.message !== 'transition prevented' && err.message !== 'transition aborted' && err.message !== 'transition superseded') {
                                $log.debug('transition failed', err);
                                $log.debug(err.stack);
                            }
                            return $q.reject(err);
                        });
                    };
                    return $state;
                }
            ]);
            function debugTransition($log, currentTransition, stickyTransition) {
                function message(path, index, state) {
                    return path[index] ? path[index].toUpperCase() + ': ' + state.self.name : '(' + state.self.name + ')';
                }
                var inactiveLogVar = map(stickyTransition.inactives, function (state) {
                    return state.self.name;
                });
                var enterLogVar = map(currentTransition.toState.path, function (state, index) {
                    return message(stickyTransition.enter, index, state);
                });
                var exitLogVar = map(currentTransition.fromState.path, function (state, index) {
                    return message(stickyTransition.exit, index, state);
                });
                var transitionMessage = currentTransition.fromState.self.name + ': ' + angular.toJson(currentTransition.fromParams) + ': ' + ' -> ' + currentTransition.toState.self.name + ': ' + angular.toJson(currentTransition.toParams);
                $log.debug('------------------------------------------------------');
                $log.debug('   Current transition: ', transitionMessage);
                $log.debug('Before transition, inactives are:   : ', map(_StickyState.getInactiveStates(), function (s) {
                    return s.self.name;
                }));
                $log.debug('After transition,  inactives will be: ', inactiveLogVar);
                $log.debug('Transition will exit:  ', exitLogVar);
                $log.debug('Transition will enter: ', enterLogVar);
            }
            function debugViewsAfterSuccess($log, currentState, $state) {
                $log.debug('Current state: ' + currentState.self.name + ', inactive states: ', map(_StickyState.getInactiveStates(), function (s) {
                    return s.self.name;
                }));
                var viewMsg = function (local, name) {
                    return '\'' + name + '\' (' + local.$$state.name + ')';
                };
                var statesOnly = function (local, name) {
                    return name != 'globals' && name != 'resolve';
                };
                var viewsForState = function (state) {
                    var views = map(filterObj(state.locals, statesOnly), viewMsg).join(', ');
                    return '(' + (state.self.name ? state.self.name : 'root') + '.locals' + (views.length ? ': ' + views : '') + ')';
                };
                var message = viewsForState(currentState);
                var parent = currentState.parent;
                while (parent && parent !== currentState) {
                    if (parent.self.name === '') {
                        message = viewsForState($state.$current.path[0]) + ' / ' + message;
                    }
                    message = viewsForState(parent) + ' / ' + message;
                    currentState = parent;
                    parent = currentState.parent;
                }
                $log.debug('Views: ' + message);
            }
        }
    ]);
    (function (angular, undefined) {
        var app = angular.module('ct.ui.router.extras.future', ['ct.ui.router.extras.core']);
        _futureStateProvider.$inject = [
            '$stateProvider',
            '$urlRouterProvider',
            '$urlMatcherFactoryProvider',
            'uirextras_coreProvider'
        ];
        function _futureStateProvider($stateProvider, $urlRouterProvider, $urlMatcherFactory, uirextras_coreProvider) {
            var core = uirextras_coreProvider;
            var internalStates = core.internalStates;
            var stateFactories = {}, futureStates = {};
            var lazyloadInProgress = false, resolveFunctions = [], initPromise, initDone = false;
            var provider = this;
            this.addResolve = function (promiseFn) {
                resolveFunctions.push(promiseFn);
            };
            this.stateFactory = function (futureStateType, factory) {
                stateFactories[futureStateType] = factory;
            };
            this.futureState = function (futureState) {
                if (futureState.stateName)
                    futureState.name = futureState.stateName;
                if (futureState.urlPrefix)
                    futureState.url = '^' + futureState.urlPrefix;
                futureStates[futureState.name] = futureState;
                var parentMatcher, parentName = futureState.name.split(/\./).slice(0, -1).join('.'), realParent = findState(futureState.parent || parentName);
                if (realParent) {
                    parentMatcher = realParent.url || realParent.navigable && realParent.navigable.url;
                } else if (parentName === '') {
                    parentMatcher = $urlMatcherFactory.compile('');
                } else {
                    var futureParent = findState(futureState.parent || parentName, true);
                    if (!futureParent)
                        throw new Error('Couldn\'t determine parent state of future state. FutureState:' + angular.toJson(futureState));
                    var pattern;
                    if (futureParent.urlMatcher) {
                        pattern = futureParent.urlMatcher.source.replace(/\*rest$/, '');
                    } else {
                        pattern = '';
                    }
                    parentMatcher = $urlMatcherFactory.compile(pattern);
                    futureState.parentFutureState = futureParent;
                }
                if (futureState.url) {
                    futureState.urlMatcher = futureState.url.charAt(0) === '^' ? $urlMatcherFactory.compile(futureState.url.substring(1) + '*rest') : parentMatcher.concat(futureState.url + '*rest');
                }
            };
            this.get = function () {
                return angular.extend({}, futureStates);
            };
            function findState(stateOrName, findFutureState) {
                var statename = angular.isObject(stateOrName) ? stateOrName.name : stateOrName;
                return !findFutureState ? internalStates[statename] : futureStates[statename];
            }
            function findFutureState($state, options) {
                if (options.name) {
                    var nameComponents = options.name.split(/\./);
                    if (options.name.charAt(0) === '.')
                        nameComponents[0] = $state.current.name;
                    while (nameComponents.length) {
                        var stateName = nameComponents.join('.');
                        if ($state.get(stateName, { relative: $state.current }))
                            return null;
                        if (futureStates[stateName])
                            return futureStates[stateName];
                        nameComponents.pop();
                    }
                }
                if (options.url) {
                    var matches = [];
                    for (var future in futureStates) {
                        var matcher = futureStates[future].urlMatcher;
                        if (matcher && matcher.exec(options.url)) {
                            matches.push(futureStates[future]);
                        }
                    }
                    var copy = matches.slice(0);
                    for (var i = matches.length - 1; i >= 0; i--) {
                        for (var j = 0; j < copy.length; j++) {
                            if (matches[i] === copy[j].parentFutureState)
                                matches.splice(i, 1);
                        }
                    }
                    return matches[0];
                }
            }
            function lazyLoadState($injector, futureState) {
                lazyloadInProgress = true;
                var $q = $injector.get('$q');
                if (!futureState) {
                    var deferred = $q.defer();
                    deferred.reject('No lazyState passed in ' + futureState);
                    return deferred.promise;
                }
                var parentPromises = $q.when([]), parentFuture = futureState.parentFutureState;
                if (parentFuture && futureStates[parentFuture.name]) {
                    parentPromises = lazyLoadState($injector, futureStates[parentFuture.name]);
                }
                var type = futureState.type;
                var factory = stateFactories[type];
                if (!factory)
                    throw Error('No state factory for futureState.type: ' + (futureState && futureState.type));
                var failedLoadPolicy = factory.$options && factory.$options.failedLazyLoadPolicy || 'remove';
                function deregisterFutureState() {
                    delete futureStates[futureState.name];
                }
                function errorHandler(err) {
                    if (failedLoadPolicy === 'remove')
                        deregisterFutureState();
                    return $q.reject(err);
                }
                return parentPromises.then(function (array) {
                    var factoryPromise = $injector.invoke(factory, factory, { futureState: futureState });
                    return factoryPromise.then(function (fullState) {
                        deregisterFutureState();
                        if (fullState) {
                            array.push(fullState);
                        }
                        return array;
                    });
                }).catch(errorHandler);
            }
            var otherwiseFunc = [
                '$log',
                '$location',
                function otherwiseFunc($log, $location) {
                }
            ];
            function futureState_otherwise($injector, $location) {
                var resyncing = false;
                var lazyLoadMissingState = [
                    '$rootScope',
                    '$urlRouter',
                    '$state',
                    function lazyLoadMissingState($rootScope, $urlRouter, $state) {
                        function resync() {
                            resyncing = true;
                            $urlRouter.sync();
                            resyncing = false;
                        }
                        if (!initDone) {
                            initPromise().then(resync);
                            initDone = true;
                            return;
                        }
                        var futureState = findFutureState($state, { url: $location.path() });
                        if (!futureState) {
                            return $injector.invoke(otherwiseFunc);
                        }
                        lazyLoadState($injector, futureState).then(function lazyLoadedStateCallback(states) {
                            states.forEach(function (state) {
                                if (state && (!$state.get(state) || state.name && !$state.get(state.name)))
                                    $stateProvider.state(state);
                            });
                            lazyloadInProgress = false;
                            resync();
                        }, function lazyLoadStateAborted() {
                            lazyloadInProgress = false;
                            resync();
                        });
                    }
                ];
                if (lazyloadInProgress)
                    return;
                var nextFn = resyncing ? otherwiseFunc : lazyLoadMissingState;
                return $injector.invoke(nextFn);
            }
            $urlRouterProvider.otherwise(futureState_otherwise);
            $urlRouterProvider.otherwise = function (rule) {
                if (angular.isString(rule)) {
                    var redirect = rule;
                    rule = function () {
                        return redirect;
                    };
                } else if (!angular.isFunction(rule))
                    throw new Error('\'rule\' must be a function');
                otherwiseFunc = [
                    '$injector',
                    '$location',
                    rule
                ];
                return $urlRouterProvider;
            };
            var serviceObject = {
                getResolvePromise: function () {
                    return initPromise();
                }
            };
            this.$get = [
                '$injector',
                '$state',
                '$q',
                '$rootScope',
                '$urlRouter',
                '$timeout',
                '$log',
                function futureStateProvider_get($injector, $state, $q, $rootScope, $urlRouter, $timeout, $log) {
                    function init() {
                        $rootScope.$on('$stateNotFound', function futureState_notFound(event, unfoundState, fromState, fromParams) {
                            if (lazyloadInProgress)
                                return;
                            var futureState = findFutureState($state, { name: unfoundState.to });
                            if (!futureState)
                                return;
                            event.preventDefault();
                            var promise = lazyLoadState($injector, futureState);
                            promise.then(function (states) {
                                states.forEach(function (state) {
                                    if (state && (!$state.get(state) || state.name && !$state.get(state.name)))
                                        $stateProvider.state(state);
                                });
                                $state.go(unfoundState.to, unfoundState.toParams, unfoundState.options);
                                lazyloadInProgress = false;
                            }, function (error) {
                                console.log('failed to lazy load state ', error);
                                if (fromState.name)
                                    $state.go(fromState, fromParams);
                                lazyloadInProgress = false;
                            });
                        });
                        if (!initPromise) {
                            var promises = [];
                            angular.forEach(resolveFunctions, function (promiseFn) {
                                promises.push($injector.invoke(promiseFn));
                            });
                            initPromise = function () {
                                return $q.all(promises);
                            };
                        }
                        initPromise().then(function retryInitialState() {
                            $timeout(function () {
                                if ($state.transition) {
                                    $state.transition.then(retryInitialState, retryInitialState);
                                } else {
                                    $urlRouter.sync();
                                }
                            });
                        });
                    }
                    init();
                    serviceObject.state = $stateProvider.state;
                    serviceObject.futureState = provider.futureState;
                    serviceObject.get = provider.get;
                    return serviceObject;
                }
            ];
        }
        app.provider('$futureState', _futureStateProvider);
        var statesAddedQueue = {
            state: function (state) {
                if (statesAddedQueue.$rootScope)
                    statesAddedQueue.$rootScope.$broadcast('$stateAdded', state);
            },
            itsNowRuntimeOhWhatAHappyDay: function ($rootScope) {
                statesAddedQueue.$rootScope = $rootScope;
            },
            $rootScope: undefined
        };
        app.config([
            '$stateProvider',
            function ($stateProvider) {
                var realStateFn = $stateProvider.state;
                $stateProvider.state = function state_announce() {
                    var val = realStateFn.apply($stateProvider, arguments);
                    var state = angular.isObject(arguments[0]) ? arguments[0] : arguments[1];
                    statesAddedQueue.state(state);
                    return val;
                };
            }
        ]);
        app.run([
            '$futureState',
            function ($futureState, $rootScope) {
                statesAddedQueue.itsNowRuntimeOhWhatAHappyDay($rootScope);
            }
        ]);
    }(angular));
    angular.module('ct.ui.router.extras.previous', [
        'ct.ui.router.extras.core',
        'ct.ui.router.extras.transition'
    ]).service('$previousState', [
        '$rootScope',
        '$state',
        '$q',
        function ($rootScope, $state, $q) {
            var previous = null, lastPrevious = null, memos = {};
            $rootScope.$on('$transitionStart', function (evt, $transition$) {
                var from = $transition$.from;
                var fromState = from.state && from.state.$$state && from.state.$$state();
                function commit() {
                    lastPrevious = null;
                }
                function revert() {
                    previous = lastPrevious;
                }
                if (fromState) {
                    lastPrevious = previous;
                    previous = $transition$.from;
                    $transition$.promise.then(commit)['catch'](revert);
                }
            });
            var $previousState = {
                get: function (memoName) {
                    return memoName ? memos[memoName] : previous;
                },
                set: function (memoName, previousState, previousParams) {
                    memos[memoName] = {
                        state: $state.get(previousState),
                        params: previousParams
                    };
                },
                go: function (memoName, options) {
                    var to = $previousState.get(memoName);
                    if (!to) {
                        return $q.reject(new Error('no previous state ' + (memoName ? 'for memo: ' + memoName : '')));
                    }
                    return $state.go(to.state, to.params, options);
                },
                memo: function (memoName, defaultStateName, defaultStateParams) {
                    memos[memoName] = previous || {
                        state: $state.get(defaultStateName),
                        params: defaultStateParams
                    };
                },
                forget: function (memoName) {
                    if (memoName) {
                        delete memos[memoName];
                    } else {
                        previous = undefined;
                    }
                }
            };
            return $previousState;
        }
    ]);
    angular.module('ct.ui.router.extras.previous').run([
        '$previousState',
        function ($previousState) {
        }
    ]);
    angular.module('ct.ui.router.extras.transition', ['ct.ui.router.extras.core']).config([
        '$provide',
        function ($provide) {
            $provide.decorator('$state', [
                '$delegate',
                '$rootScope',
                '$q',
                '$injector',
                function ($state, $rootScope, $q, $injector) {
                    var $state_transitionTo = $state.transitionTo;
                    var transitionDepth = -1;
                    var tDataStack = [];
                    var restoreFnStack = [];
                    function decorateInjector(tData) {
                        var oldinvoke = $injector.invoke;
                        var oldinstantiate = $injector.instantiate;
                        $injector.invoke = function (fn, self, locals) {
                            return oldinvoke(fn, self, angular.extend({ $transition$: tData }, locals));
                        };
                        $injector.instantiate = function (fn, locals) {
                            return oldinstantiate(fn, angular.extend({ $transition$: tData }, locals));
                        };
                        return function restoreItems() {
                            $injector.invoke = oldinvoke;
                            $injector.instantiate = oldinstantiate;
                        };
                    }
                    function popStack() {
                        restoreFnStack.pop()();
                        tDataStack.pop();
                        transitionDepth--;
                    }
                    function transitionSuccess(deferred, tSuccess) {
                        return function successFn(data) {
                            popStack();
                            $rootScope.$broadcast('$transitionSuccess', tSuccess);
                            deferred.resolve(data);
                            return data;
                        };
                    }
                    function transitionFailure(deferred, tFail) {
                        return function failureFn(error) {
                            popStack();
                            $rootScope.$broadcast('$transitionError', tFail, error);
                            deferred.reject(error);
                            return $q.reject(error);
                        };
                    }
                    $state.transitionTo = function (to, toParams, options) {
                        var deferred = $q.defer();
                        var tData = tDataStack[++transitionDepth] = { promise: deferred.promise };
                        restoreFnStack[transitionDepth] = function () {
                        };
                        var tPromise = $state_transitionTo.apply($state, arguments);
                        return tPromise.then(transitionSuccess(deferred, tData), transitionFailure(deferred, tData));
                    };
                    $rootScope.$on('$stateChangeStart', function (evt, toState, toParams, fromState, fromParams) {
                        if (transitionDepth >= tDataStack.length)
                            return;
                        var depth = transitionDepth;
                        var tData = angular.extend(tDataStack[depth], {
                            to: {
                                state: toState,
                                params: toParams
                            },
                            from: {
                                state: fromState,
                                params: fromParams
                            }
                        });
                        var restoreFn = decorateInjector(tData);
                        restoreFnStack[depth] = restoreFn;
                        $rootScope.$broadcast('$transitionStart', tData);
                    });
                    return $state;
                }
            ]);
        }
    ]);
    (function () {
        'use strict';
        var app = angular.module('ct.ui.router.extras.statevis', [
            'ct.ui.router.extras.core',
            'ct.ui.router.extras.sticky'
        ]);
        app.directive('stateVis', [
            '$state',
            '$timeout',
            '$interval',
            stateVisDirective
        ]);
        function stateVisDirective($state, $timeout, $interval) {
            return {
                scope: {
                    width: '@',
                    height: '@'
                },
                restrict: 'AE',
                template: '<svg></svg>',
                link: function (_scope, _elem, _attrs) {
                    var stateMap = {};
                    var width = _scope.width || 400, height = _scope.height || 400;
                    var tree = d3.layout.tree().size([
                        width - 20,
                        height - 20
                    ]).separation(function (a, b) {
                        return a.parent == b.parent ? 10 : 25;
                    });
                    var root = $state.get().filter(function (state) {
                        return state.name === '';
                    })[0];
                    var nodes = tree(root);
                    root.parent = root;
                    root.px = root.x = width / 2;
                    root.py = root.y = height / 2;
                    var activeNode = {};
                    activeNode.px = activeNode.x = root.px;
                    activeNode.py = activeNode.y = root.py;
                    var diagonal = d3.svg.diagonal();
                    var svg = d3.select(_elem.find('svg')[0]).attr('width', width).attr('height', height).append('g').attr('transform', 'translate(10, 10)');
                    var node = svg.selectAll('.node'), link = svg.selectAll('.link'), active = svg.selectAll('.active');
                    var updateInterval = 200, transLength = 200, timer = setInterval(update, updateInterval);
                    function addStates(data) {
                        data = data.map(function (node) {
                            return node.name === '' ? root : angular.copy(node);
                        });
                        angular.extend(stateMap, data.reduce(function (map, node) {
                            map[node.name] = node;
                            return map;
                        }, {}));
                        data.forEach(function (node) {
                            var parentName = node.name.split(/\./).slice(0, -1).join('.');
                            var parent = node.name != parentName && stateMap[parentName];
                            if (parent) {
                                (parent.children || (parent.children = [])).push(node);
                                node.px = parent.px;
                                node.py = parent.py;
                                nodes.push(node);
                            }
                        });
                    }
                    $interval(function () {
                        _scope.states = $state.get();
                        angular.forEach(nodes, function (n) {
                            var s = $state.get(n.name);
                            if (s) {
                                n.status = s.status || 'exited';
                            }
                        });
                    }, 250);
                    _scope.$watchCollection('states', function (newval, oldval) {
                        var oldstates = (oldval || []).map(function (s) {
                            return s.name;
                        });
                        addStates((newval || []).filter(function (state) {
                            return oldstates.indexOf(state.name) == -1;
                        }));
                    });
                    update(updateInterval);
                    function update() {
                        node = node.data(tree.nodes(root), function (d) {
                            return d.name;
                        });
                        link = link.data(tree.links(nodes), function (d) {
                            return d.target.name;
                        });
                        active = active.data(activeNode);
                        nodes.forEach(function (d) {
                            d.y = d.depth * 70;
                        });
                        var nodeEnter = node.enter();
                        function stateName(node) {
                            var name = node.name.split('.').pop();
                            if (node.sticky) {
                                name += ' (STICKY)';
                            }
                            if (node.deepStateRedirect) {
                                name += ' (DSR)';
                            }
                            return name;
                        }
                        active.enter().append('circle').attr('class', 'active').attr('r', 13).attr('cx', function (d) {
                            return d.parent.px || 100;
                        }).attr('cy', function (d) {
                            return d.parent.py || 100;
                        });
                        nodeEnter.append('circle').attr('class', 'node').attr('r', 9).attr('cx', function (d) {
                            return d.parent.px;
                        }).attr('cy', function (d) {
                            return d.parent.py;
                        });
                        nodeEnter.append('text').attr('class', 'label').attr('x', function (d) {
                            return d.parent.px;
                        }).attr('y', function (d) {
                            return d.parent.py;
                        }).attr('text-anchor', function (d) {
                            return 'middle';
                        }).text(stateName).style('fill-opacity', 1);
                        link.enter().insert('path', '.node').attr('class', 'link').attr('d', function (d) {
                            var o = {
                                x: d.source.px,
                                y: d.source.py
                            };
                            return diagonal({
                                source: o,
                                target: o
                            });
                        });
                        var t = svg.transition().duration(transLength);
                        t.selectAll('.link').attr('d', diagonal);
                        var circleColors = {
                            entered: '#AF0',
                            exited: '#777',
                            active: '#0f0',
                            inactive: '#55F',
                            future: '#009'
                        };
                        t.selectAll('.node').attr('cx', function (d) {
                            return d.px = d.x;
                        }).attr('cy', function (d) {
                            return d.py = d.y;
                        }).attr('r', function (d) {
                            return d.status === 'active' ? 15 : 10;
                        }).style('fill', function (d) {
                            return circleColors[d.status] || '#FFF';
                        });
                        t.selectAll('.label').attr('x', function (d) {
                            return d.px = d.x;
                        }).attr('y', function (d) {
                            return d.py = d.y - 15;
                        }).attr('transform', function (d) {
                            return 'rotate(-25 ' + d.x + ' ' + d.y + ')';
                        });
                        t.selectAll('.active').attr('x', function (d) {
                            return d.px = d.x;
                        }).attr('y', function (d) {
                            return d.py = d.y - 15;
                        });
                    }
                }
            };
        }
    }());
    angular.module('ct.ui.router.extras', [
        'ct.ui.router.extras.core',
        'ct.ui.router.extras.dsr',
        'ct.ui.router.extras.future',
        'ct.ui.router.extras.previous',
        'ct.ui.router.extras.statevis',
        'ct.ui.router.extras.sticky',
        'ct.ui.router.extras.transition'
    ]);
}));
/*oclazyload@1.0.9#dist/ocLazyLoad*/
define('oclazyload@1.0.9#dist/ocLazyLoad', function (require, exports, module) {
    (function (angular, window) {
        'use strict';
        var regModules = [
                'ng',
                'oc.lazyLoad'
            ], regInvokes = {}, regConfigs = [], modulesToLoad = [], realModules = [], recordDeclarations = [], broadcast = angular.noop, runBlocks = {}, justLoaded = [];
        var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);
        ocLazyLoad.provider('$ocLazyLoad', [
            '$controllerProvider',
            '$provide',
            '$compileProvider',
            '$filterProvider',
            '$injector',
            '$animateProvider',
            function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {
                var modules = {}, providers = {
                        $controllerProvider: $controllerProvider,
                        $compileProvider: $compileProvider,
                        $filterProvider: $filterProvider,
                        $provide: $provide,
                        $injector: $injector,
                        $animateProvider: $animateProvider
                    }, debug = false, events = false, moduleCache = [], modulePromises = {};
                moduleCache.push = function (value) {
                    if (this.indexOf(value) === -1) {
                        Array.prototype.push.apply(this, arguments);
                    }
                };
                this.config = function (config) {
                    if (angular.isDefined(config.modules)) {
                        if (angular.isArray(config.modules)) {
                            angular.forEach(config.modules, function (moduleConfig) {
                                modules[moduleConfig.name] = moduleConfig;
                            });
                        } else {
                            modules[config.modules.name] = config.modules;
                        }
                    }
                    if (angular.isDefined(config.debug)) {
                        debug = config.debug;
                    }
                    if (angular.isDefined(config.events)) {
                        events = config.events;
                    }
                };
                this._init = function _init(element) {
                    if (modulesToLoad.length === 0) {
                        var elements = [element], names = [
                                'ng:app',
                                'ng-app',
                                'x-ng-app',
                                'data-ng-app'
                            ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/, append = function append(elm) {
                                return elm && elements.push(elm);
                            };
                        angular.forEach(names, function (name) {
                            names[name] = true;
                            append(document.getElementById(name));
                            name = name.replace(':', '\\:');
                            if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {
                                angular.forEach(element[0].querySelectorAll('.' + name), append);
                                angular.forEach(element[0].querySelectorAll('.' + name + '\\:'), append);
                                angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);
                            }
                        });
                        angular.forEach(elements, function (elm) {
                            if (modulesToLoad.length === 0) {
                                var className = ' ' + element.className + ' ';
                                var match = NG_APP_CLASS_REGEXP.exec(className);
                                if (match) {
                                    modulesToLoad.push((match[2] || '').replace(/\s+/g, ','));
                                } else {
                                    angular.forEach(elm.attributes, function (attr) {
                                        if (modulesToLoad.length === 0 && names[attr.name]) {
                                            modulesToLoad.push(attr.value);
                                        }
                                    });
                                }
                            }
                        });
                    }
                    if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {
                        console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');
                    }
                    var addReg = function addReg(moduleName) {
                        if (regModules.indexOf(moduleName) === -1) {
                            regModules.push(moduleName);
                            var mainModule = angular.module(moduleName);
                            _invokeQueue(null, mainModule._invokeQueue, moduleName);
                            _invokeQueue(null, mainModule._configBlocks, moduleName);
                            angular.forEach(mainModule.requires, addReg);
                        }
                    };
                    angular.forEach(modulesToLoad, function (moduleName) {
                        addReg(moduleName);
                    });
                    modulesToLoad = [];
                    recordDeclarations.pop();
                };
                var stringify = function stringify(obj) {
                    try {
                        return JSON.stringify(obj);
                    } catch (e) {
                        var cache = [];
                        return JSON.stringify(obj, function (key, value) {
                            if (angular.isObject(value) && value !== null) {
                                if (cache.indexOf(value) !== -1) {
                                    return;
                                }
                                cache.push(value);
                            }
                            return value;
                        });
                    }
                };
                var hashCode = function hashCode(str) {
                    var hash = 0, i, chr, len;
                    if (str.length == 0) {
                        return hash;
                    }
                    for (i = 0, len = str.length; i < len; i++) {
                        chr = str.charCodeAt(i);
                        hash = (hash << 5) - hash + chr;
                        hash |= 0;
                    }
                    return hash;
                };
                function _register(providers, registerModules, params) {
                    if (registerModules) {
                        var k, moduleName, moduleFn, tempRunBlocks = [];
                        for (k = registerModules.length - 1; k >= 0; k--) {
                            moduleName = registerModules[k];
                            if (!angular.isString(moduleName)) {
                                moduleName = getModuleName(moduleName);
                            }
                            if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {
                                continue;
                            }
                            var newModule = regModules.indexOf(moduleName) === -1;
                            moduleFn = ngModuleFct(moduleName);
                            if (newModule) {
                                regModules.push(moduleName);
                                _register(providers, moduleFn.requires, params);
                            }
                            if (moduleFn._runBlocks.length > 0) {
                                runBlocks[moduleName] = [];
                                while (moduleFn._runBlocks.length > 0) {
                                    runBlocks[moduleName].push(moduleFn._runBlocks.shift());
                                }
                            }
                            if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {
                                tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);
                            }
                            _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);
                            _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig);
                            broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);
                            registerModules.pop();
                            justLoaded.push(moduleName);
                        }
                        var instanceInjector = providers.getInstanceInjector();
                        angular.forEach(tempRunBlocks, function (fn) {
                            instanceInjector.invoke(fn);
                        });
                    }
                }
                function _registerInvokeList(args, moduleName) {
                    var invokeList = args[2][0], type = args[1], newInvoke = false;
                    if (angular.isUndefined(regInvokes[moduleName])) {
                        regInvokes[moduleName] = {};
                    }
                    if (angular.isUndefined(regInvokes[moduleName][type])) {
                        regInvokes[moduleName][type] = {};
                    }
                    var onInvoke = function onInvoke(invokeName, invoke) {
                        if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {
                            regInvokes[moduleName][type][invokeName] = [];
                        }
                        if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {
                            newInvoke = true;
                            regInvokes[moduleName][type][invokeName].push(invoke);
                            broadcast('ocLazyLoad.componentLoaded', [
                                moduleName,
                                type,
                                invokeName
                            ]);
                        }
                    };
                    function checkHashes(potentialNew, invokes) {
                        var isNew = true, newHash;
                        if (invokes.length) {
                            newHash = signature(potentialNew);
                            angular.forEach(invokes, function (invoke) {
                                isNew = isNew && signature(invoke) !== newHash;
                            });
                        }
                        return isNew;
                    }
                    function signature(data) {
                        if (angular.isArray(data)) {
                            return hashCode(data.toString());
                        } else if (angular.isObject(data)) {
                            return hashCode(stringify(data));
                        } else {
                            if (angular.isDefined(data) && data !== null) {
                                return hashCode(data.toString());
                            } else {
                                return data;
                            }
                        }
                    }
                    if (angular.isString(invokeList)) {
                        onInvoke(invokeList, args[2][1]);
                    } else if (angular.isObject(invokeList)) {
                        angular.forEach(invokeList, function (invoke, key) {
                            if (angular.isString(invoke)) {
                                onInvoke(invoke, invokeList[1]);
                            } else {
                                onInvoke(key, invoke);
                            }
                        });
                    } else {
                        return false;
                    }
                    return newInvoke;
                }
                function _invokeQueue(providers, queue, moduleName, reconfig) {
                    if (!queue) {
                        return;
                    }
                    var i, len, args, provider;
                    for (i = 0, len = queue.length; i < len; i++) {
                        args = queue[i];
                        if (angular.isArray(args)) {
                            if (providers !== null) {
                                if (providers.hasOwnProperty(args[0])) {
                                    provider = providers[args[0]];
                                } else {
                                    throw new Error('unsupported provider ' + args[0]);
                                }
                            }
                            var isNew = _registerInvokeList(args, moduleName);
                            if (args[1] !== 'invoke') {
                                if (isNew && angular.isDefined(provider)) {
                                    provider[args[1]].apply(provider, args[2]);
                                }
                            } else {
                                var callInvoke = function callInvoke(fct) {
                                    var invoked = regConfigs.indexOf(moduleName + '-' + fct);
                                    if (invoked === -1 || reconfig) {
                                        if (invoked === -1) {
                                            regConfigs.push(moduleName + '-' + fct);
                                        }
                                        if (angular.isDefined(provider)) {
                                            provider[args[1]].apply(provider, args[2]);
                                        }
                                    }
                                };
                                if (angular.isFunction(args[2][0])) {
                                    callInvoke(args[2][0]);
                                } else if (angular.isArray(args[2][0])) {
                                    for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {
                                        if (angular.isFunction(args[2][0][j])) {
                                            callInvoke(args[2][0][j]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                function getModuleName(module) {
                    var moduleName = null;
                    if (angular.isString(module)) {
                        moduleName = module;
                    } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {
                        moduleName = module.name;
                    }
                    return moduleName;
                }
                function moduleExists(moduleName) {
                    if (!angular.isString(moduleName)) {
                        return false;
                    }
                    try {
                        return ngModuleFct(moduleName);
                    } catch (e) {
                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {
                            return false;
                        }
                    }
                }
                this.$get = [
                    '$log',
                    '$rootElement',
                    '$rootScope',
                    '$cacheFactory',
                    '$q',
                    function ($log, $rootElement, $rootScope, $cacheFactory, $q) {
                        var instanceInjector, filesCache = $cacheFactory('ocLazyLoad');
                        if (!debug) {
                            $log = {};
                            $log['error'] = angular.noop;
                            $log['warn'] = angular.noop;
                            $log['info'] = angular.noop;
                        }
                        providers.getInstanceInjector = function () {
                            return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();
                        };
                        broadcast = function broadcast(eventName, params) {
                            if (events) {
                                $rootScope.$broadcast(eventName, params);
                            }
                            if (debug) {
                                $log.info(eventName, params);
                            }
                        };
                        function reject(e) {
                            var deferred = $q.defer();
                            $log.error(e.message);
                            deferred.reject(e);
                            return deferred.promise;
                        }
                        return {
                            _broadcast: broadcast,
                            _$log: $log,
                            _getFilesCache: function getFilesCache() {
                                return filesCache;
                            },
                            toggleWatch: function toggleWatch(watch) {
                                if (watch) {
                                    recordDeclarations.push(true);
                                } else {
                                    recordDeclarations.pop();
                                }
                            },
                            getModuleConfig: function getModuleConfig(moduleName) {
                                if (!angular.isString(moduleName)) {
                                    throw new Error('You need to give the name of the module to get');
                                }
                                if (!modules[moduleName]) {
                                    return null;
                                }
                                return angular.copy(modules[moduleName]);
                            },
                            setModuleConfig: function setModuleConfig(moduleConfig) {
                                if (!angular.isObject(moduleConfig)) {
                                    throw new Error('You need to give the module config object to set');
                                }
                                modules[moduleConfig.name] = moduleConfig;
                                return moduleConfig;
                            },
                            getModules: function getModules() {
                                return regModules;
                            },
                            isLoaded: function isLoaded(modulesNames) {
                                var moduleLoaded = function moduleLoaded(module) {
                                    var isLoaded = regModules.indexOf(module) > -1;
                                    if (!isLoaded) {
                                        isLoaded = !!moduleExists(module);
                                    }
                                    return isLoaded;
                                };
                                if (angular.isString(modulesNames)) {
                                    modulesNames = [modulesNames];
                                }
                                if (angular.isArray(modulesNames)) {
                                    var i, len;
                                    for (i = 0, len = modulesNames.length; i < len; i++) {
                                        if (!moduleLoaded(modulesNames[i])) {
                                            return false;
                                        }
                                    }
                                    return true;
                                } else {
                                    throw new Error('You need to define the module(s) name(s)');
                                }
                            },
                            _getModuleName: getModuleName,
                            _getModule: function getModule(moduleName) {
                                try {
                                    return ngModuleFct(moduleName);
                                } catch (e) {
                                    if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {
                                        e.message = 'The module "' + stringify(moduleName) + '" that you are trying to load does not exist. ' + e.message;
                                    }
                                    throw e;
                                }
                            },
                            moduleExists: moduleExists,
                            _loadDependencies: function _loadDependencies(moduleName, localParams) {
                                var loadedModule, requires, diff, promisesList = [], self = this;
                                moduleName = self._getModuleName(moduleName);
                                if (moduleName === null) {
                                    return $q.when();
                                } else {
                                    try {
                                        loadedModule = self._getModule(moduleName);
                                    } catch (e) {
                                        return reject(e);
                                    }
                                    requires = self.getRequires(loadedModule);
                                }
                                angular.forEach(requires, function (requireEntry) {
                                    if (angular.isString(requireEntry)) {
                                        var config = self.getModuleConfig(requireEntry);
                                        if (config === null) {
                                            moduleCache.push(requireEntry);
                                            return;
                                        }
                                        requireEntry = config;
                                        config.name = undefined;
                                    }
                                    if (self.moduleExists(requireEntry.name)) {
                                        diff = requireEntry.files.filter(function (n) {
                                            return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;
                                        });
                                        if (diff.length !== 0) {
                                            self._$log.warn('Module "', moduleName, '" attempted to redefine configuration for dependency. "', requireEntry.name, '"\n Additional Files Loaded:', diff);
                                        }
                                        if (angular.isDefined(self.filesLoader)) {
                                            promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {
                                                return self._loadDependencies(requireEntry);
                                            }));
                                        } else {
                                            return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));
                                        }
                                        return;
                                    } else if (angular.isArray(requireEntry)) {
                                        var files = [];
                                        angular.forEach(requireEntry, function (entry) {
                                            var config = self.getModuleConfig(entry);
                                            if (config === null) {
                                                files.push(entry);
                                            } else if (config.files) {
                                                files = files.concat(config.files);
                                            }
                                        });
                                        if (files.length > 0) {
                                            requireEntry = { files: files };
                                        }
                                    } else if (angular.isObject(requireEntry)) {
                                        if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {
                                            self.setModuleConfig(requireEntry);
                                            moduleCache.push(requireEntry['name']);
                                        }
                                    }
                                    if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {
                                        if (angular.isDefined(self.filesLoader)) {
                                            promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {
                                                return self._loadDependencies(requireEntry);
                                            }));
                                        } else {
                                            return reject(new Error('Error: the module "' + requireEntry.name + '" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));
                                        }
                                    }
                                });
                                return $q.all(promisesList);
                            },
                            inject: function inject(moduleName) {
                                var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                                var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
                                var self = this, deferred = $q.defer();
                                if (angular.isDefined(moduleName) && moduleName !== null) {
                                    if (angular.isArray(moduleName)) {
                                        var promisesList = [];
                                        angular.forEach(moduleName, function (module) {
                                            promisesList.push(self.inject(module, localParams, real));
                                        });
                                        return $q.all(promisesList);
                                    } else {
                                        self._addToLoadList(self._getModuleName(moduleName), true, real);
                                    }
                                }
                                if (modulesToLoad.length > 0) {
                                    var res = modulesToLoad.slice();
                                    var loadNext = function loadNext(moduleName) {
                                        moduleCache.push(moduleName);
                                        modulePromises[moduleName] = deferred.promise;
                                        self._loadDependencies(moduleName, localParams).then(function success() {
                                            try {
                                                justLoaded = [];
                                                _register(providers, moduleCache, localParams);
                                            } catch (e) {
                                                self._$log.error(e.message);
                                                deferred.reject(e);
                                                return;
                                            }
                                            if (modulesToLoad.length > 0) {
                                                loadNext(modulesToLoad.shift());
                                            } else {
                                                deferred.resolve(res);
                                            }
                                        }, function error(err) {
                                            deferred.reject(err);
                                        });
                                    };
                                    loadNext(modulesToLoad.shift());
                                } else if (localParams && localParams.name && modulePromises[localParams.name]) {
                                    return modulePromises[localParams.name];
                                } else {
                                    deferred.resolve();
                                }
                                return deferred.promise;
                            },
                            getRequires: function getRequires(module) {
                                var requires = [];
                                angular.forEach(module.requires, function (requireModule) {
                                    if (regModules.indexOf(requireModule) === -1) {
                                        requires.push(requireModule);
                                    }
                                });
                                return requires;
                            },
                            _invokeQueue: _invokeQueue,
                            _registerInvokeList: _registerInvokeList,
                            _register: _register,
                            _addToLoadList: _addToLoadList,
                            _unregister: function _unregister(modules) {
                                if (angular.isDefined(modules)) {
                                    if (angular.isArray(modules)) {
                                        angular.forEach(modules, function (module) {
                                            regInvokes[module] = undefined;
                                        });
                                    }
                                }
                            }
                        };
                    }
                ];
                this._init(angular.element(window.document));
            }
        ]);
        var bootstrapFct = angular.bootstrap;
        angular.bootstrap = function (element, modules, config) {
            angular.forEach(modules.slice(), function (module) {
                _addToLoadList(module, true, true);
            });
            return bootstrapFct(element, modules, config);
        };
        var _addToLoadList = function _addToLoadList(name, force, real) {
            if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {
                modulesToLoad.push(name);
                if (real) {
                    realModules.push(name);
                }
            }
        };
        var ngModuleFct = angular.module;
        angular.module = function (name, requires, configFn) {
            _addToLoadList(name, false, true);
            return ngModuleFct(name, requires, configFn);
        };
        if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {
            module.exports = 'oc.lazyLoad';
        }
    }(angular, window));
    (function (angular) {
        'use strict';
        angular.module('oc.lazyLoad').directive('ocLazyLoad', [
            '$ocLazyLoad',
            '$compile',
            '$animate',
            '$parse',
            '$timeout',
            function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {
                return {
                    restrict: 'A',
                    terminal: true,
                    priority: 1000,
                    compile: function compile(element, attrs) {
                        var content = element[0].innerHTML;
                        element.html('');
                        return function ($scope, $element, $attr) {
                            var model = $parse($attr.ocLazyLoad);
                            $scope.$watch(function () {
                                return model($scope) || $attr.ocLazyLoad;
                            }, function (moduleName) {
                                if (angular.isDefined(moduleName)) {
                                    $ocLazyLoad.load(moduleName).then(function () {
                                        $animate.enter(content, $element);
                                        $compile($element.contents())($scope);
                                    });
                                }
                            }, true);
                        };
                    }
                };
            }
        ]);
    }(angular));
    (function (angular) {
        'use strict';
        angular.module('oc.lazyLoad').config([
            '$provide',
            function ($provide) {
                $provide.decorator('$ocLazyLoad', [
                    '$delegate',
                    '$q',
                    '$window',
                    '$interval',
                    function ($delegate, $q, $window, $interval) {
                        var uaCssChecked = false, useCssLoadPatch = false, anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];
                        $delegate.buildElement = function buildElement(type, path, params) {
                            var deferred = $q.defer(), el, loaded, filesCache = $delegate._getFilesCache(), cacheBuster = function cacheBuster(url) {
                                    var dc = new Date().getTime();
                                    if (url.indexOf('?') >= 0) {
                                        if (url.substring(0, url.length - 1) === '&') {
                                            return url + '_dc=' + dc;
                                        }
                                        return url + '&_dc=' + dc;
                                    } else {
                                        return url + '?_dc=' + dc;
                                    }
                                };
                            if (angular.isUndefined(filesCache.get(path))) {
                                filesCache.put(path, deferred.promise);
                            }
                            switch (type) {
                            case 'css':
                                el = $window.document.createElement('link');
                                el.type = 'text/css';
                                el.rel = 'stylesheet';
                                el.href = params.cache === false ? cacheBuster(path) : path;
                                break;
                            case 'js':
                                el = $window.document.createElement('script');
                                el.src = params.cache === false ? cacheBuster(path) : path;
                                break;
                            default:
                                filesCache.remove(path);
                                deferred.reject(new Error('Requested type "' + type + '" is not known. Could not inject "' + path + '"'));
                                break;
                            }
                            el.onload = el['onreadystatechange'] = function (e) {
                                if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded)
                                    return;
                                el.onload = el['onreadystatechange'] = null;
                                loaded = 1;
                                $delegate._broadcast('ocLazyLoad.fileLoaded', path);
                                deferred.resolve();
                            };
                            el.onerror = function () {
                                filesCache.remove(path);
                                deferred.reject(new Error('Unable to load ' + path));
                            };
                            el.async = params.serie ? 0 : 1;
                            var insertBeforeElem = anchor.lastChild;
                            if (params.insertBefore) {
                                var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));
                                if (element && element.length > 0) {
                                    insertBeforeElem = element[0];
                                }
                            }
                            insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);
                            if (type == 'css') {
                                if (!uaCssChecked) {
                                    var ua = $window.navigator.userAgent.toLowerCase();
                                    if (/iP(hone|od|ad)/.test($window.navigator.platform)) {
                                        var v = $window.navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
                                        var iOSVersion = parseFloat([
                                            parseInt(v[1], 10),
                                            parseInt(v[2], 10),
                                            parseInt(v[3] || 0, 10)
                                        ].join('.'));
                                        useCssLoadPatch = iOSVersion < 6;
                                    } else if (ua.indexOf('android') > -1) {
                                        var androidVersion = parseFloat(ua.slice(ua.indexOf('android') + 8));
                                        useCssLoadPatch = androidVersion < 4.4;
                                    } else if (ua.indexOf('safari') > -1) {
                                        var versionMatch = ua.match(/version\/([\.\d]+)/i);
                                        useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;
                                    }
                                }
                                if (useCssLoadPatch) {
                                    var tries = 1000;
                                    var interval = $interval(function () {
                                        try {
                                            el.sheet.cssRules;
                                            $interval.cancel(interval);
                                            el.onload();
                                        } catch (e) {
                                            if (--tries <= 0) {
                                                el.onerror();
                                            }
                                        }
                                    }, 20);
                                }
                            }
                            return deferred.promise;
                        };
                        return $delegate;
                    }
                ]);
            }
        ]);
    }(angular));
    (function (angular) {
        'use strict';
        angular.module('oc.lazyLoad').config([
            '$provide',
            function ($provide) {
                $provide.decorator('$ocLazyLoad', [
                    '$delegate',
                    '$q',
                    function ($delegate, $q) {
                        $delegate.filesLoader = function filesLoader(config) {
                            var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                            var cssFiles = [], templatesFiles = [], jsFiles = [], promises = [], cachePromise = null, filesCache = $delegate._getFilesCache();
                            $delegate.toggleWatch(true);
                            angular.extend(params, config);
                            var pushFile = function pushFile(path) {
                                var file_type = null, m;
                                if (angular.isObject(path)) {
                                    file_type = path.type;
                                    path = path.path;
                                }
                                cachePromise = filesCache.get(path);
                                if (angular.isUndefined(cachePromise) || params.cache === false) {
                                    if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {
                                        file_type = m[1];
                                        path = path.substr(m[1].length + 1, path.length);
                                    }
                                    if (!file_type) {
                                        if ((m = /[.](css|less|html|htm|js)?((\?|#).*)?$/.exec(path)) !== null) {
                                            file_type = m[1];
                                        } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {
                                            file_type = 'js';
                                        } else {
                                            $delegate._$log.error('File type could not be determined. ' + path);
                                            return;
                                        }
                                    }
                                    if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {
                                        cssFiles.push(path);
                                    } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {
                                        templatesFiles.push(path);
                                    } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {
                                        jsFiles.push(path);
                                    } else {
                                        $delegate._$log.error('File type is not valid. ' + path);
                                    }
                                } else if (cachePromise) {
                                    promises.push(cachePromise);
                                }
                            };
                            if (params.serie) {
                                pushFile(params.files.shift());
                            } else {
                                angular.forEach(params.files, function (path) {
                                    pushFile(path);
                                });
                            }
                            if (cssFiles.length > 0) {
                                var cssDeferred = $q.defer();
                                $delegate.cssLoader(cssFiles, function (err) {
                                    if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {
                                        $delegate._$log.error(err);
                                        cssDeferred.reject(err);
                                    } else {
                                        cssDeferred.resolve();
                                    }
                                }, params);
                                promises.push(cssDeferred.promise);
                            }
                            if (templatesFiles.length > 0) {
                                var templatesDeferred = $q.defer();
                                $delegate.templatesLoader(templatesFiles, function (err) {
                                    if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {
                                        $delegate._$log.error(err);
                                        templatesDeferred.reject(err);
                                    } else {
                                        templatesDeferred.resolve();
                                    }
                                }, params);
                                promises.push(templatesDeferred.promise);
                            }
                            if (jsFiles.length > 0) {
                                var jsDeferred = $q.defer();
                                $delegate.jsLoader(jsFiles, function (err) {
                                    if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') || $delegate.jsLoader.hasOwnProperty('requirejs'))) {
                                        $delegate._$log.error(err);
                                        jsDeferred.reject(err);
                                    } else {
                                        jsDeferred.resolve();
                                    }
                                }, params);
                                promises.push(jsDeferred.promise);
                            }
                            if (promises.length === 0) {
                                var deferred = $q.defer(), err = 'Error: no file to load has been found, if you\'re trying to load an existing module you should use the \'inject\' method instead of \'load\'.';
                                $delegate._$log.error(err);
                                deferred.reject(err);
                                return deferred.promise;
                            } else if (params.serie && params.files.length > 0) {
                                return $q.all(promises).then(function () {
                                    return $delegate.filesLoader(config, params);
                                });
                            } else {
                                return $q.all(promises)['finally'](function (res) {
                                    $delegate.toggleWatch(false);
                                    return res;
                                });
                            }
                        };
                        $delegate.load = function (originalModule) {
                            var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                            var self = this, config = null, deferredList = [], deferred = $q.defer(), errText;
                            var module = angular.copy(originalModule);
                            var params = angular.copy(originalParams);
                            if (angular.isArray(module)) {
                                angular.forEach(module, function (m) {
                                    deferredList.push(self.load(m, params));
                                });
                                $q.all(deferredList).then(function (res) {
                                    deferred.resolve(res);
                                }, function (err) {
                                    deferred.reject(err);
                                });
                                return deferred.promise;
                            }
                            if (angular.isString(module)) {
                                config = self.getModuleConfig(module);
                                if (!config) {
                                    config = { files: [module] };
                                }
                            } else if (angular.isObject(module)) {
                                if (angular.isDefined(module.path) && angular.isDefined(module.type)) {
                                    config = { files: [module] };
                                } else {
                                    config = self.setModuleConfig(module);
                                }
                            }
                            if (config === null) {
                                var moduleName = self._getModuleName(module);
                                errText = 'Module "' + (moduleName || 'unknown') + '" is not configured, cannot load.';
                                $delegate._$log.error(errText);
                                deferred.reject(new Error(errText));
                                return deferred.promise;
                            } else {
                                if (angular.isDefined(config.template)) {
                                    if (angular.isUndefined(config.files)) {
                                        config.files = [];
                                    }
                                    if (angular.isString(config.template)) {
                                        config.files.push(config.template);
                                    } else if (angular.isArray(config.template)) {
                                        config.files.concat(config.template);
                                    }
                                }
                            }
                            var localParams = angular.extend({}, params, config);
                            if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {
                                return $delegate.inject(config.name, localParams, true);
                            }
                            $delegate.filesLoader(config, localParams).then(function () {
                                $delegate.inject(null, localParams).then(function (res) {
                                    deferred.resolve(res);
                                }, function (err) {
                                    deferred.reject(err);
                                });
                            }, function (err) {
                                deferred.reject(err);
                            });
                            return deferred.promise;
                        };
                        return $delegate;
                    }
                ]);
            }
        ]);
    }(angular));
    (function (angular) {
        'use strict';
        angular.module('oc.lazyLoad').config([
            '$provide',
            function ($provide) {
                $provide.decorator('$ocLazyLoad', [
                    '$delegate',
                    '$q',
                    function ($delegate, $q) {
                        $delegate.cssLoader = function (paths, callback, params) {
                            var promises = [];
                            angular.forEach(paths, function (path) {
                                promises.push($delegate.buildElement('css', path, params));
                            });
                            $q.all(promises).then(function () {
                                callback();
                            }, function (err) {
                                callback(err);
                            });
                        };
                        $delegate.cssLoader.ocLazyLoadLoader = true;
                        return $delegate;
                    }
                ]);
            }
        ]);
    }(angular));
    (function (angular) {
        'use strict';
        angular.module('oc.lazyLoad').config([
            '$provide',
            function ($provide) {
                $provide.decorator('$ocLazyLoad', [
                    '$delegate',
                    '$q',
                    function ($delegate, $q) {
                        $delegate.jsLoader = function (paths, callback, params) {
                            var promises = [];
                            angular.forEach(paths, function (path) {
                                promises.push($delegate.buildElement('js', path, params));
                            });
                            $q.all(promises).then(function () {
                                callback();
                            }, function (err) {
                                callback(err);
                            });
                        };
                        $delegate.jsLoader.ocLazyLoadLoader = true;
                        return $delegate;
                    }
                ]);
            }
        ]);
    }(angular));
    (function (angular) {
        'use strict';
        angular.module('oc.lazyLoad').config([
            '$provide',
            function ($provide) {
                $provide.decorator('$ocLazyLoad', [
                    '$delegate',
                    '$templateCache',
                    '$q',
                    '$http',
                    function ($delegate, $templateCache, $q, $http) {
                        $delegate.templatesLoader = function (paths, callback, params) {
                            var promises = [], filesCache = $delegate._getFilesCache();
                            angular.forEach(paths, function (url) {
                                var deferred = $q.defer();
                                promises.push(deferred.promise);
                                $http.get(url, params).success(function (data) {
                                    if (angular.isString(data) && data.length > 0) {
                                        angular.forEach(angular.element(data), function (node) {
                                            if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {
                                                $templateCache.put(node.id, node.innerHTML);
                                            }
                                        });
                                    }
                                    if (angular.isUndefined(filesCache.get(url))) {
                                        filesCache.put(url, true);
                                    }
                                    deferred.resolve();
                                }).error(function (err) {
                                    deferred.reject(new Error('Unable to load template file "' + url + '": ' + err));
                                });
                            });
                            return $q.all(promises).then(function () {
                                callback();
                            }, function (err) {
                                callback(err);
                            });
                        };
                        $delegate.templatesLoader.ocLazyLoadLoader = true;
                        return $delegate;
                    }
                ]);
            }
        ]);
    }(angular));
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement, fromIndex) {
            var k;
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var O = Object(this);
            var len = O.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = +fromIndex || 0;
            if (Math.abs(n) === Infinity) {
                n = 0;
            }
            if (n >= len) {
                return -1;
            }
            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
            while (k < len) {
                if (k in O && O[k] === searchElement) {
                    return k;
                }
                k++;
            }
            return -1;
        };
    }
});
/*js/orefine/OrefineBridge*/
define('js/orefine/OrefineBridge', [
    'jquery',
    'angular'
], function (jquery, angular) {
    OpenRefineBridge = {
        addSelectionSet: function (selection) {
            console.debug('in addSelectionSet');
            console.debug('selection', selection);
            var elm = document.querySelector('#selectionSetMgr');
            var selectionSetMgrDOM = angular.element(elm);
            var rootScope = angular.element(document).scope();
            if (rootScope.$state) {
                rootScope.$state.go('^.' + selection.dimension.toLowerCase() + 'Set', { setId: selection.name });
            }
            var selectionSetManagerScope = selectionSetMgrDOM.scope();
            console.debug('selectionSetManagerScope:', selectionSetManagerScope);
            if (selectionSetManagerScope) {
                selectionSetManagerScope.addItem(selection);
            } else {
                rootScope.$broadcast('mui:dataset:selections:added', selection.dimension.toLowerCase(), selection);
            }
        },
        loadedProject: function (theProject) {
            var rootScope = angular.element(document).scope();
            ;
            console.debug('loadedProject', theProject);
            if (theProject.metadata.customMetadata.dimension === 'COLUMN')
                rootScope.$broadcast('openRefine:loadedAnnotations:column', theProject);
            else if (theProject.metadata.customMetadata.dimension === 'ROW')
                rootScope.$broadcast('openRefine:loadedAnnotations:row', theProject);
            else
                rootScope.$broadcast('openRefine:loadedAnnotations', theProject);
        },
        openDataset: function (dataset) {
            console.debug('in openDataset');
            console.debug('dataset:' + angular.toJson(dataset));
            jquery('#import-presets-modal').modal('hide');
            jquery('div.modal-backdrop').hide();
            var rootScope = angular.element(document).scope();
            if (rootScope.$state) {
                rootScope.$state.go('root.dataset.home', { datasetId: dataset.name });
                return;
            }
            var datasetUrl = '/#/dataset/' + dataset.name + '/';
            window.location.replace(datasetUrl);
        },
        showPresetList: function () {
            var elm = document.querySelector('#presetMgr');
            var presetMgrDOM = angular.element(elm);
            var presetManagerScope = presetMgrDOM.scope();
            var presetManagerController = presetMgrDOM.controller();
            console.debug('presetManagerScope:' + angular.toJson(presetManagerScope));
            console.debug('presetManagerScope.orderByColumn:' + presetManagerScope.orderByColumn);
            console.debug('presetManagerController.orderByColumn:' + presetManagerController.orderByColumn);
            presetManagerScope.showPresetList();
            presetManagerScope.$apply();
        }
    };
    return OpenRefineBridge;
});
/*mainmenu*/
define('mainmenu', [
    'angular',
    'angular-utils-ui-breadcrumbs'
], function (angular) {
    var module = angular.module('Mev.MainMenuModule', ['angularUtils.directives.uiBreadcrumbs']);
    module.path = '/container/javascript/mainmenu/';
    return module;
});
/*app/app*/
define('app/app', [
    'mui',
    'angular-animate',
    'angular-ui-router',
    'bootstrap',
    'angular-ui-bootstrap',
    'angular-route',
    'app/views/root/views.root.module',
    'app/views/import/views.import.module',
    'app/views/welcome/views.welcome.module',
    'app/widgets/widgets.module',
    'app/utils/utils.module',
    'browser-filesaver',
    'angular-utils-ui-breadcrumbs',
    'ui-router-extras',
    'oclazyload',
    'js/orefine/OrefineBridge',
    'mainmenu'
], function (ng) {
    'use strict';
    return ng.module('ngbootstrap-app', ['ct.ui.router.extras'], arguments).config([
        '$stateProvider',
        '$urlRouterProvider',
        function ($stateProvider, $urlRouterProvider) {
            $urlRouterProvider.when('/', '/welcome');
            $urlRouterProvider.when('', '/welcome');
            $stateProvider.state('root', {
                url: '',
                templateUrl: 'app/views/root/templates/root.tpl.html',
                controller: 'RootCtrl',
                controllerAs: 'RootCtrl',
                abstract: true,
                breadcrumbProxy: 'root.welcome'
            }).state('root.about', {
                url: '/about',
                templateUrl: 'app/views/about/templates/about.tpl.html',
                parent: 'root'
            }).state('root.contact', {
                url: '/contact',
                templateUrl: 'app/views/contact/templates/contact.tpl.html',
                parent: 'root',
                data: { sidemenuUrl: 'app/views/contact/templates/contact.sidemenu.tpl.html' }
            });
        }
    ]).service('mevFetchSrc', [
        '$ocLazyLoad',
        function ($ocLazyLoad) {
            var self = this;
            self.sources = {};
            this.fetch = function (src, $$AnimateJsProvider) {
                if (self.sources[src])
                    return self.sources[src].promise;
                var source = self.sources[src] = {
                    status: 'importing',
                    promise: System.import(src).then(function (module) {
                        _.assign(self.sources[src], {
                            status: 'imported',
                            module: module
                        });
                        console.log('heavy imported', arguments);
                        return $ocLazyLoad.inject(['ng']).then(function () {
                            console.log('loaded ng', arguments);
                            ng.module('ng').provider('$$animateJs', $$AnimateJsProvider);
                            _.assign(self.sources[src], { status: 'loading' });
                            return $ocLazyLoad.load([module]).then(function () {
                                _.assign(self.sources[src], { status: 'completed' });
                                console.log('heavy loaded', arguments);
                            }).catch(function (e) {
                                throw e;
                            });
                        });
                    }).catch(function (e) {
                        throw e;
                    })
                };
                return source.promise;
            };
        }
    ]).config([
        '$futureStateProvider',
        '$$animateJsProvider',
        function ($futureStateProvider, $$AnimateJsProvider) {
            $futureStateProvider.stateFactory('lazy', [
                'mevFetchSrc',
                'futureState',
                function (mevFetchSrc, futureState) {
                    return mevFetchSrc.fetch(futureState.src, $$AnimateJsProvider).catch(function (e) {
                        throw e;
                    });
                }
            ]);
            $futureStateProvider.futureState({
                parent: 'root',
                type: 'lazy',
                stateName: 'root.datasets',
                src: 'app/views/datasets/views.datasets.module',
                url: '/datasets',
                displayName: 'datasets'
            });
            $futureStateProvider.futureState({
                type: 'lazy',
                stateName: 'root.abstractDataset',
                src: 'app/views/dataset/views.dataset.module',
                parent: 'root',
                'abstract': true,
                url: '/dataset',
                breadcrumbProxy: 'root.datasets',
                displayName: 'datasets',
                template: '<ui-view></ui-view>'
            });
            $futureStateProvider.futureState({
                type: 'lazy',
                stateName: 'root.dataset',
                src: 'app/views/dataset/views.dataset.module',
                parent: 'root.abstractDataset',
                'abstract': true,
                url: '/:datasetId/'
            });
        }
    ]).config(function ($provide) {
    }).config([
        '$sceProvider',
        function ($sceProvider) {
            $sceProvider.enabled(false);
        }
    ]).config([
        '$httpProvider',
        function ($httpProvider) {
            $httpProvider.interceptors.push(function ($q, $rootScope) {
                return {
                    responseError: function (rejection) {
                        console.log('rejection', rejection);
                        if (_.includes(rejection.data, 'DatasetNotFoundException'))
                            $rootScope.$broadcast('mui:error:sessionTimeout', rejection);
                        return $q.reject(rejection);
                    }
                };
            });
        }
    ]).run([
        '$rootScope',
        '$state',
        '$stateParams',
        function ($rootScope, $state, $stateParams) {
            $rootScope.$state = $state;
            $rootScope.$stateParams = $stateParams;
            $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {
                $('.page-loading').removeClass('hidden');
            });
            $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
                $('.page-loading').addClass('hidden');
                if (toState.redirectTo) {
                    $state.go(toState.redirectTo, toParams);
                }
            });
        }
    ]);
});
/*stealmain*/
window.global = window;
define('stealmain', [
    'mui',
    'jquery',
    './app/app',
    './less/boot.less'
], function (ng, jquery, app) {
    ng.element(document).ready(function () {
        ng.bootstrap(document, [app.name]);
    });
    window.OpenRefineBridge = OpenRefineBridge;
});
/*[import-main-module]*/
System["import"]('package.json!npm').then(function() {
System["import"]('stealmain'); 
});